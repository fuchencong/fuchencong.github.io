<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="之前其实已经学习过 Go 生态中的一个依赖注入库 fx，这篇文章我们将继续学习另一个依赖注入库 Wire。">
<meta property="og:type" content="article">
<meta property="og:title" content="go 库学习之 Wire">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2025/05/01/go-library-wire/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="之前其实已经学习过 Go 生态中的一个依赖注入库 fx，这篇文章我们将继续学习另一个依赖注入库 Wire。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-05-01T05:55:07.000Z">
<meta property="article:modified_time" content="2026-01-16T05:55:44.889Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2025/05/01/go-library-wire/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>go 库学习之 Wire | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2025/05/01/go-library-wire/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          go 库学习之 Wire
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-05-01 13:55:07" itemprop="dateCreated datePublished" datetime="2025-05-01T13:55:07+08:00">2025-05-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>之前其实已经学习过 Go 生态中的一个依赖注入库 <a target="_blank" rel="noopener" href="https://fuchencong.com/2023/12/28/go-library-fx/">fx</a>，这篇文章我们将继续学习另一个依赖注入库 <a target="_blank" rel="noopener" href="https://github.com/google/wire">Wire</a>。</p>
<span id="more"></span>
<h2 id="wire-简介"><a class="markdownIt-Anchor" href="#wire-简介"></a> Wire 简介</h2>
<p>Wire 是 Google 开发的一个依赖注入（Dependency Injection）库，它通过代码生成的方式实现依赖注入，而不是使用反射机制。Wire 是一个代码生成工具，它通过依赖注入的方式自动连接组件，组件间的依赖通过 <code>函数参数</code> 的方式声明，鼓励使用显式初始化而不是全局变量。使用 Wire 有一个好处，因为 Wire 不依赖于运行时状态/反射，因此使用 Wire 时写的代码照样可以用于手写初始化的场景。</p>
<h3 id="wire-解决什么问题"><a class="markdownIt-Anchor" href="#wire-解决什么问题"></a> Wire 解决什么问题</h3>
<p>依赖注入是一种标准技术，<strong>通过显式地为组件提供其工作所需的所有依赖关系</strong>，来生成灵活且松散耦合的代码。在 Go 中，<code>依赖</code> 通常是以 constructor 参数的形式出现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewUserStore returns a UserStore that uses cfg and db as dependencies.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUserStore</span><span class="params">(cfg *Config, db *mysql.DB)</span></span> (*UserStore, <span class="type">error</span>) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>这种通过参数来传递依赖项的方式，在小型应用程序中工作良好。但是大型应用通常具有复杂的依赖关系图，这就需要编写大量的初始化代码，而且顺序也很重要。这导致难以干净地分解代码，尤其是某些依赖需要多次使用。实现服务间的替换也会很痛苦，因为需要更改依赖图：删除旧的依赖，添加一系列新的依赖。在实践中，在具有复杂依赖的应用程序中更改初始化代码既繁琐又缓慢。</p>
<p>依赖注入工具 Wire 则是为了简化 <code>初始化代码</code> 的管理。可以在代码或配置中描述服务及其依赖，然后由 Wire 来梳理组件间的依赖关系、依赖顺序，并为组件传递所需的依赖。当应用程序需要修改依赖时，只需要修改函数签名或者添加/删除 initializer（Wire 中也称为 provider），Wire 会自动完成根据依赖图 <code>生成初始化代码</code> 的繁琐工作。</p>
<p>Wire 最初是为 <a target="_blank" rel="noopener" href="https://github.com/google/go-cloud">Go Cloud</a> 服务的，<code>go-cloud</code> 的目标是为不同的云服务提供一致的 Go API，这样更容易编写可移植的云应用。举个例子：<code>blob.Bucket</code> 是云存储服务的同一接口，它底层即可以使用 AWS S3，也可以使用 GCS（Google Cloud Storage）。当使用 <code>blob.Bucket</code> API 时，即使底层存储服务发生变化，应用程序逻辑也无需修改。但是有个问题，初始化代码还是 <code>provider</code> 特定的，例如：</p>
<ul>
<li>构造 GCS <code>blob.Bucket</code> 需要 <code>gcp.HTTPClient</code>，最终需要 <code>google.Credentials</code></li>
<li>构造 S3 对象则需要 <code>aws.Config</code>，最终需要 <code>AWS Credentials</code></li>
</ul>
<p>这样应用程序如果需要替换 <code>blob.Bucket</code> 的底层实现，就需要大量修改初始化代码。而为了解决这个问题，通用的依赖注入工具 Wire 应运而生。</p>
<h3 id="与其他依赖注入工具的比较"><a class="markdownIt-Anchor" href="#与其他依赖注入工具的比较"></a> 与其他依赖注入工具的比较</h3>
<p>Go 已经有了不少依赖注入工具，例如 Uber 的 <a target="_blank" rel="noopener" href="https://github.com/uber-go/dig">dig</a>、Facebook 的 <a target="_blank" rel="noopener" href="https://github.com/facebookgo/inject">inject</a>，这两个工具都是通过反射来实现运行时依赖注入，而 Wire 是一个代码生成工具，它在编译时实现依赖注入，不需要依赖反射或者 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Service_locator_pattern">service locator</a>。这种实现方式有以下好处：</p>
<ul>
<li>当依赖图变得复杂时，运行时依赖注入可能很难追踪、调试。而代码生成的方式则意味着 <code>初始化代码</code> 在运行时和普通的 Go 代码没有任何区别，更容易理解和调试。而且如果遗漏某个依赖，会导致编译期错误，而不是运行期错误</li>
<li>不像 <code>service locator</code> 那样，不需要为注册服务而提供名称或 key，Wire 使用 Go 类型来连接组件及其依赖</li>
<li>避免依赖膨胀，Wire 生成的代码只会 import 你需要的依赖，所以生成的二进制文件不会包含没有使用的组件。而运行时依赖注入工具只有到运行时才能发现 <code>无用的依赖</code></li>
<li>Wire 的依赖图是静态可知的，方便工具使用，例如可视化工具</li>
</ul>
<h2 id="wire-的基本概念"><a class="markdownIt-Anchor" href="#wire-的基本概念"></a> Wire 的基本概念</h2>
<p>Wire 有两个基本概念：<code>provider</code> 和 <code>injector</code>。</p>
<p><code>provider</code> 是普通的 Go 函数，根据 <code>依赖关系</code> 提供 <code>value</code>，而依赖则是简单地通过 <code>函数参数</code> 描述。如下定义了 3 个 <code>provider</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewUserStore is the same function we saw above; it is a provider for UserStore,</span></span><br><span class="line"><span class="comment">// with dependencies on *Config and *mysql.DB.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUserStore</span><span class="params">(cfg *Config, db *mysql.DB)</span></span> (*UserStore, <span class="type">error</span>) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewDefaultConfig is a provider for *Config, with no dependencies.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDefaultConfig</span><span class="params">()</span></span> *Config &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewDB is a provider for *mysql.DB based on some connection info.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDB</span><span class="params">(info *ConnectionInfo)</span></span> (*mysql.DB, <span class="type">error</span>) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>通常一起使用的 <code>provider</code> 可以分组为 <code>ProviderSet</code>，例如当使用 <code>*UserStore</code> 时，通常需要默认的 <code>*Config</code>，因此将如下 provider 分组到一个 <code>ProviderSet</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> UserStoreSet = wire.NewSet(NewUserStore, NewDefaultConfig)</span><br></pre></td></tr></table></figure>
<p><code>injector</code> 则是 Wire 生成的函数，它根据依赖关系调用 <code>provider</code> 来初始化组件。你需要编写 <code>injector</code> 的签名：将任何需要的输入作为参数，并插入一个 <code>wire.Build</code> 调用，同时将构建最终结果所需要的一系列 <code>provider</code> 或者 <code>ProviderSet</code> 作为 <code>wire.Build</code> 的参数。如下是一个 <code>injector</code> 的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initUserStore</span><span class="params">(info *ConnectionInfo)</span></span> (*UserStore, <span class="type">error</span>) &#123;</span><br><span class="line">        wire.Build(UserStoreSet, NewDB)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span> <span class="comment">// These return values are ignored.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后通过 wire 的命令行工具 wire，就可以自动生成初始化代码，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initUserStore</span><span class="params">(info *ConnectionInfo)</span></span> (*UserStore, <span class="type">error</span>) &#123;</span><br><span class="line">        config := NewDefaultConfig()</span><br><span class="line">        db, err := NewDB(info)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        userStore, err := NewUserStore(config, db)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userStore, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 Wire 时完全没有运行时依赖，自动生成的初始化代码就和普通的 Go 代码一样。</p>
<h2 id="wire-示例"><a class="markdownIt-Anchor" href="#wire-示例"></a> Wire 示例</h2>
<p>接下来以 Wire 官方的 Tutorial 为例，完整地介绍 Wire 的使用方法。如下是一个简单的 Go 程序，它没有使用依赖注入：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Message <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Greeter <span class="keyword">struct</span> &#123;</span><br><span class="line">	Message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Event <span class="keyword">struct</span> &#123;</span><br><span class="line">	Greeter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMessage</span><span class="params">()</span></span> Message &#123;</span><br><span class="line">	<span class="keyword">return</span> Message(<span class="string">&quot;Hi&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGreeter</span><span class="params">(m Message)</span></span> Greeter &#123;</span><br><span class="line">	<span class="keyword">return</span> Greeter&#123;Message: m&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Greeter)</span></span> Greet() Message &#123;</span><br><span class="line">	<span class="keyword">return</span> g.Message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEvent</span><span class="params">(g Greeter)</span></span> Event &#123;</span><br><span class="line">	<span class="keyword">return</span> Event&#123;Greeter: g&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Event)</span></span> Start() &#123;</span><br><span class="line">	fmt.Println(e.Greet())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	message := NewMessage()</span><br><span class="line">	greeter := NewGreeter(message)</span><br><span class="line">	event := NewEvent(greeter)</span><br><span class="line"></span><br><span class="line">	event.Start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在没有使用依赖注入的情况，为了生成最终的 <code>Event</code> 对象，需要手动依次创建 <code>Message</code>, <code>Greeter</code>, <code>Event</code> 对象。接下来使用 Wire 来改造这个过程，定义一个 <code>wire.go</code> 文件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//+build wireinject</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/google/wire&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeEvent</span><span class="params">()</span></span> Event &#123;</span><br><span class="line">        wire.Build(NewEvent, NewGreeter, NewMessage)</span><br><span class="line">        <span class="keyword">return</span> Event&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后 <code>main()</code> 函数修改为如下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        event := InitializeEvent()</span><br><span class="line"></span><br><span class="line">        event.Start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>InitializeEvent()</code> 这个 injector 中，我们返回了一个 Event 的零值，这样做是可以的。因为 Wire 本身只是需要根据 injector 中提供的 provider 来生成初始化代码（这里即构造最终的 Event 对象）。因此 <code>wire.go</code> 本身只是在构建时使用，不需要包含在最终的二进制文件中。因此在 <code>wire.go</code> 中包含了一个 <code>build tag</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//+build wireinject</span></span><br></pre></td></tr></table></figure>
<p>接下来就可以通过 wire 来生成初始化代码，首先需要安装 wire 命令行工具</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> install github.com/google/wire/cmd/wire@latest</span><br></pre></td></tr></table></figure>
<p>然后在当前目录下执行 <code>wire</code> 命令，它会找到 <code>InitializeEvent</code> injector 并生成一个对应的函数，包含初始化代码。生成的代码报文在文件 <code>wire_gen.go</code> 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># wire</span><br><span class="line"></span><br><span class="line"># cat wire_gen.<span class="keyword">go</span></span><br><span class="line"><span class="comment">// Code generated by Wire. DO NOT EDIT.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:generate go run -mod=mod github.com/google/wire/cmd/wire</span></span><br><span class="line"><span class="comment">//go:build !wireinject</span></span><br><span class="line"><span class="comment">// +build !wireinject</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// Injectors from wire.go:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitializeEvent</span><span class="params">()</span></span> Event &#123;</span><br><span class="line">        message := NewMessage()</span><br><span class="line">        greeter := NewGreeter(message)</span><br><span class="line">        event := NewEvent(greeter)</span><br><span class="line">        <span class="keyword">return</span> event</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成的代码和我们自己写的初始化代码是一样的，只不过这次我们不需要手动编写这部分逻辑了。这个示例只是展示了最简单的情况，实际上 Wire 还有很多特性：</p>
<ul>
<li>即使某些 provider 会返回 error，Wire 生成的初始化代码也能正确处理：它会检查 error 并尽早返回。</li>
<li>injector 也可以接收参数，并将它们传递给 provider</li>
<li>当代码中出现错误时，wire 也会提供有用的编译错误信息（例如缺少或多余 provider）</li>
</ul>
<p>当使用 Wire 时，<code>wire.go</code> 和 <code>wire_gen.go</code> 都会提交到源码控制系统中。如果想了解 Wire 在大规模程序中的使用，可以参考这个 Go Cloud 中的 <a target="_blank" rel="noopener" href="https://github.com/google/go-cloud/tree/master/samples/guestbook">guestbook 示例</a>。</p>
<h2 id="wire-高级特性"><a class="markdownIt-Anchor" href="#wire-高级特性"></a> Wire 高级特性</h2>
<p>上文已经介绍了 Wire 的基本用法，也简单介绍了 Wire 的两个核心概念：<code>provider</code> 和 <code>injector</code>。这里再详细介绍一下 <code>provider</code> 和 <code>injector</code>：</p>
<ul>
<li>Provider 函数必须是导出函数，这样才可以在其他 package 中使用这些函数</li>
<li>Provider 通过函数参数指定依赖</li>
<li>Provider 可以返回 errors</li>
<li>Provider 可以分组为 <code>provider set</code>。当几个 provider 通常一起使用时，将它们分组到一个 <code>provider set</code>，这样可以方便使用。通过 <code>wire.NewSet</code> 创建 <code>provider set</code></li>
<li>可以将其他 <code>provider set</code> 继续添加到 <code>provider set</code> 中</li>
<li>应用程序在 <code>injector</code> 中将多个 <code>provider</code> 连接起来</li>
<li><code>injector</code> 是一个函数，我们需要编写它的函数签名，同时在函数体内需要调用 <code>wire.Build</code>，函数的返回值 <code>值本身</code> 并不重要，只要保证类型正确即可。<code>injector</code> 也可以接收参数并返回错误</li>
<li><code>wire</code> 会根据 <code>injector</code> 生成真正的 <code>初始化代码</code>，文件中的非 <code>injector</code> 代码则会原样复制到输出文件中</li>
<li>通过 <code>wire</code> 命令生成 <code>初始化代码</code>，生成的 <code>初始化代码</code> 和普通的 Go 代码基本没有区别，这些生成的代码可以在没有 Wire 的环境中使用</li>
<li>一旦 <code>wire_gen.go</code> 创建之后，可以通过 <code>go generate</code> 命令重新生成代码</li>
</ul>
<p>接下来再来介绍 Wire 的一些高级特性。</p>
<h3 id="interface-binding"><a class="markdownIt-Anchor" href="#interface-binding"></a> interface binding</h3>
<p>依赖注入通常用于为接口类型绑定一个具体的实现，Wire 通过 <code>类型标识</code> 来将输入映射到输出，因此你可以会倾向于创建一个返回接口类型的 provider。但这不符合 Go 语言的惯例，因为 Go 的最佳实践是返回具体类型。为了解决这个问题，你可以在 <code>provider set</code> 中声明一个 <code>interface binding</code>，如下是一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fooer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Foo() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFooer <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *MyFooer)</span></span> Foo() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(*b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">provideMyFooer</span><span class="params">()</span></span> *MyFooer &#123;</span><br><span class="line">    b := <span class="built_in">new</span>(MyFooer)</span><br><span class="line">    *b = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bar <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">provideBar</span><span class="params">(f Fooer)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">// f will be a *MyFooer.</span></span><br><span class="line">    <span class="keyword">return</span> f.Foo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Set = wire.NewSet(</span><br><span class="line">    provideMyFooer,</span><br><span class="line">    wire.Bind(<span class="built_in">new</span>(Fooer), <span class="built_in">new</span>(*MyFooer)),</span><br><span class="line">    provideBar)</span><br></pre></td></tr></table></figure>
<ul>
<li>wire.Bind 的第一个参数是指向 <code>interface</code> 的指针，第二个参数是指向 <code>实现该 interface 的具体类型</code> 的指针</li>
<li>包含 <code>interface binding</code> 的 <code>provider set</code> 也必须包含提供 <code>实现类型</code> 的 provider</li>
</ul>
<h3 id="struct-provider"><a class="markdownIt-Anchor" href="#struct-provider"></a> struct provider</h3>
<p>可以通过 <code>provided types</code> 来构造结构体，使用 <code>wire.Struct()</code> 来创建一个 <code>struct</code> 类型并告诉 injector 应该注入到哪个字段，injector 会根据 field 的 type 调用 provider 来填充这些字段。<code>wire.Struct()</code> 可以生成 <code>S</code> 或 <code>*S</code> 类型。</p>
<p>如下是个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FooBar <span class="keyword">struct</span> &#123;</span><br><span class="line">    MyFoo Foo</span><br><span class="line">    MyBar Bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Set = wire.NewSet(</span><br><span class="line">    ProvideFoo,</span><br><span class="line">    ProvideBar,</span><br><span class="line">    wire.Struct(<span class="built_in">new</span>(FooBar), <span class="string">&quot;MyFoo&quot;</span>, <span class="string">&quot;MyBar&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><code>wire.Struct()</code> 的第一个参数是指向期望 struct 的指针，之后的参数则是需要注入的字段名称，<code>*</code> 可以表示所有字段。如下代码则只注入了一个字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Set = wire.NewSet(</span><br><span class="line">    ProvideFoo,</span><br><span class="line">    wire.Struct(<span class="built_in">new</span>(FooBar), <span class="string">&quot;MyFoo&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>使用 ``wire:“-”` 结构体标签可以让 Wire 忽略某些字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu sync.Mutex <span class="string">`wire:&quot;-&quot;`</span></span><br><span class="line">    Bar Bar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="binding-values"><a class="markdownIt-Anchor" href="#binding-values"></a> Binding values</h3>
<p>有时候会想给某个类型绑定一个基本值，可以在 <code>provider set</code> 中使用 <code>值表达式</code>（value expression）来实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">injectFoo</span><span class="params">()</span></span> Foo &#123;</span><br><span class="line">    wire.Build(wire.Value(Foo&#123;X: <span class="number">42</span>&#125;))</span><br><span class="line">    <span class="keyword">return</span> Foo&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成的 injector 代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">injectFoo</span><span class="params">()</span></span> Foo &#123;</span><br><span class="line">    foo := _wireFooValue</span><br><span class="line">    <span class="keyword">return</span> foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    _wireFooValue = Foo&#123;X: <span class="number">42</span>&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>对于接口类型的值，则使用 <code>InterfaceValue</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">injectReader</span><span class="params">()</span></span> io.Reader &#123;</span><br><span class="line">    wire.Build(wire.InterfaceValue(<span class="built_in">new</span>(io.Reader), os.Stdin))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用结构体的字段作为-provider"><a class="markdownIt-Anchor" href="#使用结构体的字段作为-provider"></a> 使用结构体的字段作为 provider</h3>
<p>有时候  provider 提供的是某个结构体中的某个字段，例如如下代码中的 getS：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    S <span class="type">string</span></span><br><span class="line">    N <span class="type">int</span></span><br><span class="line">    F <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getS</span><span class="params">(foo Foo)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">// Bad! Use wire.FieldsOf instead.</span></span><br><span class="line">    <span class="keyword">return</span> foo.S</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">provideFoo</span><span class="params">()</span></span> Foo &#123;</span><br><span class="line">    <span class="keyword">return</span> Foo&#123; S: <span class="string">&quot;Hello, World!&quot;</span>, N: <span class="number">1</span>, F: <span class="number">3.14</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">injectedMessage</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    wire.Build(</span><br><span class="line">        provideFoo,</span><br><span class="line">        getS)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时可以使用 <code>wire.FieldsOf</code> 来实现，而不用编写 <code>getS</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">injectedMessage</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    wire.Build(</span><br><span class="line">        provideFoo,</span><br><span class="line">        wire.FieldsOf(<span class="built_in">new</span>(Foo), <span class="string">&quot;S&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在 <code>wire.FieldsOf</code> 中添加任意个数的字段名称，对于给定的字段类型 T，<code>FieldsOf</code> 至少提供 T 类型，如果结构体参数是指向结构体的指针，则 <code>FieldsOf</code> 也提供 <code>*T</code>。</p>
<h3 id="清理函数"><a class="markdownIt-Anchor" href="#清理函数"></a> 清理函数</h3>
<p>如果 provider 创建的值需要被清理（例如关闭文件），它可以返回返回一个闭包来清理资源。<code>injector</code> 可以使用这个返回的闭包函数。如下是个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">provideFile</span><span class="params">(log Logger, path Path)</span></span> (*os.File, <span class="function"><span class="keyword">func</span><span class="params">()</span></span>, <span class="type">error</span>) &#123;</span><br><span class="line">    f, err := os.Open(<span class="type">string</span>(path))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    cleanup := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := f.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Log(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f, cleanup, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="另一种-injector-语法"><a class="markdownIt-Anchor" href="#另一种-injector-语法"></a> 另一种 injector 语法</h3>
<p>在 injector 中，还可以有一种简单写法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">injectFoo</span><span class="params">()</span></span> Foo &#123;</span><br><span class="line">    <span class="built_in">panic</span>(wire.Build(<span class="comment">/* ... */</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就不用编写类似于 <code>return foobarbaz.Foo&#123;&#125;, nil</code> 的返回语句了。</p>
<h2 id="最佳实践"><a class="markdownIt-Anchor" href="#最佳实践"></a> 最佳实践</h2>
<p>接下来再列举一些 Wire 官方推荐的最佳实践。</p>
<p>如果需要注入 string 这种公共类型，可以创建一个新的类型，这样可以避免和其他 provider 产生冲突：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MySQLConnectionString <span class="type">string</span></span><br></pre></td></tr></table></figure>
<p>包含许多依赖的 provider，可以和 options 结构体配合使用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Options <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Messages is the set of recommended greetings.</span></span><br><span class="line">    Messages []Message</span><br><span class="line">    <span class="comment">// Writer is the location to send greetings. nil goes to stdout.</span></span><br><span class="line">    Writer io.Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGreeter</span><span class="params">(ctx context.Context, opts *Options)</span></span> (*Greeter, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> GreeterSet = wire.NewSet(wire.Struct(<span class="built_in">new</span>(Options), <span class="string">&quot;*&quot;</span>), NewGreeter)</span><br></pre></td></tr></table></figure>
<p>对于库中提供的 <code>provider set</code>，为了不破坏兼容性，需要遵守如下原则：</p>
<ul>
<li>只要 provider 不对 <code>provider set</code> 引入新的输入（可以移除输入），可以更新 <code>provider set</code> 中的某个 provider</li>
<li>只有该类型本身是新添加的类型，才可以在 <code>provider set</code> 中引入新的输出类型。因为如果该类型不是新类型，有可能某些 injector 已经包含了该类型，这会导致冲突</li>
</ul>
<p>以下修改都可能是不可全的：</p>
<ul>
<li>在 <code>provider set</code> 中引入新的输入类型</li>
<li>在 <code>provider set</code> 中移除输入类型</li>
<li>在 <code>provider set</code> 中添加已存在的输出类型</li>
</ul>
<p>为了避免破坏兼容性，可以创建一个新的 <code>provider set</code> 来解决这些问题。</p>
<p>例如假设有如下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> GreeterSet = wire.NewSet(NewStdoutGreeter)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DefaultGreeter</span><span class="params">(ctx context.Context)</span></span> *Greeter &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStdoutGreeter</span><span class="params">(ctx context.Context, msgs []Message)</span></span> *Greeter &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGreeter</span><span class="params">(ctx context.Context, w io.Writer, msgs []Message)</span></span> (*Greeter, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以在 <code>GreeterSet</code> 中使用 <code>DefaultGreeter</code>，替换 <code>NewStdoutGreeter</code></li>
<li>如果新创建了一个类型 T，可以在 GreeterSet 中添加一个 T 类型的 provider（在同一个 commit 中进行修改）</li>
<li>不可以在 <code>GreeterSet</code> 中添加 <code>NewGreeter</code> 来替换 <code>NewStdoutGreeter</code>，因为这会导致 injector 引入新的类型、同时增加了一个输出类型 error</li>
<li>不可以从 <code>GreeterSet</code> 中移除 <code>NewStdoutGreeter</code>，因为这会导致依赖 <code>*Greeter</code> 的 injector 的无法工作</li>
<li>也不能在 <code>GreeterSet</code> 中为 <code>io.Writer</code> 引入 provider，因为 injector 可能已经为 <code>io.Writer</code> 提供了 provider，这可能导致冲突</li>
</ul>
<p>因此尽可能保持库中的 <code>provider set</code> 最小化，可以降低冲突的可能。</p>
<p>如果想使用 <code>mocked 依赖</code> 来创建一个依赖注入应用，有两种方式，具体可以参考官方提供的<a target="_blank" rel="noopener" href="https://github.com/google/wire/tree/master/internal/wire/testdata/ExampleWithMocks/foo">示例</a>。</p>
<h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/google/wire?tab=readme-ov-file">google/wire</a></li>
<li><a target="_blank" rel="noopener" href="https://go.dev/blog/wire">Compile-time Dependency Injection With Go Cloud’s Wire</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/google/wire/blob/main/_tutorial/README.md">Wire Tutorial</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/google/wire/blob/main/docs/guide.md">Wire User Guide</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/Go/" rel="tag"># Go</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/06/20/go-webhook/" rel="prev" title="adnanh/webhook 源码分析">
      <i class="fa fa-chevron-left"></i> adnanh/webhook 源码分析
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/04/05/jwt-basic/" rel="next" title="JWT 基础">
      JWT 基础 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#wire-%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text"> Wire 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#wire-%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.</span> <span class="nav-text"> Wire 解决什么问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">1.2.</span> <span class="nav-text"> 与其他依赖注入工具的比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wire-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.</span> <span class="nav-text"> Wire 的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wire-%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.</span> <span class="nav-text"> Wire 示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wire-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="nav-number">4.</span> <span class="nav-text"> Wire 高级特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#interface-binding"><span class="nav-number">4.1.</span> <span class="nav-text"> interface binding</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#struct-provider"><span class="nav-number">4.2.</span> <span class="nav-text"> struct provider</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binding-values"><span class="nav-number">4.3.</span> <span class="nav-text"> Binding values</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AD%97%E6%AE%B5%E4%BD%9C%E4%B8%BA-provider"><span class="nav-number">4.4.</span> <span class="nav-text"> 使用结构体的字段作为 provider</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%85%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">4.5.</span> <span class="nav-text"> 清理函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%A6%E4%B8%80%E7%A7%8D-injector-%E8%AF%AD%E6%B3%95"><span class="nav-number">4.6.</span> <span class="nav-text"> 另一种 injector 语法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">5.</span> <span class="nav-text"> 最佳实践</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reference"><span class="nav-number">6.</span> <span class="nav-text"> Reference</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">228</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">


  

</body>
</html>
