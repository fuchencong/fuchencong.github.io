<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="GoFrame 是一款模块化、高性能的 Go 语言开发框架，具有工程完备、开箱即用、高扩展性等特点，包含了常用的基础组件和开发工具，既可以作为完整的业务项目框架使用也可以作为独立的组件库使用。">
<meta property="og:type" content="article">
<meta property="og:title" content="GoFrame 学习（1）：快速开始">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2025/07/02/goframe-01/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="GoFrame 是一款模块化、高性能的 Go 语言开发框架，具有工程完备、开箱即用、高扩展性等特点，包含了常用的基础组件和开发工具，既可以作为完整的业务项目框架使用也可以作为独立的组件库使用。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2025/07/02/goframe-01/images/swagger.jpg">
<meta property="article:published_time" content="2025-07-02T06:33:37.000Z">
<meta property="article:modified_time" content="2025-07-06T02:39:11.705Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fuchencong.github.io/fuchencong.github.io/2025/07/02/goframe-01/images/swagger.jpg">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2025/07/02/goframe-01/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>GoFrame 学习（1）：快速开始 | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2025/07/02/goframe-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          GoFrame 学习（1）：快速开始
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-02 14:33:37" itemprop="dateCreated datePublished" datetime="2025-07-02T14:33:37+08:00">2025-07-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>GoFrame 是一款模块化、高性能的 Go 语言开发框架，具有工程完备、开箱即用、高扩展性等特点，包含了常用的基础组件和开发工具，既可以作为完整的业务项目框架使用也可以作为独立的组件库使用。</p>
<span id="more"></span>
<h2 id="快速开始"><a class="markdownIt-Anchor" href="#快速开始"></a> 快速开始</h2>
<p>接下来我们将使用 GoFrame 来开发一个简单的 Web 服务，从而快速上手 GoFrame。如下代码使用 GoFrame 快速启动一个 <code>Web Server</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/gogf/gf/v2/frame/g&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/gogf/gf/v2/net/ghttp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := g.Server()</span><br><span class="line">	s.BindHandler(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(r *ghttp.Request)</span></span> &#123;</span><br><span class="line">		r.Response.Write(<span class="string">&quot;Hello World\n&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	s.SetPort(<span class="number">8000</span>)</span><br><span class="line">	s.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来配置 <code>go mod</code> 并安装依赖：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">go</span> mod init main</span><br><span class="line"># <span class="keyword">go</span> mod tidy</span><br></pre></td></tr></table></figure>
<p>运行该程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># go run main.go</span></span><br><span class="line">2025-06-28T15:07:00.962+08:00 [INFO] pid[2719616]: http server started listening on [:8000]</span><br><span class="line">2025-06-28T15:07:00.962+08:00 [INFO] openapi specification is disabled</span><br><span class="line"></span><br><span class="line">  ADDRESS | METHOD | ROUTE |     HANDLER     | MIDDLEWARE</span><br><span class="line">----------|--------|-------|-----------------|-------------</span><br><span class="line">  :8000   | ALL    | /     | main.main.func1 |</span><br><span class="line">----------|--------|-------|-----------------|-------------</span><br></pre></td></tr></table></figure>
<p>接下来使用 curl 访问该服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curl 127.0.0.1:8000/</span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>
<p>快速解释一下上面代码：</p>
<ul>
<li>g 组件是框架提供的一个耦合组件，封装和初始化一些常用的组件对象，例如 <code>g.Server()</code> 就可以获取一个默认的 Server 对象</li>
<li>通过 Server 的 <code>BindHandler</code> 方法绑定路由及其处理函数，输出参数为当前请求对象 <code>r *ghttp.Request</code>，包含了当前请求的上下文信息</li>
<li>通过调用 <code>r.Response</code> 对象的 <code>Write</code> 方法输出响应内容</li>
<li>调用 Server 的 <code>Run()</code> 方法启动服务</li>
</ul>
<h3 id="获取请求参数"><a class="markdownIt-Anchor" href="#获取请求参数"></a> 获取请求参数</h3>
<p>可以对上面的 <code>Web Server</code> 进行扩展，获取客户端提交的请求参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   ......</span><br><span class="line">s.BindHandler(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(r *ghttp.Request)</span></span> &#123;</span><br><span class="line">	r.Response.Writef(<span class="string">&quot;Hello, %s, you are %d years old\n&quot;</span>,</span><br><span class="line">		r.Get(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;unknown&quot;</span>).String(),</span><br><span class="line">		r.Get(<span class="string">&quot;age&quot;</span>, <span class="number">0</span>).Int())</span><br><span class="line">&#125;)</span><br><span class="line">   ......</span><br></pre></td></tr></table></figure>
<p>可以通过 <code>r.Get()</code> 方法来获取请求参数，它的第一个参数为参数名称，第二个参数为默认值，返回值是一个 <code>gvar.Var</code> 对象，它是一个运行时泛型对象，需要根据具体场景转换为特定类型值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span></span> Get(key <span class="type">string</span>, def ...<span class="keyword">interface</span>&#123;&#125;) *gvar.Var</span><br></pre></td></tr></table></figure>
<p><code>r.Get()</code> 可以获取所有 HTTP 请求方法提交的参数，例如它支持从 URL 查询参数、HTTP body 等中获取参数，而且可以自动识别不同的 <code>Content-Type</code>，例如 <code>JSON</code>、<code>x-www-form-urlencoded</code> 等。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curl 127.0.0.1:8000/</span></span><br><span class="line">Hello, unknown, you are 0 years old</span><br><span class="line"></span><br><span class="line"><span class="comment"># curl &#x27;127.0.0.1:8000?name=jack&amp;age=20&#x27;</span></span><br><span class="line">Hello, jack, you are 20 years old</span><br><span class="line"></span><br><span class="line"><span class="comment"># curl 127.0.0.1:8000 -H &quot;Content-Type:json&quot; -d &#x27;&#123;&quot;name&quot;: &quot;jane&quot;, &quot;age&quot;: 25&#125;&#x27;</span></span><br><span class="line">Hello, jane, you are 25 years old</span><br><span class="line"></span><br><span class="line"><span class="comment"># curl 127.0.0.1:8000 -d &#x27;name=mark&amp;age=22&#x27;</span></span><br><span class="line">Hello, mark, you are 22 years old</span><br></pre></td></tr></table></figure>
<p>这种获取参数的方式有一些缺点，例如参数名称硬编码到代码中，而且与业务数据结构无法关联起来，可以通过结构化的参数对象来解决这个问题。</p>
<h3 id="请求数据结构"><a class="markdownIt-Anchor" href="#请求数据结构"></a> 请求数据结构</h3>
<p>通过 <code>结构化数据</code> 来提取请求参数，可以很好地维护参数的名称和类型。通过 <code>r.Parse()</code> 方法将请求参数映射到请求对象上，同样 <code>r.Parse()</code> 支持解析不同方法提交的请求参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   ......</span><br><span class="line">s := g.Server()</span><br><span class="line">s.BindHandler(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(r *ghttp.Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> req HelloReq</span><br><span class="line">	<span class="keyword">if</span> err := r.Parse(&amp;req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		r.Response.Write(err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r.Response.Writef(<span class="string">&quot;Hello, %s, you are %d years old\n&quot;</span>, req.Name, req.Age)</span><br><span class="line">&#125;)</span><br><span class="line">   .....</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curl &#x27;127.0.0.1:8000?name=jack&amp;age=20&#x27;</span></span><br><span class="line">Hello, jack, you are 20 years old</span><br><span class="line"></span><br><span class="line"><span class="comment"># curl 127.0.0.1:8000 -d &#x27;name=mark&amp;age=22&#x27;</span></span><br><span class="line">Hello, mark, you are 22 years old</span><br><span class="line"></span><br><span class="line"><span class="comment"># curl 127.0.0.1:8000  -d &#x27;&#123;&quot;name&quot;: &quot;jane&quot;, &quot;age&quot;: 25&#125;&#x27;</span></span><br><span class="line">Hello, jane, you are 25 years old</span><br></pre></td></tr></table></figure>
<h3 id="使用规范路由"><a class="markdownIt-Anchor" href="#使用规范路由"></a> 使用规范路由</h3>
<p>为了简化路由的注册方式，而且避免在每个路由处理函数中进行繁琐的参数解析，GoFrame 提供了 <code>规范化的路由注册方式</code>。为了使用 <code>规范路由</code>，首先需要定义请求数据结构和响应数据结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HelloReq <span class="keyword">struct</span> &#123;</span><br><span class="line">	g.Meta <span class="string">`path:&quot;/&quot; method:&quot;get&quot;`</span></span><br><span class="line">	Name   <span class="type">string</span> <span class="string">`v:&quot;required&quot; dc:&quot;name&quot;`</span></span><br><span class="line">	Age    <span class="type">int</span>    <span class="string">`v:&quot;required&quot; dc:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloRes <span class="keyword">struct</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>请求对象中新增了一个 <code>g.Meta</code> 对象，并提供过了一些结构体标签。该对象为元数据对象，用于给结构体嵌入一些标签信息：</p>
<ul>
<li>path：路由的地址</li>
<li>method：HTTP 方法</li>
</ul>
</li>
<li>
<p>请求对象的其他属性中，也新增了一些标签：</p>
<ul>
<li>v：<code>valid</code> 的缩写，用于自动校验参数</li>
<li>dc：<code>description</code> 的缩写，用于描述参数</li>
</ul>
</li>
</ul>
<p>当接口比较多时，手动配置路由与路由函数的关系有些繁琐，可以通过对象化的形式来封装路由函数。如下定义一个 <code>路由对象</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Hello &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Hello)</span></span> Say(ctx context.Context, req *HelloReq) (res *HelloRes, err <span class="type">error</span>) &#123;</span><br><span class="line">	r := g.RequestFromCtx(ctx)</span><br><span class="line">	r.Response.Writef(<span class="string">&quot;Hello, %s, you are %d years old\n&quot;</span>, req.Name, req.Age)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>路由对象用于封装路由函数，其所有定义的公开方法都将作为路由函数进行注册</li>
<li>这里路由对象的 <code>Say</code> 方法其实就是一个路由函数，但是的它的定义更加符合业务逻辑函数的定义风格</li>
<li>通过 <code>g.RequestFromCtx</code> 从 ctx 中获取原始的 <code>ghttp.Request</code> 对象，之后就可以返回自定义内容</li>
</ul>
<p>最后通过如下方式完成路由的注册：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    s.Group(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(group *ghttp.RouterGroup)</span></span> &#123;</span><br><span class="line">        group.Bind(<span class="built_in">new</span>(Hello))</span><br><span class="line">    &#125;)</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里使用了 <code>s.Group</code> 来进行路由分组，在其回调方法中注册的所有路由，都会带有其定义的 <code>分组路由前缀</code>，这里即 <code>/</code></li>
<li>通过 <code>group.Bind</code> 方法注册路由对象，<strong>该方法将会遍历路由对象的所有公开方法，读取方法的输入输出结构体定义，并对其执行路由注册</strong>。</li>
</ul>
<p>代码运行如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curl &#x27;127.0.0.1:8000?name=jack&amp;age=20&#x27;</span></span><br><span class="line">Hello, jack, you are 20 years old</span><br><span class="line"></span><br><span class="line"><span class="comment"># curl 127.0.0.1:8000 -H &quot;Content-Type:json&quot; -d &#x27;name=mark&amp;age=22&#x27;</span></span><br><span class="line">Not Found</span><br></pre></td></tr></table></figure>
<p>可以看到，此时已经不支持通过 <code>POST</code> 方法提交的请求了，因为我们的请求对象的 <code>g.Meta</code> 对象中指定了请求方法为 <code>GET</code>。</p>
<h3 id="中间件"><a class="markdownIt-Anchor" href="#中间件"></a> 中间件</h3>
<p>中间件是一种拦截器设计，在 Web Server 中可以拦截请求/响应，并添加自定义处理逻辑。中间件的定义和普通的路由函数一样，但可以在 Request 参数中使用 Middleware 属性对象来控制请求流程。</p>
<p>中间件的类型分为两种：</p>
<ul>
<li>前置中间件：在路由服务函数调用之前</li>
<li>后置中间件：在路由服务函数调用之后</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Middleware</span><span class="params">(r *ghttp.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 前置中间件处理逻辑</span></span><br><span class="line">    r.Middleware.Next()</span><br><span class="line">    <span class="comment">// 后置中间件处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在中间件中执行完成处理逻辑后，使用 <code>r.Middleware.Next()</code> 方法进一步执行下一个流程。如果这个时候直接退出不调用 <code>r.Middleware.Next()</code> 方法的话，将会退出后续的执行流程（例如请求鉴权失败）。</p>
<p>如下使用中间件来实现错误处理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ErrorHandler</span><span class="params">(r *ghttp.Request)</span></span> &#123;</span><br><span class="line">	r.Middleware.Next()</span><br><span class="line">	<span class="keyword">if</span> err := r.GetError(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		r.Response.Write(<span class="string">&quot;error occurs: &quot;</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    s.Group(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(group *ghttp.RouterGroup)</span></span> &#123;</span><br><span class="line">		group.Middleware(ErrorHandler)</span><br><span class="line">		group.Bind(<span class="built_in">new</span>(Hello))</span><br><span class="line">	&#125;)</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里定义了 <code>ErrorHandler</code> 这个错误处理中间件，它首先调用 <code>r.Middleware.Next()</code> 执行路由函数流程，然后通过 <code>r.GetError()</code> 获取路由函数执行过程中产生的错误，如果有则进行处理。因此它是一个后置中间件</li>
<li>在路由注册中，通过 <code>group.Middleware(ErrorHandler)</code> 给该分组下的所有路由，都绑定这个错误处理的中间件</li>
</ul>
<p>再次运行，查看错误处理中间件的效果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curl 127.0.0.1:8000</span></span><br><span class="line">error occurs: The Name field is required</span><br></pre></td></tr></table></figure>
<h3 id="统一返回结构"><a class="markdownIt-Anchor" href="#统一返回结构"></a> 统一返回结构</h3>
<p>如果希望执行成功或者失败，都是以 json 格式返回应答，可以使用如下方法实现：</p>
<ul>
<li>首先定义路由函数返回的数据结构以及统一的数据结构</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HelloRes <span class="keyword">struct</span> &#123;</span><br><span class="line">	Content <span class="type">string</span> <span class="string">`json:&quot;content&quot; dc:&quot;result&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Response <span class="keyword">struct</span> &#123;</span><br><span class="line">	Message <span class="type">string</span>      <span class="string">`json:&quot;message&quot;`</span></span><br><span class="line">	Data    <span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>修改路由处理函数的实现，让它返回 <code>HelloRes</code> 数据结构，而不是直接写入响应内容</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Hello)</span></span> Say(ctx context.Context, req *HelloReq) (res *HelloRes, err <span class="type">error</span>) &#123;</span><br><span class="line">	res = &amp;HelloRes&#123;</span><br><span class="line">		Content: fmt.Sprintf(<span class="string">&quot;Hello, %s, you are %d years old&quot;</span>, req.Name, req.Age),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>修改中间件的实现，统一返回 json 数据。这里的关键是通过 <code>r.GetHandlerResponse()</code> 获取路由函数返回的执行结果，并通过 <code>r.Response.WriteJson</code> 方法写入真正的响应内容</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Middleware</span><span class="params">(r *ghttp.Request)</span></span> &#123;</span><br><span class="line">	r.Middleware.Next()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		msg <span class="type">string</span></span><br><span class="line">		res = r.GetHandlerResponse()</span><br><span class="line">		err = r.GetError()</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		msg = err.Error()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		msg = <span class="string">&quot;OK&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r.Response.WriteJson(Response&#123;</span><br><span class="line">		Message: msg,</span><br><span class="line">		Data:    res,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最后，路由注册相关代码如下所示：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   ......</span><br><span class="line">s.Group(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(group *ghttp.RouterGroup)</span></span> &#123;</span><br><span class="line">	group.Middleware(Middleware)</span><br><span class="line">	group.Bind(<span class="built_in">new</span>(Hello))</span><br><span class="line">&#125;)</span><br><span class="line">   ......</span><br></pre></td></tr></table></figure>
<p>实际测试结果如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># curl <span class="string">&#x27;127.0.0.1:8000?name=jack&amp;age=20&#x27;</span></span><br><span class="line">&#123;<span class="string">&quot;message&quot;</span>:<span class="string">&quot;OK&quot;</span>,<span class="string">&quot;data&quot;</span>:&#123;<span class="string">&quot;content&quot;</span>:<span class="string">&quot;Hello, jack, you are 20 years old&quot;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"># curl <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8000</span></span><br><span class="line">&#123;<span class="string">&quot;message&quot;</span>:<span class="string">&quot;The Name field is required&quot;</span>,<span class="string">&quot;data&quot;</span>:null&#125;</span><br></pre></td></tr></table></figure>
<p><strong>通过中间件对返回的数据统一进行封装，这对有着大量 API 接口的业务来说是很有必要的</strong>。</p>
<h3 id="自动化生成接口文档"><a class="markdownIt-Anchor" href="#自动化生成接口文档"></a> 自动化生成接口文档</h3>
<p>使用 GoFrame 框架自动化生成接口文档非常简单：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	......</span><br><span class="line">	s.SetOpenApiPath(<span class="string">&quot;/api.json&quot;</span>)</span><br><span class="line">	s.SetSwaggerPath(<span class="string">&quot;/swagger&quot;</span>)</span><br><span class="line">	s.SetPort(<span class="number">8000</span>)</span><br><span class="line">	s.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>s.SetOpenApiPath(&quot;/api.json&quot;)</code> 启用 <code>OpenAPIv3</code> 接口文档生成，访问路径设置为 <code>/api.json</code>。<code>OpenAPIv3</code> 是目前业界接口文档的标准协议，通常使用 json 格式生成，这个 json 文件可以使用很多接口管理攻击打开，例如 <code>Swagger UI</code>、<code>Postman</code> 等</p>
</li>
<li>
<p><code>s.SetSwaggerPath(&quot;/swagger&quot;)</code> 启用内置的接口文档 UI 工具，访问路径设置为 <code>/swagger</code>。<code>swagger</code> 是常用的接口文档 UI 工具，支持多种接口文档格式，例如 <code>OpenAPIv3</code>。其实准确地说，GoFrame 框架内置的 UI 工具是 <code>redoc</code>，而不是 <code>swagger ui</code></p>
</li>
</ul>
<p>另外，我们可以按照 <code>OpenAPIv3</code> 接口协议规范，在 <code>g.Meta</code> 中继续完善接口定义，例如添加如下标签：</p>
<ul>
<li>tags：接口分类/模块</li>
<li>summary：接口描述</li>
</ul>
<p>现在我们访问对应的 URI 地址，就能看到接口文档了，也能使用 <code>Swagger UI</code> 查看接口：</p>
<img src="/fuchencong.github.io/2025/07/02/goframe-01/images/swagger.jpg" class="">
<h2 id="项目脚手架"><a class="markdownIt-Anchor" href="#项目脚手架"></a> 项目脚手架</h2>
<p>GoFrame 框架同时还提供了 <code>项目脚手架</code> 工具，以快速生成标准化、工程化的项目框架代码。</p>
<h3 id="安装框架工具"><a class="markdownIt-Anchor" href="#安装框架工具"></a> 安装框架工具</h3>
<p>如下在 Linux 系统上下载并安装预编译的框架工具：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O gf <span class="string">&quot;https://github.com/gogf/gf/releases/latest/download/gf_<span class="subst">$(go env GOOS)</span>_<span class="subst">$(go env GOARCH)</span>&quot;</span> &amp;&amp; <span class="built_in">chmod</span> +x gf &amp;&amp; ./gf install -y &amp;&amp; <span class="built_in">rm</span> ./gf</span><br></pre></td></tr></table></figure>
<p>确认安装成功：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gf -v</span></span><br><span class="line">v2.9.0</span><br><span class="line">Welcome to GoFrame!</span><br><span class="line">Env Detail:</span><br><span class="line">  Go Version: go1.23.1 linux/amd64</span><br><span class="line">  GF Version(go.mod): cannot find go.mod</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h3 id="创建项目模版"><a class="markdownIt-Anchor" href="#创建项目模版"></a> 创建项目模版</h3>
<p>使用如下命令快速创建一个工程项目，项目名称为 demo，<code>-u</code> 参数用于指定是否更新项目中使用的 GoFrame 框架：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gf init demo -u</span></span><br></pre></td></tr></table></figure>
<p>生成的项目脚手架是按照通用性设计的，可以满足 Web、微服务等开发场景：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd demo</span></span><br><span class="line"><span class="comment"># tree -L 1 --dirsfirst</span></span><br><span class="line">.</span><br><span class="line">├── api</span><br><span class="line">├── hack</span><br><span class="line">├── internal</span><br><span class="line">├── manifest</span><br><span class="line">├── resource</span><br><span class="line">├── utility</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">├── Makefile</span><br><span class="line">└── README.MD</span><br></pre></td></tr></table></figure>
<p>默认会生成一个 <code>HTTP Web Server</code> 的模版项目，因此直接可以直接运行该项目：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># go run main.go</span></span><br><span class="line">2025-06-30T13:21:36.393+08:00 [INFO] pid[3830415]: http server started listening on [:8000]</span><br><span class="line">2025-06-30T13:21:36.393+08:00 [INFO] swagger ui is serving at address: http://127.0.0.1:8000/swagger/</span><br><span class="line">2025-06-30T13:21:36.393+08:00 [INFO] openapi specification is serving at address: http://127.0.0.1:8000/api.json</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curl 127.0.0.1:8000/hello</span></span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>
<p>如果想要更新项目使用的 GoFrame 框架版本，可以在项目根目录下（目录下有 go.mod 文件）使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gf up -a</span><br></pre></td></tr></table></figure>
<h3 id="项目启动分析"><a class="markdownIt-Anchor" href="#项目启动分析"></a> 项目启动分析</h3>
<p>接下来将对该工具生成的 <code>脚手架</code> 项目的启动流程进行分析，以熟悉工具生成的 <code>脚手架</code> 代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	_ <span class="string">&quot;demo/internal/packed&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/gogf/gf/v2/os/gctx&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;demo/internal/cmd&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd.Main.Run(gctx.GetInitCtx())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>程序入口由 main.go 进入，该文件调用 <code>internal/cmd</code> 包的 <code>Main.Run</code> 启动程序</li>
<li>项目的所有核心业务逻辑都放到了 <code>internal</code> 目录下，以封装内部实现</li>
<li>框架的核心组件均需要传递 context 上下文参数，这里使用 <code>gctx.GetInitCtx()</code> 获取一个 Context</li>
</ul>
<p><code>Main.Run</code> 函数主要完成启动逻辑，默认它会启动一个 HTTP Server：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	Main = gcmd.Command&#123;</span><br><span class="line">		Name:  <span class="string">&quot;main&quot;</span>,</span><br><span class="line">		Usage: <span class="string">&quot;main&quot;</span>,</span><br><span class="line">		Brief: <span class="string">&quot;start http server&quot;</span>,</span><br><span class="line">		Func: <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, parser *gcmd.Parser)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">			s := g.Server()</span><br><span class="line">			s.Group(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(group *ghttp.RouterGroup)</span></span> &#123;</span><br><span class="line">				group.Middleware(ghttp.MiddlewareHandlerResponse)</span><br><span class="line">				group.Bind(</span><br><span class="line">					hello.NewV1(),</span><br><span class="line">				)</span><br><span class="line">			&#125;)</span><br><span class="line">			s.Run()</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>这里仍然是通过 <code>s.Group()</code> 的方式创建分组路由，在路由处理函数内，通过 <code>Middleware</code> 方法添加中间件 <code>ghttp.MiddlewareHandlerResponse</code>，用于规范 HTTP 响应</li>
<li>通过 <code>Bind</code> 方法绑定 <code>hello.NewV1()</code> 所返回的路由对象，这个路由对象下的所有公开方法均会自动注册到路由中。项目脚手架支持接口的版本管理，默认返回的路由对象都是 v1 版本</li>
</ul>
<p><code>NewV1()</code> 的返回值其实是一个接口，而不是具体的对象。这样实现的理由是：当我们定义了很多 API 接口，但是具体实现的 controller 对象可能只实现了其中的一部分，为了尽早发现这个问题，我们就可以使用 Go 的接口特性了。<strong>假设具体实现（例如这里的 ControllerV1）只实现了接口的部分方法，那么在编译时就会报错，就不用等到运行时才能发现这个问题了</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IHelloV1 <span class="keyword">interface</span> &#123;</span><br><span class="line">	Hello(ctx context.Context, req *v1.HelloReq) (res *v1.HelloRes, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewV1</span><span class="params">()</span></span> hello.IHelloV1 &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;ControllerV1&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ControllerV1)</span></span> Hello(ctx context.Context, req *v1.HelloReq) (res *v1.HelloRes, err <span class="type">error</span>) &#123;</span><br><span class="line">	g.RequestFromCtx(ctx).Response.Writeln(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从具体的 <code>路由函数实现</code> 中可以看到，请求参数的定义是 <code>v1.HelloReq</code>，响应参数的定义是 <code>v1.HelloRes</code>，从这两个参数的定义中可以看到路由信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HelloReq <span class="keyword">struct</span> &#123;</span><br><span class="line">	g.Meta <span class="string">`path:&quot;/hello&quot; tags:&quot;Hello&quot; method:&quot;get&quot; summary:&quot;You first hello api&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloRes <span class="keyword">struct</span> &#123;</span><br><span class="line">	g.Meta <span class="string">`mime:&quot;text/html&quot; example:&quot;string&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后通过调用 <code>ghttp.Server.Run()</code> 方法启动 HTTP Server，开始接收 HTTP 请求。</p>
<h3 id="接口开发"><a class="markdownIt-Anchor" href="#接口开发"></a> 接口开发</h3>
<p>接下来继续在脚手架框架代码中编写简单的 CRUD 接口，实现对数据库表的增删改查操作。</p>
<h4 id="设计数据表"><a class="markdownIt-Anchor" href="#设计数据表"></a> 设计数据表</h4>
<p>在接口开发之前先设计数据库表是比较好的开发习惯，如下流程启动 mysql 数据库并创建数据库表：</p>
<ul>
<li>首先启动 mysql 数据库：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name mysql \</span><br><span class="line"> -p 3306:3306 \</span><br><span class="line"> -e MYSQL_DATABASE=<span class="built_in">test</span> \</span><br><span class="line"> -e MYSQL_ROOT_PASSWORD=12345678 \</span><br><span class="line"> mysql:8.0</span><br></pre></td></tr></table></figure>
<ul>
<li>测试数据库连接成功</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql mysql -h 127.0.0.1 -P 3306 -u root -p12345678 <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用如下命令创建数据表：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `<span class="built_in">id</span>` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT <span class="string">&#x27;user id&#x27;</span>,</span><br><span class="line">  `name` varchar(45) DEFAULT NULL COMMENT <span class="string">&#x27;user name&#x27;</span>,</span><br><span class="line">  `status` tinyint DEFAULT NULL COMMENT <span class="string">&#x27;user status&#x27;</span>,</span><br><span class="line">  `age` tinyint unsigned DEFAULT NULL COMMENT <span class="string">&#x27;user age&#x27;</span>,</span><br><span class="line">  PRIMARY KEY (`<span class="built_in">id</span>`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show tables;</span><br><span class="line">+----------------+</span><br><span class="line">| Tables_in_test |</span><br><span class="line">+----------------+</span><br><span class="line">| user           |</span><br><span class="line">+----------------+</span><br></pre></td></tr></table></figure>
<h4 id="生成-daodoentity"><a class="markdownIt-Anchor" href="#生成-daodoentity"></a> 生成 dao/do/entity</h4>
<p>开发工具的配置在 <code>hack/config.yaml</code> 文件中维护，我们首先需要检查生成的默认配置是否符合预期：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gfcli:</span><br><span class="line">  gen:</span><br><span class="line">    dao:</span><br><span class="line">      - link: <span class="string">&quot;mysql:root:12345678@tcp(127.0.0.1:3306)/test&quot;</span></span><br><span class="line">        descriptionTag: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  docker:</span><br><span class="line">    build: <span class="string">&quot;-a amd64 -s linux -p temp -ew&quot;</span></span><br><span class="line">    tagPrefixes:</span><br><span class="line">      - my.image.pub/my-app</span><br></pre></td></tr></table></figure>
<p>当我们执行 <code>make dao</code> 命令时，就会用到该配置文件中的 <code>dao</code> 部分配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># make dao</span></span><br><span class="line">generated: /root/code/private/go/go_open/gofg_learn/gf_tool/demo/internal/dao/user.go</span><br><span class="line">generated: /root/code/private/go/go_open/gofg_learn/gf_tool/demo/internal/dao/internal/user.go</span><br><span class="line">generated: /root/code/private/go/go_open/gofg_learn/gf_tool/demo/internal/model/do/user.go</span><br><span class="line">generated: /root/code/private/go/go_open/gofg_learn/gf_tool/demo/internal/model/entity/user.go</span><br><span class="line"><span class="keyword">done</span>!</span><br></pre></td></tr></table></figure>
<p>执行 <code>make dao</code> 命令后，会自动生成 <code>dao/do/entity</code> 文件。每张表将会生成 3 类 Go 文件：</p>
<ul>
<li>dao：通过对象方式访问底层数据源，底层基于 ORM 组件实现</li>
<li>do：数据转换模型，用于业务模型到数据模型的转换，由工具维护，用户不能修改</li>
<li>entity：数据模型，由工具维护，用户不能修改</li>
</ul>
<p>对于工具生成的代码，如果有 <code>Code generated and maintained by GoFrame CLI tool. DO NOT EDIT</code> 的注释，提示我们不要手动修改这些文件。</p>
<p>生成的 dao 文件有 2 个：</p>
<ul>
<li><code>internal/dao/internal/user.go</code> 用于封装对数据表 user 的访问，提供一些数据结构和方法以简化对数据表的 CRUD 操作</li>
<li><code>internal/dao/user.go</code> 对 <code>internal/dao/internal/user.go</code> 的进一步封装，用于供其他模块直接调用访问。开发者可以按需修改该文件</li>
</ul>
<p><code>internal/dao/user.go</code> 提供的方法与对象才是可供其他模块调用的接口，它的代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dao</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;demo/internal/dao/internal&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// userDao is the data access object for the table user.</span></span><br><span class="line"><span class="comment">// You can define custom methods on it to extend its functionality as needed.</span></span><br><span class="line"><span class="keyword">type</span> userDao <span class="keyword">struct</span> &#123;</span><br><span class="line">	*internal.UserDao</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// User is a globally accessible object for table user operations.</span></span><br><span class="line">	User = userDao&#123;internal.NewUserDao()&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add your custom methods and functionality below.</span></span><br></pre></td></tr></table></figure>
<p>生成的 <code>do</code> 代码文件 <code>internal/model/do/user.go</code> 内容如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> do</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/gogf/gf/v2/frame/g&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// User is the golang structure of table user for DAO operations like Where/Data.</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	g.Meta <span class="string">`orm:&quot;table:user, do:true&quot;`</span></span><br><span class="line">	Id     <span class="keyword">interface</span>&#123;&#125; <span class="comment">// user id</span></span><br><span class="line">	Name   <span class="keyword">interface</span>&#123;&#125; <span class="comment">// user name</span></span><br><span class="line">	Status <span class="keyword">interface</span>&#123;&#125; <span class="comment">// user status</span></span><br><span class="line">	Age    <span class="keyword">interface</span>&#123;&#125; <span class="comment">// user age</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成的 <code>entity</code> 代码文件 <code>internal/model/entity/user.go</code> 内容如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> entity</span><br><span class="line"></span><br><span class="line"><span class="comment">// User is the golang structure for table user.</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id     <span class="type">uint</span>   <span class="string">`json:&quot;id&quot;     orm:&quot;id&quot;     description:&quot;user id&quot;`</span>     <span class="comment">// user id</span></span><br><span class="line">	Name   <span class="type">string</span> <span class="string">`json:&quot;name&quot;   orm:&quot;name&quot;   description:&quot;user name&quot;`</span>   <span class="comment">// user name</span></span><br><span class="line">	Status <span class="type">int</span>    <span class="string">`json:&quot;status&quot; orm:&quot;status&quot; description:&quot;user status&quot;`</span> <span class="comment">// user status</span></span><br><span class="line">	Age    <span class="type">uint</span>   <span class="string">`json:&quot;age&quot;    orm:&quot;age&quot;    description:&quot;user age&quot;`</span>    <span class="comment">// user age</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，entity 数据结构定义与数据表字段一一对应。</p>
<h4 id="编写-api-接口定义"><a class="markdownIt-Anchor" href="#编写-api-接口定义"></a> 编写 API 接口定义</h4>
<p>在 <code>api</code> 子目录下，定义 CRUD 接口，接口采用 RESTful 风格，充分使用 <code>GET/POST/PUT/DELETE</code> 的 HTTP Method，同时使用 v1 作为版本号。API 接口代码文件 <code>api/user/v1/user.go</code> 内容如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> v1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;demo/internal/model/entity&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/gogf/gf/v2/frame/g&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Status marks user status.</span></span><br><span class="line"><span class="keyword">type</span> Status <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	StatusOK       Status = <span class="number">0</span> <span class="comment">// User is OK.</span></span><br><span class="line">	StatusDisabled Status = <span class="number">1</span> <span class="comment">// User is disabled.</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CreateReq <span class="keyword">struct</span> &#123;</span><br><span class="line">	g.Meta <span class="string">`path:&quot;/user&quot; method:&quot;post&quot; tags:&quot;User&quot; summary:&quot;Create user&quot;`</span></span><br><span class="line">	Name   <span class="type">string</span> <span class="string">`v:&quot;required|length:3,10&quot; dc:&quot;user name&quot;`</span></span><br><span class="line">	Age    <span class="type">uint</span>   <span class="string">`v:&quot;required|between:18,200&quot; dc:&quot;user age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> CreateRes <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id <span class="type">int64</span> <span class="string">`json:&quot;id&quot; dc:&quot;user id&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UpdateReq <span class="keyword">struct</span> &#123;</span><br><span class="line">	g.Meta <span class="string">`path:&quot;/user/&#123;id&#125;&quot; method:&quot;put&quot; tags:&quot;User&quot; summary:&quot;Update user&quot;`</span></span><br><span class="line">	Id     <span class="type">int64</span>   <span class="string">`v:&quot;required&quot; dc:&quot;user id&quot;`</span></span><br><span class="line">	Name   *<span class="type">string</span> <span class="string">`v:&quot;length:3,10&quot; dc:&quot;user name&quot;`</span></span><br><span class="line">	Age    *<span class="type">uint</span>   <span class="string">`v:&quot;between:18,200&quot; dc:&quot;user age&quot;`</span></span><br><span class="line">	Status *Status <span class="string">`v:&quot;in:0,1&quot; dc:&quot;user status&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> UpdateRes <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DeleteReq <span class="keyword">struct</span> &#123;</span><br><span class="line">	g.Meta <span class="string">`path:&quot;/user/&#123;id&#125;&quot; method:&quot;delete&quot; tags:&quot;User&quot; summary:&quot;Delete user&quot;`</span></span><br><span class="line">	Id     <span class="type">int64</span> <span class="string">`v:&quot;required&quot; dc:&quot;user id&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> DeleteRes <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GetOneReq <span class="keyword">struct</span> &#123;</span><br><span class="line">	g.Meta <span class="string">`path:&quot;/user/&#123;id&#125;&quot; method:&quot;get&quot; tags:&quot;User&quot; summary:&quot;Get one user&quot;`</span></span><br><span class="line">	Id     <span class="type">int64</span> <span class="string">`v:&quot;required&quot; dc:&quot;user id&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> GetOneRes <span class="keyword">struct</span> &#123;</span><br><span class="line">	*entity.User <span class="string">`dc:&quot;user&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GetListReq <span class="keyword">struct</span> &#123;</span><br><span class="line">	g.Meta <span class="string">`path:&quot;/user&quot; method:&quot;get&quot; tags:&quot;User&quot; summary:&quot;Get users&quot;`</span></span><br><span class="line">	Age    *<span class="type">uint</span>   <span class="string">`v:&quot;between:18,200&quot; dc:&quot;user age&quot;`</span></span><br><span class="line">	Status *Status <span class="string">`v:&quot;in:0,1&quot; dc:&quot;user age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> GetListRes <span class="keyword">struct</span> &#123;</span><br><span class="line">	List []*entity.User <span class="string">`json:&quot;list&quot; dc:&quot;user list&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里实现了 User 的创建、更新、删除和查询接口（单个查询和列表查询）</li>
<li>在请求对象的定义中，同样使用了 <code>g.Meta</code> 来管理接口的元数据信息</li>
<li>在请求对象的其他属性中，使用了 <code>v</code> 标签来进行参数校验，<code>required</code>、<code>length</code>、<code>between</code> 等都是内置的校验规则</li>
<li>在响应对象中，通过 json 标签来定义 json 序列化时的字段名</li>
<li>对于 path 标签 <code>/user/&#123;id&#125;</code>，其中 <code>&#123;id&#125;</code> 表示一个路由参数。该参数通过 <code>URL Path</code> 的方式传递，参数名称为 id。从路由中匹配到的 id 参数会自动赋值给请求对象的同名属性（不区分大小写）</li>
<li>在 <code>UpdateReq</code> 请求对象中，我们看到一些参数使用了指针类型。<strong>这是避免类型默认值对接口的影响</strong>，例如如果 <code>Status</code> 字段不使用指针，则它的默认值就是 0，那么就无法区分调用端到底有没有传递该参数。而使用指针（其默认值是 nil）则可以很好地进行区分</li>
<li>在查询接口中，返回的数据直接使用了 <code>*entity.User</code> 结构体</li>
</ul>
<p>这种接口定义方式可以自动化地生成接口文档，保证文档与代码的一致性（代码即文档）。</p>
<h4 id="根据-api-生成代码"><a class="markdownIt-Anchor" href="#根据-api-生成代码"></a> 根据 api 生成代码</h4>
<p>当 api 定义完成后，直接通过 <code>make ctrl</code> 命令（或者 gf gen ctrl）生成 controller 代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># make ctrl</span></span><br><span class="line">generated: /root/code/private/go/go_open/gofg_learn/gf_tool/demo/api/hello/hello.go</span><br><span class="line">generated: /root/code/private/go/go_open/gofg_learn/gf_tool/demo/api/user/user.go</span><br><span class="line">generated: /root/code/private/go/go_open/gofg_learn/gf_tool/demo/internal/controller/user/user.go</span><br><span class="line">generated: /root/code/private/go/go_open/gofg_learn/gf_tool/demo/internal/controller/user/user_new.go</span><br><span class="line">generated: /root/code/private/go/go_open/gofg_learn/gf_tool/demo/internal/controller/user/user_v1_create.go</span><br><span class="line">generated: /root/code/private/go/go_open/gofg_learn/gf_tool/demo/internal/controller/user/user_v1_update.go</span><br><span class="line">generated: /root/code/private/go/go_open/gofg_learn/gf_tool/demo/internal/controller/user/user_v1_delete.go</span><br><span class="line">generated: /root/code/private/go/go_open/gofg_learn/gf_tool/demo/internal/controller/user/user_v1_get_one.go</span><br><span class="line">generated: /root/code/private/go/go_open/gofg_learn/gf_tool/demo/internal/controller/user/user_v1_get_list.go</span><br></pre></td></tr></table></figure>
<p>生成的代码主要包含 3 类文件：</p>
<ul>
<li>api 接口抽象文件：例如 <code>api/user/user.go</code> 文件就是对 API 接口的 interface 定义，这样能在编译期就发现某些接口未实现的问题</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IUserV1 <span class="keyword">interface</span> &#123;</span><br><span class="line">	Create(ctx context.Context, req *v1.CreateReq) (res *v1.CreateRes, err <span class="type">error</span>)</span><br><span class="line">	Update(ctx context.Context, req *v1.UpdateReq) (res *v1.UpdateRes, err <span class="type">error</span>)</span><br><span class="line">	Delete(ctx context.Context, req *v1.DeleteReq) (res *v1.DeleteRes, err <span class="type">error</span>)</span><br><span class="line">	GetOne(ctx context.Context, req *v1.GetOneReq) (res *v1.GetOneRes, err <span class="type">error</span>)</span><br><span class="line">	GetList(ctx context.Context, req *v1.GetListReq) (res *v1.GetListRes, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>controller 路由对象管理：用于管理 controller 的初始化</li>
<li><code>internal/controller/user/user.go</code>：其实是一个空文件，可用于定义一些 controller 内部使用的数据结构、常量等</li>
<li><code>internal/controller/user/user_new.go</code>：包含路由对象创建函数</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> user</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;demo/api/user&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ControllerV1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewV1</span><span class="params">()</span></span> user.IUserV1 &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;ControllerV1&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>controller 路由实现代码：用于实现 API 接口，默认会按照一个 api 接口一个源文件的形式生成代码（也可以控制聚合到一个源码文件中）
<ul>
<li><code>internal/controller/user/user_v1_create.go</code></li>
<li><code>internal/controller/user/user_v1_delete.go</code></li>
<li><code>internal/controller/user/user_v1_get_list.go</code></li>
<li><code>internal/controller/user/user_v1_get_one.go</code></li>
<li><code>internal/controller/user/user_v1_update.go</code></li>
</ul>
</li>
</ul>
<p>默认生成的代码内容如下所示，需要我们自己完善对应的业务逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ControllerV1)</span></span> Create(ctx context.Context, req *v1.CreateReq) (res *v1.CreateRes, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, gerror.NewCode(gcode.CodeNotImplemented)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="完成接口逻辑实现"><a class="markdownIt-Anchor" href="#完成接口逻辑实现"></a> 完成接口逻辑实现</h4>
<p>通过脚手架工具，很多与业务逻辑无关的代码都已经生成好了，我们只需要在对应的代码文件中实现业务逻辑即可。使用 GoFrame 框架数据库 ORM 组件，可以非常方便、高效完成接口开发工作。</p>
<p>例如修改 <code>internal/controller/user/user_v1_create.go</code> 文件，实现用户创建逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ControllerV1)</span></span> Create(ctx context.Context, req *v1.CreateReq) (res *v1.CreateRes, err <span class="type">error</span>) &#123;</span><br><span class="line">	id, err := dao.User.Ctx(ctx).Data(do.User&#123;</span><br><span class="line">		Name:   req.Name,</span><br><span class="line">		Status: v1.StatusOK,</span><br><span class="line">		Age:    req.Age,</span><br><span class="line">	&#125;).InsertAndGetId()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	res = &amp;v1.CreateRes&#123;</span><br><span class="line">		Id: id,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 <code>dao.User</code> 通过 dao 组件操作 user 表</li>
<li>每个 dao 操作都需要传递 ctx 参数，通过 Ctx(ctx) 方法创建一个 <code>gdb.Model</code> 对象，该对象是框架的模型对象，用于操作特定的数据表</li>
<li>通过 Data 方法传递需要写入数据表的数据，使用 <code>do 转换模型对象</code> 输入我们的数据，由 do 模型在底层自动转换为对应的数据表字段类型</li>
<li>最后通过 <code>InsertAndGetId</code> 方法执行插入操作，并返回新创建数据的 ID</li>
</ul>
<p>另外参数的校验逻辑不需要在 Controller 中编写，因为我们在定义请求对象时已经通过 <code>v</code> 标签定义好了，框架会自动进行校验，如果校验失败，不会执行对应的路由函数。因此只需要在路由函数中实现业务逻辑即可。</p>
<p>如下分别实现剩余几个接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ControllerV1)</span></span> Delete(ctx context.Context, req *v1.DeleteReq) (res *v1.DeleteRes, err <span class="type">error</span>) &#123;</span><br><span class="line">	_, err = dao.User.Ctx(ctx).WherePri(req.Id).Delete()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ControllerV1)</span></span> Update(ctx context.Context, req *v1.UpdateReq) (res *v1.UpdateRes, err <span class="type">error</span>) &#123;</span><br><span class="line">	_, err = dao.User.Ctx(ctx).Data(do.User&#123;</span><br><span class="line">		Name:   req.Name,</span><br><span class="line">		Status: req.Status,</span><br><span class="line">		Age:    req.Age,</span><br><span class="line">	&#125;).WherePri(req.Id).Update()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ControllerV1)</span></span> GetList(ctx context.Context, req *v1.GetListReq) (res *v1.GetListRes, err <span class="type">error</span>) &#123;</span><br><span class="line">	res = &amp;v1.GetListRes&#123;&#125;</span><br><span class="line">	err = dao.User.Ctx(ctx).Where(do.User&#123;</span><br><span class="line">		Age:    req.Age,</span><br><span class="line">		Status: req.Status,</span><br><span class="line">	&#125;).Scan(&amp;res.List)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ControllerV1)</span></span> GetOne(ctx context.Context, req *v1.GetOneReq) (res *v1.GetOneRes, err <span class="type">error</span>) &#123;</span><br><span class="line">	res = &amp;v1.GetOneRes&#123;&#125;</span><br><span class="line">	err = dao.User.Ctx(ctx).WherePri(req.Id).Scan(&amp;res.User)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="配置与路由"><a class="markdownIt-Anchor" href="#配置与路由"></a> 配置与路由</h4>
<p>GoFrame 的数据库组件使用了接口化设计，接口与实现是分离的，以提供更好的抽象型和扩展性。由于当前我们使用 mysql 数据库，因此需要引入 mysql 驱动，在 `main.go 中新增如下代码即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ <span class="string">&quot;github.com/gogf/gf/contrib/drivers/mysql/v2&quot;</span></span><br></pre></td></tr></table></figure>
<p>之后需要完成项目配置，脚手架生成的文件中主要有两个配置文件：</p>
<ul>
<li><code>hack/config.yaml</code>：用于配置脚手架工具本身，主要在项目开发过程中使用</li>
<li><code>manifest/config/config.yaml</code>：业务项目的配置文件，由开发者自行维护。默认生成的配置内容如下所示：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># https:<span class="comment">//goframe.org/docs/web/server-config-file-template</span></span><br><span class="line">server:</span><br><span class="line">  address:     <span class="string">&quot;:8000&quot;</span></span><br><span class="line">  openapiPath: <span class="string">&quot;/api.json&quot;</span></span><br><span class="line">  swaggerPath: <span class="string">&quot;/swagger&quot;</span></span><br><span class="line"></span><br><span class="line"># https:<span class="comment">//goframe.org/docs/core/glog-config</span></span><br><span class="line">logger:</span><br><span class="line">  level : <span class="string">&quot;all&quot;</span></span><br><span class="line">  stdout: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"># https:<span class="comment">//goframe.org/docs/core/gdb-config-file</span></span><br><span class="line">database:</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    link: <span class="string">&quot;mysql:root:12345678@tcp(127.0.0.1:3306)/test&quot;</span></span><br></pre></td></tr></table></figure>
<p>最后，我们还需要为新添加的接口注册路由，修改 <code>internal/cmd/cmd.go</code> 文件，在 <code>group.Bind</code> 方法中，通过 <code>user.NewV1()</code> 添加我们的路由对象即可。</p>
<h4 id="运行项目"><a class="markdownIt-Anchor" href="#运行项目"></a> 运行项目</h4>
<ul>
<li>通过如下命令启动服务：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line"><span class="number">2025</span><span class="number">-07</span><span class="number">-02</span>T14:<span class="number">07</span>:<span class="number">54.560</span>+<span class="number">08</span>:<span class="number">00</span> [INFO] pid[<span class="number">802037</span>]: http server started listening on [:<span class="number">8000</span>]</span><br><span class="line"><span class="number">2025</span><span class="number">-07</span><span class="number">-02</span>T14:<span class="number">07</span>:<span class="number">54.560</span>+<span class="number">08</span>:<span class="number">00</span> [INFO] swagger ui is serving at address: http:<span class="comment">//127.0.0.1:8000/swagger/</span></span><br><span class="line"><span class="number">2025</span><span class="number">-07</span><span class="number">-02</span>T14:<span class="number">07</span>:<span class="number">54.560</span>+<span class="number">08</span>:<span class="number">00</span> [INFO] openapi specification is serving at address: http:<span class="comment">//127.0.0.1:8000/api.json</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>我们可以访问对应的 <code>http://127.0.0.1:8000/swagger/</code> 来使用 Swagger UI 查看 API 地址</p>
</li>
<li>
<p>如下使用 curl 测试接口：</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#  curl -X POST <span class="string">&#x27;http://127.0.0.1:8000/user&#x27;</span> -d <span class="string">&#x27;&#123;&quot;name&quot;:&quot;john&quot;,&quot;age&quot;:20&#125;&#x27;</span></span><br><span class="line">&#123;<span class="string">&quot;code&quot;</span>:<span class="number">0</span>,<span class="string">&quot;message&quot;</span>:<span class="string">&quot;OK&quot;</span>,<span class="string">&quot;data&quot;</span>:&#123;<span class="string">&quot;id&quot;</span>:<span class="number">1</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"># curl <span class="string">&#x27;http://127.0.0.1:8000/user&#x27;</span></span><br><span class="line">&#123;<span class="string">&quot;code&quot;</span>:<span class="number">0</span>,<span class="string">&quot;message&quot;</span>:<span class="string">&quot;OK&quot;</span>,<span class="string">&quot;data&quot;</span>:&#123;<span class="string">&quot;list&quot;</span>:[&#123;<span class="string">&quot;id&quot;</span>:<span class="number">1</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;john&quot;</span>,<span class="string">&quot;status&quot;</span>:<span class="number">0</span>,<span class="string">&quot;age&quot;</span>:<span class="number">20</span>&#125;]&#125;&#125;</span><br><span class="line"></span><br><span class="line"># curl <span class="string">&#x27;http://127.0.0.1:8000/user/1&#x27;</span></span><br><span class="line">&#123;<span class="string">&quot;code&quot;</span>:<span class="number">0</span>,<span class="string">&quot;message&quot;</span>:<span class="string">&quot;OK&quot;</span>,<span class="string">&quot;data&quot;</span>:&#123;<span class="string">&quot;id&quot;</span>:<span class="number">1</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;john&quot;</span>,<span class="string">&quot;status&quot;</span>:<span class="number">0</span>,<span class="string">&quot;age&quot;</span>:<span class="number">20</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"># curl -X PUT <span class="string">&#x27;http://127.0.0.1:8000/user/1&#x27;</span> -d <span class="string">&#x27;&#123;&quot;name&quot;:&quot;john&quot;,&quot;age&quot;:30&#125;&#x27;</span></span><br><span class="line">&#123;<span class="string">&quot;code&quot;</span>:<span class="number">0</span>,<span class="string">&quot;message&quot;</span>:<span class="string">&quot;OK&quot;</span>,<span class="string">&quot;data&quot;</span>:null&#125;</span><br><span class="line"></span><br><span class="line"># curl -X DELETE <span class="string">&#x27;http://127.0.0.1:8000/user/1&#x27;</span></span><br><span class="line">&#123;<span class="string">&quot;code&quot;</span>:<span class="number">0</span>,<span class="string">&quot;message&quot;</span>:<span class="string">&quot;OK&quot;</span>,<span class="string">&quot;data&quot;</span>:null&#125;</span><br><span class="line"></span><br><span class="line"># curl <span class="string">&#x27;http://127.0.0.1:8000/user&#x27;</span></span><br><span class="line">&#123;<span class="string">&quot;code&quot;</span>:<span class="number">0</span>,<span class="string">&quot;message&quot;</span>:<span class="string">&quot;OK&quot;</span>,<span class="string">&quot;data&quot;</span>:&#123;<span class="string">&quot;list&quot;</span>:null&#125;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h4>
<p>可以看到，使用 GoFrame 脚手架工具来进行 CRUD 接口的开发，主要的几件事情是：</p>
<ul>
<li>数据库表涉及</li>
<li>api 接口定义</li>
<li>接口的业务逻辑实现</li>
<li>简单的配置、路由注册</li>
</ul>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>这篇文章学习了 GoFrame 框架的基本使用方法，可以看到，使用 GoFrame 框架来开发项目的确比较高效，而且 GoFrame 框架的文档非常丰富，解释也很详尽，的确是一个非常值得学习的开源项目。</p>
<h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://goframe.org.cn/">GoFrame</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/gogf/gf">GoFrame Github</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/Go/" rel="tag"># Go</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/08/19/machine-learning-math/" rel="prev" title="白话机器学习的数学">
      <i class="fa fa-chevron-left"></i> 白话机器学习的数学
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/06/20/go-webhook/" rel="next" title="adnanh/webhook 源码分析">
      adnanh/webhook 源码分析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B"><span class="nav-number">1.</span> <span class="nav-text"> 快速开始</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0"><span class="nav-number">1.1.</span> <span class="nav-text"> 获取请求参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text"> 请求数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83%E8%B7%AF%E7%94%B1"><span class="nav-number">1.3.</span> <span class="nav-text"> 使用规范路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-number">1.4.</span> <span class="nav-text"> 中间件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.</span> <span class="nav-text"> 统一返回结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E7%94%9F%E6%88%90%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3"><span class="nav-number">1.6.</span> <span class="nav-text"> 自动化生成接口文档</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E8%84%9A%E6%89%8B%E6%9E%B6"><span class="nav-number">2.</span> <span class="nav-text"> 项目脚手架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E6%A1%86%E6%9E%B6%E5%B7%A5%E5%85%B7"><span class="nav-number">2.1.</span> <span class="nav-text"> 安装框架工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%A8%A1%E7%89%88"><span class="nav-number">2.2.</span> <span class="nav-text"> 创建项目模版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90"><span class="nav-number">2.3.</span> <span class="nav-text"> 项目启动分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91"><span class="nav-number">2.4.</span> <span class="nav-text"> 接口开发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="nav-number">2.4.1.</span> <span class="nav-text"> 设计数据表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E6%88%90-daodoentity"><span class="nav-number">2.4.2.</span> <span class="nav-text"> 生成 dao&#x2F;do&#x2F;entity</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99-api-%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89"><span class="nav-number">2.4.3.</span> <span class="nav-text"> 编写 API 接口定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE-api-%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81"><span class="nav-number">2.4.4.</span> <span class="nav-text"> 根据 api 生成代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E6%88%90%E6%8E%A5%E5%8F%A3%E9%80%BB%E8%BE%91%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.4.5.</span> <span class="nav-text"> 完成接口逻辑实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%B7%AF%E7%94%B1"><span class="nav-number">2.4.6.</span> <span class="nav-text"> 配置与路由</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE"><span class="nav-number">2.4.7.</span> <span class="nav-text"> 运行项目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">2.4.8.</span> <span class="nav-text"> 小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.</span> <span class="nav-text"> 总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reference"><span class="nav-number">4.</span> <span class="nav-text"> Reference</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">225</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">


  

</body>
</html>
