<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="学会描述符之后，不仅有更多的工具集可用，还能对 Python 的运作方式有更深入的理解，不得不由衷赞叹 Python 设计的优雅。描述符是对多个属性运用相同存取逻辑的一种方式。例如，Django ORM 和 SQLAlchemy 等 ORM 中的字段类型就是描述符，其把数据库记录中字段里的数据与 Python 对象的属性对应了起来。">
<meta property="og:type" content="article">
<meta property="og:title" content="流畅的 Python 第 2 版（23）：属性描述符">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2025/11/16/fluent-python-v2-23/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="学会描述符之后，不仅有更多的工具集可用，还能对 Python 的运作方式有更深入的理解，不得不由衷赞叹 Python 设计的优雅。描述符是对多个属性运用相同存取逻辑的一种方式。例如，Django ORM 和 SQLAlchemy 等 ORM 中的字段类型就是描述符，其把数据库记录中字段里的数据与 Python 对象的属性对应了起来。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2025/11/16/fluent-python-v2-23/images/01.jpg">
<meta property="article:published_time" content="2025-11-16T14:05:18.000Z">
<meta property="article:modified_time" content="2025-12-28T11:43:53.205Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fuchencong.github.io/fuchencong.github.io/2025/11/16/fluent-python-v2-23/images/01.jpg">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2025/11/16/fluent-python-v2-23/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>流畅的 Python 第 2 版（23）：属性描述符 | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2025/11/16/fluent-python-v2-23/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          流畅的 Python 第 2 版（23）：属性描述符
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-16 22:05:18" itemprop="dateCreated datePublished" datetime="2025-11-16T22:05:18+08:00">2025-11-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>学会描述符之后，不仅有更多的工具集可用，还能对 Python 的运作方式有更深入的理解，不得不由衷赞叹 Python 设计的优雅。<strong>描述符是对多个属性运用相同存取逻辑的一种方式</strong>。例如，Django ORM 和 SQLAlchemy 等 ORM 中的字段类型就是描述符，其把数据库记录中字段里的数据与 Python 对象的属性对应了起来。</p>
<span id="more"></span>
<p>描述符是实现了动态协议的类，这个协议包括 <code>__get__</code> 方法、<code>__set__</code> 方法和 <code>__delete__</code> 方法。property 类实现了完整的描述符协议。通常，动态协议可以部分实现。其实，我们在真实的代码中见到的大多数描述符只实现了 <code>__get__</code> 方法和 <code>__set__</code> 方法，还有很多只实现了其中一个方法。</p>
<p><strong>描述符为去除存取方法中的重复逻辑提供了一种机制。描述符是 Python 独有的功能，不仅在应用程序层中使用，在语言的基础设施中也会用到。用户定义的函数就是描述符。我们将看到，描述符协议可以把方法变成绑定方法或非绑定方法，这取决于方法的调用方式</strong>。</p>
<h2 id="描述符示例属性验证"><a class="markdownIt-Anchor" href="#描述符示例属性验证"></a> 描述符示例：属性验证</h2>
<p>特性工厂函数借助函数式编程模式避免重复编写读值方法和设值方法。特性工厂函数是高阶函数，在闭包中存储 storage_name 等设置，由参数决定创建哪些存取函数，再使用存取函数构建自定义的特性实例。解决这种问题的面向对象方式是描述符类。</p>
<p>接下来将定义一个 Quantity 描述符，LineItem 类用到两个 Quantity 实例：一个用于管理 weight 属性，另一个用于管理 price 属性。</p>
<p>实现和使用描述符涉及多个组件，各个组件的命名务必准确：</p>
<ul>
<li>描述符类，实现描述符协议的类，例如 Quantity 类是描述符类</li>
<li>托管类：<strong>把描述符实例声明为类属性的类</strong>，LineItem 类就是托管类</li>
<li>描述符实例：描述符类的各个实例，声明为托管类的类属性</li>
<li>托管实例：托管类的实例。在这个示例中，LineItem 实例是托管实例</li>
<li>储存属性：<strong>托管实例中存储托管属性的属性</strong>。LineItem 实例的 weight 属性和 price 属性是储存属性。这种属性与描述符属性不同，后者始终是类属性。</li>
<li>托管属性：<strong>托管类中由描述符实例处理的公开属性，值存储在储存属性中</strong>。也就是说，<strong>描述符实例和储存属性为托管属性建立了基础</strong>。</li>
</ul>
<img src="/fuchencong.github.io/2025/11/16/fluent-python-v2-23/images/01.jpg" class="">
<p>在这个例子中：</p>
<ul>
<li>类是机器，用于生产小怪兽（实例）</li>
<li>Quantity 机器生产了两个圆头小怪兽，依附在 LineItem 机器上，即 weight 和 price</li>
<li>LineItem 机器生产的是方头小怪兽，有自己的 weight 属性和 price 属性，存储着相应的值</li>
<li>Quantity 实例从 LineItem 实例中获取存储的值</li>
</ul>
<p>如下是代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quantity</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, storage_name</span>):</span><br><span class="line">        self.storage_name = storage_name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">            instance.__dict__[self.storage_name] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg = <span class="string">f&#x27;<span class="subst">&#123;self.storage_name&#125;</span> must be &gt; 0&#x27;</span></span><br><span class="line">            <span class="keyword">raise</span> ValueError(msg)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[self.storage_name]</span><br></pre></td></tr></table></figure>
<ul>
<li>描述符基于协议实现，无须子类化</li>
<li>Quantity 实例有一个 storage_name 属性，<strong>这是托管实例中用于存储值的储存属性的名称</strong></li>
<li>尝试为托管属性赋值时，调用 <code>__set__</code> 方法。这里，self 是描述符实例（<code>LineItem.weight</code> 或<code>LineItem.price</code> )，instance 是托管实例（LineItem 实例）​，value 是要设定的值</li>
<li>必须把属性的值直接存入 <code>__dict__</code>。调用 <code>setattr(instance, self.storage_name)</code> 将再次触发<code>__set__</code> 方法，导致无限递归</li>
<li>需要实现 <code>__get__</code> 方法，因为托管属性的名称可能与 storage_name 不同。用户可能编写如下代码</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">House</span>:</span><br><span class="line">    rooms = Quantity(<span class="string">&#x27;number_of_rooms&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>这里托管属性是 rooms，而储存属性是 number_of_rooms</li>
<li>对于一个名为 <code>chaos_manor</code> 的 House 实例，读写 <code>chaos_manor.rooms</code> 都经过依附在 rooms 上的 Quantity 描述符</li>
<li>但是读写 <code>chaos_manor.number_of_rooms</code> 会绕过该描述符</li>
</ul>
<p>注意，<code>__get__</code> 方法接受 3 个参数：self、instance 和 owner：</p>
<ul>
<li>owner 参数是对托管类（例如LineItem）的引用，在希望描述符支持获取类属性时会用到：比如说模拟 Python 在实例中未找到指定名称的属性时获取类属性的默认行为。</li>
<li>如果通过类获取托管属性（例如 <code>LineItem.weight</code>）​，<strong>那么描述符的 <code>__get__</code> 方法收到的 instance 参数值为 None</strong></li>
<li>为了支持内省和其他元编程技巧，当通过类存取托管属性时，<code>__get__</code> 方法最好返回描述符实例，例如</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">    <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[self.storage_name]</span><br></pre></td></tr></table></figure>
<p>如下则是 LineItem 类的实现，它使用了描述符类 Quantity：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LineItem</span>:</span><br><span class="line">    weight = Quantity(<span class="string">&#x27;weight&#x27;</span>)</span><br><span class="line">    price = Quantity(<span class="string">&#x27;price&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, description, weight, price</span>):</span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subtotal</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br></pre></td></tr></table></figure>
<p>编写描述符的 <code>__get__</code> 方法和 <code>__set__</code> 方法时，要记住 self 参数和 instance 参数的意思：self是描述符实例，instance 是托管实例。<strong>管理实例属性的描述符应该把值存储在托管实例中</strong>。因此，Python 才为描述符中的方法提供了 instance 参数。</p>
<p>你可能想把各个托管属性的值直接存在描述符实例中，但这种做法是错误的。也就是说，在 <code>__set__</code> 方法中，应该像下面这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance.__dict__[self.storage_name] = value</span><br></pre></td></tr></table></figure>
<p>而这样写这是错误的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.__dict__[self.storage_name] = value</span><br></pre></td></tr></table></figure>
<ul>
<li>self 是描述符实例，<strong>它其实是托管类的类属性</strong>。同一时刻，内存中可能有几千个 LineItem 实例，不过只会有两个描述符实例，即类属性 LineItem.weight 和 LineItem.price。因此如果将数据存储在描述符实例，这些数据居等同于成为了 LineItem 的类属性，从而由全部 LineItem 实例共享，而这是错误的</li>
</ul>
<h3 id="为存储属性自动命名"><a class="markdownIt-Anchor" href="#为存储属性自动命名"></a> 为存储属性自动命名</h3>
<p>这段代码中有个小缺点，<code>weight</code> 名称编写了两次（<code>price</code> 也是类似的）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">weight = Quantity(<span class="string">&#x27;weight&#x27;</span>)</span><br><span class="line">price = Quantity(<span class="string">&#x27;price&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>为了避免在描述符实例中重复输入属性名，我们将实现 <code>__set_name__</code> 方法，设置各个 Quantity 实例的<code>storage_name</code>。特殊方法 <code>__set_name__</code> 在 Python3.6 中加入了描述符协议。解释器会在 class 主体中找到的每个描述符上调用 <code>__set_name__</code> 方法，当然前提是描述符实现了该方法。</p>
<p>LineItem 的描述符类不需要 <code>__init__</code> 方法了，<code>__set_name__</code> 方法负责保存储存属性的名称：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quantity</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set_name__</span>(<span class="params">self, owner, name</span>):</span><br><span class="line">        self.storage_name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">            instance.__dict__[self.storage_name] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg = <span class="string">f&#x27;<span class="subst">&#123;self.storage_name&#125;</span> must be &gt; 0&#x27;</span></span><br><span class="line">            <span class="keyword">raise</span> ValueError(msg)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不需要__get__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LineItem</span>:</span><br><span class="line">    weight = Quantity()</span><br><span class="line">    price = Quantity()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, description, weight, price</span>):</span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subtotal</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br></pre></td></tr></table></figure>
<ul>
<li><code>__set_name__</code> 中，self 是描述符实例（不是托管实例）​，owner 是托管类，<strong>name 是在 owner 的类主体中把描述符实例赋给的那个属性的名称</strong></li>
<li>不需要实现 <code>__get__</code> 方法，因为储存属性的名称与托管属性的名称一致。表达式 <code>product.price</code> 直接从 LineItem 实例中获取 price 属性</li>
</ul>
<p>现在描述符的逻辑抽象到单独的代码单元中了：Quantity 类。通常，我们不在使用描述符的模块中定义描述符，而是在一个单独的实用工具模块中定义，以方便在整个应用程序中重用——如果是在开发库或框架，那么甚至可以在多个应用程序中使用。</p>
<h3 id="通过继承创建新的描述符"><a class="markdownIt-Anchor" href="#通过继承创建新的描述符"></a> 通过继承创建新的描述符</h3>
<p>由于描述符通过类实现，因此可以利用继承重用部分代码来创建新描述符。如下是个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Validated</span>(abc.ABC):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set_name__</span>(<span class="params">self, owner, name</span>):</span><br><span class="line">        self.storage_name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        value = self.validate(self.storage_name, value)</span><br><span class="line">        instance.__dict__[self.storage_name] = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">validate</span>(<span class="params">self, name, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回通过验证的值，或者抛出ValueError&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>__set__</code> 方法把验证操作委托给 <code>validate</code> 方法，而 <code>validate</code> 是一个抽象方法，不同的具体描述符可以实现不同的验证逻辑。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quantity</span>(<span class="title class_ inherited__">Validated</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;数值要大于零&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">validate</span>(<span class="params">self, name, value</span>):</span><br><span class="line">        <span class="keyword">if</span> value &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span> must be &gt; 0&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonBlank</span>(<span class="title class_ inherited__">Validated</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;字符串至少要包含一个非空字符&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">validate</span>(<span class="params">self, name, value</span>):</span><br><span class="line">        value = value.strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> value:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span> cannot be blank&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure>
<p>这个例子演示了描述符的典型用途，即管理数据属性。Quantity 这种描述符叫作覆盖型描述符，因为描述符的__set__方法使用托管实例中的同名属性覆盖（插手接管）了要设置的属性。除此之外，还有非覆盖型描述符。</p>
<h2 id="覆盖型描述符与非覆盖型描述符对比"><a class="markdownIt-Anchor" href="#覆盖型描述符与非覆盖型描述符对比"></a> 覆盖型描述符与非覆盖型描述符对比</h2>
<p>之前说过，Python 处理属性的方式特别不对等。通过实例读取属性时，通常返回的是实例中定义的属性。但是，如果实例中没有指定的属性，则会获取类属性。而为实例中的属性赋值时，往往会在实例中创建属性，根本不影响类。</p>
<p>这种不对等的处理方式对描述符也有影响。其实，<strong>根据是否实现 <code>__set__</code> 方法，描述符可分为两大类</strong>：</p>
<ul>
<li>实现 <code>__set__</code> 方法的类是覆盖型描述符</li>
<li>未实现 <code>__set__</code> 方法的类则是非覆盖型描述符</li>
</ul>
<p>如下是一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 辅助函数，仅用于显示###</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cls_name</span>(<span class="params">obj_or_cls</span>):</span><br><span class="line">    cls = <span class="built_in">type</span>(obj_or_cls)</span><br><span class="line">    <span class="comment"># 如果 obj_or_cls 本身就是类型，type(cls) 返回 type 类型</span></span><br><span class="line">    <span class="keyword">if</span> cls <span class="keyword">is</span> <span class="built_in">type</span>:</span><br><span class="line">        cls = obj_or_cls</span><br><span class="line">    <span class="keyword">return</span> cls.__name__.split(<span class="string">&#x27;.&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">obj</span>):</span><br><span class="line">    cls = <span class="built_in">type</span>(obj)</span><br><span class="line">    <span class="keyword">if</span> cls <span class="keyword">is</span> <span class="built_in">type</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;&lt;class <span class="subst">&#123;obj.__name__&#125;</span>&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> cls <span class="keyword">in</span> [<span class="built_in">type</span>(<span class="literal">None</span>), <span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">repr</span>(obj)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;&lt;<span class="subst">&#123;cls_name(obj)&#125;</span> object&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_args</span>(<span class="params">name, *args</span>):</span><br><span class="line">    pseudo_args = <span class="string">&#x27;, &#x27;</span>.join(display(x) <span class="keyword">for</span> x <span class="keyword">in</span> args)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;-&gt; <span class="subst">&#123;cls_name(args[<span class="number">0</span>])&#125;</span>.__<span class="subst">&#123;name&#125;</span>__(<span class="subst">&#123;pseudo_args&#125;</span>)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 对这个示例重要的类 ###</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Overriding</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;也叫数据描述符或强制描述符&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        print_args(<span class="string">&#x27;get&#x27;</span>, self, instance, owner)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        print_args(<span class="string">&#x27;set&#x27;</span>, self, instance, value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OverridingNoGet</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;没有``__get__``方法的覆盖型描述符&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        print_args(<span class="string">&#x27;set&#x27;</span>, self, instance, value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonOverriding</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;也叫非数据描述符或遮盖型描述符&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        print_args(<span class="string">&#x27;get&#x27;</span>, self, instance, owner)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Managed</span>:</span><br><span class="line">    over = Overriding()</span><br><span class="line">    over_no_get = OverridingNoGet()</span><br><span class="line">    non_over = NonOverriding()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;-&gt; Managed.spam(<span class="subst">&#123;display(self)&#125;</span>)&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这里展示了三种描述符：</p>
<ul>
<li>有 <code>__get__</code> 方法和 <code>__set__</code> 方法的覆盖型描述符</li>
<li>没有 <code>__get__</code> 方法的覆盖型描述符。</li>
<li>没有 <code>__set__</code> 方法，所以这是一个非覆盖型描述符</li>
</ul>
<p>Python官方文档使用 <code>数据描述符</code>​，不过 <code>覆盖型描述符</code> 更能凸显它的特殊行为。覆盖型描述符也叫 <code>强制描述符</code>​。非覆盖型描述符也叫 <code>非数据描述符</code> 或 <code>遮盖型描述符</code>。</p>
<h3 id="覆盖型描述符"><a class="markdownIt-Anchor" href="#覆盖型描述符"></a> 覆盖型描述符</h3>
<p>实现 <code>__set__</code> 方法的描述符属于覆盖型描述符，<strong>因为虽然描述符是类属性，但是实现 <code>__set__</code> 方法的话，描述符将覆盖对实例属性的赋值操作。特性也是覆盖型描述符：如果没有提供设值函数，那么 property 类中的 <code>__set__</code> 方法就会抛出 AttributeError 异常，表明那个属性是只读的</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> managed <span class="keyword">import</span> Managed</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Managed()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over</span><br><span class="line">-&gt; Overriding.__get__(&lt;Overriding <span class="built_in">object</span>&gt;, &lt;Managed <span class="built_in">object</span>&gt;, &lt;<span class="keyword">class</span> <span class="title class_">Managed</span>&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Managed.over</span><br><span class="line">-&gt; Overriding.__get__(&lt;Overriding <span class="built_in">object</span>&gt;, <span class="literal">None</span>, &lt;<span class="keyword">class</span> <span class="title class_">Managed</span>&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over = <span class="number">7</span></span><br><span class="line">-&gt; Overriding.__set__(&lt;Overriding <span class="built_in">object</span>&gt;, &lt;Managed <span class="built_in">object</span>&gt;, <span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over</span><br><span class="line">-&gt; Overriding.__get__(&lt;Overriding <span class="built_in">object</span>&gt;, &lt;Managed <span class="built_in">object</span>&gt;, &lt;<span class="keyword">class</span> <span class="title class_">Managed</span>&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.__dict__[<span class="string">&#x27;over&#x27;</span>] =<span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">vars</span>(obj)</span><br><span class="line">&#123;<span class="string">&#x27;over&#x27;</span>: <span class="number">8</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over</span><br><span class="line">-&gt; Overriding.__get__(&lt;Overriding <span class="built_in">object</span>&gt;, &lt;Managed <span class="built_in">object</span>&gt;, &lt;<span class="keyword">class</span> <span class="title class_">Managed</span>&gt;)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>obj.over</code> 触发描述符的 <code>__get__</code> 方法，传入的第二个参数是托管实例 obj</li>
<li><code>Managed.over</code> 触发描述符的 <code>__get__</code> 方法，传入的第二个参数（instance）是 None</li>
<li>为 <code>obj.over</code> 赋值，触发描述符的 <code>__set__</code> 方法，传入的最后一个参数是 7</li>
<li>读取 <code>obj.over</code> 仍会调用描述符的 <code>__get__</code> 方法</li>
<li>可以绕过描述符，直接通过 <code>obj.__dict__</code> 属性设值</li>
<li>然而，即使是名为 <code>over</code> 的实例属性，<strong>Managed.over 描述符仍会覆盖读取 obj.over 操作</strong></li>
</ul>
<p>另外需要注意，因为一切设置实例属性的操作均会被 <code>__setattr__</code> 方法截获了，即使存在诸如覆盖型描述符。因此如果 Managed 中增加了如下代码，由于这个 <code>__setattr__</code> 实现里并没有自己处理描述符相关的逻辑,，因此覆盖型描述符不会起作用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, name: <span class="built_in">str</span>, value: <span class="type">Any</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;f-&gt; __setattr__ called&quot;</span>, name, value)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over =<span class="number">1</span></span><br><span class="line">f-&gt; __setattr__ called over <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>如果 <code>__setattr__</code> 是这样实现的，则可以正常工作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, name: <span class="built_in">str</span>, value: <span class="type">Any</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;f-&gt; __setattr__ called&quot;</span>, name, value)</span><br><span class="line">    <span class="built_in">super</span>().__setattr__(name, value)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over = <span class="number">1</span></span><br><span class="line">f-&gt; __setattr__ called over <span class="number">1</span></span><br><span class="line">-&gt; Overriding.__set__(&lt;Overriding <span class="built_in">object</span>&gt;, &lt;Managed <span class="built_in">object</span>&gt;, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="没有-__get__-方法的覆盖型描述符"><a class="markdownIt-Anchor" href="#没有-__get__-方法的覆盖型描述符"></a> 没有 <code>__get__</code> 方法的覆盖型描述符</h3>
<p>特性和其他覆盖型描述符（例如Django模型字段）既实现 <code>__set__</code> 方法，也实现 <code>__get__</code> 方法，不过也可以只实现 <code>__set__</code> 方法。此时：</p>
<ul>
<li>只有写操作由描述符处理</li>
<li>通过实例读取描述符会返回描述符对象本身，因为没有处理读操作的 <code>__get__</code> 方法</li>
<li>如果直接通过实例的 <code>__dict__</code> 属性创建同名实例属性，那么以后再设置那个属性时，仍由 <code>__set__</code> 方法插手接管，<strong>但是读取那个属性的话，会直接从实例中返回新赋予的值，而不返回描述符对象</strong></li>
</ul>
<p>也就是说，<strong>实例属性会遮盖描述符，不过只有读操作是如此</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over_no_get</span><br><span class="line">&lt;managed.OverridingNoGet <span class="built_in">object</span> at <span class="number">0x7f530aef6840</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Managed.over_no_get</span><br><span class="line">&lt;managed.OverridingNoGet <span class="built_in">object</span> at <span class="number">0x7f530aef6840</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over_no_get = <span class="number">7</span></span><br><span class="line">-&gt; OverridingNoGet.__set__(&lt;OverridingNoGet <span class="built_in">object</span>&gt;, &lt;Managed <span class="built_in">object</span>&gt;, <span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over_no_get</span><br><span class="line">&lt;managed.OverridingNoGet <span class="built_in">object</span> at <span class="number">0x7f530aef6840</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.__dict__[<span class="string">&#x27;over_no_get&#x27;</span>] = <span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over_no_get</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over_no_get = <span class="number">7</span></span><br><span class="line">-&gt; OverridingNoGet.__set__(&lt;OverridingNoGet <span class="built_in">object</span>&gt;, &lt;Managed <span class="built_in">object</span>&gt;, <span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over_no_get</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<h3 id="非覆盖性描述符"><a class="markdownIt-Anchor" href="#非覆盖性描述符"></a> 非覆盖性描述符</h3>
<p>没有实现 <code>__set__</code> 方法的描述符是非覆盖型描述符。<strong>如果设置了同名的实例属性，那么描述符就会被遮盖，致使其无法处理那个实例的那个属性。所有方法和 <code>@functools.cached_property</code> 是以非覆盖型描述符实现的</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.non_over</span><br><span class="line">-&gt; NonOverriding.__get__(&lt;NonOverriding <span class="built_in">object</span>&gt;, &lt;Managed <span class="built_in">object</span>&gt;, &lt;<span class="keyword">class</span> <span class="title class_">Managed</span>&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.non_over = <span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.non_over</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Managed.non_over</span><br><span class="line">-&gt; NonOverriding.__get__(&lt;NonOverriding <span class="built_in">object</span>&gt;, <span class="literal">None</span>, &lt;<span class="keyword">class</span> <span class="title class_">Managed</span>&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> obj.non_over</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.non_over</span><br><span class="line">-&gt; NonOverriding.__get__(&lt;NonOverriding <span class="built_in">object</span>&gt;, &lt;Managed <span class="built_in">object</span>&gt;, &lt;<span class="keyword">class</span> <span class="title class_">Managed</span>&gt;)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>obj.non_over</code> 触发描述符的 <code>__get__</code> 方法，传入的第二个参数是 obj</li>
<li><code>Managed.non_over</code> 是非覆盖型描述符，没有干涉赋值操作的 <code>__set__</code> 方法</li>
<li><strong>当 obj 有个名为 <code>non_over</code> 的实例属性，会遮盖 <code>Managed</code> 类的同名描述符属性</strong></li>
<li>但 <code>Managed.non_over</code> 描述符依然存在，可以通过类截获这次访问</li>
<li>如果把 <code>non_over</code> 实例属性删除了，那么读取 <code>obj.non_over</code> 时会触发类中描述符的 <code>__get__</code> 方法。但要注意，第二个参数的值是托管实例</li>
</ul>
<p>我们为几个与描述符同名的实例属性赋了值，结果依描述符是否有 <code>__set__</code> 方法而有所不同。</p>
<p>需要注意，<strong>依附在类上的描述符无法控制为类属性赋值的操作。其实，这意味着为类属性赋值能覆盖描述符属性</strong>。</p>
<h3 id="覆盖类中描述符"><a class="markdownIt-Anchor" href="#覆盖类中描述符"></a> 覆盖类中描述符</h3>
<p><strong>不管描述符是不是覆盖型，为类属性赋值都能覆盖描述符</strong>。这是一种猴子补丁技术：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Managed()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over</span><br><span class="line">-&gt; Overriding.__get__(&lt;Overriding <span class="built_in">object</span>&gt;, &lt;Managed <span class="built_in">object</span>&gt;, &lt;<span class="keyword">class</span> <span class="title class_">Managed</span>&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over_no_get</span><br><span class="line">&lt;managed.OverridingNoGet <span class="built_in">object</span> at <span class="number">0x7f530aef6840</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.non_over</span><br><span class="line">-&gt; NonOverriding.__get__(&lt;NonOverriding <span class="built_in">object</span>&gt;, &lt;Managed <span class="built_in">object</span>&gt;, &lt;<span class="keyword">class</span> <span class="title class_">Managed</span>&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Managed.over = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Managed.over_no_get = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Managed.non_over = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over, obj.over_no_get, obj.non_over</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>这也揭示了读写属性的另一种不对等：类属性读取操作可以由依附在托管类上定义有 <code>__get__</code> 方法的描述符处理，但是类属性写入操作不由依附在托管类上定义有 <code>__set__</code> 方法的描述符处理。</p>
<p><strong>要想控制设置类属性的操作，需要把描述符依附在类的类上，即依附在元类上</strong>。默认情况下，对于用户定义的类，元类是 type，不能向 type 添加属性。</p>
<h2 id="方法是描述符"><a class="markdownIt-Anchor" href="#方法是描述符"></a> 方法是描述符</h2>
<p>在类中定义的函数，如果在实例上调用，就会变成绑定方法，<strong>因为用户定义的函数都有 <code>__get__</code> 方法，在依附到类上后，就相当于描述符</strong>。而且，方法相当于是非覆盖型描述符：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Managed()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.spam</span><br><span class="line">&lt;bound method Managed.spam of &lt;managed.Managed <span class="built_in">object</span> at <span class="number">0x7f530b0f0650</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj</span><br><span class="line">&lt;managed.Managed <span class="built_in">object</span> at <span class="number">0x7f530b0f0650</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Managed.spam</span><br><span class="line">&lt;function Managed.spam at <span class="number">0x7f530af07b00</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.spam = <span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.spam</span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><code>obj.spam</code> 获取一个绑定方法对象</li>
<li>但是 <code>Managed.spam</code> 获取的是一个函数</li>
<li>为 <code>obj.spam</code> 赋值，遮盖类属性，导致无法通过 obj 实例访问 spam 方法</li>
</ul>
<p>函数没有实现 <code>__set__</code> 方法，因此是非覆盖型描述符。这也解释了上述代码为 <code>obj.spam</code> 赋值后的行为。</p>
<p><code>obj.spam</code> 和 <code>Managed.spam</code> 获取的是不同的对象：</p>
<ul>
<li>与描述符一样，通过托管类访问时，函数的 <code>__get__</code> 方法返回自身的引用</li>
<li>但是，通过实例访问时，函数的 <code>__get__</code> 方法返回的是绑定方法对象：一种可调用对象，里面包装着函数，并把托管实例（例如 obj）绑定给函数的第一个参数（self），这与 <code>functools.partial</code> 函数的行为一致</li>
</ul>
<p>来看一个具体例子，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Text</span>(collections.UserString):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Text(&#123;!r&#125;)&#x27;</span>.<span class="built_in">format</span>(self.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word = Text(<span class="string">&quot;forward&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word</span><br><span class="line">Text(<span class="string">&#x27;forward&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word.reverse()</span><br><span class="line">Text(<span class="string">&#x27;drawrof&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Text.reverse(Text(<span class="string">&#x27;backward&#x27;</span>))</span><br><span class="line">Text(<span class="string">&#x27;drawkcab&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(Text.reverse), <span class="built_in">type</span>(word.reverse)</span><br><span class="line">(&lt;<span class="keyword">class</span> <span class="string">&#x27;function&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;method&#x27;</span>&gt;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(Text.reverse, [<span class="string">&#x27;repaid&#x27;</span>, (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>), Text(<span class="string">&#x27;stressed&#x27;</span>)]))</span><br><span class="line">[<span class="string">&#x27;diaper&#x27;</span>, (<span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>), Text(<span class="string">&#x27;desserts&#x27;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Text.reverse.__get__(word, Text)</span><br><span class="line">&lt;bound method Text.reverse of Text(<span class="string">&#x27;forward&#x27;</span>)&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Text.reverse.__get__(<span class="literal">None</span>, Text)</span><br><span class="line">&lt;function Text.reverse at <span class="number">0x7fa8e0273560</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word.reverse</span><br><span class="line">&lt;bound method Text.reverse of Text(<span class="string">&#x27;forward&#x27;</span>)&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word.reverse.__self__</span><br><span class="line">Text(<span class="string">&#x27;forward&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word.reverse.__func__ <span class="keyword">is</span> Text.reverse</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">t</span>():</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.__get__</span><br><span class="line">&lt;method-wrapper <span class="string">&#x27;__get__&#x27;</span> of function <span class="built_in">object</span> at <span class="number">0x7fa8e02734c0</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.__set__</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">&#x27;function&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;__set__&#x27;</span>. Did you mean: <span class="string">&#x27;__get__&#x27;</span>?</span><br></pre></td></tr></table></figure>
<ul>
<li>在类上调用方法相当于调用函数</li>
<li>注意类型是不同的，<code>Text.reverse</code> 是function，<code>word.reverse</code> 是 method</li>
<li><code>Text.reverse</code> 相当于函数，甚至可以处理 Text 实例之外的其他对象。</li>
<li><strong>函数都是非覆盖型描述符。如果在函数上调用 <code>__get__</code> 方法时传入实例，则得到的是绑定到那个实例上的方法</strong></li>
<li>调用函数的 <code>__get__</code> 方法时，如果 instance 参数的值是 None，那么得到的是函数本身</li>
<li><strong><code>word.reverse</code> 表达式其实会调用 <code>Text.reverse.__get__(word)</code>返回对应的绑定方法</strong></li>
<li>绑定方法对象有一个 <code>__self__</code> 属性，其值是调用该方法的实例引用</li>
<li>绑定方法的 <code>__func__</code> 属性是依附在托管类上那个原始函数的引用</li>
</ul>
<p><strong>绑定方法对象还有 <code>__call__</code> 方法，用于处理实际调用过程。这个方法会调用 <code>__func__</code> 属性引用的原始函数，传入的第一个参数是方法的 <code>__self__</code> 属性。这就是形参self的隐式绑定方式</strong>。</p>
<p>函数会变成绑定方法，这是 Python 语言底层使用描述符的最好例证。</p>
<h2 id="描述符用法建议"><a class="markdownIt-Anchor" href="#描述符用法建议"></a> 描述符用法建议</h2>
<p>下面根据刚刚探讨的描述符特征给出一些实用的结论：</p>
<ul>
<li>
<p>使用 property 以保持简单：内置的 property 类创建的其实是实现了 <code>__set__</code> 方法和 <code>__get__</code> 方法的覆盖型描述符，即使没有定义设值方法，特性的 <code>__set__</code> 方法会默认抛出 <code>AttributeError: can't set attribute</code>，因此创建只读属性最简单的方式是使用特性</p>
</li>
<li>
<p>只读描述符必须有 <code>__set__</code> 方法：使用描述符类实现只读属性时要记住，<code>__get__</code> 和 <code>__set__</code> 这两个方法必须都定义，否则，实例的同名属性会遮盖描述符。只读属性的 <code>__set__</code> 方法只需抛出AttributeError 异常，并提供合适的错误消息</p>
</li>
<li>
<p>用于验证的描述符可以只有 <code>__set__</code> 方法：在仅用于验证的描述符中，<code>__set__</code> 方法应该检查value参数获得的值，如果有效，就使用描述符实例的名称作为键，直接在实例的 <code>__dict__</code> 属性中设置。这样，从实例中读取同名属性的速度很快，因为不用经过 <code>__get__</code> 方法处理</p>
</li>
<li>
<p>仅有 <code>__get__</code> 方法的描述符可以实现高效缓存：如果只编写了 <code>__get__</code> 方法，那么得到的是非覆盖型描述符。这种描述符可用于执行某些耗费资源的计算，然后为实例设置同名属性，缓存结果。同名实例属性会遮盖描述符，因此后续访问直接从实例的 <code>__dict__</code> 属性中获取值，不再触发描述符的 <code>__get__</code> 方法。<code>@functools.cached_property</code> 装饰器创建的其实就是非覆盖型描述符</p>
</li>
<li>
<p>非特殊的方法可以被实例属性遮盖：函数和方法只实现了 <code>__get__</code> 方法，属于非覆盖型描述符：</p>
<ul>
<li>因此 像 <code>my_obj.the_method =7</code> 这样简单赋值之后，后续通过该实例访问 <code>the_method</code>，得到的是数值 7，但是不影响类或其他实例</li>
<li>解释器只在类中寻找特殊方法，也就是说，<code>repr(x)</code> 执行的其实是 <code>x.__class__.__repr__(x)，因此 x 的 </code><strong>repr</strong><code>属性对</code>repr(x)` 方法调用没有影响</li>
<li>出于同样的原因，实例的 <code>__getattr__</code> 属性不会破坏常规的属性访问规则</li>
</ul>
</li>
</ul>
<p>实例的非特殊方法可以轻易被覆盖，这听起来不太可靠且容易出错，但是一般不需要担心被困扰。然而，如果要创建大量动态属性，且属性名称从不受自己控制的数据中获取​，那么就应该知道这种行为。或许可以实现某种机制，筛选或转义动态属性的名称，以维持数据的健全性。而且，<strong>只要通过类访问，类方法就是安全的</strong>。</p>
<h2 id="描述符的文档字符串和覆盖删除操作"><a class="markdownIt-Anchor" href="#描述符的文档字符串和覆盖删除操作"></a> 描述符的文档字符串和覆盖删除操作</h2>
<p>描述符类的文档字符串也用作托管类中各个描述符实例的文档。</p>
<p>我们在讨论特性时还讲了一个细节，而描述符还没有涉及，那就是对删除托管属性的处理。在描述符类中，除了实现常规的 <code>__get__</code> 方法和 <code>__set__</code> 方法，还可以实现 <code>__delete__</code> 方法，或者只实现 <code>__delete__</code> 方法，处理删除托管属性操作。但是现实中一般很少使用。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/Python/" rel="tag"># Python</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/11/18/fluent-python-v2-24/" rel="prev" title="流畅的 Python 第 2 版（24）：类元编程">
      <i class="fa fa-chevron-left"></i> 流畅的 Python 第 2 版（24）：类元编程
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/11/15/fluent-python-v2-22/" rel="next" title="流畅的 Python 第 2 版（22）：动态属性和特性">
      流畅的 Python 第 2 版（22）：动态属性和特性 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%A4%BA%E4%BE%8B%E5%B1%9E%E6%80%A7%E9%AA%8C%E8%AF%81"><span class="nav-number">1.</span> <span class="nav-text"> 描述符示例：属性验证</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E5%AD%98%E5%82%A8%E5%B1%9E%E6%80%A7%E8%87%AA%E5%8A%A8%E5%91%BD%E5%90%8D"><span class="nav-number">1.1.</span> <span class="nav-text"> 为存储属性自动命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BF%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">1.2.</span> <span class="nav-text"> 通过继承创建新的描述符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E5%9E%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%9D%9E%E8%A6%86%E7%9B%96%E5%9E%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%AF%B9%E6%AF%94"><span class="nav-number">2.</span> <span class="nav-text"> 覆盖型描述符与非覆盖型描述符对比</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E5%9E%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">2.1.</span> <span class="nav-text"> 覆盖型描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B2%A1%E6%9C%89-__get__-%E6%96%B9%E6%B3%95%E7%9A%84%E8%A6%86%E7%9B%96%E5%9E%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">2.2.</span> <span class="nav-text"> 没有 __get__ 方法的覆盖型描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E8%A6%86%E7%9B%96%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">2.3.</span> <span class="nav-text"> 非覆盖性描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%B1%BB%E4%B8%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">2.4.</span> <span class="nav-text"> 覆盖类中描述符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E6%98%AF%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">3.</span> <span class="nav-text"> 方法是描述符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%94%A8%E6%B3%95%E5%BB%BA%E8%AE%AE"><span class="nav-number">4.</span> <span class="nav-text"> 描述符用法建议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E6%96%87%E6%A1%A3%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E8%A6%86%E7%9B%96%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-number">5.</span> <span class="nav-text"> 描述符的文档字符串和覆盖删除操作</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">226</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">


  

</body>
</html>
