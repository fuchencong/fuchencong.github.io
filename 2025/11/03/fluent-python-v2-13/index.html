<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="面向对象设计第一原则是 对接口编程，而不是对实现编程。在 Python 中，支撑一个类型的是它提供的方法，也就是接口。在不同的编程语言中，接口的定义和使用方式不尽相同。">
<meta property="og:type" content="article">
<meta property="og:title" content="流畅的 Python 第 2 版（13）：接口、协议和抽象基类">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2025/11/03/fluent-python-v2-13/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="面向对象设计第一原则是 对接口编程，而不是对实现编程。在 Python 中，支撑一个类型的是它提供的方法，也就是接口。在不同的编程语言中，接口的定义和使用方式不尽相同。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2025/11/03/fluent-python-v2-13/images/01.jpg">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2025/11/03/fluent-python-v2-13/images/02.jpg">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2025/11/03/fluent-python-v2-13/images/03.jpg">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2025/11/03/fluent-python-v2-13/images/04.jpg">
<meta property="article:published_time" content="2025-11-03T03:30:52.000Z">
<meta property="article:modified_time" content="2025-11-23T10:30:54.406Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fuchencong.github.io/fuchencong.github.io/2025/11/03/fluent-python-v2-13/images/01.jpg">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2025/11/03/fluent-python-v2-13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>流畅的 Python 第 2 版（13）：接口、协议和抽象基类 | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2025/11/03/fluent-python-v2-13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          流畅的 Python 第 2 版（13）：接口、协议和抽象基类
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-03 11:30:52" itemprop="dateCreated datePublished" datetime="2025-11-03T11:30:52+08:00">2025-11-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>面向对象设计第一原则是 <code>对接口编程，而不是对实现编程</code>。在 Python 中，支撑一个类型的是它提供的方法，也就是接口。在不同的编程语言中，接口的定义和使用方式不尽相同。</p>
<span id="more"></span>
<p>从 <code>Python 3.8</code> 开始，有 4 种方式，如下类型图所示。这 4 种方式概述如下：</p>
<ul>
<li>鸭子类型：自 Python 诞生以来默认使用的类型实现方式</li>
<li>大鹅类型：由抽象基类支持的方式，该方式会在运行时检查对象是否符合抽象基类的要求</li>
<li>静态类型：C 和 Java 等传统静态类型语言采用的方式。自 Python3.5 开始，由 typing 模块支持，由符合<code>PEP 484—Type Hints</code> 要求的外部类型检查工具实施检查</li>
<li>静态鸭子类型：因 Go 语言而流行的方式。由 <code>typing.Protocol</code>（Python3.8 新增）的子类支持，由外部类型检查工具实施检查</li>
</ul>
<img src="/fuchencong.github.io/2025/11/03/fluent-python-v2-13/images/01.jpg" class="">
<ul>
<li>上半部分是只使用 Python 解释器在运行时检查类型的方式；下半部分则要借助外部静态类型检查工具</li>
<li>左边两象限中的类型基于对象的结构（对象提供的方法）​，与对象所属的类或超类无关；右边两象限中的类型要求对象有明确的类型名称：对象所属类的名称，或者超类的名称</li>
</ul>
<p>这 4 种方式全都依靠接口，不过静态类型可以只使用具体类型实现（效果差）​，而不使用协议和抽象基类等接口抽象。本章涵盖围绕接口实现的 3 种类型：鸭子类型、大鹅类型和静态鸭子类型。</p>
<h2 id="两种协议"><a class="markdownIt-Anchor" href="#两种协议"></a> 两种协议</h2>
<p>之前介绍过，对象协议指明为了履行某个角色，对象必须实现哪些方法。完全实现一个协议可能需要多个方法，不过，通常可以只实现部分协议。所以，经常说协议是 <code>非正式接口</code>。在 Python 文档中，除了有关网络编程的内容，​**<code>协议</code> 一词基本上是指非正式接口**。</p>
<p>Python3.8 通过 <code>PEP 544—Protocols: Structural subtyping (static duck typing)</code> 之后，，​<code>协议</code> 一词在 Python 中多了一种含义，<strong>PEP 544 提议通过 <code>typing.Protocol</code> 的子类定义一个类必须实现（或继承）的一个或多个方法，让静态类型检查工具满意</strong>。</p>
<p>需要区分时，我会使用以下两个术语：</p>
<ul>
<li>动态协议：Python 一直有的非正式协议。<strong>动态协议是隐含的，按约定定义</strong>，在文档中描述。Python 大多数重要的动态协议由解释器支持</li>
<li>静态协议：<code>PEP 544—Protocols: Structural subtyping (static duck typing)</code> 定义的协议，自 Python3.8 开始支持。静态协议要使用 <code>typing.Protocol</code> 子类显式定义</li>
</ul>
<p>二者之间的主要区别如下：</p>
<ul>
<li>对象可以只实现动态协议的一部分，但是如果想满足静态协议，则对象必须提供协议类中声明的每一个方法，即使程序用不到</li>
<li>静态协议可以使用静态类型检查工具确认，动态协议则不能</li>
</ul>
<p><strong>两种协议共有一个基本特征：类无须通过名称（例如通过继承）声明支持什么协议。除了静态协议，Python 还提供了另一种定义显式接口的方式，即抽象基类</strong>。</p>
<p>接下来的内容将涵盖动态协议和静态协议，以及抽象基类。</p>
<h2 id="利用鸭子类型编程"><a class="markdownIt-Anchor" href="#利用鸭子类型编程"></a> 利用鸭子类型编程</h2>
<p>我们以 Python 中两个最重要的协议（序列协议和可迭代协议）为例展开对动态协议的讨论。即使对象只实现了这些协议的最少一部分，也会引起解释器的注意。</p>
<p>如下通过 Python Sequence 抽象类来说明一个功能完善的序列应该支持什么操作。<code>collections.abc</code> 模块中的大多数抽象基类存在的目的是确立由内置对象实现并且由解释器隐式支持的接口。这些抽象基类可作为新类的基础，并为运行时显式类型检查（大鹅类型）和静态类型检查工具用到的类型提示提供支持。</p>
<img src="/fuchencong.github.io/2025/11/03/fluent-python-v2-13/images/02.jpg" class="">
<p>为了确保行为正确，Sequence 的子类必须实现 <code>__getitem__</code> 和 <code>__len__</code>（来自 Sized）​。Sequence 中的其他方法都是具体的，因此子类可以继承或者提供更好的实现。</p>
<p>这也是为什么即使没有 <code>__iter__</code> 或者 <code>__contains__</code> 方法， <code>in</code> 操作符和迭代操作符 <code>for</code> 循环也能作用在自定义序列对象上。如果没有 <code>__iter__</code> 方法和 <code>__contains__</code> 方法，则 Python 会调用 <code>__getitem__</code> 方法，设法让迭代和 in 运算符可用。</p>
<p>下面的例子 FrenchDeck 类也没有继承 <code>abc.Sequence</code>，但是实现了序列协议的两个方法：<code>__getitem__</code> 和<code>__len__</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">Card = collections.namedtuple(<span class="string">&#x27;Card&#x27;</span>, [<span class="string">&#x27;rank&#x27;</span>, <span class="string">&#x27;suit&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FrenchDeck</span>:</span><br><span class="line">    ranks = [<span class="built_in">str</span>(n) <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">11</span>)] + <span class="built_in">list</span>(<span class="string">&#x27;JQKA&#x27;</span>)</span><br><span class="line">    suits = <span class="string">&#x27;spades diamonds clubs hearts&#x27;</span>.split()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits</span><br><span class="line">                                        <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self._cards)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, position</span>):</span><br><span class="line">        <span class="keyword">return</span> self._cards[position]</span><br></pre></td></tr></table></figure>
<p>下面再分析一个示例，强调协议的动态本性，并解释静态类型检查工具为什么没机会处理动态协议。</p>
<h3 id="使用猴子补丁在运行时实现协议"><a class="markdownIt-Anchor" href="#使用猴子补丁在运行时实现协议"></a> 使用猴子补丁在运行时实现协议</h3>
<p>猴子补丁在运行时动态修改模块、类或函数，以增加功能或修正 bug。对上面的 FrenchDeck 示例进行 shuffle，会遇到如下错误：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> frenchdeck <span class="keyword">import</span> FrenchDeck</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> random <span class="keyword">import</span> shuffle</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck = FrenchDeck()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shuffle(deck)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;/usr/lib/python3.10/random.py&quot;</span>, line <span class="number">394</span>, <span class="keyword">in</span> shuffle</span><br><span class="line">    x[i], x[j] = x[j], x[i]</span><br><span class="line">TypeError: <span class="string">&#x27;FrenchDeck&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure>
<p>这个问题的原因在于，shuffle 函数会就地操作，调换容器内项的位置，而 FrenchDeck 只实现了不可变序列协议。可变序列还必须提供 <code>__setitem__</code> 方法。因为 Python 是动态语言，<strong>所以可以在运行时修正这个问题，甚至在交互式控制台中就能做到</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">set_card</span>(<span class="params">deck, position, card</span>):</span><br><span class="line"><span class="meta">... </span>    deck._cards[position] = card</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>FrenchDeck.__setitem__ = set_card</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shuffle(deck)</span><br></pre></td></tr></table></figure>
<p>这就是猴子补丁：<strong>在运行时修改类或模块，而不改动源码</strong>。虽然猴子补丁很强大，但是打补丁的代码与被打补丁的程序耦合十分紧密，而且往往要处理文档没有明确说明的私有属性。另外说明一下，Python 方法说到底就是普通函数，把第一个参数命名为 self 只是一种约定，这里 set_card() 并没有将第一个参数（FrechDeck 对象）命名为 self。</p>
<p>这个例子还强调了动态鸭子类型中的协议是动态的：random.shuffle 函数不关心参数所属的类，只要那个对象实现了可变序列协议的方法即可。即便对象一开始没有所需的方法也没关系，可以之后再提供。</p>
<h3 id="防御性编程和快速失败"><a class="markdownIt-Anchor" href="#防御性编程和快速失败"></a> 防御性编程和快速失败</h3>
<p>许多 bug 只有在运行时才能捕获，即使主流的静态类型语言也是如此。对于动态类型语言，​<code>快速失败</code> 可以提升程序的安全性，让程序更易于维护。<strong>快速失败的意思是尽早抛出运行时错误</strong>，例如，在函数主体开头就拒绝无效的参数。如果一个函数接受一系列项，在内部按照列表处理，那么就不要通过类型检查强制要求传入一个列表。正确的做法是立即利用参数构建一个列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, iterable</span>):</span><br><span class="line">    self._balls = <span class="built_in">list</span>(iterable)</span><br></pre></td></tr></table></figure>
<ul>
<li>这样写出的代码更灵活，因为 <code>list()</code> 构造函数能处理任何在内存中放得下的可迭代对象。如果传入的参数不是可迭代对象，那么初始化对象时 <code>list()</code> 调用就会快速失败，抛出意义十分明确的 TypeError 异常。</li>
<li>如果想更明确一些，可以把 <code>list()</code> 调用放在 <code>try/except</code> 结构中，自定义错误消息。我只会在外部 API 中这么做，因为这样方便基准代码维护人员发现问题</li>
<li>无论如何，出错的调用将出现在调用跟踪的末尾，直指根源</li>
</ul>
<p>当然如果数据过多，或者需要就地修改数据，这种方式就不合适了。遇到这种情况，应该使用 <code>isinstance(x, abc.MutableSequence)</code> 做运行时检查。</p>
<ul>
<li>如果害怕传入的是无穷生成器（不常见）​，则可以先使用 <code>len()</code> 获取参数的长度，这样可以拒绝迭代器</li>
<li>如果接受任何可迭代对象，那么要尽早调用 <code>iter(x)</code>，获得一个迭代器。同样，如果 x 不是可迭代对象，则这也会快速失败，抛出一个易于调试的异常</li>
</ul>
<p>利用鸭子类型做防御性编程，无须使用 <code>isinstance()</code> 或 <code>hasattr()</code> 测试就能处理不同的类型。如下利用鸭子类型处理一个字符串或由字符串构成的可迭代对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    field_names = field_names.replace(<span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27; &#x27;</span>).split()</span><br><span class="line"><span class="keyword">except</span> AttributeError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">field_names = <span class="built_in">tuple</span>(field_names)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">all</span>(s.isidentifier() <span class="keyword">for</span> s <span class="keyword">in</span> field_names):</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&#x27;field_names must all be valid identifiers&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>假设是一个字符串（EAFP原则：<strong>取得原谅比获得许可容易</strong>）​，把逗号替换成空格，再拆分成名称列表</li>
<li>如果抛出 <code>AttributeError</code>，说明 field_names 不是字符串，那就假设 field_names 是由名称构成的可迭代对象。</li>
<li>为了确保是可迭代对象，也为了留存一份副本，根据现有数据创建一个元组。元组比列表紧凑，还能防止代码意外改动名称</li>
<li>使用 <code>str.isidentifier</code> 确保每个名称都是有效的标识符</li>
</ul>
<p>接下来讨论运行时类型检查更为外显的一种形式，即大鹅类型。</p>
<h2 id="大鹅类型"><a class="markdownIt-Anchor" href="#大鹅类型"></a> 大鹅类型</h2>
<p>Python 没有 interface 关键字。<strong>我们使用抽象基类定义接口，在运行时显式检查类型（静态类型检查工具也支持）</strong>。抽象基类是对鸭子类型的补充，提供了一种定义接口的方式。抽象基类引入了虚拟子类，这种类不继承其他类，却能被 <code>isinstance()</code> 和 <code>issubclass()</code> 识别。详见 abc 模块文档。</p>
<p>大鹅类型是一种利用抽象基类实现的运行时检查方式。大鹅类型指的是，只要 cls 是抽象基类（cls 的元类是 <code>abc.ABCMeta</code>）​，就可以使用 <code>isinstance(obj, cls)</code>。与具体类相比，抽象基类有很多理论上的优点。有时，为了让抽象基类识别子类，甚至不用注册（抽象基类的本质就是几个特殊方法）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Struggle</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>): <span class="keyword">return</span> <span class="number">23</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(Struggle(), abc.Sized)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<ul>
<li>无须注册，<code>abc.Sized</code> 也能把 Struggle 识别为自己的子类，只要实现了特殊方法 <code>__len__</code> 即可</li>
<li>如果实现的类体现了 numbers、collections.abc 或其他框架中抽象基类的概念，则要么继承相应的抽象基类（必要时）​，要么把类注册到相应的抽象基类中（开始开发程序时，不要使用提供注册功能的库或框架，要自己动手注册）</li>
<li>如果必须检查参数的类型（例如检查是不是 <code>序列</code>​）​，则可以像下面这样做</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isinstance</span>(the_arg, collections.abc.<span class="type">Sequence</span>)</span><br></pre></td></tr></table></figure>
<p>综上所述，大鹅类型要求：</p>
<ul>
<li>定义抽象基类的子类，明确表明你在实现既有的接口</li>
<li>运行时检查类型时，isinstance 和 issubclass的第二个参数要使用抽象基类，而不是具体类。使用 isinstance 和 issubclass 测试抽象基类（而不是具体类）更为人接受。如果用于测试具体类，则类型检查将限制多态—— <code>面向对象编程的一个重要功能</code>，用于测试抽象基类更加灵活</li>
</ul>
<p>继承抽象基类其实就是实现必要的方法——这也明确表明了开发人员的意图。这个意图还可以通过注册虚拟子类明确表述。例如对于 FrenchDeck 类，如果想通过 <code>issubclass(FrenchDeck, Sequence)</code> 检查，那么可以使用以下几行代码把 FrenchDeck 注册为抽象基类 Sequence 的虚拟子类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> <span class="type">Sequence</span></span><br><span class="line"><span class="type">Sequence</span>.register(FrenchDeck)</span><br></pre></td></tr></table></figure>
<p>然而，即使是抽象基类，也不能滥用 <code>isinstance</code> 检查，因为用得多了可能导致代码异味，即表明面向对象设计不佳：</p>
<ul>
<li>在一连串 <code>if/elif/elif</code> 中使用 isinstance 做检查，然后根据对象的类型执行不同的操作，往往是不好的做法</li>
<li>此时应该使用多态，即采用一定的方式定义类，让解释器把调用分派给正确的方法，而不使用 <code>if/elif/elif</code> 块硬编码分派逻辑</li>
<li>另外，如果必须强制执行 API 契约，那么通常可以使用 <code>isinstance</code> 检查抽象基类。这对采用插入式架构的系统来说特别有用。</li>
</ul>
<p>在框架之外，鸭子类型通常比类型检查更简单且更灵活。<strong>要抑制住创建抽象基类的冲动。滥用抽象基类会造成灾难性后果，表明语言太注重表面形式</strong>，这对以实用和务实著称的 Python 可不是好事。</p>
<p><strong>抽象基类是用于封装框架所引入的一般性概念和抽象的</strong>。基本上不需要自己编写新的抽象基类，只要正确使用现有的抽象基类，就能获得 99.9% 的好处，而不用冒着设计不当导致的巨大风险。</p>
<h3 id="子类化一个抽象基类"><a class="markdownIt-Anchor" href="#子类化一个抽象基类"></a> 子类化一个抽象基类</h3>
<p>如下把 FrenchDeck2 声明为了 <code>collections.MutableSequence</code> 的子类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple, abc</span><br><span class="line"></span><br><span class="line">Card = namedtuple(<span class="string">&#x27;Card&#x27;</span>, [<span class="string">&#x27;rank&#x27;</span>, <span class="string">&#x27;suit&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FrenchDeck2</span>(abc.MutableSequence):</span><br><span class="line">    ranks = [<span class="built_in">str</span>(n) <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">11</span>)] + <span class="built_in">list</span>(<span class="string">&#x27;JQKA&#x27;</span>)</span><br><span class="line">    suits = <span class="string">&#x27;spades diamonds clubs hearts&#x27;</span>.split()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits</span><br><span class="line">                                        <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self._cards)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, position</span>):</span><br><span class="line">        <span class="keyword">return</span> self._cards[position]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, position, value</span>):</span><br><span class="line">        self._cards[position] = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delitem__</span>(<span class="params">self, position</span>):</span><br><span class="line">        <span class="keyword">del</span> self._cards[position]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, position, value</span>):</span><br><span class="line">        self._cards.insert(position, value)</span><br></pre></td></tr></table></figure>
<ul>
<li>为了支持洗牌，只需实现 <code>__setitem__</code> 方法即可</li>
<li>继承 MutableSequence 的类必须实现 <code>__delitem__</code> 方法，这是 MutableSequence 类的一个抽象方法</li>
<li>还要实现 insert 方法，这是 MutableSequence 类的第三个抽象方法</li>
</ul>
<p>Python 在导入时（加载并编译 <code>frenchdeck2.py</code> 模块时）不检查抽象方法的实现，<strong>在运行时实例化 FrenchDeck2 类时才真正检查</strong>。因此：</p>
<ul>
<li>如果没有正确实现某个抽象方法，那么 Python 就会抛出 TypeError 异常，错误消息为 <code>Can't instantiate abstract class FrenchDeck2 with abstract methods __delitem__, insert</code></li>
<li>抽象基类 Sequence 和 MutableSequence 的方法不全是抽象的</li>
<li>为了把 FrenchDeck2 声明为 MutableSequence 的子类，我不得不实现例子中用不到的 <code>__delitem__</code> 方法和 <code>insert</code> 方法。作为回报，FrenchDeck2 从 Sequence 继承了 5 个具体方法，另外，FrenchDeck2 还从 MutableSequence 继承了 6 个方法</li>
<li>作为实现具体子类的人，你可以覆盖从抽象基类继承的方法，以更高效的方式重新实现</li>
</ul>
<p>为了充分利用抽象基类，要知道有哪些抽象基类可用。接下来介绍 collections 包中的抽象基类。</p>
<h3 id="标准库中的抽象基类"><a class="markdownIt-Anchor" href="#标准库中的抽象基类"></a> 标准库中的抽象基类</h3>
<p>标准库提供了多个抽象基类，大都在 <code>collections.abc</code> 模块中定义，不过其他地方也有，例如，io 包和 numbers 包中就有一些抽象基类。如下是 collections.abc 模块中 17 个抽象基类的 UML 类图：</p>
<img src="/fuchencong.github.io/2025/11/03/fluent-python-v2-13/images/03.jpg" class="">
<ul>
<li>
<p>Iterable、Container 和 Sized：每个容器都应该继承这 3 个抽象基类，或者实现兼容的协议：</p>
<ul>
<li>Iterable通过 <code>__iter__</code> 方法支持迭代，</li>
<li>Container通过 <code>__contains__</code> 方法支持 in 运算符，</li>
<li>Sized通过 <code>__len__</code> 方法支持 <code>len()</code> 函数</li>
</ul>
</li>
<li>
<p>Collection：这个抽象基类是 Python 3.6 新增的，自身没有方法，目的是方便子类化 Iterable、Container 和 Sized</p>
</li>
<li>
<p>Sequence、Mapping 和 Set：主要的不可变容器类型，而且各自都有可变的子类</p>
</li>
<li>
<p>MappingView：映射方法 <code>.items()</code>、<code>.keys()</code> 和 <code>.values()</code> 返回的对象分别实现了 ItemsView、 KeysView 和 ValuesView 定义的接口</p>
</li>
<li>
<p>Iterator：它是 Iterable 的子类</p>
<ul>
<li>即使 <code>isinstance(obj, Iterable)</code> 返回 False，Python 依然可以通过 <code>__getitem__</code>（基于 0 的索引）迭代 obj</li>
<li>判断一个对象是否可以迭代，唯一可靠的方式是调用 <code>iter(obj)</code></li>
</ul>
</li>
<li>
<p>Callable 和 Hashable：可以在类型检查中用于指定可调用和可哈希的对象</p>
<ul>
<li>如果 <code>isinstance(obj, Hashable)</code> 返回 True，那么仅仅表示 obj 所属的类实现或继承了 <code>__hash__</code>方法</li>
<li>假如 obj 是包含不可哈希项的元组，那么即便 isinstance 的检查结果为真，obj 仍是不可哈希对象</li>
<li>利用鸭子类型判断一个实例是否可哈希是最准确的，即调用 <code>hash(obj)</code>。如果 obj 不可哈希，那么该调用就会抛出 TypeError</li>
</ul>
</li>
</ul>
<h3 id="定义并使用一个抽象基类"><a class="markdownIt-Anchor" href="#定义并使用一个抽象基类"></a> 定义并使用一个抽象基类</h3>
<p>抽象基类与描述符和元类一样，是用于构建框架的工具。如今，抽象基类的作用更广，可用在类型提示中，支持静态类型，之前说过，把函数参数类型提示中的具体类型换成抽象基类能为调用方提供更大的灵活性。</p>
<p>为了证明有必要定义抽象基类，需要在框架中找到使用它的场景。如下定义了一个抽象基类：抽象基类 Tombola 有 4 个方法，其中两个是抽象方法。</p>
<img src="/fuchencong.github.io/2025/11/03/fluent-python-v2-13/images/04.jpg" class="">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tombola</span>(abc.ABC):</span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">self, iterable</span>):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pick</span>(<span class="params">self</span>):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">loaded</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bool</span>(self.inspect())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inspect</span>(<span class="params">self</span>):</span><br><span class="line">        items = []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                items.append(self.pick())</span><br><span class="line">            <span class="keyword">except</span> LookupError:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        self.load(items)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">tuple</span>(items)</span><br></pre></td></tr></table></figure>
<ul>
<li>继承 <code>abc.ABC</code>，定义一个抽象基类</li>
<li>抽象方法使用 <code>@abstractmethod</code> 装饰器标记，主体通常只有文档字符串</li>
<li>其实，<strong>抽象方法可以有实现代码。即便实现了，子类也必须覆盖抽象方法</strong>，但是在子类中可以使用 <code>super()</code> 函数调用抽象方法，在此基础上添加功能，而不是从头开始实现</li>
<li>抽象基类可以包含具体方法，抽象基类中的具体方法只能依赖抽象基类定义的接口（只能使用抽象基类中的其他具体方法、抽象方法或特性）</li>
<li><code>inspect</code> 具体方法的实现，通过调用 <code>pick</code> 方法获取元素，然后继续调用 <code>load</code> 方法将元素重新放回去，随意实现有些笨拙，但是它说明了抽象基类可以提供具体方法，只要仅依赖接口中的其他方法就行</li>
<li>Tombola 的具体子类知晓内部数据结构，可以使用更聪明的实现覆盖 <code>.inspect()</code> 方法，但这不是强制要求</li>
<li>另外，实现 <code>.inspect()</code> 方法采用的迂回方式要求捕获 <code>self.pick()</code> 抛出的 <code>LookupError</code>。<strong><code>self.pick()</code> 会抛出 LookupError 这一事实也是接口的一部分，但是在 Python 中没办法明确表明，只能在文档中说明</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Fake</span>(<span class="title class_ inherited__">Tombola</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">pick</span>(<span class="params">self</span>):</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> <span class="number">13</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fake</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Fake&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = Fake()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: Can<span class="string">&#x27;t instantiate abstract class Fake with abstract method load</span></span><br></pre></td></tr></table></figure>
<p>尝试实例化 Fake 时抛出了 TypeError。错误消息十分明确，<strong>Python 认为 Fake是抽象类，因为它没有实现抽象基类 Tombola 声明的抽象方法之一 <code>load()</code></strong>。</p>
<h3 id="抽象基类句法详解"><a class="markdownIt-Anchor" href="#抽象基类句法详解"></a> 抽象基类句法详解</h3>
<p>声明抽象基类的标准方式是继承 <code>abc.ABC</code> 或其他抽象基类。除了 <code>ABC</code> 基类和 <code>@abstractmethod</code> 装饰器，abc 模块还定义了 <code>@abstractclassmethod</code> 装饰器、<code>@abstractstaticmethod</code> 装饰器和 <code>@abstractproperty</code> 装饰器。然而，后 3 个装饰器在 Python3.3 中弃用了，因为现在可以在 @abstractmethod 之上叠放装饰器，那 3 个就显得多余了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyABC</span>(abc.ABC):</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">an_abstract_classmethod</span>(<span class="params">cls, ...</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>在函数上叠放装饰器的顺序通常很重要</strong>，@abstractmethod 的文档就特别指出。与其他方法描述符一起使用时， <code>abstractmethod()</code> 应该放在最里层</li>
</ul>
<h3 id="子类化抽象基类-tombola"><a class="markdownIt-Anchor" href="#子类化抽象基类-tombola"></a> 子类化抽象基类 Tombola</h3>
<p>定义好抽象基类 Tombola 之后，要开发两个具体子类，满足 Tombola 规定的接口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BingoCage</span>(<span class="title class_ inherited__">Tombola</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, items</span>):</span><br><span class="line">        self._randomizer = random.SystemRandom()</span><br><span class="line">        self._items = []</span><br><span class="line">        self.load(items)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">self, items</span>):</span><br><span class="line">        self._items.extend(items)</span><br><span class="line">        self._randomizer.shuffle(self._items)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pick</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self._items.pop()</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">raise</span> LookupError(<span class="string">&#x27;pick from empty BingoCage&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self</span>):</span><br><span class="line">        self.pick()</span><br></pre></td></tr></table></figure>
<ul>
<li>BingoCage 类会显式扩展 Tombola 类</li>
<li>额外实现了 <code>__call__</code> 方法，为了满足 Tombola 接口，无须实现这个方法，不过额外增加方法也没有危害</li>
<li>我们可以偷懒，直接从抽象基类中继承不是那么理想的具体方法。从 Tombola 中继承的方法没有 BingoCage 自己定义的那么快，不过只要 Tombola 的子类正确实现 pick 方法和 load 方法，就能提供正确的结果</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LottoBlower</span>(<span class="title class_ inherited__">Tombola</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, iterable</span>):</span><br><span class="line">        self._balls = <span class="built_in">list</span>(iterable)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">self, iterable</span>):</span><br><span class="line">        self._balls.extend(iterable)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pick</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            position = random.randrange(<span class="built_in">len</span>(self._balls))</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">raise</span> LookupError(<span class="string">&#x27;pick from empty LottoBlower&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self._balls.pop(position)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">loaded</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bool</span>(self._balls)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inspect</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">tuple</span>(self._balls)</span><br></pre></td></tr></table></figure>
<ul>
<li>在 <code>__init__</code> 方法中，<code>self._balls</code> 存储的是 <code>list(iterable)</code>，而不是 iterable 的引用（没有直接把 iterable 赋值给 <code>self._balls</code>，为参数创建别名）。这样做使得 LottoBlower 更灵活，因为 iterable 参数可以是任何可迭代类型。把元素存入列表中还可以确保能取出元素。就算 iterable 参数始终传入列表，<code>list(iterable)</code> 也会创建参数的副本，这依然是好的做法，<strong>因为要从中删除元素，而客户可能不希望自己提供的列表被修改</strong></li>
<li>覆盖 loaded 方法，避免调用 <code>inspect</code> 方法。可以直接处理 <code>self._balls</code>，而不必构建整个元组，从而提升速度</li>
<li>覆盖 inspect 方法，仅用一行代码</li>
</ul>
<h3 id="抽象基类的虚拟子类"><a class="markdownIt-Anchor" href="#抽象基类的虚拟子类"></a> 抽象基类的虚拟子类</h3>
<p>大鹅类型的一个基本特征是，即便不继承，也有办法把一个类注册为抽象基类的虚拟子类。这是大鹅类型的重要动态特性：使用 <code>register</code> 方法声明虚拟子类。这样做时，我们承诺注册的类忠实地实现了抽象基类定义的接口，而 Python 会相信我们，不再检查。如果我们说谎了，那么常规的运行时异常会把我们捕获。</p>
<p>注册虚拟子类的方式是在抽象基类上调用 register 类方法。这么做之后</p>
<ul>
<li>注册的类就变成了抽象基类的虚拟子类</li>
<li><strong>而且 <code>issubclass</code> 函数能够识别这种关系，但是注册的类不会从抽象基类中继承任何方法或属性</strong></li>
<li>虚拟子类不继承注册的抽象基类，而且任何时候都不检查它是否符合抽象基类的接口，<strong>即便在实例化时也不会检查</strong></li>
<li>另外，静态类型检查工具目前也无法处理虚拟子类</li>
</ul>
<p>register 方法通常作为普通函数调用​，不过也可以作为装饰器使用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</span><br><span class="line"></span><br><span class="line"><span class="meta">@Tombola.register</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TomboList</span>(<span class="title class_ inherited__">list</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pick</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self:</span><br><span class="line">            position = randrange(<span class="built_in">len</span>(self))</span><br><span class="line">            <span class="keyword">return</span> self.pop(position)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> LookupError(<span class="string">&#x27;pop from empty TomboList&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    load = <span class="built_in">list</span>.extend</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">loaded</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bool</span>(self)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inspect</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">tuple</span>(self)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Tombola.register(TomboList)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>把 Tombolist 注册为 Tombola 的虚拟子类</li>
<li>Tombolist 扩展 list</li>
<li>始终可以这样调用 <code>Tombola.register(TomboList)</code>。如果需要注册不是自己维护的类，却能满足指定的接口，就可以这么做</li>
</ul>
<p>注册之后，可以使用 issubclass 函数和 isinstance 函数判断 TomboList 是不是 Tombola 的子类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> tombolist <span class="keyword">import</span> TomboList</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(TomboList, Tombola)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = TomboList(<span class="built_in">range</span>(<span class="number">100</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(t, Tombola)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>类的继承关系是在一个名为 <code>__mro__</code>（Method Resolution Order，方法解析顺序）的特殊类属性中指定的。这个属性的作用很简单，<strong>它会按顺序列出类及其超类，而 Python 会按照这个顺序搜索方法</strong>。查看 TomboList 类的 <code>__mro__</code> 属性，你会发现它只列出了 <code>真实</code> 的超类，即 list 和 object：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>TomboList.__mro__</span><br><span class="line">(&lt;<span class="keyword">class</span> <span class="string">&#x27;tombolist.TomboList&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;object&#x27;</span>&gt;)</span><br></pre></td></tr></table></figure>
<p><strong>Tombolist.__mro__中没有 Tombola，因此 Tombolist 没有从 Tombola 中继承任何方法</strong>。</p>
<h3 id="register-的实际使用"><a class="markdownIt-Anchor" href="#register-的实际使用"></a> register 的实际使用</h3>
<p>上面例子中，我们把 <code>Tombola.register</code> 当作一个类装饰器使用。除此之外，仍然经常把 register 当作普通函数调用，注册其他地方定义的类。注册过程仅在导入模块时发生是没有问题的，因为如果想使用抽象基类，则必须导入模块。</p>
<p>子类化抽象基类或者注册到抽象基类上都能让类通过 <code>issubclass</code> 检查和 <code>isinstance</code> 检查（后者依赖前者）​。但是，有些抽象基类还支持结构类型。</p>
<h3 id="使用抽象基类实现结构类型"><a class="markdownIt-Anchor" href="#使用抽象基类实现结构类型"></a> 使用抽象基类实现结构类型</h3>
<p><strong>抽象基类最常用于实现名义类型</strong>。假如一个类 <code>Sub</code> 会显式继承抽象基类 <code>AnABC</code>，或者注册到 <code>AnABC</code> 上，那么 AnABC 这个名称就和 Sub 连在了一起，因此在运行时，<code>issubclass(AnABC, Sub)</code> 会返回 True。</p>
<p>相比之下，<strong>结构类型通过对象公开接口的结构判断对象的类型，如果一个对象实现了某个类型定义的方法，那么该对象就与该类型相容。动态鸭子类型和静态鸭子类型是实现结构类型的两种方式</strong>。</p>
<p>其实，<strong>某些抽象基类也支持结构类型，之前说过，未注册的类也可能被识别为抽象基类的子类</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Struggle</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>): <span class="keyword">return</span> <span class="number">23</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(Struggle(), abc.Sized)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(Struggle, abc.Sized)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>经 issubclass 函数判断，Struggle 类是 abc.Sized 的子类（进而 <code>isinstance</code> 也得出同样的结论）​，<strong>因为 <code>abc.Sized</code> 实现了一个名为 <code>__subclasshook__</code> 的特殊的类方法</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sized</span>(metaclass=ABCMeta):</span><br><span class="line"></span><br><span class="line">    __slots__ = ()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__subclasshook__</span>(<span class="params">cls, C</span>):</span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">is</span> Sized:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">any</span>(<span class="string">&quot;__len__&quot;</span> <span class="keyword">in</span> B.__dict__ <span class="keyword">for</span> B <span class="keyword">in</span> C.__mro__):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果 <code>C.__mro__</code> 列出的某个类（C 及其超类）的 <code>__dict__</code> 中有名为 <code>__len__</code> 的属性，就表明 C 是 cls（Sized）的虚拟子类</li>
<li>否则，返回 NotImplemented，让子类检查继续下去</li>
</ul>
<p><strong>抽象基类对结构类型的支持就是通过 <code>__subclasshook__</code> 实现的</strong>。可以使用抽象基类确立接口，使用 <code>isinstance</code> 检查该抽象基类，一个完全无关的类仍然能通过 issubclass 检查，因为该类实现了特定的方法（或者该类竭力说服了 <code>__subclasshook__</code> 为它 <code>担保</code>​）​。</p>
<p>对于我们自己编写的抽象基类，一般不应该实现 <code>__subclasshook__</code>，因为可信度并不高，让程序员显式定义子类或者使用 <code>register</code> 方法来注册，这样才能板上钉钉。</p>
<h2 id="静态协议"><a class="markdownIt-Anchor" href="#静态协议"></a> 静态协议</h2>
<p>Python 最初实现类型提示利用的是名义类型系统，注解中的类型名称要与实参的类型名称（或者某个超类的名称）匹配。而我们知道，支持必要操作的类型就算实现了协议，而这样的类型可能很多，无法一一列出，因此在 Python 3.8 之前，类型提示无法描述鸭子类型，对于如下 double 函数，引入静态协议之前，几乎不可能为 double 函数添加完美的类型提示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">double</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>有了 <code>typing.Protocol</code> 之后，现在可以告诉 Mypy，double 函数接受支持 <code>x * 2</code> 运算的参数 x</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar, Protocol</span><br><span class="line"></span><br><span class="line">T = TypeVar(<span class="string">&#x27;T&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Repeatable</span>(<span class="title class_ inherited__">Protocol</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self: T, repeat_count: <span class="built_in">int</span></span>) -&gt; T: ...</span><br><span class="line"></span><br><span class="line">RT = TypeVar(<span class="string">&#x27;RT&#x27;</span>, bound=Repeatable)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">double</span>(<span class="params">x: RT</span>) -&gt; RT:</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>T 在 <code>__mul__</code> 签名中使用，<code>__mul__</code> 是 Repeatable 协议的核心</li>
<li><strong>self 参数通常不注解，因为默认假定为所在的类。这里使用 T 是为了确保返回值的类型与 self 相同</strong></li>
<li>类型变量 RT 的上界由 Repeatable 协议限定，类型检查工具将要求具体使用的类型实现 Repeatable 协议</li>
</ul>
<p>这样就实现了提供给 double 函数的实参 x 是什么名义类型无关紧要，只要实现了 <code>__mul__</code> 方法就行——这就是鸭子类型的好处。</p>
<h3 id="运行时可检查的静态协议"><a class="markdownIt-Anchor" href="#运行时可检查的静态协议"></a> 运行时可检查的静态协议</h3>
<p>虽然 <code>typing.Protocol</code> 属于静态检查，但是定义 <code>typing.Protocol</code> 的子类时，<strong>可以借由 <code>@runtime_checkable</code> 装饰器让协议支持在运行时使用 <code>isinstance/issubclass</code> 检查</strong>。这背后的原因是，<code>typing.Protocol</code> 是一个抽象基类，因此它支持上文所讲过的 <code>__subclasshook__</code>。</p>
<p>从 Python3.9 开始，typing 模块提供了 7 个可在运行时检查的协议，例如：</p>
<ul>
<li>class typing.SupportsComplex：抽象基类，有一个抽象方法 <code>__complex__</code></li>
<li>class typing.SupportsFloat：抽象基类，有一个抽象方法 <code>__float__</code></li>
</ul>
<p>另外值得说明的是，<strong>对于外部类型检查工具，使用 <code>isinstance</code> 明确检查类型有一个好处：在条件为 <code>isinstance(o, MyType)</code> 的if语句块内，Mypy 可以推导出 o 对象的类型与 MyType 相容</strong>。</p>
<p>在运行时，鸭子类型本身往往是类型检查的最佳方式。不要调用 isinstance 或 hasattr，直接在对象上尝试执行所需的操作，如果抛出异常，就处理异常。因为取得原谅比获得许可容易（EAFP 原则）​：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    c = <span class="built_in">complex</span>(o)</span><br><span class="line"><span class="keyword">except</span> TypeError <span class="keyword">as</span> exc:</span><br><span class="line">    <span class="keyword">raise</span> TypeError(<span class="string">&#x27;o must be convertible to complex&#x27;</span>) <span class="keyword">from</span> exc</span><br></pre></td></tr></table></figure>
<p>如果只想抛出 TypeError，就省略 <code>try/except/raise</code> 语句，直接写成如下形式，这时，如果 o 不是可接受的类型，那么 Python 将抛出异常，输出非常明确的消息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="built_in">complex</span>(o)</span><br></pre></td></tr></table></figure>
<h3 id="运行时可检查协议的局限性"><a class="markdownIt-Anchor" href="#运行时可检查协议的局限性"></a> 运行时可检查协议的局限性</h3>
<p>如前所述，类型提示在运行时一般会被忽略。使用 isinstance 或 issubclass 检查静态协议有类似的影响。</p>
<p>例如，实现 <code>__float__</code> 方法的类在运行时都被认定是 SupportsFloat 的虚拟子类，不管 <code>__float__</code> 方法是否返回一个 float 值。</p>
<p><code>isinstance</code> 或 <code>issubclass</code> 只检查有没有特定的方法，不检查方法的签名，更不会检查方法的类型注解。这种行为不会改变，因为在运行时大规模检查类型损耗的性能是不可接受的。</p>
<h3 id="支持静态协议"><a class="markdownIt-Anchor" href="#支持静态协议"></a> 支持静态协议</h3>
<p>如下为自己的类实现了 <code>__complex__</code> 方法，此时对于运行时类型检查 <code>SupportsComplex</code>，该类就满足要求。当然为了让 Mypy 更好地做静态检查和错误报告，<code>__complex__</code> 方法和 <code>fromcomplex</code> 方法应该有类型提示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__complex__</span>(<span class="params">self</span>) -&gt; <span class="built_in">complex</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(self.x, self.y)</span><br><span class="line"></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fromcomplex</span>(<span class="params">cls, datum</span>) -&gt; Vector2d:</span><br><span class="line">    c = <span class="built_in">complex</span>(datum)</span><br><span class="line">    <span class="keyword">return</span> cls(c.real, c.imag)</span><br></pre></td></tr></table></figure>
<ul>
<li>如果该模块的顶部有 <code>from __future__ import annotations</code>，那么 <code>fromcomplex</code> 的返回值类型可以是 Vector2d。有了那个导入语句，类型提示将存储为字符串，在导入时（求解函数定义时）不做求解</li>
<li>不从 <code>__future__</code> 中导入 <code>annotations</code>，Vector2d 在那一刻（<strong>类尚未完整定义</strong>）就是无效引用，应该写为字符串 <code>'Vector2d'</code>，假装是向前引用</li>
<li>这个 <code>__future__</code> 导入由 <code>PEP 563—Postponed Evaluation of Annotations</code> 引入，在 <code>Python3.7</code> 中实现</li>
<li>原本计划在 Python3.10 中把这个行为定为默认行为，但是后来推迟到下一个版本了。<strong>到那时，这个导入语句就是多余的了，但是也没有危害</strong></li>
</ul>
<h3 id="设计一个静态协议"><a class="markdownIt-Anchor" href="#设计一个静态协议"></a> 设计一个静态协议</h3>
<p>Go 语言一般推荐接口的定义中应包含尽量少的方法：单方法协议实现的静态鸭子类型更有用且更灵活。Go 语言标准库中有多个这样的接口，例如 Reader，这是一个 I/O 接口，只要求一个 read 方法。以后，如果觉得需要一个更完整的协议，可以把多个协议合而为一。</p>
<p>之前的抽象基类示例 Tombola 有两个抽象方法：pick 和 load。我们定义对应的静态协议版本，首先是 RandomPicker：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Protocol, runtime_checkable, <span class="type">Any</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@runtime_checkable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomPicker</span>(<span class="title class_ inherited__">Protocol</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pick</span>(<span class="params">self</span>) -&gt; <span class="type">Any</span>: ...</span><br></pre></td></tr></table></figure>
<ul>
<li>pick 方法的返回值类型是 Any。<strong>后面会说明如何让 RandomPicker 支持泛型参数，允许协议的用户指定 pick 方法的返回值类型</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Any</span>, Iterable, TYPE_CHECKING</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimplePicker</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, items: Iterable</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._items = <span class="built_in">list</span>(items)</span><br><span class="line">        random.shuffle(self._items)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pick</span>(<span class="params">self</span>) -&gt; <span class="type">Any</span>:</span><br><span class="line">        <span class="keyword">return</span> self._items.pop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_isinstance</span>() -&gt; <span class="literal">None</span>:</span><br><span class="line">    popper: RandomPicker = SimplePicker([<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(popper, RandomPicker)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_item_type</span>() -&gt; <span class="literal">None</span>:</span><br><span class="line">    items = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    popper = SimplePicker(items)</span><br><span class="line">    item = popper.pick()</span><br><span class="line">    <span class="keyword">assert</span> item <span class="keyword">in</span> items</span><br><span class="line">    <span class="keyword">if</span> TYPE_CHECKING:</span><br><span class="line">        reveal_type(item)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(item, <span class="built_in">int</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>实现协议的类本身不需要 <code>静态协议类</code>。SimplePicker 实现 RandomPicker 协议，但不是后者的子类。这就是静态鸭子类型</li>
<li>默认的返回值类型就是 Any，因此严格来说，不需要这个注解</li>
<li>为 popper 变量添加了类型提示，指出 Mypy 知道 SimplePicker 是相容的</li>
<li>如果想让 Mypy 检查，那么别忘了加上类型提示 <code>-&gt; None</code></li>
<li>SimplePicker 的实例也是 RandomPicker 的实例。背后的原因是，RandomPicker 应用了 <code>@runtime_checkable</code> 装饰器，而且 SimplePicker 有所需的 pick 方法</li>
<li>reveal_type 是能被 Mypy 识别的 <code>魔法</code> 函数，无须导入，而且只能在受 <code>typing.TYPE_CHECKING</code> 条件保护的 if 块中调用</li>
</ul>
<h3 id="协议设计最佳实践"><a class="markdownIt-Anchor" href="#协议设计最佳实践"></a> 协议设计最佳实践</h3>
<p>Go 语言 10 年的静态鸭子类型经验表明，窄协议（narrow protocol）更有用。通常，窄协议只有一个方法，很少超过两个。另外，有时你会发现，协议在使用它的函数附近定义，即在 <code>客户代码</code> 中而不是在库中定义。这样方便调用相关函数创建新类型，也有利于扩展和使用 mock 测试。窄协议和客户代码协议都能有效避免紧密耦合，不应强迫客户依赖用不到的接口。​</p>
<p><code>Contributing to typeshed</code> 页面建议静态协议采用以下命名约定：</p>
<ul>
<li>使用朴素的名称命名协议，清楚表明概念</li>
<li>使用 <code>SupportsX</code> 形式命名提供可调用方法的协议</li>
<li>使用 <code>HasX</code> 形式命名有可读属性和可写属性，或者有读值方法和设值方法的协议</li>
</ul>
<p>另外，Go 语言接口的命名也挺不错，例如 Reader、Formatter 等。</p>
<h3 id="扩展一个协议"><a class="markdownIt-Anchor" href="#扩展一个协议"></a> 扩展一个协议</h3>
<p>接口的定义倾向于极简主义，如果实际使用中发现协议需要多个方法，那么不要直接为协议添加方法，最好衍生原协议，创建一个新协议。<strong>在 Python 中，扩展静态协议有几个问题需要注意</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Protocol, runtime_checkable</span><br><span class="line"><span class="keyword">from</span> randompick <span class="keyword">import</span> RandomPicker</span><br><span class="line"></span><br><span class="line"><span class="meta">@runtime_checkable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoadableRandomPicker</span>(RandomPicker, Protocol):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">self, Iterable</span>) -&gt; <span class="literal">None</span>: ...</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>如果希望衍生的协议可在运行时检查，则必须再次应用这个装饰器，因为该装饰器的行为不被继承</strong></li>
<li><strong>每个协议都必须明确把 <code>typing.Protocol</code> 列出来，作为基类。另外，再列出要扩展的协议</strong>。这与 Python 中的继承不是一回事</li>
<li>只需要声明衍生协议新增的方法（类似于常规的面对对象编程方式）</li>
</ul>
<h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2>
<p>在现代的 Python 中，我们有 4 种互补的接口编程方法，它们各有优缺点。对于现代的 Python 基准代码，只要体量够大，4 种类型模式都有用武之地。抛下哪一种类型，作为 Python 程序员，你的日子都不会好过。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/Python/" rel="tag"># Python</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/11/03/fluent-python-v2-14/" rel="prev" title="流畅的 Python 第 2 版（14）：继承：瑕瑜互见">
      <i class="fa fa-chevron-left"></i> 流畅的 Python 第 2 版（14）：继承：瑕瑜互见
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/11/02/fluent-python-v2-12/" rel="next" title="流畅的 Python 第 2 版（12）：序列的特殊方法">
      流畅的 Python 第 2 版（12）：序列的特殊方法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.</span> <span class="nav-text"> 两种协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text"> 利用鸭子类型编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%8C%B4%E5%AD%90%E8%A1%A5%E4%B8%81%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AE%9E%E7%8E%B0%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.1.</span> <span class="nav-text"> 使用猴子补丁在运行时实现协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%B2%E5%BE%A1%E6%80%A7%E7%BC%96%E7%A8%8B%E5%92%8C%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5"><span class="nav-number">2.2.</span> <span class="nav-text"> 防御性编程和快速失败</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E9%B9%85%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text"> 大鹅类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E7%B1%BB%E5%8C%96%E4%B8%80%E4%B8%AA%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="nav-number">3.1.</span> <span class="nav-text"> 子类化一个抽象基类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="nav-number">3.2.</span> <span class="nav-text"> 标准库中的抽象基类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%B9%B6%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="nav-number">3.3.</span> <span class="nav-text"> 定义并使用一个抽象基类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB%E5%8F%A5%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="nav-number">3.4.</span> <span class="nav-text"> 抽象基类句法详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E7%B1%BB%E5%8C%96%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB-tombola"><span class="nav-number">3.5.</span> <span class="nav-text"> 子类化抽象基类 Tombola</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB%E7%9A%84%E8%99%9A%E6%8B%9F%E5%AD%90%E7%B1%BB"><span class="nav-number">3.6.</span> <span class="nav-text"> 抽象基类的虚拟子类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#register-%E7%9A%84%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8"><span class="nav-number">3.7.</span> <span class="nav-text"> register 的实际使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.8.</span> <span class="nav-text"> 使用抽象基类实现结构类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.</span> <span class="nav-text"> 静态协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%AF%E6%A3%80%E6%9F%A5%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.1.</span> <span class="nav-text"> 运行时可检查的静态协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%AF%E6%A3%80%E6%9F%A5%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="nav-number">4.2.</span> <span class="nav-text"> 运行时可检查协议的局限性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E9%9D%99%E6%80%81%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.3.</span> <span class="nav-text"> 支持静态协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.4.</span> <span class="nav-text"> 设计一个静态协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">4.5.</span> <span class="nav-text"> 协议设计最佳实践</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E4%B8%80%E4%B8%AA%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.6.</span> <span class="nav-text"> 扩展一个协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text"> 小结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">228</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">


  

</body>
</html>
