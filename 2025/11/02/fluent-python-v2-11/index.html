<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="得益于 Python 数据模型，自定义类型的行为可以像内置类型那样自然。实现如此自然的行为，靠的不是继承，而是鸭子类型：只需按照预定行为实现对象所需的方法即可。对库或框架来说，程序员可能希望你定义的类能像 Python 内置的类一样。满足这个预期也算得上是符合 Python风格。">
<meta property="og:type" content="article">
<meta property="og:title" content="流畅的 Python 第 2 版（11）：符合 Python 风格的对象">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2025/11/02/fluent-python-v2-11/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="得益于 Python 数据模型，自定义类型的行为可以像内置类型那样自然。实现如此自然的行为，靠的不是继承，而是鸭子类型：只需按照预定行为实现对象所需的方法即可。对库或框架来说，程序员可能希望你定义的类能像 Python 内置的类一样。满足这个预期也算得上是符合 Python风格。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-11-02T02:36:37.000Z">
<meta property="article:modified_time" content="2025-11-02T02:37:42.776Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2025/11/02/fluent-python-v2-11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>流畅的 Python 第 2 版（11）：符合 Python 风格的对象 | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2025/11/02/fluent-python-v2-11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          流畅的 Python 第 2 版（11）：符合 Python 风格的对象
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-02 10:36:37" itemprop="dateCreated datePublished" datetime="2025-11-02T10:36:37+08:00">2025-11-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>得益于 Python 数据模型，自定义类型的行为可以像内置类型那样自然。实现如此自然的行为，靠的不是继承，而是鸭子类型：只需按照预定行为实现对象所需的方法即可。对库或框架来说，程序员可能希望你定义的类能像 Python 内置的类一样。满足这个预期也算得上是符合 <code>Python风格</code>。</p>
<span id="more"></span>
<h2 id="对象表示形式"><a class="markdownIt-Anchor" href="#对象表示形式"></a> 对象表示形式</h2>
<p>每门面向对象语言至少都有一种获取对象字符串表示形式的标准方式。Python 提供了两种方式：</p>
<ul>
<li>repr()：以便于开发者理解的方式返回对象的字符串表示形式。Python 控制台或调试器在显示对象时采用这种方式</li>
<li>str()：以便于用户理解的方式返回对象的字符串表示形式。使用 <code>print()</code> 打印对象时采用这种方式</li>
</ul>
<p>在背后支持 <code>repr()</code> 和 <code>str()</code> 的是特殊方法 <code>__repr__</code> 和 <code>__str__</code>。除此之外，还有两个特殊方法 <code>__bytes__</code> 和 <code>__format__</code>，可为对象提供其他表示形式。</p>
<ul>
<li><code>__bytes__</code> 方法与 <code>__str__</code> 方法类似，<code>bytes()</code> 函数调用它获取对象的字节序列表示形式</li>
<li>而 <code>__format__</code> 方法供 <code>f 字符串</code>、<code>内置函数 format()</code> 和 <code>str.format()</code> 使用，通过调用 <code>obj.__format__(format_spec)</code> 以特殊的格式化代码显示对象的字符串表示形式</li>
</ul>
<h2 id="再谈向量类"><a class="markdownIt-Anchor" href="#再谈向量类"></a> 再谈向量类</h2>
<p>如下实现了一个 Vector2d 类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector2d</span>:</span><br><span class="line">    typecode = <span class="string">&#x27;d&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = <span class="built_in">float</span>(x)</span><br><span class="line">        self.y = <span class="built_in">float</span>(y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self.x, self.y))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        class_name = <span class="built_in">type</span>(self).__name__</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#123;&#125;(&#123;!r&#125;, &#123;!r&#125;)&#x27;</span>.<span class="built_in">format</span>(class_name, *self)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">tuple</span>(self))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__bytes__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">bytes</span>([<span class="built_in">ord</span>(self.typecode)]) +</span><br><span class="line">                <span class="built_in">bytes</span>(array(self.typecode, self)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">tuple</span>(self) == <span class="built_in">tuple</span>(other)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__abs__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> math.hypot(self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__bool__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bool</span>(<span class="built_in">abs</span>(self))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1</span><br><span class="line">Vector2d(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = v1</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y</span><br><span class="line">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1_clone = <span class="built_in">eval</span>(<span class="built_in">repr</span>(v1))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1_clone</span><br><span class="line">Vector2d(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 == v1_clone</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(v1)</span><br><span class="line"><span class="number">5.0</span></span><br><span class="line">* &gt;&gt;&gt; <span class="built_in">bytes</span>(v1)</span><br><span class="line"><span class="string">b&#x27;d\x00\x00\x00\x00\x00\x00\x08@\x00\x00\x00\x00\x00\x00\x10@&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(v1)</span><br><span class="line"><span class="string">&#x27;(3.0, 4.0)&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>typecode 是类属性，在 Vector2d 实例和字节序列之间转换时使用</li>
<li>在 <code>__init__</code> 方法中把 x 和 y 转换成浮点数，<strong>尽早捕获错误，以防调用 Vector2d 构造函数时传入不当参数</strong></li>
<li>定义 <code>__iter__</code> 方法，把 Vector2d 实例变成可迭代对象，这样才能拆包</li>
<li><code>__repr__</code> 方法使用 <code>&#123;!r&#125;</code> 获取各个分量的表示形式，然后插值，构成一个字符串。因为 Vector2d 实例是可迭代对象，所以 <code>*self</code> 会把 x 分量和 y 分量提供给 format 方法</li>
</ul>
<h2 id="备选构造函数"><a class="markdownIt-Anchor" href="#备选构造函数"></a> 备选构造函数</h2>
<p>我们已经可以把 Vector2d 实例转换成字节序列了。同理，我们也希望能从字节序列构建 Vector2d 实例。使用 <code>array.array</code> 的类方法 <code>.frombytes</code> 可以从字节序列构建 Vector2d ：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">frombytes</span>(<span class="params">cls, octets</span>):</span><br><span class="line">    typecode = <span class="built_in">chr</span>(octets[<span class="number">0</span>])</span><br><span class="line">    memv = <span class="built_in">memoryview</span>(octets[<span class="number">1</span>:]).cast(typecode)</span><br><span class="line">    <span class="keyword">return</span> cls(*memv)</span><br></pre></td></tr></table></figure>
<ul>
<li>classmethod 装饰的方法可直接在类上调用</li>
<li>第一个参数不是 self，而是类自身（习惯命名为 cls）​</li>
<li>从第一字节中读取 <code>typecode</code>，使用传入的 octets 字节序列创建一个 memoryview，然后使用 typecode 进行转换</li>
<li>拆包转换后的 memoryview，得到构造函数所需的一对参数</li>
</ul>
<h2 id="classmethod-与-staticmethod"><a class="markdownIt-Anchor" href="#classmethod-与-staticmethod"></a> classmethod 与 staticmethod</h2>
<p>classmethod 装饰器定义操作类而不是操作实例的方法。由于 classmethod 改变了调用方法的方式，因此接收的第一个参数是类本身，而不是实例。classmethod 最常见的用途是定义备选构造函数。上面例子中就使用 cls 参数构建了一个新实例，即 <code>cls(*memv)</code>。</p>
<p>相比之下，staticmethod 装饰器也会改变方法的调用方式，使其接收的第一个参数没什么特殊的。其实，<strong>静态方法就是普通的函数，只是碰巧位于类的定义体中，而不是在模块层定义</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>:</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">klassmeth</span>(<span class="params">*args</span>):</span><br><span class="line">        <span class="keyword">return</span> args</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">statmeth</span>(<span class="params">*args</span>):</span><br><span class="line">        <span class="keyword">return</span> args</span><br><span class="line"></span><br><span class="line"><span class="comment"># (&lt;class &#x27;__main__.Demo&#x27;&gt;,)</span></span><br><span class="line"><span class="built_in">print</span>(Demo.klassmeth())</span><br><span class="line"><span class="comment"># (&lt;class &#x27;__main__.Demo&#x27;&gt;, &#x27;test&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(Demo.klassmeth(<span class="string">&quot;test&quot;</span>))</span><br><span class="line"><span class="comment"># ()</span></span><br><span class="line"><span class="built_in">print</span>(Demo.statmeth())</span><br><span class="line"><span class="comment"># (&#x27;test&#x27;,)</span></span><br><span class="line"><span class="built_in">print</span>(Demo.statmeth(<span class="string">&quot;test&quot;</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>不管怎样调用 <code>Demo.klassmeth</code> ，它的第一个参数始终是 Demo 类</li>
<li><code>Demo.statmeth</code> 的行为与普通的函数一样</li>
</ul>
<p>有些函数即使不直接处理类，也与类联系紧密，因此你会想把函数与类放在一起定义，这种情况就是 <code>staticmethod</code> 的用武之地。对于这种情况，在类的前面或后面定义函数，保持二者在同一个模块中也是可行的方法（所以 staticmethod 其实不是特别有用）。</p>
<h2 id="格式化显示"><a class="markdownIt-Anchor" href="#格式化显示"></a> 格式化显示</h2>
<p>f 字符串、内置函数 <code>format()</code> 和 <code>str.format()</code> 方法会把各种类型的格式化方式委托给相应的 <code>.__format__(format_spec)</code> 方法。<code>format_spec</code> 参数是格式说明符。格式说明符使用的表示法叫格式规范微语言（Format Specification Mini-Language）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">format</span>(<span class="number">42</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;101010&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">format</span>(<span class="number">2</span>/<span class="number">3</span>, <span class="string">&#x27;.1%&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;66.7%&#x27;</span></span><br></pre></td></tr></table></figure>
<p>格式规范微语言是可扩展的，各个类可以自行决定如何解释 format_spec 参数。如果一个类没有定义 <code>__format__</code>，那么该方法就会从 object 继承，并返回 <code>str(my_object)</code>。如果传入格式说明符，则 <code>object.__format__</code> 会抛出 TypeError。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">format</span>(v1)</span><br><span class="line"><span class="string">&#x27;(3.0, 4.0)&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">format</span>(v1, <span class="string">&#x27;.3f&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unsupported <span class="built_in">format</span> string passed to Vector2d.__format__</span><br></pre></td></tr></table></figure>
<p>如下在 Vector2d 类中实现了自己的 <code>__format__</code> 方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__format__</span>(<span class="params">self, fmt_spec=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> fmt_spec.endswith(<span class="string">&#x27;p&#x27;</span>):</span><br><span class="line">        fmt_spec = fmt_spec[:-<span class="number">1</span>]</span><br><span class="line">        coords = (<span class="built_in">abs</span>(self), self.angle())</span><br><span class="line">        outer_fmt = <span class="string">&#x27;&lt;&#123;&#125;, &#123;&#125;&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        coords = self</span><br><span class="line">        outer_fmt = <span class="string">&#x27;(&#123;&#125;, &#123;&#125;)&#x27;</span></span><br><span class="line">    components = (<span class="built_in">format</span>(c, fmt_spec) <span class="keyword">for</span> c <span class="keyword">in</span> coords)</span><br><span class="line">    <span class="keyword">return</span> outer_fmt.<span class="built_in">format</span>(*components)</span><br></pre></td></tr></table></figure>
<h2 id="可哈希的-vector2d"><a class="markdownIt-Anchor" href="#可哈希的-vector2d"></a> 可哈希的 Vector2d</h2>
<p>按照定义，目前 Vector2d 实例不可哈希，因此不能放入集合中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>(v1)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;Vector2d&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1.__hash__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(v1.__hash__)</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(v1.__eq__)</span><br><span class="line">&lt;bound method Vector2d.__eq__ of Vector2d(<span class="number">3.0</span>, <span class="number">4.0</span>)&gt;</span><br></pre></td></tr></table></figure>
<p>如果一个类定义了 <code>__eq__</code> 但没有定义 <code>__hash__</code>，那么它的实例将自动变为不可哈希（Python 自动设置 <code>__hash__ = None</code>）。为了把 Vector2d 实例变成可哈希的，必须实现 <code>__hash__</code> 方法（还需要 <code>__eq__</code> 方法，前面已经实现了）。此外，还要让向量实例不可变。</p>
<p>目前我们可以随意设置 Vector2d 实例的 <code>_x</code> 和 <code>_y</code> 属性，这可能会导致向量的哈希值改变。为了避免这种情况，必须把 <code>_x</code> 和 <code>_y</code> 属性设为只读属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector2d</span>:</span><br><span class="line">    typecode = <span class="string">&#x27;d&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.__x = <span class="built_in">float</span>(x)</span><br><span class="line">        self.__y = <span class="built_in">float</span>(y)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">x</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">y</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__y</span><br></pre></td></tr></table></figure>
<ul>
<li>使用两个前导下划线（尾部没有下划线或有一个下划线）​，把属性标记为私有的</li>
<li><code>@property</code> 装饰器把读值方法标记为特性（property），读值方法与公开属性同名</li>
</ul>
<p>现在，向量不会被意外修改，有了一定的安全性。接下来可以实现 <code>__hash__</code> 方法了，这个方法应该返回一个 int 值，理想情况下还要考虑对象属性的哈希值，因为相等的对象应该具有相同的哈希值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span>((self.x, self.y))</span><br></pre></td></tr></table></figure>
<p>实现 <code>__hash__</code> 方法之后，向量就变成可哈希的了。</p>
<p>特性的使用方法表明，可以先以最简单的方式定义类，也就是使用公开属性，因为如果以后需要对读值方法和设值方法增加控制，则可以通过特性实现。这样做对一开始通过公开属性的名称（例如 x 和 y）与对象交互的代码没有影响。<br />
在 Python 中，到处使用读值方法和设值方法是不明智的，在Python中，可以先使用公开属性，然后等需要时再变成特性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_object.set_foo(my_object.get_foo() + <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 不如直接这样</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_object.foo += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="支持位置模式匹配"><a class="markdownIt-Anchor" href="#支持位置模式匹配"></a> 支持位置模式匹配</h2>
<p>目前，Vector2d 实例兼容关键字类模式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">keyword_pattern_demo</span>(<span class="params">v: Vector2d</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">match</span> v:</span><br><span class="line">        <span class="keyword">case</span> Vector2d(x=<span class="number">0</span>, y=<span class="number">0</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;v!r&#125;</span> is null&#x27;</span>)</span><br><span class="line">        <span class="keyword">case</span> Vector2d(x=<span class="number">0</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;v!r&#125;</span> is vertical&#x27;</span>)</span><br><span class="line">        <span class="keyword">case</span> Vector2d(y=<span class="number">0</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;v!r&#125;</span> is horizontal&#x27;</span>)</span><br><span class="line">        <span class="keyword">case</span> Vector2d(x=x, y=y) <span class="keyword">if</span> x==y:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;v!r&#125;</span> is diagonal&#x27;</span>)</span><br><span class="line">        <span class="keyword">case</span> _:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;v!r&#125;</span> is awesome&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>但是如果使用如下位置模式则会出错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> Vector2d(_, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;v!r&#125;</span> is horizontal&#x27;</span>)</span><br><span class="line"></span><br><span class="line">TypeError: Vector2d() accepts <span class="number">0</span> positional sub-patterns (<span class="number">1</span> given)</span><br></pre></td></tr></table></figure>
<p>为了让 <code>Vector2d</code> 支持位置模式，需要添加一个名为 <code>__match_args__</code> 的类属性，按照在位置模式匹配中的使用顺序列出实例属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector2d</span>:</span><br><span class="line">    __match_args__ = (<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>现在就可以匹配 Vector2d 对象的位置模式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">positional_pattern_demo</span>(<span class="params">v: Vector2d</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">match</span> v:</span><br><span class="line">        <span class="keyword">case</span> Vector2d(<span class="number">0</span>, <span class="number">0</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;v!r&#125;</span> is null&#x27;</span>)</span><br><span class="line">        <span class="keyword">case</span> Vector2d(<span class="number">0</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;v!r&#125;</span> is vertical&#x27;</span>)</span><br><span class="line">        <span class="keyword">case</span> Vector2d(_, <span class="number">0</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;v!r&#125;</span> is horizontal&#x27;</span>)</span><br><span class="line">        <span class="keyword">case</span> Vector2d(x, y) <span class="keyword">if</span> x==y:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;v!r&#125;</span> is diagonal&#x27;</span>)</span><br><span class="line">        <span class="keyword">case</span> _:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;v!r&#125;</span> is awesome&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><code>__match_args__</code> 类属性不一定要把所有公开的实例属性都列出来。如果一个类的 <code>__init__</code> 方法可能有全都赋值给实例属性的必需的参数和可选的参数，那么 <code>__match_args__</code> 应当列出必需的参数，而不必列出可选的参数。</p>
<h2 id="vector2d-类型小结"><a class="markdownIt-Anchor" href="#vector2d-类型小结"></a> Vector2d 类型小结</h2>
<p>额外说一下，如果你定义的类型有标量数值，那么可能还要实现 <code>__int__</code> 方法和 <code>__float__</code> 方法（分别被 <code>int()</code> 构造函数和 <code>float()</code> 构造函数调用）​，以便在某些情况下强制转换类型。</p>
<p>当应用程序真正需要这些特殊方法时才应实现它们。终端用户并不关心应用程序中的对象是否符合 <code>Python风格</code>。如果你的类是供其他 Python 程序员使用的库的一部分，那么你肯定猜不到程序员会对你的对象做什么，他们或许更希望你的代码符合 <code>Python风格</code>。</p>
<h2 id="python-私有属性和-受保护-的属性"><a class="markdownIt-Anchor" href="#python-私有属性和-受保护-的属性"></a> Python 私有属性和 <code>受保护</code> 的属性</h2>
<p>Python 不能像 Java 那样使用 private 修饰符创建私有属性，但是它有一个简单的机制，<strong>能避免子类意外覆盖 <code>私有</code> 属性</strong>。</p>
<p>对于实例属性，如果以 <code>__xxx</code> 形式命名（两个前导下划线，尾部没有或最多有一个下划线），那么 Python 就会把属性名存入实例属性 <code>__dict__</code> 中，而且会在前面加上一个下划线和类名。这个语言功能叫名称改写（name mangling）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line"><span class="meta">... </span>            self.__a = <span class="number">10</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = A()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;_A__a&#x27;</span>: <span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure>
<p>名称改写是一种安全措施，不能保证万无一失：它的目的是避免意外访问，不能防止故意做错事。<strong>只要知道改写私有属性名称的机制，任何人都能直接读取私有属性——这实际上对调试和序列化很有用</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.__a</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">&#x27;A&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;__a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t._A__a</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>当然有人不喜欢这种句法，他们约定使用一个下划线前缀编写 <code>受保护</code> 的属性（例如self._x）​。批评使用两个下划线这种改写机制的人认为，应该使用命名约定来避免意外覆盖属性。<strong>Python 解释器不会对使用单下划线的属性名做特殊处理，不过这是很多 Python 程序员严格遵守的约定，他们不会在类的外部访问这种属性</strong>。遵守使用一个下划线标记对象的私有属性很容易，就像遵守使用全大写字母编写常量一样。Python 文档的某些角落把使用一个下划线前缀标记的属性称为 <code>受保护</code> 的属性。</p>
<h2 id="使用-__slots__-节省空间"><a class="markdownIt-Anchor" href="#使用-__slots__-节省空间"></a> 使用 <code>__slots__</code> 节省空间</h2>
<p>默认情况下，<strong>Python 把各个实例的属性存储在一个名为 <code>__dict__</code> 的字典中</strong>。之前介绍过，字典消耗的内存很多（即使有一些优化措施）。但是，如果定义一个名为 <code>__slots__</code> 的类属性，以序列的形式存储属性名称，那么 Python 将使用其他模型存储实例属性：<code>__slots__</code> 中的属性名称存储在一个隐藏的引用数组中，消耗的内存比字典少。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Pixel</span>:</span><br><span class="line"><span class="meta">... </span>    __slots__ = (<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Pixel()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.__dict__</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;python-input-2&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    p.__dict__</span><br><span class="line">AttributeError: <span class="string">&#x27;Pixel&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;__dict__&#x27;</span>. Did you mean: <span class="string">&#x27;__dir__&#x27;</span>?</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.x = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.y = <span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.color = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;python-input-5&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    p.color = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">    ^^^^^^^</span><br><span class="line">AttributeError: <span class="string">&#x27;Pixel&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;color&#x27;</span> <span class="keyword">and</span> no __dict__ <span class="keyword">for</span> setting new attributes</span><br></pre></td></tr></table></figure>
<ul>
<li><code>__slots__</code> 必须在定义类时声明，之后再添加或修改均无效。属性名称可以存储在一个元组或列表中（推荐使用元组，因为这可以明确表明 <code>__slots__</code> 无法修改）</li>
<li>可以看到，Pixel 实例没有 <code>__dict__</code> 属性，而且设置不在 <code>__slots__</code> 中的属性抛出 AttributeError</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>op = OpenPixel()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>op.__dict__</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>op.x = <span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>op.__dict__</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>op.x</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>op.color = <span class="string">&#x27;green&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>op.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>子类实例存在 <code>__dict__</code> 属性</li>
<li>设置存在于基类 <code>__slots__</code> 中的属性，不会存入实例的 <code>__dict__</code>（存入实例的一个隐藏的引用数组中）</li>
<li>设置不存在于基类 <code>__slots__</code> 中的属性，会存入实例的 <code>__dict__</code></li>
</ul>
<p>这个例子则说明，子类只继承 <code>__slots__</code> 的部分效果。为了确保子类的实例也没有 <code>__dict__</code> 属性，必须在子类中再次声明 <code>__slots__</code> 属性。</p>
<ul>
<li>如果在子类中声明 <code>__slots__= ()</code>（一个空元组）​，则子类的实例将没有 <strong>dict</strong> 属性，而且只接受基类的 <code>__slots__</code> 属性列出的属性名称</li>
<li>如果子类需要额外属性，则在子类的 <code>__slots__</code> 属性中列出来</li>
</ul>
<p>关于 <code>__slots__</code>，还有几个注意事项：</p>
<ul>
<li>实例只能拥有 <code>__slots__</code> 列出的属性，除非把 <code>__dict__</code> 加入 <code>__slots__</code> 中（但是这样做就失去了节省内存的功效）</li>
<li>有 <code>__slots__</code> 的类不能使用 <code>@cached_property</code> 装饰器，除非把 <code>__dict__</code> 加入 <code>__slots__</code> 中</li>
<li>如果不把 <code>__weakref__</code> 加入 <code>__slots__</code> 中，那么实例就不能作为弱引用的目标</li>
</ul>
<h2 id="覆盖类属性"><a class="markdownIt-Anchor" href="#覆盖类属性"></a> 覆盖类属性</h2>
<p>Python 有一个很独特的功能：<strong>类属性可为实例属性提供默认值</strong>。如果为不存在的实例属性赋值，那么将创建一个新实例属性，此时同名类属性将被遮盖。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"><span class="meta">... </span>    a = <span class="number">10</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = A()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.a</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.a = <span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.a</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.a</span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.a = <span class="number">30</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = A()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2.a</span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果想修改类属性的值，那么必须直接在类上修改，不能通过实例修改</li>
<li>还有一种修改方法更符合 Python 风格，而且效果持久，也更有针对性。类属性是公开的，会被子类继承，于是我们经常会创建一个子类，只用于定制类的数据属性</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> vector2d_v3 <span class="keyword">import</span> Vector2d</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">ShortVector2d</span>(<span class="title class_ inherited__">Vector2d</span>):</span><br><span class="line"><span class="meta">... </span>    typecode = <span class="string">&#x27;f&#x27;</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sv = ShortVector2d(<span class="number">1</span>/<span class="number">11</span>, <span class="number">1</span>/<span class="number">27</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sv</span><br><span class="line">ShortVector2d(<span class="number">0.09090909090909091</span>, <span class="number">0.037037037037037035</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(<span class="built_in">bytes</span>(sv))</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>
<h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2>
<p>符合 Python 风格的对象应该正好符合所需，而不是堆砌语言功能。开发应用程序时，应该集中精力满足终端用户的需求，仅此而已。编写供其他程序员使用的库时，应该实现一些特殊方法，提供 Python 程序员预期的行为。</p>
<p>简洁胜于复杂。要构建符合 Python 风格的对象，就要观察真正的 Python 对象的行为。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/Python/" rel="tag"># Python</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/11/02/fluent-python-v2-12/" rel="prev" title="流畅的 Python 第 2 版（12）：序列的特殊方法">
      <i class="fa fa-chevron-left"></i> 流畅的 Python 第 2 版（12）：序列的特殊方法
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/11/02/fluent-python-v2-10/" rel="next" title="流畅的 Python 第 2 版（10）：使用一等函数实现设计模式">
      流畅的 Python 第 2 版（10）：使用一等函数实现设计模式 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F"><span class="nav-number">1.</span> <span class="nav-text"> 对象表示形式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%8D%E8%B0%88%E5%90%91%E9%87%8F%E7%B1%BB"><span class="nav-number">2.</span> <span class="nav-text"> 再谈向量类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%87%E9%80%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">3.</span> <span class="nav-text"> 备选构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#classmethod-%E4%B8%8E-staticmethod"><span class="nav-number">4.</span> <span class="nav-text"> classmethod 与 staticmethod</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%98%BE%E7%A4%BA"><span class="nav-number">5.</span> <span class="nav-text"> 格式化显示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E5%93%88%E5%B8%8C%E7%9A%84-vector2d"><span class="nav-number">6.</span> <span class="nav-text"> 可哈希的 Vector2d</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E4%BD%8D%E7%BD%AE%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">7.</span> <span class="nav-text"> 支持位置模式匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vector2d-%E7%B1%BB%E5%9E%8B%E5%B0%8F%E7%BB%93"><span class="nav-number">8.</span> <span class="nav-text"> Vector2d 类型小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python-%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C-%E5%8F%97%E4%BF%9D%E6%8A%A4-%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">9.</span> <span class="nav-text"> Python 私有属性和 受保护 的属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-__slots__-%E8%8A%82%E7%9C%81%E7%A9%BA%E9%97%B4"><span class="nav-number">10.</span> <span class="nav-text"> 使用 __slots__ 节省空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%B1%BB%E5%B1%9E%E6%80%A7"><span class="nav-number">11.</span> <span class="nav-text"> 覆盖类属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">12.</span> <span class="nav-text"> 小结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">227</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">


  

</body>
</html>
