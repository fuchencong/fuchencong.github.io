<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="惨痛的教训告诉我，对于小型程序，动态类型就够了，而大型程序则需要更规范的方式。如果语言能做出规范，那么当然比 放任自流 要好。这篇文章我们将继续讲解 Python 的渐进式类型系统。">
<meta property="og:type" content="article">
<meta property="og:title" content="流畅的 Python 第 2 版（15）：类型提示进阶">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2025/11/04/fluent-python-v2-15/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="惨痛的教训告诉我，对于小型程序，动态类型就够了，而大型程序则需要更规范的方式。如果语言能做出规范，那么当然比 放任自流 要好。这篇文章我们将继续讲解 Python 的渐进式类型系统。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-11-04T10:20:22.000Z">
<meta property="article:modified_time" content="2025-11-23T10:33:45.264Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2025/11/04/fluent-python-v2-15/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>流畅的 Python 第 2 版（15）：类型提示进阶 | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2025/11/04/fluent-python-v2-15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          流畅的 Python 第 2 版（15）：类型提示进阶
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-04 18:20:22" itemprop="dateCreated datePublished" datetime="2025-11-04T18:20:22+08:00">2025-11-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>惨痛的教训告诉我，对于小型程序，动态类型就够了，而大型程序则需要更规范的方式。如果语言能做出规范，那么当然比 <code>放任自流</code> 要好。这篇文章我们将继续讲解 Python 的渐进式类型系统。</p>
<span id="more"></span>
<h2 id="重载的签名"><a class="markdownIt-Anchor" href="#重载的签名"></a> 重载的签名</h2>
<p>Python 函数可以接受不同的参数组合。这些不同的参数组合使用 <code>@typing.overload</code> 装饰器注解。如果函数的返回值类型取决于两个或以上参数的类型，那么这个功能就十分必要。</p>
<p>例如内置函数 sum 是用 C 语言编写的，typeshed 项目在 <code>builtins.pyi</code> 文件中为其提供了重载的类型提示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@overload</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">__iterable: Iterable[_T]</span>) -&gt; <span class="type">Union</span>[_T, <span class="built_in">int</span>]: ...</span><br><span class="line"><span class="meta">@overload</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">__iterable: Iterable[_T], start: _S</span>) -&gt; <span class="type">Union</span>[_T, _S]: ...</span><br></pre></td></tr></table></figure>
<ul>
<li><code>__iterable</code> 中的两个前导下划线是 <code>PEP 484</code> 制定的约定，表示仅限位置参数，供 Mypy 检查</li>
<li>类型检查工具根据参数按顺序匹配各个重载的签名。例如 <code>sum(range(100), 1000)</code> 调用不匹配第一个重载的签名，因为该签名只有一个参数，但是它匹配第二个签名</li>
</ul>
<p>在常规的 Python 模块中也可以使用 <code>@overload</code>，重载的签名放在函数具体的签名和实现前面。如下是个例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> overload, <span class="type">Union</span>, TypeVar</span><br><span class="line"></span><br><span class="line">T = TypeVar(<span class="string">&#x27;T&#x27;</span>)</span><br><span class="line">S = TypeVar(<span class="string">&#x27;S&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@overload</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">it: Iterable[T]</span>) -&gt; <span class="type">Union</span>[T, <span class="built_in">int</span>]: ...</span><br><span class="line"><span class="meta">@overload</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">it: Iterable[T], /, start: S</span>) -&gt; <span class="type">Union</span>[T, S]: ...</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">it, /, start=<span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">return</span> functools.reduce(operator.add, it, start)</span><br></pre></td></tr></table></figure>
<ul>
<li>定义了两个类型变量 <code>T</code> 和 <code>S</code></li>
<li>第一个重载签名针对 <code>start=0</code> 的情况，此时结果的类型既可能是 T，也可能是 int（迭代器对象为空）</li>
<li>第二个重载签名针对 <code>start</code> 参数不为默认值的情况，此时结果的类型是 T 或 S。因为提供的 start 参数可以是任何类型 S，这也是为什么要定义类型变量 T 的原因</li>
<li><strong>函数具体实现中的签名没有类型提示</strong></li>
</ul>
<p>追求注解全覆盖可能导致代码充斥太多噪声，有价值的信息不多。为了简化类型提示而重构也会导致 API 烦琐难用。有时，<strong>我们应该务实一点儿，部分代码没有类型提示也没关系</strong>。符合 Python 风格的 API 往往难以注解。</p>
<h3 id="重载-max-函数"><a class="markdownIt-Anchor" href="#重载-max-函数"></a> 重载 max 函数</h3>
<p>利用 Python 强大动态功能的函数往往难以添加类型提示。如下使用 python 重新实现了 max 函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">MISSING = <span class="built_in">object</span>()</span><br><span class="line">EMPTY_MSG = <span class="string">&#x27;max() arg is an empty sequence&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">max</span>(<span class="params">first, *args, key=<span class="literal">None</span>, default=MISSING</span>):</span><br><span class="line">    <span class="keyword">if</span> args:</span><br><span class="line">        series = args</span><br><span class="line">        candidate = first</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        series = <span class="built_in">iter</span>(first)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            candidate = <span class="built_in">next</span>(series)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">if</span> default <span class="keyword">is</span> <span class="keyword">not</span> MISSING:</span><br><span class="line">                <span class="keyword">return</span> default</span><br><span class="line">            <span class="keyword">raise</span> ValueError(EMPTY_MSG) <span class="keyword">from</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> current <span class="keyword">in</span> series:</span><br><span class="line">            <span class="keyword">if</span> candidate &lt; current:</span><br><span class="line">                candidate = current</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        candidate_key = key(candidate)</span><br><span class="line">        <span class="keyword">for</span> current <span class="keyword">in</span> series:</span><br><span class="line">            current_key = key(current)</span><br><span class="line">            <span class="keyword">if</span> candidate_key &lt; current_key:</span><br><span class="line">                candidate = current</span><br><span class="line">                candidate_key = current_key</span><br><span class="line">    <span class="keyword">return</span> candidate</span><br></pre></td></tr></table></figure>
<ul>
<li>这里重点是 MISSING 是常量，该常量的值是一个独特的 object 实例，用作哨符</li>
<li>MISSING 是 <code>default=</code> 关键字参数的默认值，这样可以让 max 函数接受 default=None，而且区分以下两种情况</li>
</ul>
<p>如下是为这个 max 函数添加类型注解：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> <span class="type">Callable</span>, Iterable</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Protocol, <span class="type">Any</span>, TypeVar, overload, <span class="type">Union</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SupportsLessThan</span>(<span class="title class_ inherited__">Protocol</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other: <span class="type">Any</span></span>) -&gt; <span class="built_in">bool</span>: ...</span><br><span class="line"></span><br><span class="line">T = TypeVar(<span class="string">&#x27;T&#x27;</span>)</span><br><span class="line">LT = TypeVar(<span class="string">&#x27;LT&#x27;</span>, bound=SupportsLessThan)</span><br><span class="line">DT = TypeVar(<span class="string">&#x27;DT&#x27;</span>)</span><br><span class="line"></span><br><span class="line">MISSING = <span class="built_in">object</span>()</span><br><span class="line">EMPTY_MSG = <span class="string">&#x27;max() arg is an empty sequence&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@overload</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">max</span>(<span class="params">__arg1: LT, __arg2: LT, *args: LT, key: <span class="literal">None</span> = ...</span>) -&gt; LT:</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">@overload</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">max</span>(<span class="params">__arg1: T, __arg2: T, *args: T, key: <span class="type">Callable</span>[[T], LT]</span>) -&gt; T:</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">@overload</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">max</span>(<span class="params">__iterable: Iterable[LT], *, key: <span class="literal">None</span> = ...</span>) -&gt; LT:</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">@overload</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">max</span>(<span class="params">__iterable: Iterable[T], *, key: <span class="type">Callable</span>[[T], LT]</span>) -&gt; T:</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">@overload</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">max</span>(<span class="params">__iterable: Iterable[LT], *, key: <span class="literal">None</span> = ...,</span></span><br><span class="line"><span class="params">        default: DT</span>) -&gt; <span class="type">Union</span>[LT, DT]:</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">@overload</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">max</span>(<span class="params">__iterable: Iterable[T], *, key: <span class="type">Callable</span>[[T], LT],</span></span><br><span class="line"><span class="params">        default: DT</span>) -&gt; <span class="type">Union</span>[T, DT]:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p><strong><code>@overload</code> 的关键优势是，可以根据参数的类型尽量准确声明返回值的类型</strong>。下面将以一个或两个为一组，深入研究 max 函数重载的签名。</p>
<ul>
<li>
<p>参数实现了SupportsLessThan，但是没有提供 key 和 default：此时输入的是一个个单独的参数，类型为实现了 SupportsLessThan 协议的 LT，或者是一个可迭代对象，项的类型也是 LT。max 函数的返回值类型与实参或项的类型相同。</p>
<ul>
<li><code>key: None = ...</code> 的含义是 key 参数的类型在此上下文中是 None，并且它有一个默认值（即实际运行时 key 可以不传）</li>
</ul>
</li>
<li>
<p>提供了 key，但未提供 default：输入可以是一个个单独的值，类型为 T，或者是可迭代对象，类型为 <code>Iterable[T]</code>​，而且 <code>key=</code> 必须是可调用对象，接受同为 T 类型的参数，返回实现了 <code>SupportsLessThan</code> 协议的值</p>
</li>
<li>
<p>提供了 default，但未提供 key：输入值是一个可迭代对象，项的类型为实现了 SupportsLessThan 协议的 LT。当可迭代对象为空时，<code>default=</code> 是返回值。因此，max 函数的返回值类型必须是 LT 类型和 default 参数类型的联合</p>
</li>
<li>
<p>提供了 key 和 default：</p>
<ul>
<li>输入是一个可迭代对象，项的类型为任意类型 T</li>
<li>一个可调用对象，该对象接受类型为 T 的参数，返回实现了 <code>SupportsLessThan</code> 协议的 LT 类型值</li>
<li>一个默认值，类型为任意类型 DT</li>
<li>max 函数的返回值类型必须是 T 类型和 default 参数类型的联合</li>
</ul>
</li>
</ul>
<p>这些类型注解隐含了，如果参数是一个个单独的值，是不能提供 default 参数的。</p>
<p>有了类型提示，对于 <code>max([None, None])</code> 之类的调用，Mypy 将输出以下错误消息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mymax_demo.py:<span class="number">109</span>: error: Value of <span class="built_in">type</span> variable <span class="string">&quot;_LT&quot;</span> of <span class="string">&quot;max&quot;</span></span><br><span class="line">  cannot be <span class="string">&quot;None&quot;</span></span><br></pre></td></tr></table></figure>
<p>为了给类型检查工具提供支持，要编写这么多行注解可能会让人打消念头，不愿编写 max 这样简便灵活的函数。如果还要重新实现 min 函数，我肯定会重用 max 函数的大多数实现，在此基础上适当改动。min 函数重载的签名基本没有变化，唯有函数名称变了，我要复制并粘贴所有重载的签名。</p>
<p>max 函数的签名虽然难以表达，但是也没有超出人类的理解能力，注解标记的表现能力十分有限，跟 Python 没法比。</p>
<h2 id="typeddict"><a class="markdownIt-Anchor" href="#typeddict"></a> TypedDict</h2>
<p>处理动态数据结构（例如JSON API的响应）时容易误用TypedDict来避免错误。<strong>通过本节的示例，你会发现，必须在运行时才能正确处理 JSON，不能依靠静态类型检查。在运行时使用类型提示检查 JSON 等结构时，可以借助 PyPI 中的 pydantic 包</strong>。</p>
<p>Python 字典有时被当作记录使用，以键表示字段名称，字段的值可以是不同的类型。例如如下描述一本书的记录：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;isbn&quot;</span>: <span class="string">&quot;0134757599&quot;</span>,</span><br><span class="line"> <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Refactoring, 2e&quot;</span>,</span><br><span class="line"> <span class="string">&quot;authors&quot;</span>: [<span class="string">&quot;Martin Fowler&quot;</span>, <span class="string">&quot;Kent Beck&quot;</span>],</span><br><span class="line"> <span class="string">&quot;pagecount&quot;</span>: <span class="number">478</span>&#125;</span><br></pre></td></tr></table></figure>
<p>在 Python 3.8 之前，没有什么好方法可以注解这样的记录，因为映射类型中的所有值必须是同种类型。对于上述JSON对象，下面两个注解都不完美。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 值可以是任何类型</span></span><br><span class="line"><span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 值只能是 int、str 或 List[str]</span></span><br><span class="line"><span class="comment"># 难以理解，而且没有体现字段名称与对应的字段类型之间的关系</span></span><br><span class="line"><span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">str</span>, <span class="type">List</span>[<span class="built_in">str</span>]]]</span><br></pre></td></tr></table></figure>
<p><code>PEP 589：TypedDict: Type Hints for Dictionaries with a Fixed Set of Keys</code> 解决了这个问题。如下是一个简单的 TypedDict 示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypedDict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookDict</span>(<span class="title class_ inherited__">TypedDict</span>):</span><br><span class="line">    isbn: <span class="built_in">str</span></span><br><span class="line">    title: <span class="built_in">str</span></span><br><span class="line">    authors: <span class="built_in">list</span>[<span class="built_in">str</span>]</span><br><span class="line">    pagecount: <span class="built_in">int</span></span><br></pre></td></tr></table></figure>
<p>乍一看，<code>typing.TypedDict</code> 好像是一个数据类构建器，这是句法类似引起的误会。<strong>TypedDict 与数据类构建器千差万别。TypedDict 仅为类型检查工具而生，在运行时没有作用</strong>。TypedDict 有以下两个作用：</p>
<ul>
<li>使用与类相似的句法注解字典，为各个 <code>字段</code>的值提供类型提示</li>
<li><strong>通过一个构造函数告诉类型检查工具，字典应具有指定的键和指定类型的值</strong></li>
</ul>
<p>在运行时，TypedDict 构造函数（例如BookDict）相当于一种安慰剂，其实作用与使用同样的参数调用 dict 构造函数相同。BookDict 创建的是普通字典，这也就意味着：</p>
<ul>
<li>伪类声明中的 <code>字段</code> 不创建实例属性</li>
<li>不能通过初始化方法为 <code>字段</code> 指定默认值</li>
<li>不允许定义方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">BookDict</span>(<span class="title class_ inherited__">TypedDict</span>):</span><br><span class="line"><span class="meta">... </span>    isbn: <span class="built_in">str</span></span><br><span class="line"><span class="meta">... </span>    title: <span class="built_in">str</span></span><br><span class="line"><span class="meta">... </span>    authors: <span class="built_in">list</span>[<span class="built_in">str</span>]</span><br><span class="line"><span class="meta">... </span>    pagecount: <span class="built_in">int</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pp = BookDict(title=<span class="string">&quot;HeadFirst Python&quot;</span>, isbn=<span class="string">&quot;110&quot;</span>, authors=[<span class="string">&quot;jack&quot;</span>], pagecount=<span class="number">500</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pp</span><br><span class="line">&#123;<span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;HeadFirst Python&#x27;</span>, <span class="string">&#x27;isbn&#x27;</span>: <span class="string">&#x27;110&#x27;</span>, <span class="string">&#x27;authors&#x27;</span>: [<span class="string">&#x27;jack&#x27;</span>], <span class="string">&#x27;pagecount&#x27;</span>: <span class="number">500</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(pp)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pp.title</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">&#x27;dict&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;title&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pp[<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;HeadFirst Python&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>BookDict.__annotations__</span><br><span class="line">&#123;<span class="string">&#x27;isbn&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;, <span class="string">&#x27;title&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;, <span class="string">&#x27;authors&#x27;</span>: <span class="built_in">list</span>[<span class="built_in">str</span>], <span class="string">&#x27;pagecount&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pp[<span class="string">&#x27;authors&#x27;</span>]=<span class="string">&quot;mark&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>由于是普通的字典，因此不能使用 <code>object.field</code> 表示法读取数据。</li>
<li>由于不会进行运行时类型检查，因此 <code>pp['authors']=&quot;mark&quot;</code> 这样的赋值没有报错</li>
</ul>
<p>没有类型检查工具，TypedDict 充其量算是注释，可以为阅读代码的人提供些许帮助，仅此而已。而数据类构建器即使不使用类型检查工具，也是十分有用的，因为类构建器可在运行时生成或增强自定义的类，而且可以实例化。另外，类构建器还提供了多个有用的方法或函数。</p>
<p>但是 TypedDict 能协助 Mypy 捕获错误。它能发现无限的类型赋值、不能为定义中没有的键赋值、不能删除 TypedDict 定义的键等。</p>
<p>在如下代码中，定义了一个解析 JSON 字符串并返回 BookDict 的函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">from_json</span>(<span class="params">data: <span class="built_in">str</span></span>) -&gt; BookDict:</span><br><span class="line">    whatever = json.loads(data)</span><br><span class="line">    <span class="keyword">return</span> whatever</span><br></pre></td></tr></table></figure>
<ul>
<li>json.loads()的返回值类型为 Any，可以返回 whatever（Any类型）​，因为Any与任何类型都相容，包括声明的返回值类型 BookDict</li>
<li>运行 Mypy 时，如果指定了 <code>--disallow-any-expr</code>，则 from_json 函数主体中的两行都会报错。因为使用了 Any 类型</li>
</ul>
<p>为了解决这种错误，可以在 whatever 变量的初始化语句中添加一个类型提示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.../typeddict/ $ mypy books_any.py --disallow-<span class="built_in">any</span>-expr</span><br><span class="line">books_any.py:<span class="number">30</span>: error: Expression has <span class="built_in">type</span> <span class="string">&quot;Any&quot;</span></span><br><span class="line">books_any.py:<span class="number">31</span>: error: Expression has <span class="built_in">type</span> <span class="string">&quot;Any&quot;</span></span><br><span class="line">Found <span class="number">2</span> errors <span class="keyword">in</span> <span class="number">1</span> file (checked <span class="number">1</span> source file)</span><br></pre></td></tr></table></figure>
<ul>
<li>把类型为 Any 的表达式赋值给带有类型提示的变量，即使加上 <code>--disallow-any-expr</code>，也不报错</li>
<li>现在，whatever 的类型是 BookDict，即声明的返回值类型</li>
</ul>
<p>一定还是要注意，类型检查工具无法预测 <code>json.loads()</code> 一定会返回类似 BookDict 结构的数据，只有运行时验证能确保这一点。<strong>静态类型检查无法避免本身就具有不确定性的代码出现错误</strong>。<code>json.loads()</code> 就是这样的代码，它在运行时可能会构建不同类型的 Python 对象。</p>
<p>处理具有动态结构的数据（例如 JSON 或 XML）时，TypedDict 根本不能取代运行时数据验证。真想做数据验证，可以使用 pydantic。</p>
<p>这也告诉我们，从动态的映射中获取静态的结构化记录时，运行时检查和错误处理是不可避免的。</p>
<h2 id="类型校正"><a class="markdownIt-Anchor" href="#类型校正"></a> 类型校正</h2>
<p>任何类型系统都不完美，静态类型检查工具、typeshed 项目中的类型提示，以及第三方包中的类型提示也是如此。<code>typing.cast()</code> 是一个特殊函数，可用于处理不受控制的代码中存在的类型检查问题或不正确的类型提示。</p>
<p>类型校正用于消除类型检查工具发出的虚假警告，在类型检查工具无法完全理解事态时提供些许帮助。在运行时，<code>typing.cast</code> 什么也不做。PEP 484 要求类型检查工具务必 <code>听信</code> cast 中所述的类型。如下是一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> cast</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_first_str</span>(<span class="params">a: <span class="built_in">list</span>[<span class="built_in">object</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    index = <span class="built_in">next</span>(i <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(a) <span class="keyword">if</span> <span class="built_in">isinstance</span>(x, <span class="built_in">str</span>))</span><br><span class="line">    <span class="comment"># 至少有一个字符串才能执行到这里</span></span><br><span class="line">    <span class="keyword">return</span> cast(<span class="built_in">str</span>, a[index])</span><br></pre></td></tr></table></figure>
<ul>
<li>在生成器表达式上调用 <code>next()</code> 函数时，要么返回一个字符串项，要么抛出 StopIteration</li>
<li>没有异常抛出时，<code>find_first_str</code> 始终返回一个字符串，而且 str 是声明的返回值类型</li>
<li>然而，如果最后一行只有 <code>return a[index]</code>​，那么 Mypy 推导出的返回值类型将是 object，因为 a 参数声明的类型是 <code>list[object]</code>​。所以，必须通过 <code>cast()</code> 指引 Mypy</li>
</ul>
<p>不要过于依赖使用 cast 静默 Mypy 报错，Mypy 报错肯定是有原因的。经常使用 cast 也是一种 <code>代码异味</code>​，可能意味着你的团队使用的类型提示有误，或者你的基准代码使用了低质量的依赖。尽管有缺点，但是 cast 也有合理的用途：<strong>偶尔调用 <code>cast()</code>，偶尔编写 <code># type: ignore</code> 注释，何错之有？</strong></p>
<p>彻底禁止使用 cast 显然是不明智的，主要原因是其他变通方法更糟。</p>
<ul>
<li><code># type: ignore提供的信息量更少</code></li>
<li>使用 Any 有连锁反应。Any 与所有类型相容，一旦滥用，类型推导可能导致级联效应，破坏类型检查工具对代码中其他部分的检错能力</li>
</ul>
<p>当然，不是所有类型问题都能使用 cast 纠正。有时需要使用 <code># type: ignore</code>，偶尔还要使用 Any，甚至可以不为函数添加类型提示。</p>
<h2 id="在运行时提取类型提示"><a class="markdownIt-Anchor" href="#在运行时提取类型提示"></a> 在运行时提取类型提示</h2>
<p>Python 会在导入时读取函数、类和模块中的类型提示，把类型提示存储在 <code>__annotations__</code> 属性中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">clip</span>(<span class="params">text: <span class="built_in">str</span>, max_len: <span class="built_in">int</span> = <span class="number">80</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>clip.__annotations__</span><br><span class="line">&#123;<span class="string">&#x27;text&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;, <span class="string">&#x27;max_len&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;, <span class="string">&#x27;return&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>注意，与参数的默认值一样，注解在导入时由解释器求解。因此，注解中用的值是 Python 类 str 和 int，而不是字符串 ‘str’ 和 ‘int’。</p>
<h3 id="注解在运行时的问题"><a class="markdownIt-Anchor" href="#注解在运行时的问题"></a> 注解在运行时的问题</h3>
<p>类型提示使用量的增加会引起两个问题：</p>
<ul>
<li>如果类型提示很多，那么导入模块使用的 CPU 和内存会更多</li>
<li>引用尚未定义的类型需要使用字符串，而不是真正的类型</li>
</ul>
<p>鉴于 <code>向前引用</code> 问题（类型提示需要引用同一模块后部定义的类）​，有时必须以字符串形式存储注解。然而，源码中经常见到的一种现象看起来根本不像向前引用：方法返回同一类的新对象。由于类对象直到 Python 完全求解类主体之后才被定义，因此类型提示必须使用类名的字符串形式。但是随着 PEP563 变成标准行为，则情况有所变化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>:</span><br><span class="line">    <span class="comment"># ...省略几行...</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stretch</span>(<span class="params">self, factor: <span class="built_in">float</span></span>) -&gt; <span class="string">&#x27;Rectangle&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> Rectangle(width=self.width * factor)</span><br></pre></td></tr></table></figure>
<p>截至 Python 3.10，涉及向前引用的类型提示必须使用字符串，这是标准做法。静态类型检查工具从一开始就考虑到了这个问题。</p>
<p>但是，在运行时，当获取 stretch 方法的 return 注解时，得到的是字符串 <code>Rectangle</code>，而不是真正的类型（Rectangle类）​。因此，要设法确定得到的字符串是什么意思。typing 模块中有 3 个函数和一个类被归类为内省辅助工具，其中最重要的是 <code>typing.get_type_hints</code> 函数。该函数的文档做了如下说明：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_type_hints(obj, <span class="built_in">globals</span>=<span class="literal">None</span>, <span class="built_in">locals</span>=<span class="literal">None</span>, include_extras=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>得到的结果通常与 <code>obj.__annotations__</code> 相同。不过，以字符串字面量表示的向前引用会放在 <code>globals 命名空间</code> 和 <code>locals 命名空间</code> 中求解</p>
</li>
<li>
<p>从 Python3.10 开始，应使用新增的 <code>inspect.get_annotations(...)</code> 函数代替 <code>typing.get_type_hints</code></p>
</li>
</ul>
<p>而现在，<code>PEP 563—Postponed Evaluation of Annotations</code> 已经通过，无须再使用字符串编写注解了，而且类型提示的运行时开销也减少了。这个 PEP 的主要目的在 <code>摘要</code> 中表达得很清楚，即下面这句话：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本 PEP 提议更改函数注解和变量注解，不在定义函数时求解，在注解中保留字符串形式。</span><br></pre></td></tr></table></figure>
<p>从 Python3.7 开始，开头有以下 import 语句的模块都按上述方式处理注解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br></pre></td></tr></table></figure>
<p>如下展示了使用 <code>from __future__ import annotations</code> 的之后的变化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">clip</span>(<span class="params">text: <span class="built_in">str</span>, max_len: <span class="built_in">int</span> = <span class="number">80</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>clip.__annotations__</span><br><span class="line">&#123;<span class="string">&#x27;text&#x27;</span>: <span class="string">&#x27;str&#x27;</span>, <span class="string">&#x27;max_len&#x27;</span>: <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;return&#x27;</span>: <span class="string">&#x27;str&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，现在所有类型提示都是普通的字符串，尽管事实上在定义 clip 函数时并没有使用括在引号内的字符串。而调用 <code>get_type_hints</code> 得到的是真正的类型，即便有时候原始类型提示是括在引号内的字符串。这是在运行时读取类型提示的推荐方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> typing <span class="keyword">import</span> get_type_hints</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_type_hints(clip)</span><br><span class="line">&#123;<span class="string">&#x27;text&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;, <span class="string">&#x27;max_len&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;, <span class="string">&#x27;return&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>PEP 563 的行为计划在 Python 3.10 中变成默认行为，无须导入 <code>__future__</code>。但是由于这个变化可能会导致在运行时依赖类型提示的代码失效，因此这个 PEP563 定位默认行为的计划有所推迟。</p>
<p>鉴于目前不稳定的局势，如果需要在运行时读取注解，可以参考以下两点建议。</p>
<ul>
<li>不要直接读取 <code>__annotations__</code> 属性，使用 <code>inspect.get_annotations</code> 或 <code>typing.get_type_hints</code></li>
<li>自己编写一个函数，简单包装 <code>inspect.get_annotations</code> 或 <code>typing.get_type_hints</code>。在基准代码中调用自己编写的那个函数，这样当以后行为有变时，只需修改一个函数即可</li>
</ul>
<h2 id="实现一个泛化类"><a class="markdownIt-Anchor" href="#实现一个泛化类"></a> 实现一个泛化类</h2>
<p>如下实现了一个泛化的彩票摇奖机类（基于之前代码实现的 <code>LottoBlower</code> 类）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> generic_lotto <span class="keyword">import</span> LottoBlower</span><br><span class="line"></span><br><span class="line">machine = LottoBlower[<span class="built_in">int</span>](<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>))</span><br><span class="line"></span><br><span class="line">first = machine.pick()</span><br><span class="line">remain = machine.inspect()</span><br></pre></td></tr></table></figure>
<ul>
<li>实例化泛化类需要提供具体的类型参数，例如这里的 int</li>
<li>Mypy 能正确推导出 first 是一个 int 值，以及 remain 是一个 int 元组</li>
</ul>
<p>另外，如果与参数化类型相悖，则 Mypy 还会报告详细的消息。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> generic_lotto <span class="keyword">import</span> LottoBlower</span><br><span class="line"></span><br><span class="line">machine = LottoBlower[<span class="built_in">int</span>]([<span class="number">1</span>, <span class="number">.2</span>])</span><br><span class="line"><span class="comment">## error: List item 1 has incompatible type &quot;float&quot;;</span></span><br><span class="line"><span class="comment">##        expected &quot;int&quot;</span></span><br></pre></td></tr></table></figure>
<p>这个泛化类的实现如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar, <span class="type">Generic</span></span><br><span class="line"><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</span><br><span class="line"></span><br><span class="line">T = TypeVar(<span class="string">&#x27;T&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LottoBlower</span>(Tombola, <span class="type">Generic</span>[T]):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, items: Iterable[T]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._balls = <span class="built_in">list</span>[T](items)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">self, items: Iterable[T]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._balls.extend(items)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pick</span>(<span class="params">self</span>) -&gt; T:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            position = random.randrange(<span class="built_in">len</span>(self._balls))</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">raise</span> LookupError(<span class="string">&#x27;pick from empty LottoBlower&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self._balls.pop(position)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">loaded</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bool</span>(self._balls)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inspect</span>(<span class="params">self</span>) -&gt; <span class="built_in">tuple</span>[T, ...]:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">tuple</span>(self._balls)</span><br></pre></td></tr></table></figure>
<ul>
<li>泛化类声明通常使用多重继承，因为需要子类化 <code>Generic</code>，以声明 <code>形式类型参数</code>（这里的 T）​</li>
<li><code>__init__</code> 方法的 items 参数是 <code>Iterable[T]</code> 类型。如果使用 <code>LottoBlower[int]</code> 实例化，则类型是 <code>Iterable[int]​</code></li>
<li><code>tuple[T, ...]</code> 表示一个元组，其中的元素类型是 T。这里的 <code>...</code> 表示任意长度</li>
</ul>
<p>现在，我们知道如何实现泛化类了。下面定义与泛化有关的术语。</p>
<ul>
<li>泛型：<strong>泛型具有一个或多个类型变量的类型</strong>，例如 <code>LottoBlower[T]</code> 和 <code>abc.Mapping[KT, VT]​</code></li>
<li>形式类型参数：泛型声明中出现的类型变量，例如 <code>abc.Mapping[KT, VT]</code> 中的 <code>KT</code> 和 <code>VT</code></li>
<li>参数化类型：使用具体类型参数声明的类型，例如 <code>LottoBlower[int]</code> 和 <code>abc.Mapping[str, float]​</code></li>
<li>具体类型参数：声明参数化类型时为参数提供的具体类型。例如 <code>LottoBlower[int]</code> 中的 <code>int</code></li>
</ul>
<h2 id="型变"><a class="markdownIt-Anchor" href="#型变"></a> 型变</h2>
<p>型变概念抽象难懂，而且需要严谨的表述。其实，真正需要关注型变的基本上是代码库作者，因为只有他们才需要支持新的泛化容器类型，或者提供基于回调的 API。不过，为了降低复杂度，可以仅支持不变容器——Python 标准库基本上就是这么做的。</p>
<p>假设一所学校的食堂规定，只允许安装果汁自动售货机。不允许安装一般的饮料自动售货机，以防止售卖学校董事会禁止的苏打水。</p>
<h3 id="一个不变的自动售货机"><a class="markdownIt-Anchor" href="#一个不变的自动售货机"></a> 一个不变的自动售货机</h3>
<p>下面试着为食堂的规定建模：定义一个泛化的 BeverageDispenser 类，参数化饮料的类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar, <span class="type">Generic</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Beverage</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;任何饮料&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Juice</span>(<span class="title class_ inherited__">Beverage</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;任何果汁&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrangeJuice</span>(<span class="title class_ inherited__">Juice</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用巴西橙子制作的美味果汁&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">T = TypeVar(<span class="string">&#x27;T&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BeverageDispenser</span>(<span class="type">Generic</span>[T]):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;一个参数化饮料类型的自动售货机&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, beverage: T</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.beverage = beverage</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dispense</span>(<span class="params">self</span>) -&gt; T:</span><br><span class="line">        <span class="keyword">return</span> self.beverage</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">install</span>(<span class="params">dispenser: BeverageDispenser[Juice]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;安装一个果汁自动售货机&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>BeverageDispenser 参数化了饮料的类型</li>
<li>install 是模块全局函数。该函数的类型提示会执行只能安装果汁自动售货机的规定</li>
</ul>
<p>按照定义，如下代码是有效的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">juice_dispenser = BeverageDispenser(Juice())</span><br><span class="line">install(juice_dispenser)</span><br></pre></td></tr></table></figure>
<p>但是如下代码则是无效的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beverage_dispenser = BeverageDispenser(Beverage())</span><br><span class="line">install(beverage_dispenser)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beverage.py:<span class="number">30</span>: error: Argument <span class="number">1</span> to <span class="string">&quot;install&quot;</span> has incompatible <span class="built_in">type</span> <span class="string">&quot;BeverageDispenser[Beverage]&quot;</span>; expected <span class="string">&quot;BeverageDispenser[Juice]&quot;</span>  [arg-<span class="built_in">type</span>]</span><br><span class="line">Found <span class="number">1</span> error <span class="keyword">in</span> <span class="number">1</span> file (checked <span class="number">1</span> source file)</span><br></pre></td></tr></table></figure>
<p>不接受可售卖任何饮料(Beverage)的自动售货机，因为食堂要求自动售货机只能售卖果汁(Juice)。但是令人费解的是，如下代码也是无效的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">orange_juice_dispenser = BeverageDispenser(OrangeJuice())</span><br><span class="line">install(orange_juice_dispenser)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beverage.py:<span class="number">30</span>: error: Argument <span class="number">1</span> to <span class="string">&quot;install&quot;</span> has incompatible <span class="built_in">type</span> <span class="string">&quot;BeverageDispenser[OrangeJuice]&quot;</span>; expected <span class="string">&quot;BeverageDispenser[Juice]&quot;</span>  [arg-<span class="built_in">type</span>]</span><br><span class="line">Found <span class="number">1</span> error <span class="keyword">in</span> <span class="number">1</span> file (checked <span class="number">1</span> source file)</span><br></pre></td></tr></table></figure>
<p>使用 <code>OrangeJuice</code> 特化的自动售货机也不允许安装，只允许安装 <code>BeverageDispenser[Juice]</code>， <code>BeverageDispenser[OrangeJuice]</code> 与 <code>BeverageDispenser[Juice]</code> 不兼容（尽管 OrangeJuice是 Juice 的子类型）​，<strong>按照类型相关的术语，我们说 <code>BeverageDispenser(Generic[T])</code> 是不变的</strong>。诸如 <code>list</code> 和 <code>set </code>之类 Python 可变的容器类型都是不变的。</p>
<h3 id="一个协变的自动售货机"><a class="markdownIt-Anchor" href="#一个协变的自动售货机"></a> 一个协变的自动售货机</h3>
<p>如果想灵活一些，把自动售货机建模为可接受某些饮料类型及其子类型的泛化类，<strong>则必须让它支持协变</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">T_co = TypeVar(<span class="string">&#x27;T_co&#x27;</span>, covariant=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BeverageDispenser</span>(<span class="type">Generic</span>[T_co]):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, beverage: T_co</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.beverage = beverage</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dispense</span>(<span class="params">self</span>) -&gt; T_co:</span><br><span class="line">        <span class="keyword">return</span> self.beverage</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">install</span>(<span class="params">dispenser: BeverageDispenser[Juice]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;安装一个果汁自动售货机&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>声明类型变量时，设置 <code>covariant=True</code>。<code>_co</code> 后缀是 typeshed 项目采用的一种约定，表明这是协变的类型参数</li>
<li>使用 T_co 参数化特殊的 Generic 类</li>
</ul>
<p>以下代码能正常运行，<strong>因为现在对可协变的 BeverageDispenser 来说，Juice 和 OrangeJuice 都是有效的自动售货机</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">juice_dispenser = BeverageDispenser(Juice())</span><br><span class="line">install(juice_dispenser)</span><br><span class="line"></span><br><span class="line">orange_juice_dispenser = BeverageDispenser(OrangeJuice())</span><br><span class="line">install(orange_juice_dispenser)</span><br></pre></td></tr></table></figure>
<p>但是，不接受售卖任何饮料的 Beverage 自动售货机：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beverage_dispenser = BeverageDispenser(Beverage())</span><br><span class="line">install(beverage_dispenser)</span><br><span class="line"></span><br><span class="line"><span class="comment"># beverage.py:32: error: Argument 1 to &quot;BeverageDispenser&quot; has incompatible type &quot;Beverage&quot;; expected &quot;OrangeJuice&quot;  [arg-type]</span></span><br><span class="line"><span class="comment"># Found 1 error in 1 file (checked 1 source file)</span></span><br></pre></td></tr></table></figure>
<p><strong>这就是协变，参数化自动售货机子类型关系的变化方向与类型参数子类型关系的变化方向相同</strong>。</p>
<h3 id="一个逆变的垃圾桶"><a class="markdownIt-Anchor" href="#一个逆变的垃圾桶"></a> 一个逆变的垃圾桶</h3>
<p>在看一个垃圾桶的建模例子：</p>
<ul>
<li>Refuse 是最一般的垃圾类型。所有垃圾都是废弃物</li>
<li>Biodegradable 是特殊的垃圾类型，可被生物体降解</li>
<li>Compostable 是特殊的可生物降解垃圾（Biodegradable），可在堆肥箱或堆肥设施中转化为有机肥料</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar, <span class="type">Generic</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Refuse</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;任何废弃物&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Biodegradable</span>(<span class="title class_ inherited__">Refuse</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;可生物降解的废弃物&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Compostable</span>(<span class="title class_ inherited__">Biodegradable</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;可制成肥料的废弃物&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">T_contra = TypeVar(<span class="string">&#x27;T_contra&#x27;</span>, contravariant=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrashCan</span>(<span class="type">Generic</span>[T_contra]):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, refuse: T_contra</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;在倾倒之前存放垃圾&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deploy</span>(<span class="params">trash_can: TrashCan[Biodegradable]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;放置一个垃圾桶，存放可生物降解的废弃物&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>T_contra 表示逆变类型变量</li>
<li>TrashCan 对废弃物的类型实行逆变</li>
</ul>
<p>按照上述定义，以下类型的垃圾桶是可接受的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bio_can: TrashCan[Biodegradable] = TrashCan()</span><br><span class="line">deploy(bio_can)</span><br><span class="line"></span><br><span class="line">trash_can: TrashCan[Refuse] = TrashCan()</span><br><span class="line">deploy(trash_can)</span><br></pre></td></tr></table></figure>
<p>更一般的 <code>TrashCan[Refuse]</code> 是可接受的，<strong>因为它可以存放任何废弃物，包括可生物降解的废弃物(Biodegradable)</strong>，然而，<code>TrashCan[Compostable]</code> 不可接受，因为它不能存放可生物降解的废弃物（Biodegradable）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">compost_can: TrashCan[Compostable] = TrashCan()</span><br><span class="line">deploy(compost_can)</span><br><span class="line"><span class="comment">## mypy: Argument 1 to &quot;deploy&quot; has</span></span><br><span class="line"><span class="comment">## incompatible type &quot;TrashCan[Compostable]&quot;</span></span><br><span class="line"><span class="comment">##          expected &quot;TrashCan[Biodegradable]&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="型变总结"><a class="markdownIt-Anchor" href="#型变总结"></a> 型变总结</h2>
<p>型变是一种难以描述的性质。下面我们会总结不变类型、协变类型和逆变类型等概念，并提供一些经验法则，用于推断型变种类。</p>
<h3 id="不变类型"><a class="markdownIt-Anchor" href="#不变类型"></a> 不变类型</h3>
<p>不管实参之间是否存在关系，当两个参数化类型之间不存在超类型或子类型关系时，泛型 L 是不变的。也就是说，如果 L 是不变的，那么 <code>L[A]</code> 就不是 <code>L[B]</code> 的超类型或子类型。两个方向都是不相容的。</p>
<p>Python 中的可变容器默认是不可变的。list 类型就是一例：<code>list[int]</code> 与 <code>list[float]</code> 不相容，反之亦然。</p>
<p>一般来说，如果一个形式类型参数既出现在方法参数的类型提示中，又出现在方法的返回值类型中，那么该参数必须是不可变的，因为要确保更新容器和从容器中读取时的类型安全性。</p>
<h3 id="协变类型"><a class="markdownIt-Anchor" href="#协变类型"></a> 协变类型</h3>
<p>即对于 <code>A :&gt; B</code>（A 是 B 的超类型），当满足 <code>C[A] :&gt; C[B]</code> 时，泛型 C 是可协变的。在前后两种情况中，<code>:&gt;</code> 符号的方向是相同的，A 在 B 的左边。协变的泛型遵循具体类型参数的子类型关系。</p>
<p>不可变容器可以是协变的。例如，文档中使用约定的命名方式 <code>T_co</code> 指明 <code>typing.FrozenSet</code> 有一个可协变的类型变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FrozenSet</span>(<span class="built_in">frozenset</span>, AbstractSet[T_co]):</span><br></pre></td></tr></table></figure>
<p>使用 <code>:&gt;</code> 表示参数化类型，如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">           <span class="built_in">float</span> :&gt; <span class="built_in">int</span></span><br><span class="line"><span class="built_in">frozenset</span>[<span class="built_in">float</span>] :&gt; <span class="built_in">frozenset</span>[<span class="built_in">int</span>]</span><br></pre></td></tr></table></figure>
<p>迭代器也可以是协变的。迭代器不是 frozenset 这种只读的容器，而是只产生输出。只要预期产出浮点数的 <code>abc.Iterator[float]</code>​，就可以放心使用产出整数的 <code>abc.Iterator[int]​</code>。基于同样的原因，Callable 类型的返回值类型也可以是协变的。</p>
<h3 id="逆变类型"><a class="markdownIt-Anchor" href="#逆变类型"></a> 逆变类型</h3>
<p>对于 <code>A :&gt; B</code>（A 是 B 的超类型），当满足 <code>K[A] &lt;: K[B]</code> 时，泛型 K 是可逆变的。可逆变的泛型可以逆转具体类型参数的子类型关系。TrashCan 类就是一例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">          Refuse :&gt; Biodegradable</span><br><span class="line">TrashCan[Refuse] &lt;: TrashCan[Biodegradable]</span><br></pre></td></tr></table></figure>
<p>可逆变的容器通常是只写的数据结构（也叫“接收器”​，sink）​。标准库中没有这样的容器，不过一些类型有可逆变的类型参数。</p>
<p><code>Callable[​[ParamType, ...], ReturnType]</code> 中的参数类型是可逆变的，不过 ReturnType 是可协变的。另外，Generator、Coroutine 和 AsyncGenerator 都有一个可逆变的类型参数。</p>
<p>以上关于型变的讨论，主要是想告诉你，<strong>可逆变的形式参数可以定义用于调用或向对象发送数据的参数的类型，而可协变的形式参数可以定义对象产生的输出的类型</strong>——根据对象的不同，可以是产出值的类型或返回值的类型。</p>
<p>根据 <code>输出可协变，输入可逆变</code> 的结论，可以得出一些有用的指导方针：</p>
<ul>
<li>如果一个形式类型参数定义的是从对象中获取的数据类型，那么该形式类型参数可能是协变的</li>
<li>如果一个形式类型参数定义的是对象初始化之后向对象中输入的数据类型，那么该形式类型参数可能是逆变的</li>
<li>如果一个形式类型参数定义的是从对象中获取的数据类型，同时也是向对象中输入的数据类型，那么该形式类型参数必定是不变的</li>
<li>为保险起见，形式类型参数最好是不变的</li>
</ul>
<p><code>Callable[​[ParamType, ...], ReturnType]</code> 体现了第 1 条和第 2 条：ReturnType 是协变的，各个 ParamType 是逆变的。默认情况下，TypeVar 创建的形式参数是不变的，标准库中的可变容器都是这样注解的。</p>
<p>虽然协变和逆变是通过 TypeVar 声明（而不是在泛化类上进行声明），<strong>但是协变或逆变不是类型变量的性质，而是使用类型变量定义的泛化类的性质</strong>。</p>
<h2 id="实现泛化静态协议"><a class="markdownIt-Anchor" href="#实现泛化静态协议"></a> 实现泛化静态协议</h2>
<p>Python3.10 标准库提供了几个泛化静态协议。typing 模块中的 <code>SupportsAbs</code> 就是一个，实现方式如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">T_co = TypeVar(<span class="string">&#x27;T_co&#x27;</span>, covariant=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@runtime_checkable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SupportsAbs</span>(Protocol[T_co]):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;An ABC with one abstract method __abs__ that is covariant in its</span></span><br><span class="line"><span class="string">        return type.&quot;&quot;&quot;</span></span><br><span class="line">    __slots__ = ()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__abs__</span>(<span class="params">self</span>) -&gt; T_co:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> NamedTuple, SupportsAbs</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector2d</span>(<span class="title class_ inherited__">NamedTuple</span>):</span><br><span class="line">    x: <span class="built_in">float</span></span><br><span class="line">    y: <span class="built_in">float</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__abs__</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="keyword">return</span> math.hypot(self.x, self.y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_unit</span>(<span class="params">v: SupportsAbs[<span class="built_in">float</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;&#x27;v&#x27;的模接近1时为&#x27;True&#x27;&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> math.isclose(<span class="built_in">abs</span>(v), <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">issubclass</span>(Vector2d, SupportsAbs)</span><br><span class="line"></span><br><span class="line">v0 = Vector2d(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">sqrt2 = math.sqrt(<span class="number">2</span>)</span><br><span class="line">v1 = Vector2d(sqrt2 / <span class="number">2</span>, sqrt2 / <span class="number">2</span>)</span><br><span class="line">v2 = Vector2d(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">v3 = <span class="built_in">complex</span>(<span class="number">.5</span>, math.sqrt(<span class="number">3</span>) / <span class="number">2</span>)</span><br><span class="line">v4 = <span class="number">1</span></span><br><span class="line"><span class="keyword">assert</span> is_unit(v0)</span><br><span class="line"><span class="keyword">assert</span> is_unit(v1)</span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">not</span> is_unit(v2)</span><br><span class="line"><span class="keyword">assert</span> is_unit(v3)</span><br><span class="line"><span class="keyword">assert</span> is_unit(v4)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;OK&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>由于 <code>SupportsAbs</code> 的定义中有 <code>@runtime_checkable</code>，因此 <code>issubclass(Vector2d, SupportsAbs)</code> 是一个有效的运行时检查</li>
<li>int 类型也与 SupportsAbs 相容。根据 typeshed 项目，<code>int.__abs__</code> 返回一个 int 值，而 int 与 is_unit 函数中 v 参数声明的 float 类型参数相容</li>
</ul>
<p>如下代码则实现了泛化的 RandomPicker 协议，pick 方法的返回值类型可协变：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Protocol, runtime_checkable, TypeVar</span><br><span class="line"></span><br><span class="line">T_co = TypeVar(<span class="string">&#x27;T_co&#x27;</span>, covariant=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@runtime_checkable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomPicker</span>(Protocol[T_co]):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pick</span>(<span class="params">self</span>) -&gt; T_co: ...</span><br></pre></td></tr></table></figure>
<ul>
<li>声明可协变的 T_co，使用可协变的形式类型参数泛化 <code>RandomPicker</code></li>
<li>使用 T_co 作为返回值类型</li>
<li>泛化的 RandomPicker 协议可以协变，因为在返回值类型中使用了唯一的形式参数</li>
</ul>
<h2 id="类型无底洞"><a class="markdownIt-Anchor" href="#类型无底洞"></a> 类型无底洞</h2>
<p>使用类型检查工具，有时迫不得已要导入不需要知道的类，而除了编写类型提示外，这些类在代码中根本用不到。这些类没有文档记录，可能是因为包的作者认为它们是实现细节。仅仅为了编写一个类型提示，就要花几个小时寻找该导入的类，而且文档中没有线索。为此，直接写上 <code># type: ignore</code> 就可以搞定（有时，这是唯一合算的方案）。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/Python/" rel="tag"># Python</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/11/04/fluent-python-v2-16/" rel="prev" title="流畅的 Python 第 2 版（16）：运算符重载">
      <i class="fa fa-chevron-left"></i> 流畅的 Python 第 2 版（16）：运算符重载
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/11/03/fluent-python-v2-14/" rel="next" title="流畅的 Python 第 2 版（14）：继承：瑕瑜互见">
      流畅的 Python 第 2 版（14）：继承：瑕瑜互见 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E7%9A%84%E7%AD%BE%E5%90%8D"><span class="nav-number">1.</span> <span class="nav-text"> 重载的签名</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD-max-%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.</span> <span class="nav-text"> 重载 max 函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#typeddict"><span class="nav-number">2.</span> <span class="nav-text"> TypedDict</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%A0%A1%E6%AD%A3"><span class="nav-number">3.</span> <span class="nav-text"> 类型校正</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8F%90%E5%8F%96%E7%B1%BB%E5%9E%8B%E6%8F%90%E7%A4%BA"><span class="nav-number">4.</span> <span class="nav-text"> 在运行时提取类型提示</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">4.1.</span> <span class="nav-text"> 注解在运行时的问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%B3%9B%E5%8C%96%E7%B1%BB"><span class="nav-number">5.</span> <span class="nav-text"> 实现一个泛化类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%8B%E5%8F%98"><span class="nav-number">6.</span> <span class="nav-text"> 型变</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%8F%98%E7%9A%84%E8%87%AA%E5%8A%A8%E5%94%AE%E8%B4%A7%E6%9C%BA"><span class="nav-number">6.1.</span> <span class="nav-text"> 一个不变的自动售货机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%8D%8F%E5%8F%98%E7%9A%84%E8%87%AA%E5%8A%A8%E5%94%AE%E8%B4%A7%E6%9C%BA"><span class="nav-number">6.2.</span> <span class="nav-text"> 一个协变的自动售货机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E9%80%86%E5%8F%98%E7%9A%84%E5%9E%83%E5%9C%BE%E6%A1%B6"><span class="nav-number">6.3.</span> <span class="nav-text"> 一个逆变的垃圾桶</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%8B%E5%8F%98%E6%80%BB%E7%BB%93"><span class="nav-number">7.</span> <span class="nav-text"> 型变总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%8F%98%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.1.</span> <span class="nav-text"> 不变类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E5%8F%98%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.2.</span> <span class="nav-text"> 协变类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%86%E5%8F%98%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.3.</span> <span class="nav-text"> 逆变类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%B3%9B%E5%8C%96%E9%9D%99%E6%80%81%E5%8D%8F%E8%AE%AE"><span class="nav-number">8.</span> <span class="nav-text"> 实现泛化静态协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%97%A0%E5%BA%95%E6%B4%9E"><span class="nav-number">9.</span> <span class="nav-text"> 类型无底洞</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">227</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">


  

</body>
</html>
