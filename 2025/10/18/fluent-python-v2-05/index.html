<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Python 提供了几种构建简单类的方式，这些类只是字段的容器，几乎没有额外功能。这种模式称为 数据类（data class），dataclasses 包就支持该模式。">
<meta property="og:type" content="article">
<meta property="og:title" content="流畅的 Python 第 2 版（5）：数据类构造器">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2025/10/18/fluent-python-v2-05/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="Python 提供了几种构建简单类的方式，这些类只是字段的容器，几乎没有额外功能。这种模式称为 数据类（data class），dataclasses 包就支持该模式。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2025/10/18/fluent-python-v2-05/images/01.jpg">
<meta property="article:published_time" content="2025-10-18T13:35:41.000Z">
<meta property="article:modified_time" content="2025-10-18T13:37:39.295Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fuchencong.github.io/fuchencong.github.io/2025/10/18/fluent-python-v2-05/images/01.jpg">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2025/10/18/fluent-python-v2-05/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>流畅的 Python 第 2 版（5）：数据类构造器 | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2025/10/18/fluent-python-v2-05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          流畅的 Python 第 2 版（5）：数据类构造器
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-18 21:35:41" itemprop="dateCreated datePublished" datetime="2025-10-18T21:35:41+08:00">2025-10-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Python 提供了几种构建简单类的方式，这些类只是字段的容器，几乎没有额外功能。这种模式称为 <code>数据类</code>（data class），dataclasses 包就支持该模式。</p>
<span id="more"></span>
<h2 id="数据类构建器概述"><a class="markdownIt-Anchor" href="#数据类构建器概述"></a> 数据类构建器概述</h2>
<p>如下是一个简单的类，表示地理位置的经纬度：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Coordinate</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, lat, lon</span>):</span><br><span class="line">        self.lat = lat</span><br><span class="line">        self.lon = lon</span><br></pre></td></tr></table></figure>
<p>Coordinate 类的作用是保存经纬度属性。为 <code>__init__</code> 方法编写样板代码容易让人感到枯燥，尤其是属性较多的时候。而且样板代码并没有给我们提供 Python 对象都有的基本功能：</p>
<ul>
<li>例如继承自 object 的 <code>__repr__</code> 作用不大</li>
<li><code>==</code> 没有意义，<strong>因为继承自 object 的 <strong>eq</strong> 方法比较对象的ID</strong></li>
</ul>
<p>本章要讲的数据类构建器自动提供必要的 <code>__init__</code>、<code>__repr__</code> 和 <code>__eq__</code> 等方法，此外还有其他有用的功能。而且这些类构建器都不依赖继承，它们使用不同的元编程技术把方法和数据属性注入要构建的类。</p>
<p>namedtuple 是一个工厂方法，使用指定的名称和字段构建 tuple 的子类。它创建的子类型提供了有意义的 <code>__repr__</code> 和 <code>__eq__</code> 方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Coordinate = namedtuple(<span class="string">&#x27;Coordinate&#x27;</span>, <span class="string">&#x27;lat lon&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(Coordinate, <span class="built_in">tuple</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>moscow == Coordinate(lat=<span class="number">1.0</span>, lon=<span class="number">2.0</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>新出现的 <code>typing.NamedTuple</code> 具有一样的功能，不过可为各个字段添加类型注解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Coordinate = NamedTuple(<span class="string">&#x27;Coordinate&#x27;</span>, [(<span class="string">&#x27;lat&#x27;</span>, <span class="built_in">float</span>), (<span class="string">&#x27;lon&#x27;</span>, <span class="built_in">float</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>typing.get_type_hints(Coordinate)</span><br><span class="line">&#123;<span class="string">&#x27;lat&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;float&#x27;</span>&gt;, <span class="string">&#x27;lon&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;float&#x27;</span>&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>构建带类型的具名元组，也可以通过关键字参数指定字段：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Coordinate = typing.NamedTuple(<span class="string">&#x27;Coordinate&#x27;</span>, lat=<span class="built_in">float</span>, lon=<span class="built_in">float</span>)</span><br></pre></td></tr></table></figure>
<p><code>typing.NamedTuple</code> 也可以在 class 语句中使用，类型注解按 <code>PEP 526—Syntax for Variable Annotations</code> 标准编写，这样写出的代码可读性更高，而且方便覆盖方法或添加新方法。在 <code>typing.NamedTuple</code> 生成的 <code>__init__</code> 方法中，字段参数的顺序与在 class 语句中出现的顺序相同：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> NamedTuple</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coordinate</span>(<span class="title class_ inherited__">NamedTuple</span>):</span><br><span class="line">    lat: <span class="built_in">float</span></span><br><span class="line">    lon: <span class="built_in">float</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        ns = <span class="string">&#x27;N&#x27;</span> <span class="keyword">if</span> self.lat &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;S&#x27;</span></span><br><span class="line">        we = <span class="string">&#x27;E&#x27;</span> <span class="keyword">if</span> self.lon &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;W&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">abs</span>(self.lat):<span class="number">.1</span>f&#125;</span>°<span class="subst">&#123;ns&#125;</span>, <span class="subst">&#123;<span class="built_in">abs</span>(self.lon):<span class="number">.1</span>f&#125;</span>°<span class="subst">&#123;we&#125;</span>&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>在 class 语句中，虽然 NamedTuple 出现在超类的位置上，但其实它不是超类</strong>。typing.NamedTuple 使用元类这一高级功能创建用户类。</p>
<p>与 typing.NamedTuple 一样，dataclass 装饰器也支持使用 PEP 526 句法来声明实例属性。dataclass装饰器读取变量注解，自动为构建的类生成方法。<code>@dataclass</code> 装饰器不依赖继承或元类，如果你想使用这些机制，则不受影响。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass(<span class="params">frozen=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coordinate</span>:</span><br><span class="line">    lat: <span class="built_in">float</span></span><br><span class="line">    lon: <span class="built_in">float</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        ns = <span class="string">&#x27;N&#x27;</span> <span class="keyword">if</span> self.lat &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;S&#x27;</span></span><br><span class="line">        we = <span class="string">&#x27;E&#x27;</span> <span class="keyword">if</span> self.lon &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;W&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">abs</span>(self.lat):<span class="number">.1</span>f&#125;</span>°<span class="subst">&#123;ns&#125;</span>, <span class="subst">&#123;<span class="built_in">abs</span>(self.lon):<span class="number">.1</span>f&#125;</span>°<span class="subst">&#123;we&#125;</span>&#x27;</span></span><br></pre></td></tr></table></figure>
<p>比较 3 个数据类构建器的部分功能：</p>
<img src="/fuchencong.github.io/2025/10/18/fluent-python-v2-05/images/01.jpg" class="">
<ul>
<li>3 个数据类构建器之间主要的区别在于，<code>collections.namedtuple</code> 和 <code>typing.NamedTuple</code> 构建的类是 tuple 的子类，因此实例是不可变的。@dataclass 默认构建可变的类，但 <code>@dataclass</code> 装饰器接受一个关键字参数 frozen，指定 frozen=True，初始化实例之后，如果为字段赋值，则抛出异常</li>
<li>只有 <code>typing.NamedTuple</code> 和 <code>dataclass</code> 支持常规的 class 语句句法，方便为构建的类添加方法和文档字符串</li>
<li>两种具名元组都提供了构造 dict 对象的实例方法 <code>._asdict</code>，可根据数据类实例的字段构造字典。dataclasses 模块也提供了构造字典的函数，即 <code>dataclasses.asdict</code></li>
<li>3 个类构建器都支持获取字段名称和可能配置的默认值</li>
<li><code>typing.NamedTuple</code> 和 <code>@dataclass</code> 构建的类有一个 <code>__annotations__</code> 属性，存放字段的类型提示。然而，不建议直接读取 <code>__annotations__</code> 属性。推荐使用 <code>inspect.get_annotations(MyClass)</code> 或 <code>typing.get_type_hints(MyClass)</code> 获取类型信息</li>
<li>对于具名元组实例 x，<code>x._replace(**kwargs)</code> 根据指定的关键字参数替换某些属性的值，返回一个新实例。模块级函数 <code>dataclasses.replace(x, **kwargs)</code> 与 <code>dataclass</code> 装饰的类具有相同的作用。</li>
<li>class 句法虽然可读性更高，但毕竟还是硬编码的。<strong>框架可能需要在运行时动态构建数据类</strong>。为此，可以使用默认的函数调用句法，<code>collections.namedtuple</code> 和 <code>typing.NamedTuple</code> 都支持。 dataclasses 模块提供的 <code>make_dataclass</code> 函数也是出于这个目的</li>
</ul>
<h2 id="典型的具名元组"><a class="markdownIt-Anchor" href="#典型的具名元组"></a> 典型的具名元组</h2>
<p><code>collections.namedtuple</code> 是一个工厂函数，用于构建增强的 tuple 子类，具有字段名称、类名和提供有用信息的 <code>__repr__</code> 方法。namedtuple 构建的类可在任何需要元组的地方使用（以前标准库中返回元组的很多函数，现在都返回具名元组，这对用户的代码没有任何影响）。而且 namedtuple 构建的类，其实例占用的内存量与元组相同，因为字段名称存储在类中。</p>
<ul>
<li>创建具名元组需要指定两个参数：一个类名和一个字段名称列表。后一个参数可以是产生字符串的可迭代对象，也可以是一整个以空格分隔的字符串</li>
<li>字段的值必须以单个位置参数传给构造函数</li>
<li>可以通过名称或位置访问字段</li>
<li>作为 tuple 的子类，创建的命名元组类继承了一些有用的方法，例如 <code>__eq__</code>、<code>__lt__</code> 等，以及类型属性 <code>_fields</code>（返回一个元组，存储类的字段名称）、<code>_make(iterable)</code>（根据可迭代对象构建类的实例） 和实例方法 <code>_as_dict()</code>（返回对应的 dict 对象）。</li>
<li>namedtuple 接受 defaults 关键字参数，值为一个产生 N 项的可迭代对象，为从右数的 N 个字段指定默认值</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>point = namedtuple(<span class="string">&quot;point&quot;</span>, <span class="string">&quot;x y&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.x</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p[<span class="number">1</span>]</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>point._fields</span><br><span class="line">(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p2 =  point._make([<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p2</span><br><span class="line">point(x=<span class="number">3</span>, y=<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p2._asdict()</span><br><span class="line">&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps(p2._asdict())</span><br><span class="line"><span class="string">&#x27;&#123;&quot;x&quot;: 3, &quot;y&quot;: 4&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>point3D = namedtuple(<span class="string">&quot;point3D&quot;</span>, <span class="string">&quot;x y z&quot;</span>, defaults=[<span class="number">10</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = point3D(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p</span><br><span class="line">point3D(x=<span class="number">1</span>, y=<span class="number">2</span>, z=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p><code>namedtuple()</code> 返回的类型也能增加自定义方法，只不过过程有些曲折：要先定义一个函数，再把这个函数赋值给一个类属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">point3D(x=<span class="number">1</span>, y=<span class="number">2</span>, z=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">add_one</span>(<span class="params">point</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> point3D(point.x + <span class="number">1</span>, point.y + <span class="number">1</span>, point.z + <span class="number">1</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>point3D.add_one = add_one</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.add_one()</span><br><span class="line">point3D(x=<span class="number">2</span>, y=<span class="number">3</span>, z=<span class="number">11</span>)</span><br></pre></td></tr></table></figure>
<p>定义的方法函数第一个参数不必命名为 self，但是调用时指代的就是接收方。这种动态添加方法也展示了动态语言的强大。</p>
<h2 id="带类型的具名元组"><a class="markdownIt-Anchor" href="#带类型的具名元组"></a> 带类型的具名元组</h2>
<p>通过 <code>typing.NamedTUple</code> 也可以定义命名元组，这种定义方式提供了 <code>class</code> 语法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> NamedTuple</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coordinate</span>(<span class="title class_ inherited__">NamedTuple</span>):</span><br><span class="line">    lat: <span class="built_in">float</span></span><br><span class="line">    lon: <span class="built_in">float</span></span><br><span class="line">    reference: <span class="built_in">str</span> = <span class="string">&#x27;WGS84&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>每个实例字段都要注解类型</li>
<li>实例字段 reference 注解了类型，还指定了默认值</li>
</ul>
<p>使用 <code>typing.NamedTuple</code> 构建的类基本和 <code>collections.namedtuple</code> 生成的类类似，唯一的区别是多了类属性 <code>__annotations__</code>。鉴于 <code>typing.NamedTuple</code> 的主要功能是类型注解，接下来先简单介绍类型注解。</p>
<h2 id="类型提示入门"><a class="markdownIt-Anchor" href="#类型提示入门"></a> 类型提示入门</h2>
<p><strong>类型提示（也叫类型注解）声明函数参数、返回值、变量和属性的预期类型</strong>。关于类型提示，首先你要知道，Python 字节码编译器和解释器根本不强制你提供类型信息。</p>
<h3 id="运行时没有作用"><a class="markdownIt-Anchor" href="#运行时没有作用"></a> 运行时没有作用</h3>
<p>Python 类型提示可以看作 <code>供IDE和类型检查工具验证类型的文档</code>。<strong>类型提示对 Python 程序的运行时行为没有影响</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> typing</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Point</span>(typing.NamedTuple):</span><br><span class="line"><span class="meta">... </span>    x: <span class="built_in">float</span></span><br><span class="line"><span class="meta">... </span>    y: <span class="built_in">float</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Point(<span class="string">&quot;str&quot;</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p</span><br><span class="line">Point(x=<span class="string">&#x27;str&#x27;</span>, y=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到，运行时根本不考虑类型提示，也不检查类型。<strong>类型提示主要为第三方类型检查工具提供支持</strong>，例如 Mypy 和 PyCharm IDE 内置的类型检查器。这些是静态分析工具，在 <code>静止</code> 状态下检查 Python 源码，不运行代码。为了看到类型提示的效果，必须使用相关工具（例如linter）检查代码。</p>
<p>使用 mypy 检查之前的示例，看到的输出如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mypy point.py</span></span><br><span class="line">point.py:<span class="number">6</span>: error: Argument <span class="number">1</span> to <span class="string">&quot;Point&quot;</span> has incompatible <span class="built_in">type</span> <span class="string">&quot;str&quot;</span>; expected <span class="string">&quot;float&quot;</span>  [arg-<span class="built_in">type</span>]</span><br><span class="line">point.py:<span class="number">6</span>: error: Argument <span class="number">2</span> to <span class="string">&quot;Point&quot;</span> has incompatible <span class="built_in">type</span> <span class="string">&quot;None&quot;</span>; expected <span class="string">&quot;float&quot;</span>  [arg-<span class="built_in">type</span>]</span><br><span class="line">Found <span class="number">2</span> errors <span class="keyword">in</span> <span class="number">1</span> file (checked <span class="number">1</span> source file)</span><br></pre></td></tr></table></figure>
<h3 id="变量注解句法"><a class="markdownIt-Anchor" href="#变量注解句法"></a> 变量注解句法</h3>
<p><code>typing.NamedTuple</code> 和 <code>@dataclass</code> 使用 <code>PEP 526</code> 定义的句法注解变量。这里先介绍在 class 语句中定义属性的注解句法。变量注解的基本句法如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var_name: some_type</span><br></pre></td></tr></table></figure>
<p>允许使用的类型在 PEP 484 中的 <code>Acceptable type hints</code> 一节规定，不过定义数据类时，最常使用以下类型：</p>
<ul>
<li>一个具体类，例如 <code>str</code> 或 <code>FrenchDeck</code></li>
<li>一个参数化容器类型，例如 <code>list[int]</code>​、<code>tuple[str, float]</code> 等</li>
<li>typing.Optional，例如 <code>Optional[str]</code>​，声明一个字段的类型可以是 <code>str</code> 或 <code>None</code></li>
</ul>
<p>另外，还可以为变量指定初始值。在 <code>typing.NamedTuple</code> 和 <code>@dataclass</code> 声明中，指定的初始值作为属性的默认值，防止调用构造函数时没有提供对应的参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var_name: some_type = a_value</span><br></pre></td></tr></table></figure>
<h3 id="变量注解的意义"><a class="markdownIt-Anchor" href="#变量注解的意义"></a> 变量注解的意义</h3>
<p>类型提示在运行时没有作用。然而，Python 在导入时（加载模块时）会读取类型提示，构建 <code>__annotations__</code> 字典，供 <code>typing.NamedTuple</code> 和 <code>@dataclass</code> 使用，增强类的功能。接下来先定义一个简单的类，然后再讨论 <code>typing.NamedTuple</code> 和 <code>@dataclass</code> 增加的额外功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DemoPlainClass</span>:</span><br><span class="line">    a: <span class="built_in">int</span></span><br><span class="line">    b: <span class="built_in">float</span> = <span class="number">1.1</span></span><br><span class="line">    c = <span class="string">&#x27;spam&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>a 出现在 <code>__annotations__</code> 中，但被抛弃了，因为该类没有名为 a 的属性</li>
<li>b 作为注解记录在案，而且是一个类属性，值为 1.1</li>
<li>c 是普通的类属性，没有注解</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> demo <span class="keyword">import</span> DemoPlainClass</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>DemoPlainClass.__annotations__</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;, <span class="string">&#x27;b&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;float&#x27;</span>&gt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>DemoPlainClass.a</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="built_in">type</span> <span class="built_in">object</span> <span class="string">&#x27;DemoPlainClass&#x27;</span> has no attribute <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>DemoPlainClass.b</span><br><span class="line"><span class="number">1.1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>DemoPlainClass.c</span><br><span class="line"><span class="string">&#x27;spam&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>特殊属性 <code>__annotations__</code> 由解释器创建，记录源码中出现的类型提示，即使是普通的类</li>
<li><strong>a 只作为注解存在，不是类属性，因为没有绑定值</strong>。b 和 c 存储为类属性，因为它们绑定了值</li>
<li><strong>这 3 个属性都不出现在 DemoPlainClass 的实例中</strong>。使用 <code>o = DemoPlainClass()</code> 创建一个对象，<code>o.a</code> 抛出 <code>AttributeError</code>，<strong>而 <code>o.b</code> 和 <code>o.c</code> 检索类属性</strong>，值分别为 <code>1.1</code> 和 <code>spam</code>，行为与常规的 Python 对象相同</li>
</ul>
<p>接下来研究一个使用 <code>typing.NamedTuple</code> 构建的类，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> typing</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoNTClass</span>(typing.NamedTuple):</span><br><span class="line">    a: <span class="built_in">int</span></span><br><span class="line">    b: <span class="built_in">float</span> = <span class="number">1.1</span></span><br><span class="line">    c = <span class="string">&#x27;spam&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>a 是注解，也是实例属性</li>
<li>b 是注解，也是实例属性</li>
<li>c 是普通的类属性，没有注解</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>DemoNTClass.__annotations__</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;, <span class="string">&#x27;b&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;float&#x27;</span>&gt;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>DemoNTClass.a</span><br><span class="line">_tuplegetter(<span class="number">0</span>, <span class="string">&#x27;Alias for field number 0&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>DemoNTClass.b</span><br><span class="line">_tuplegetter(<span class="number">1</span>, <span class="string">&#x27;Alias for field number 1&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>DemoNTClass.c</span><br><span class="line"><span class="string">&#x27;spam&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>DemoNTClass.__doc__</span><br><span class="line"><span class="string">&#x27;DemoNTClass(a, b)&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>typing.NamedTuple</code> 创建了类属性 a 和 b。c 是普通的类属性，值为 <code>spam</code></li>
<li>类属性 a 和 b 是描述符。可以把描述符理解为特性（property）读值（getter）方法，即不带调用 <code>运算符()</code> 的方法，用于读取实例属性</li>
<li>这意味着 a 和 b 是只读实例属性。这一点不难理解，因为 DemoNTClass 实例是某种高级的元组，而元组是不可变的</li>
<li>DemoNTClass 还有定制的文档字符串</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = DemoNTClass(<span class="number">8</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">DemoNTClass(a=<span class="number">8</span>, b=<span class="number">1.1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.a</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.b</span><br><span class="line"><span class="number">1.1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.c</span><br><span class="line"><span class="string">&#x27;spam&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.a = <span class="number">1</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: can<span class="string">&#x27;t set attribute</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; t.c = &quot;test&quot;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="string">AttributeError: &#x27;</span>DemoNTClass<span class="string">&#x27; object attribute &#x27;</span>c<span class="string">&#x27; is read-only</span></span><br></pre></td></tr></table></figure>
<ul>
<li>构造 DemoNTClass 实例时，需要提供 a 参数，b 也是构造函数的参数，不过它有默认值 <code>1.1</code>，因此可以不提供。</li>
<li>实例有 a 和 b 两个属性，这在预期之中。但是，没有 c 属性，像往常一样，Python 从类中检索该属性</li>
<li>为属性赋值时设置抛出抛出 AttributeError 异常，因为对象是元组，是不可变的</li>
</ul>
<p>如下是使用 dataclass 装饰类的类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoDataClass</span>:</span><br><span class="line">    a: <span class="built_in">int</span></span><br><span class="line">    b: <span class="built_in">float</span> = <span class="number">1.1</span></span><br><span class="line">    c = <span class="string">&#x27;spam&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>a 是注解，也是受描述符控制的实例属性</li>
<li>同样，b 是注解，也是受描述符控制的实例属性，默认值为 1.1</li>
<li>c 是普通的类属性，没有注解</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> demo_dataclass <span class="keyword">import</span> DemoDataClass</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>DemoDataClass.__annotations__</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;, <span class="string">&#x27;b&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;float&#x27;</span>&gt;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>DemoDataClass.__doc__</span><br><span class="line"><span class="string">&#x27;DemoDataClass(a: int, b: float = 1.1)&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>DemoDataClass.a</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="built_in">type</span> <span class="built_in">object</span> <span class="string">&#x27;DemoDataClass&#x27;</span> has no attribute <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>DemoDataClass.b</span><br><span class="line"><span class="number">1.1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>DemoDataClass.c</span><br><span class="line"><span class="string">&#x27;spam&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这里需要说明的是，a 属性只在DemoDataClass实例中存在。如果冻结 DemoDataClass 类，那么 a 就变成可获取和设定的公开属性</li>
<li>b 和 c 作为类属性存在，<strong>b 存储实例属性 b 的默认值</strong>，而 c 本身就是类属性，不绑定到实例上</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dc = DemoDataClass(<span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dc.a</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dc.b</span><br><span class="line"><span class="number">1.1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dc.c</span><br><span class="line"><span class="string">&#x27;spam&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dc.a = <span class="string">&quot;test&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dc</span><br><span class="line">DemoDataClass(a=<span class="string">&#x27;test&#x27;</span>, b=<span class="number">1.1</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>a 和 b 是实例属性，而 c 是通过实例获取的类属性</li>
<li>DemoDataClass 实例是可变的，而且运行时不检查类型</li>
</ul>
<p>甚至还可以为不存在的属性赋值。dc 实例有 c 属性，这对类属性 c 没有影响。我们还可以新增一个 z 属性。这是 Python 正常的行为：常规实例自身可以有未出现在类定义中的属性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dc.c = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dc.z = []</span><br></pre></td></tr></table></figure>
<p>PEP 526提出的实例属性和类属性注解句法与我们在 class 语句中养成的习惯相反。以前，**class 块顶层声明的全是类属性（方法也是类属性）**​。而对于 <code>PEP 526</code> 和 <code>NamedTuple</code> 及 <code>@dataclass</code>，<strong>在顶层声明的带有类型提示的属性变成了实例属性</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>:</span><br><span class="line">    repeat: <span class="built_in">int</span>  <span class="comment"># 实例属性</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>:</span><br><span class="line">    repeat: <span class="built_in">int</span>  <span class="comment"># 实例属性</span></span><br></pre></td></tr></table></figure>
<p>但是，如果没有类型提示，我们一下子就回到了从前，在类顶层声明的属性只属于类自身。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>:</span><br><span class="line">    repeat = <span class="number">99</span>  <span class="comment"># 类属性！</span></span><br></pre></td></tr></table></figure>
<p>如果你想为类属性注解类型，则不能使用常规的类型，否则就变成实例属性了。正确的做法是使用伪类型 <code>ClassVar</code> 注解（下文详解）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>:</span><br><span class="line">    repeat: ClassVar[<span class="built_in">int</span>] = <span class="number">99</span>  <span class="comment"># 真乱！</span></span><br></pre></td></tr></table></figure>
<p>这是例外中的例外，语法的可读性的确不高，不太符合 Python 风格。</p>
<h2 id="dataclass-详解"><a class="markdownIt-Anchor" href="#dataclass-详解"></a> @dataclass 详解</h2>
<p>@dataclass 装饰器可以接受多个关键字参数，完整签名如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass(<span class="params">*, init=<span class="literal">True</span>, <span class="built_in">repr</span>=<span class="literal">True</span>, eq=<span class="literal">True</span>, order=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="meta">              unsafe_hash=<span class="literal">False</span>, frozen=<span class="literal">False</span></span>)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果 eq 和 frozen 参数的值都是 True，那么 <code>@dataclass</code> 将生成一个合适的__hash__方法，确保实例是可哈希的。生成的 <code>__hash__</code> 方法使用所有字段的数据，通过字段选项也不能排除</li>
<li>对于 <code>frozen=False</code>（默认值）​，@dataclass 把 <strong>hash</strong> 设为 None，覆盖从任何超类继承的 <strong>hash</strong> 方法，表明实例不可哈希</li>
</ul>
<p>生成的数据类还可以在字段层面进一步定制。我们已经见过最基本的字段选项，即在提供类型提示的同时设定默认值，声明的字段将作为参数传给生成的 <code>__init__</code> 方法。<strong>Python 规定，带默认值的参数后面不能有不带默认值的参数。因此，为一个字段声明默认值之后，余下的字段都要有默认值</strong>。</p>
<p>可变的默认值很容易导致 bug。如果在函数定义中使用可变默认值，调用函数时很容易破坏默认值，则导致后续调用的行为发生变化。<code>@dataclass</code> 使用类型提示中的默认值生成传给 <code>__init__</code> 方法的参数默认值。为了避免bug，@dataclass拒绝如下那样定义类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@dataclass</span><br><span class="line"><span class="meta">... </span><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"><span class="meta">... </span>    a: <span class="built_in">list</span>[<span class="built_in">int</span>] = []</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">   <span class="keyword">raise</span> ValueError(<span class="string">f&#x27;mutable default <span class="subst">&#123;<span class="built_in">type</span>(f.default)&#125;</span> for field &#x27;</span></span><br><span class="line">ValueError: mutable default &lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt; <span class="keyword">for</span> field a <span class="keyword">is</span> <span class="keyword">not</span> allowed: use default_factory</span><br></pre></td></tr></table></figure>
<p>使用 default_factory 可以解决这个问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass, field</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    a: <span class="built_in">list</span>[<span class="built_in">int</span>] = field(default_factory=<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<p>通过调用 <code>dataclasses.field</code> 函数，把参数设为 <code>default_factory=list</code>，以此设定默认值。default_factory 参数的值可以是一个函数、一个类，或者其他可调用对象，在每次创建数据类的实例时调用（不带参数）​，构建默认值。<strong>这样每次数据类的实例都将拥有自己的 list，而不是所有实例共用 list</strong>。</p>
<p><code>@dataclass</code> 主动拒绝这种方案只适用于部分情况，只对 list、dict 和 set 有效。除此之外，其他可变的值不会引起 <code>@dataclass</code> 的注意。遇到这样的问题，你要自己处理，为可变的默认值设置默认工厂。</p>
<p>另外，这里的类型注解语法 <code>list[int]</code> 表示由 int 构成的列表。这是一种参数化泛型。从 Python3.9 开始，内置类型 list 可以使用方括号表示法指定列表中项的类型。在 Python3.9 之前，内置容器类型不支持泛型表示法。为了临时解决这一问题，typing 模块提供了对应的容器类型。此时如果需要参数化 list 类型提示，则必须使用从 typing 模块中导入的 List 类型，写作 <code>List[str]​</code>。</p>
<ul>
<li><code>guests: list</code> 表示 guests 列表可以由任何类型的对象构成</li>
<li>而 <code>guests: list[str]</code> 的意思是 guests 列表中的每一项都必须是字符串。如果在列表中存储无效的项，或者读取到无效的项，则类型检查工具将报错</li>
</ul>
<p>default_factory 应该是 field 函数最常使用的参数，不过除此之外还有其他参数可用。例如 default 参数，之所以有 default 参数，是因为在字段注解中设置默认值的位置被 field 函数调用占据了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClubMember</span>:</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    guests: <span class="built_in">list</span> = field(default_factory=<span class="built_in">list</span>)</span><br><span class="line">    athlete: <span class="built_in">bool</span> = field(default=<span class="literal">False</span>, <span class="built_in">repr</span>=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h3 id="初始化后处理"><a class="markdownIt-Anchor" href="#初始化后处理"></a> 初始化后处理</h3>
<p><code>@dataclass</code> 生成的 <code>__init__</code> 方法只做一件事：把传入的参数及其默认值（如果没有提供参数）赋值给实例属性，变成实例字段。有些时候初始化实例要做的不只是这些。为此，可以提供一个 <code>__post_init__</code> 方法。如果存在这个方法，则 <code>@dataclass</code> 将在生成的 <code>__init__</code> 方法最后调用 <code>__post_init__</code> 方法。<code>__post_init__</code> 经常用于执行验证，以及根据其他字段计算一个字段的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClubMember</span>:</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    handle: <span class="built_in">str</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    all_handles = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__post_init__</span>(<span class="params">self</span>):</span><br><span class="line">        cls = self.__class__</span><br><span class="line">        <span class="keyword">if</span> self.handle == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            self.handle = self.name.split()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.handle <span class="keyword">in</span> cls.all_handles:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f&quot;handle <span class="subst">&#123;self.handle!r&#125;</span> already exist&quot;</span>)</span><br><span class="line"></span><br><span class="line">        cls.all_handles.add(self.handle)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c1 = ClubMember(<span class="string">&quot;jack lee&quot;</span>)</span><br><span class="line">c2 = ClubMember(<span class="string">&quot;jack song&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">f&quot;handle <span class="subst">&#123;self.handle!r&#125;</span> already exist&quot;</span>)</span><br><span class="line">ValueError: handle <span class="string">&#x27;jack&#x27;</span> already exist</span><br></pre></td></tr></table></figure>
<h3 id="带类型的类属性"><a class="markdownIt-Anchor" href="#带类型的类属性"></a> 带类型的类属性</h3>
<p>虽然能实现我们的需求，能实现我们的需求，但不能让静态类型检查工具满意。如下是 mypy 的报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mypy all_handler.py</span></span><br><span class="line">all_handler.py:<span class="number">7</span>: error: Need <span class="built_in">type</span> annotation <span class="keyword">for</span> <span class="string">&quot;all_handles&quot;</span> (hint: <span class="string">&quot;all_handles: set[&lt;type&gt;] = ...&quot;</span>)  [var-annotated]</span><br><span class="line">Found <span class="number">1</span> error <span class="keyword">in</span> <span class="number">1</span> file (checked <span class="number">1</span> source file)</span><br></pre></td></tr></table></figure>
<p>mypy 认为需要改 <code>all_handlers</code> 提供类型注解，但是如果为 <code>all_handles</code> 添加类型提示，例如 <code>set[...]</code>​，那么 <code>@dataclass</code> 将把 <code>all_handles</code> 变成实例字段。所以要解决这个问题，同时仍然将 <code>all_handles</code> 保留为类属性，则要使用一个名为 <code>typing.ClassVar</code> 的伪类型，借助泛型表示法 <code>[​]</code> 设定变量的类型，同时声明为类属性。这样就可以为类变量添加类型提示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_handles: ClassVar[<span class="built_in">set</span>[<span class="built_in">str</span>]] = <span class="built_in">set</span>()</span><br></pre></td></tr></table></figure>
<p>它表示 <code>all_handles 是一个类属性，类型为字符串构成的集合，默认值是一个空集合</code>。<code>@dataclass</code> 装饰器不关心注解中的类型，但有两种例外情况，这是其中之一，即类型为 <code>ClassVar</code> 时，不为属性生成实例字段。另外一种情况是声明 <code>仅作初始化的变量”</code>。</p>
<h3 id="初始化不作为字段的变量"><a class="markdownIt-Anchor" href="#初始化不作为字段的变量"></a> 初始化不作为字段的变量</h3>
<p>有时，我们需要把不作为实例字段的参数传给 <code>__init__</code> 方法。按照 dataclasses 文档的说法，这种参数叫 <code>仅作初始化的变量</code>（init-only variable）。为了声明这种参数，dataclasses 模块提供了伪类型 InitVar，句法与 <code>typing.ClassVar</code> 一样。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    i: <span class="built_in">int</span></span><br><span class="line">    j: <span class="built_in">int</span> = <span class="literal">None</span></span><br><span class="line">    database: InitVar[DatabaseType] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__post_init__</span>(<span class="params">self, database</span>):</span><br><span class="line">        <span class="keyword">if</span> self.j <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> database <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.j = database.lookup(<span class="string">&#x27;j&#x27;</span>)</span><br><span class="line"></span><br><span class="line">c = C(<span class="number">10</span>, database=my_database)</span><br></pre></td></tr></table></figure>
<p>这里 <code>database</code> 不会被设为实例属性，也不会出现在 <code>dataclasses.fields</code> 函数返回的列表中。然而，对于生成的 <code>__init__</code> 方法，database 是参数之一，同时也传给 <code>__post_init__</code> 方法。所以如果你想自己编写 <code>__post_init__</code> 方法，需要在在方法签名中增加相应的参数。</p>
<h3 id="一个复杂例子"><a class="markdownIt-Anchor" href="#一个复杂例子"></a> 一个复杂例子</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass, field</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, auto</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ResourceType</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">    BOOK = auto()</span><br><span class="line">    EBOOK = auto()</span><br><span class="line">    VIDEO = auto()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;描述媒体资源。&quot;&quot;&quot;</span></span><br><span class="line">    identifier: <span class="built_in">str</span></span><br><span class="line">    title: <span class="built_in">str</span> = <span class="string">&#x27;&lt;untitled&gt;&#x27;</span></span><br><span class="line">    creators: <span class="built_in">list</span>[<span class="built_in">str</span>] = field(default_factory=<span class="built_in">list</span>)</span><br><span class="line">    date: <span class="type">Optional</span>[date] = <span class="literal">None</span></span><br><span class="line">    <span class="built_in">type</span>: ResourceType = ResourceType.BOOK</span><br><span class="line">    description: <span class="built_in">str</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    language: <span class="built_in">str</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    subjects: <span class="built_in">list</span>[<span class="built_in">str</span>] = field(default_factory=<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>Enum 为 <code>Resource.type</code> 字段提供类型安全的值</li>
<li>identifier 是唯一必需的字段</li>
<li>title 是第一个有默认值的字段。因此，后续字段都要提供默认值</li>
<li>date的值可以是一个 datetime.date 实例或 None</li>
<li>type 字段的默认值是 <code>ResourceType.BOOK</code></li>
</ul>
<h2 id="数据类导致代码异味"><a class="markdownIt-Anchor" href="#数据类导致代码异味"></a> 数据类导致代码异味</h2>
<p>无论是自己编写所有代码实现数据类，还是这里介绍的某个类构建器实现数据类，都要注意一点：这可能表示你的设计存在问题。所谓数据类是指，它们拥有一些字段，以及用于访问（读写）这些字段的函数，除此之外一无长物。<strong>这样的类只是一种不会说话的数据容器，它们几乎一定被其他类过分烦琐地操控着</strong>。</p>
<p>面向对象编程的主要思想是把行为和数据放在同一个代码单元（一个类）中。如果一个类使用广泛，但是自身没有什么重要的行为，那么整个系统中可能遍布处理实例的代码，并出现在很多方法和函数中。这样的系统对维护来说简直就是噩梦。鉴于此，Martin Fowler 提出的重构方案才建议把职责放回数据类中。</p>
<p>尽管如此，仍然有几种情况适合使用没什么行为或者没有任何行为的数据类。例如刚开始创建一个项目或者编写一个模块时，先用数据类简单实现一个类。随着时间的推移，类应该拥有自己的方法，而不是依赖其他类的方法操作该类的实例</p>
<p>数据类也可用于构建将要导出为 JSON 或其他交换格式的记录，也可用于存储刚刚从其他系统导入的数据。Python 中的数据类构建器都提供了把实例转换为普通字典的方法或函数，而且构造函数全部支持通过关键字参数提供一个字典（非常接近 JSON 记录）​，再使用 <code>**</code> 展开。</p>
<p><strong>在这种情况下，应把数据类实例当作不可变对象处理</strong>，即便字段是可变的，也不应在处于中间形式时更改。倘若更改，把数据和行为结合在一起的巨大优势就没有了。假如导入或导出时需要更改值，应该自己实现构建器方法，而不是使用数据类构建器提供的 <code>用作字典</code> 方法或常规的构造函数。</p>
<p>总之，不要滥用数据类，以免违背面向对象编程的一个基本原则，即数据和处理数据的函数应放在同一个类中。不含逻辑的类可能表明你把逻辑放错位置了。</p>
<h2 id="模式匹配类实例"><a class="markdownIt-Anchor" href="#模式匹配类实例"></a> 模式匹配类实例</h2>
<p>类模式通过类型和属性（可选）匹配类实例。类模式的匹配对象可以是任何类的实例，而不仅仅是数据类的实例。类模式有3种变体：简单类模式、关键字类模式和位置类模式。下面按顺序依次研究。</p>
<h3 id="简单类模式"><a class="markdownIt-Anchor" href="#简单类模式"></a> 简单类模式</h3>
<p>如下就是一个简单的类模式，该模式匹配项数为 4 的序列，第一项必须是 str 实例，最后一项必须是二元组，两项均为 float 实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">case [str(name), _, _, (float(lat), float(lon))]:</span><br></pre></td></tr></table></figure>
<p>类模式的句法看起来与构造函数调用差不多。下面的类模式匹配 <code>float</code> 值，未绑定变量（在 case 主体中，如果需要可以直接引用 x）​。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> x:</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">float</span>():</span><br><span class="line">        do_something_with(x)</span><br></pre></td></tr></table></figure>
<p>但是下面这样可能有 bug：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> x:</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">float</span>:  <span class="comment"># 危险！！！</span></span><br><span class="line">        do_something_with(x)</span><br></pre></td></tr></table></figure>
<p><code>case float:</code> 可以匹配任何对象，因为 Python 把 float 看作匹配对象绑定的变量。<code>float(x)</code> 这种简单模式句法只适用于 9 种内置类型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bytes</span>   <span class="built_in">dict</span>   <span class="built_in">float</span>   <span class="built_in">frozenset</span>   <span class="built_in">int</span>   <span class="built_in">list</span>   <span class="built_in">set</span>   <span class="built_in">str</span>   <span class="built_in">tuple</span></span><br></pre></td></tr></table></figure>
<p>对这些类来说，看上去像构造函数的参数的那个变量，例如 <code>float(x)</code> 中的 x，绑定整个匹配的实例。如果是子模式，则绑定匹配对象的一部分，例如前例中序列模式内的 <code>str(name)</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> [<span class="built_in">str</span>(name), _, _, (<span class="built_in">float</span>(lat), <span class="built_in">float</span>(lon))]:</span><br></pre></td></tr></table></figure>
<p>除9种内置类型之外，看上去像参数的那个变量表示模式匹配的类实例的属性。</p>
<h3 id="关键字类模式"><a class="markdownIt-Anchor" href="#关键字类模式"></a> 关键字类模式</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> typing</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">City</span>(typing.NamedTuple):</span><br><span class="line">    continent: <span class="built_in">str</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    country: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line">cities = [</span><br><span class="line">    City(<span class="string">&#x27;Asia&#x27;</span>, <span class="string">&#x27;Tokyo&#x27;</span>, <span class="string">&#x27;JP&#x27;</span>),</span><br><span class="line">    City(<span class="string">&#x27;Asia&#x27;</span>, <span class="string">&#x27;Delhi&#x27;</span>, <span class="string">&#x27;IN&#x27;</span>),</span><br><span class="line">    City(<span class="string">&#x27;North America&#x27;</span>, <span class="string">&#x27;Mexico City&#x27;</span>, <span class="string">&#x27;MX&#x27;</span>),</span><br><span class="line">    City(<span class="string">&#x27;North America&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;US&#x27;</span>),</span><br><span class="line">    City(<span class="string">&#x27;South America&#x27;</span>, <span class="string">&#x27;São Paulo&#x27;</span>, <span class="string">&#x27;BR&#x27;</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">match_asian_cities</span>():</span><br><span class="line">    results = []</span><br><span class="line">    <span class="keyword">for</span> city <span class="keyword">in</span> cities:</span><br><span class="line">        <span class="keyword">match</span> city:</span><br><span class="line">            <span class="keyword">case</span> City(continent=<span class="string">&#x27;Asia&#x27;</span>):</span><br><span class="line">                results.append(city)</span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(match_asian_cities())</span><br></pre></td></tr></table></figure>
<ul>
<li>City(continent=‘Asia’) 匹配的 City 实例，continent 属性的值等于 <code>Asia</code>，其他属性的值不考虑</li>
</ul>
<p>如果你想收集 country 属性的值，可以像下面这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">match_asian_countries</span>():</span><br><span class="line">    results = []</span><br><span class="line">    <span class="keyword">for</span> city <span class="keyword">in</span> cities:</span><br><span class="line">        <span class="keyword">match</span> city:</span><br><span class="line">            <span class="keyword">case</span> City(continent=<span class="string">&#x27;Asia&#x27;</span>, country=cc):</span><br><span class="line">                results.append(cc)</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>
<p><code>City(continent='Asia', country=cc)</code> 也匹配位于亚洲的城市，不过现在把变量 cc 绑定到了实例的 country 属性上。模式变量叫 country 也没关系。</p>
<p>关键字类模式的可读性非常高，适用于任何有公开的实例属性的类，不过有点烦琐。有时候，使用位置类模式更方便，不过匹配对象所属的类要显式支持。</p>
<h3 id="位置类模式"><a class="markdownIt-Anchor" href="#位置类模式"></a> 位置类模式</h3>
<p>如下函数使用位置类模式获取亚洲城市列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">match_asian_cities_pos</span>():</span><br><span class="line">    results = []</span><br><span class="line">    <span class="keyword">for</span> city <span class="keyword">in</span> cities:</span><br><span class="line">        <span class="keyword">match</span> city:</span><br><span class="line">            <span class="keyword">case</span> City(<span class="string">&#x27;Asia&#x27;</span>):</span><br><span class="line">                results.append(city)</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>
<ul>
<li><code>City('Asia')</code> 匹配的 City 实例，第一个属性的值是 ‘Asia’，其他属性的值不考虑</li>
</ul>
<p>如果你想收集 country 属性的值，可以像下面这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">match_asian_countries_pos</span>():</span><br><span class="line">    results = []</span><br><span class="line">    <span class="keyword">for</span> city <span class="keyword">in</span> cities:</span><br><span class="line">        <span class="keyword">match</span> city:</span><br><span class="line">            <span class="keyword">case</span> City(<span class="string">&#x27;Asia&#x27;</span>, _, country):</span><br><span class="line">                results.append(country)</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>
<p><strong>City 或其他类若想使用位置模式，要有一个名为 <code>__match_args__</code> 的特殊类属性</strong>。本章讲到的类构建器会自动创建这个属性。对于 City 类，<code>__match_args__</code> 属性的值如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>City.__match_args__</span><br><span class="line">(<span class="string">&#x27;continent&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;country&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>位置模式中属性的顺序就是 <code>__match_args__</code> 声明的顺序</strong>。一个模式可以同时使用关键字参数和位置参数。<strong>match_args</strong> 列出的是可供匹配的实例属性，不是全部属性。因此，有时候除了位置参数之外可能还需要使用关键字参数。</p>
<h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2>
<p>这篇文章主要介绍了 3 个数据类构建器：<code>collections.namedtuple</code>、<code>typing.NamedTuple</code> 和 <code>dataclasses.dataclass</code>。每个构建器都可以根据传给工厂函数的参数生成数据类，后两个构建器还可以通过 class 语句提供类型提示。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/Python/" rel="tag"># Python</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/10/19/fluent-python-v2-06/" rel="prev" title="流畅的 Python 第 2 版（6）：对象引用、可变性和垃圾回收">
      <i class="fa fa-chevron-left"></i> 流畅的 Python 第 2 版（6）：对象引用、可变性和垃圾回收
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/10/18/fluent-python-v2-04/" rel="next" title="流畅的 Python 第 2 版（4）：Unicode 文本和字节序列">
      流畅的 Python 第 2 版（4）：Unicode 文本和字节序列 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E6%9E%84%E5%BB%BA%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text"> 数据类构建器概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E7%9A%84%E5%85%B7%E5%90%8D%E5%85%83%E7%BB%84"><span class="nav-number">2.</span> <span class="nav-text"> 典型的具名元组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%A6%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%B7%E5%90%8D%E5%85%83%E7%BB%84"><span class="nav-number">3.</span> <span class="nav-text"> 带类型的具名元组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%8F%90%E7%A4%BA%E5%85%A5%E9%97%A8"><span class="nav-number">4.</span> <span class="nav-text"> 类型提示入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%B2%A1%E6%9C%89%E4%BD%9C%E7%94%A8"><span class="nav-number">4.1.</span> <span class="nav-text"> 运行时没有作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E6%B3%A8%E8%A7%A3%E5%8F%A5%E6%B3%95"><span class="nav-number">4.2.</span> <span class="nav-text"> 变量注解句法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">4.3.</span> <span class="nav-text"> 变量注解的意义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dataclass-%E8%AF%A6%E8%A7%A3"><span class="nav-number">5.</span> <span class="nav-text"> @dataclass 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%8E%E5%A4%84%E7%90%86"><span class="nav-number">5.1.</span> <span class="nav-text"> 初始化后处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%B1%9E%E6%80%A7"><span class="nav-number">5.2.</span> <span class="nav-text"> 带类型的类属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8D%E4%BD%9C%E4%B8%BA%E5%AD%97%E6%AE%B5%E7%9A%84%E5%8F%98%E9%87%8F"><span class="nav-number">5.3.</span> <span class="nav-text"> 初始化不作为字段的变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%A4%8D%E6%9D%82%E4%BE%8B%E5%AD%90"><span class="nav-number">5.4.</span> <span class="nav-text"> 一个复杂例子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%AF%BC%E8%87%B4%E4%BB%A3%E7%A0%81%E5%BC%82%E5%91%B3"><span class="nav-number">6.</span> <span class="nav-text"> 数据类导致代码异味</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%B1%BB%E5%AE%9E%E4%BE%8B"><span class="nav-number">7.</span> <span class="nav-text"> 模式匹配类实例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%B1%BB%E6%A8%A1%E5%BC%8F"><span class="nav-number">7.1.</span> <span class="nav-text"> 简单类模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E7%B1%BB%E6%A8%A1%E5%BC%8F"><span class="nav-number">7.2.</span> <span class="nav-text"> 关键字类模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E7%BD%AE%E7%B1%BB%E6%A8%A1%E5%BC%8F"><span class="nav-number">7.3.</span> <span class="nav-text"> 位置类模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">8.</span> <span class="nav-text"> 小结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">223</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">


  

</body>
</html>
