<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="如果表达式称为 JavaScript 的短语，那么语句就是 JavaScript 中的句子或命令。JavaScript 语句以分号（;）结尾。JavaScript 程序就是一系列待执行的语句。默认情况下，JavaScript 解释器按照它们在源代码中的顺序逐个执行这些语句，但 JavaScript 也提供了控制语句。">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 权威指南 05：语句">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2025/01/12/javascript-guide-05/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="如果表达式称为 JavaScript 的短语，那么语句就是 JavaScript 中的句子或命令。JavaScript 语句以分号（;）结尾。JavaScript 程序就是一系列待执行的语句。默认情况下，JavaScript 解释器按照它们在源代码中的顺序逐个执行这些语句，但 JavaScript 也提供了控制语句。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-01-12T06:31:18.000Z">
<meta property="article:modified_time" content="2025-03-12T06:43:15.265Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2025/01/12/javascript-guide-05/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JavaScript 权威指南 05：语句 | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2025/01/12/javascript-guide-05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaScript 权威指南 05：语句
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-12 14:31:18" itemprop="dateCreated datePublished" datetime="2025-01-12T14:31:18+08:00">2025-01-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>如果表达式称为 JavaScript 的短语，那么语句就是 JavaScript 中的句子或命令。JavaScript 语句以分号（;）结尾。JavaScript 程序就是一系列待执行的语句。默认情况下，JavaScript 解释器按照它们在源代码中的顺序逐个执行这些语句，但 JavaScript 也提供了控制语句。</p>
<span id="more"></span>

<h2 id="表达式语句"><a href="#表达式语句" class="headerlink" title="表达式语句"></a>表达式语句</h2><p>JavaScript 中最简单的一种语句就是有副效应的表达式，例如赋值语句是一种主要的表达式语句，函数调用是另一类主要的表达式语句。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">10</span> + j;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br></pre></td></tr></table></figure>

<h2 id="复合语句与空语句"><a href="#复合语句与空语句" class="headerlink" title="复合语句与空语句"></a>复合语句与空语句</h2><p>语句块将多个语句组合为一个复合语句，语句块其实就是一系列语句，可以放在任何期待一个语句的地方：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    i = <span class="number">10</span>;</span><br><span class="line">    j = <span class="number">20</span>;</span><br><span class="line">    z = <span class="number">30</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i + j + z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>块语句本身不需要以分号结尾，块中的单条语句都以分号结尾。</p>
<p>空语句让我们在期待一条语句的地方不包含任何语句。空语句是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;</span><br></pre></td></tr></table></figure>

<p>JavaScript 解释器在执行空语句时什么也不会做。空语句偶尔会有用，比如创建一个空循环体的循环。因为 JavaScript 语法要求有一条语句作为循环体，此时就可以使用空语句。</p>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>条件语句根据指定表达式的值执行或跳过执行某些语句。</p>
<p>if 语句是最基本的控制语句，可以让 JavaScript 有条件地执行语句。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>

<ul>
<li>expression 是一个表达式，其结果如果为真值，则执行 statement，否则 statement 不执行</li>
<li>expression 表达式两边的圆括号是必须的</li>
<li>if 表达式后面只能跟一个语句，但可以是一个语句块（这样就可以在语句块中包含多条语句）</li>
</ul>
<p>if 可以包含 else 子句，该子句会在表达式为 false 时执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression)</span><br><span class="line">    statement1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    statement2</span><br></pre></td></tr></table></figure>

<p>如果在嵌套的 if 语句中包含 else 子句，那么就要留心让 else 子句与相应的 if 语句对应。JavaScript 的规则（与多数编程语言一样）是，默认情况下 else 子句属于最近的 if 语句。<strong>为了让代码更清晰，应该总是使用花括号，即使语句体只有一个语句</strong>。</p>
<p>JavaScript 支持 <code>else if</code>，它并不是真正的 JavaScript 语句，而是一个在使用 if&#x2F;else 时被频繁用到的编程惯例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    ;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个 <code>else if</code> 可以实现多个分支，但是当所有判断都依赖同一个表达式的值时这并不是最好的办法。因为多个 if 语句重复对一个表达式进行求值太浪费了。此时最合适的语句是 switch 语句。switch 关键字后面跟着一个带括号的表达式和一个包含在花括号中的代码块：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="attr">value1</span>:</span><br><span class="line">    ...</span><br><span class="line">    statement1;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="attr">value2</span>:</span><br><span class="line">    ...</span><br><span class="line">    statement2;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="attr">default</span>:</span><br><span class="line">    ...</span><br><span class="line">    statement3;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 switch 执行时，它会计算表达式的值，然后对比 case 标签，看哪个表达式会求值为相同的值（这里的相同意味着 &#x3D;&#x3D;&#x3D; 为 true）。如果找到了相同的值，则执行相应 case 语句的代码块。如果没有找到，则再找标签为 <code>default</code> 的语句。如果没有 default 语句，则 switch 执行完成。</p>
<p>break 语句将导致 switch 语句执行结束。case 子句只指定了预期代码的起点，并没有指定终点。在没有 break 语句的情况下，switch 语句从匹配其表达式值的 case 代码块开始执行，一直执行到 switch 语句的末尾。一般这不是我们想要的行为（的确有时候也会这样用，实现 case 标签的 fallthrough）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">convert</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">typeof</span> x) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;number&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> x.<span class="title function_">toString</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;string&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;&quot;&#x27;</span> + x + <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">String</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">convert</span>(<span class="number">1</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">convert</span>(<span class="string">&quot;test&quot;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">convert</span>(&#123;&#125;));</span><br></pre></td></tr></table></figure>

<p>case 后面的表达式可以是任何表达式：</p>
<ul>
<li>switch 语句首先对跟在 switch 关键字后面的表达式求值</li>
<li>然后再按照顺序求值 case 表达式，直至遇到匹配的值（使用 &#x3D;&#x3D;&#x3D; 比较）</li>
<li>因此并不是所有 case 表达式都会被求值，所以应该避免使用包含副效应的 case 表达式。最可靠的做法是在 case 后面只写常量表达式</li>
<li>如果没有与 switch 表达式匹配的 case 表达式，则 switch语句就会执行标签为 default 的语句。<strong>default 标签可以出现在 switch 语句体的任何位置，不会影响上述执行流程。但一般都放在所有 case 语句的最后</strong></li>
</ul>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>循环语句可以重复执行代码中的某些部分。JavaScript 有 5 种循环语句：<code>while</code>、<code>do/while</code>、<code>for</code>、<code>for/of（及其变体for/await）</code> 和 <code>for/in</code>。</p>
<h3 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h3><p>while 的语法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (expression)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>

<ul>
<li>解释器首先会求值表达式。如果这个表达式的值是假值，则解释器会跳过作为循环体的语句</li>
<li>如果表达式是真值，则解释器会执行语句并且重复，即跳回循环的开头再次求值表达式</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">  count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="do-x2F-while-语句"><a href="#do-x2F-while-语句" class="headerlink" title="do&#x2F;while 语句"></a>do&#x2F;while 语句</h3><p><code>do/while</code> 循环与 <code>while</code> 循环类似，区别是对循环表达式的测试在循环底部而不是顶部。这意味着循环体始终会至少执行一次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">while</span>(expression);</span><br></pre></td></tr></table></figure>

<ul>
<li>do 循环必须始终以分号终止。而 while 循环在循环体使用花括号时不需要分号</li>
</ul>
<h3 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h3><p>for 语句提供了比 while 语句更方便的循环结构。for 语句简化了遵循常见模式的循环：多数循环都有某种形式的计数器变量。初始化、测试和更新是对计数器变量的三个关键操作。for语句将这三个操作分别设定为一个表达式，让这些表达式成为循环语法中明确的部分：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialize; test; increment)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>

<p>initialize、test和 increment 是三个表达式（以分号隔开）​，分别负责初始化、测试和递增循环变量。它等效于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initialize;</span><br><span class="line"><span class="keyword">while</span>(test) &#123;</span><br><span class="line">    statement;</span><br><span class="line">    increment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>initialize 表达式只在循环开始前求值一次。<strong>JavaScript 也允许 initialize 是变量声明语句，以便可以同时声明并初始化循环计数器</strong></li>
<li>test 表达式会在每次迭代时求值，用于控制是否执行循环体。如果 test 求值为真值，则作为循环体的 statement 就执行</li>
<li>执行后求值 increment 表达式</li>
<li>对 for 循环而言，三个表达式中任何一个都可以省略，只有两个分号是必需的</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> count = <span class="number">0</span>; count &lt; <span class="number">10</span>; count++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时候 initialize、increment 表达式中需要设置多个循环变量，此时可以使用逗号操作符。逗号操作符可以把多个初始化和递增表达式组合成一个表达式，从而满足 for 循环的语法要求。</p>
<h3 id="for-of-语句"><a href="#for-of-语句" class="headerlink" title="for/of 语句"></a><code>for/of</code> 语句</h3><p>ES6定义了一个新循环语句：<code>for/of</code>。<code>for/of</code> 循环专门用于可迭代对象，数组、字符串、集合、映射都是可迭代的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> sum  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> t <span class="keyword">of</span> data) &#123;</span><br><span class="line">  sum += t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum); <span class="comment">// =&gt; 6</span></span><br></pre></td></tr></table></figure>

<ul>
<li>圆括号中包含一个变量声明（对于已经声明的变量，只包含变量名即可）​</li>
<li>然后是 of 关键字和一个求值为可迭代对象的表达式</li>
<li>在每次执行循环体之前，都会把可迭代对象的下一个元素赋值给元素变量，然后执行循环体</li>
<li>迭代是实时的，即迭代过程中的变化可能影响迭代的输出</li>
</ul>
<p>对象（默认）是不可迭代的。运行时尝试对常规对象使用 for&#x2F;of 会抛出 TypeError。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> o = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;</span><br><span class="line">&gt; <span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">of</span> o) &#123;&#125;</span><br><span class="line"><span class="title class_">Uncaught</span> <span class="title class_">TypeError</span>: o is not iterable</span><br></pre></td></tr></table></figure>

<p>如果想迭代对象的属性，可以使用 <code>for/in</code> 循环，或者基于 <code>Object.keys()</code> 方法的结果使用 <code>for/of</code>。<code>Object.keys()</code> 返回一个对象属性名的数组，<code>Objece.values()</code> 返回一个对象属性值的数组。也通过 <code>Object.entries()</code> 方法并使用解构赋值来同时获取键和值。<code>Object.entries()</code> 返回一个数组的数组，其中每个内部数组表示对象的一个属性的键&#x2F;值对。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">for</span> (<span class="keyword">let</span> [k, v] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(o)) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(k, v) &#125;</span><br><span class="line">x <span class="number">1</span></span><br><span class="line">y <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>字符串在 ES6 中是可以逐个字符迭代的。注意是按照 Unicode 码点所对应的实际字符来迭代，而不是 UTF-16 字符（例如有一些表情符号需要两个 UTF-16 字符来表示，但迭代时只迭代一次）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> <span class="string">&quot;中文&quot;</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(c)&#125;</span><br><span class="line">中</span><br><span class="line">文</span><br></pre></td></tr></table></figure>

<p>ES6 内置的 Set 和 Map 类都是可迭代的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;Na na na Batman Na&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wordSet = <span class="keyword">new</span> <span class="title class_">Set</span>(text.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> word <span class="keyword">of</span> wordSet) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(word);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="number">1</span>, <span class="string">&quot;one&quot;</span>]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [k, v] <span class="keyword">of</span> m) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(k, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ES2018 新增了一种新迭代器，称为异步迭代器，同时新增了一种 <code>for/of</code> 循环，即使用异步迭代器的 <code>for/await</code> 循环，后面再详细介绍。</p>
<h3 id="for-in-语句"><a href="#for-in-语句" class="headerlink" title="for/in 语句"></a><code>for/in</code> 语句</h3><p>与 <code>for/of</code> 循环要求必须是可迭代对象不同，**<code>for/in</code> 循环 in 后面可以是任意对象**。<code>for/in</code> 是 JavaScript 就有的语法：</p>
<ul>
<li><code>for/in</code> 语句循环指定对象的属性名<ul>
<li>variable 通常是一个变量名，但也可能是变量声明或任何可以作为赋值表达式左值的东西。每次迭代前，解释器都会求值variable表达式，并将属性名字（字符串值）赋值给它</li>
<li>object是一个求值为对象的表达式，如果它求值为 null 或 undefined，解释器会跳过循环并转移到下一个语句</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (variable <span class="keyword">in</span> object)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>

<p>如下是一个示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> o = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;</span><br><span class="line">&gt; <span class="keyword">for</span> (k <span class="keyword">in</span> o ) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(o[k]) &#125;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">let</span> a = [], i = <span class="number">0</span></span><br><span class="line">&gt; <span class="keyword">for</span> (a[i++] <span class="keyword">in</span> o) ;</span><br><span class="line">&gt; a</span><br><span class="line">[ <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span> ]</span><br></pre></td></tr></table></figure>


<p>JavaScript 数组其实就是一种特殊的对象，而数组索引是对象的属性，可以通过 for&#x2F;in 循环来枚举。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> a = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">&gt; <span class="keyword">for</span> (i <span class="keyword">in</span> a) <span class="variable language_">console</span>.<span class="title function_">log</span>(i, <span class="keyword">typeof</span> i)</span><br><span class="line"><span class="number">0</span> string</span><br><span class="line"><span class="number">1</span> string</span><br><span class="line"><span class="number">2</span> string</span><br></pre></td></tr></table></figure>

<p>for&#x2F;in 循环并不会枚举对象的所有属性，比如它不会枚举名字为符号的属性。而对于名字为字符串的属性，它只会遍历可枚举的属性。JavaScript 核心定义的各种内部方法是不可枚举的。继承的可枚举属性也可以被 <code>for/in</code> 循环枚举。</p>
<p>需要注意，如果 <code>for/in</code> 循环的循环体删除一个尚未被枚举的属性，则该属性就不会再被枚举了。如果循环体在对象上又定义了新属性，则新属性可能会（也可能不会）被枚举。</p>
<h2 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h2><p>跳转语句会导致 JavaScript 解释器跳转到源代码中的新位置。</p>
<h3 id="语句标签"><a href="#语句标签" class="headerlink" title="语句标签"></a>语句标签</h3><p>通过前置一个标识符和一个冒号，可以为任何语句加上标签：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">identifier</span>: statement</span><br></pre></td></tr></table></figure>

<p>给语句加标签之后，就相当于给它起了个名字，可以在程序的任何地方通过这个名字来引用它。但通常是结合 break 或 continue 语句一起使用。下面看一个给 <code>while</code> 循环加标签并通过 <code>continue</code> 语句使用这个标签的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mainloop</span>: <span class="keyword">while</span> (token != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span> mainloop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>用作语句标签的 identifier 可以是任何合法的 JavaScript 标识符</li>
<li>标签与变量&#x2F;函数不在同一个命名空间中，因此同一个标识符既可以作为语句标签，也可以作为变量或函数名。语句标签只在定义它的语句（当然包括子语句）中有效</li>
<li>已经有标签的语句本身也可以再加标签，这意味着任何语句都可以有多个标签</li>
</ul>
<h3 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h3><p>break 语句在单独使用时，会导致包含它的循环或 switch 语句立即退出，break 语句也只有位于上述两种语句种才是合法的。JavaScript 也允许 break 关键字后面跟一个语句标签：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span> labelname;</span><br></pre></td></tr></table></figure>

<p>当 break 后面跟一个标签时，它会跳转到具有指定标签的包含语句的末尾或终止该语句。如果想中断一个并非最接近的包含循环或 switch 语句，就要使用这种带标签的 break 语句。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> matrix = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>, success = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="attr">computeSum</span>: <span class="keyword">if</span> (matrix) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; matrix; x++) &#123;</span><br><span class="line">    <span class="keyword">let</span> row = matrix[x];</span><br><span class="line">    <span class="keyword">if</span> (!row) <span class="keyword">break</span> computeSum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> y = <span class="number">0</span>; y &lt; row.<span class="property">length</span>; y++) &#123;</span><br><span class="line">      <span class="keyword">let</span> cell = row[y];</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">isNaN</span>(cell)) <span class="keyword">break</span> computeSum;</span><br><span class="line"></span><br><span class="line">      sum += cell;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  success = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// break jump here, check success to check loop finish ok</span></span><br></pre></td></tr></table></figure>

<p>最后要注意，无论带不带标签，break 语句都不能把控制权转移到函数边界之外。</p>
<h3 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h3><p>continue 语句与 break 语句类似，但 continue 不会退出循环，而是从头开始执行循环的下一次迭代。continue 语句也可以带标签：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">continue</span> labelname;</span><br></pre></td></tr></table></figure>

<p>无论带不带标签，continue 语句都只能在循环体内使用。在其他地方使用 continue 都会导致语法错误。</p>
<p>与 break 语句类似，continue语句在嵌套循环中也可以使用其带标签的形式，用于重新开始并非直接嵌套的循环。</p>
<h3 id="return-语句"><a href="#return-语句" class="headerlink" title="return 语句"></a>return 语句</h3><p>函数调用是表达式，而所有表达式都有值。函数中的 return 语句指定了函数调用的返回值。return 语句只能出现在函数体内。如果 return 出现在任何其他地方，都会导致语法错误。执行 return 语句后，包含它的函数向调用者返回 expression 的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> expression;</span><br></pre></td></tr></table></figure>

<p>如果没有 return 语句，函数调用会依次执行函数体中的每个语句，直至函数末尾，然后返回到其调用者。此时，调用表达式求值为 undefined。</p>
<p>return 语句后面也可以不带 expression，从而导致函数向调用者返回 undefined。</p>
<h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p>yield 语句非常类似于 return 语句，但只能用在 ES6 新增的生成器函数中。为了理解 yield，必须理解迭代器和生成器，因此后面再详细介绍。</p>
<h3 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h3><p>异常是一种信号，表示发生了某种意外情形或错误</p>
<ul>
<li>抛出（throw）异常是为了表明发生了这种错误或意外情形</li>
<li>捕获（catch）异常则是要处理它，即采取必要或对应的措施以从异常中恢复</li>
</ul>
<p>throw 语句用于抛出异常：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> expression;</span><br></pre></td></tr></table></figure>

<ul>
<li>expression 可能求值为任何类型的值，可以抛出一个表示错误码的数值，也可以抛出一个包含可读的错误消息的字符串</li>
<li>JavaScript 解释器在抛出错误时会使用 Error 类及其子类，当然我们也可以在自己的代码中使用这些类。Error对象有一个 name 属性和一个 message 属性，分别用于指定错误类型和保存传入构造函数的字符串</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Negative number&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> f;</span><br><span class="line">    <span class="keyword">for</span> (f = <span class="number">1</span>; n &gt; <span class="number">1</span>; n--) f *= n;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抛出异常时，JavaScript 解释器会立即停止正常程序的执行并跳到最近的异常处理程序。异常处理程序是使用 <code>try/catch/finally</code> 语句中的 <code>catch</code> 子句编写的。如果发生异常的代码块没有关联的 catch 子句，解释器会检查最接近的上一层代码块，看是否有与之关联的异常处理程序。这个过程一直持续，直至找到处理程序。在这种情况下，异常是沿 JavaScript 方法的词法结构和调用栈向上传播的。如果没有找到任何异常处理程序，则将异常作为错误报告给用户。</p>
<p>try&#x2F;catch&#x2F;finally 语句是 JavaScript 的异常处理机制：</p>
<ul>
<li>try子句用于定义要处理其中异常的代码块</li>
<li>try 块后面紧跟着 catch 子句，catch 是一个语句块，在 try 块中发生异常时会被调用</li>
<li>catch 子句后面是 finally 块，其中包含清理代码。无论 try 块中发生了什么，这个块中的代码一定会执行</li>
<li>catch 和 finally 块都是可选的，但只要有 try 块，就必须有它们两中的一个</li>
<li>try、catch 和 finally 块都以花括号开头和结尾。花括号是语法要求的部分，即使语句块只包含一条语句也不能省略</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">throw</span> expression;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">// 仅当 try 块中抛出异常时，catch 块才会执行</span></span><br><span class="line">    <span class="comment">// 使用局部变量 e 引用抛出的 Error 对象</span></span><br><span class="line">    <span class="comment">// 可以在其中通过 throw 重新排除异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论 try 块发生了什么，finally 块都会执行，包括</span></span><br><span class="line">    <span class="comment">// 1. 执行到 try 块的底部</span></span><br><span class="line">    <span class="comment">// 2. try 块由于 break、continue、return 而提前结束</span></span><br><span class="line">    <span class="comment">// 3. 抛出异常被 catch 捕获</span></span><br><span class="line">    <span class="comment">// 4. 或者异常未被处理而被继续传播</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下是一个示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;try &quot;</span>, count);</span><br><span class="line">      <span class="keyword">if</span> (count === <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;finally &quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    ++count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>()</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>  <span class="number">0</span></span><br><span class="line"><span class="keyword">finally</span>  <span class="number">0</span></span><br><span class="line"><span class="keyword">try</span>  <span class="number">1</span></span><br><span class="line"><span class="keyword">finally</span>  <span class="number">1</span></span><br><span class="line"><span class="keyword">try</span>  <span class="number">2</span></span><br><span class="line"><span class="keyword">finally</span>  <span class="number">2</span></span><br><span class="line"><span class="keyword">try</span>  <span class="number">3</span></span><br><span class="line"><span class="keyword">finally</span>  <span class="number">3</span></span><br><span class="line"><span class="keyword">try</span>  <span class="number">4</span></span><br><span class="line"><span class="keyword">finally</span>  <span class="number">4</span></span><br><span class="line"><span class="keyword">try</span>  <span class="number">5</span></span><br><span class="line"><span class="keyword">finally</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>如果 try 块中发生了异常，而且有关联的 catch 块来处理这个异常，则解释器会先执行 catch 块，然后再执行 finally 块。如果局部没有 catch 块处理异常，则解释器会先执行 finally 块，然后再跳转到最接近的包含 catch 子句。</p>
<p>如果 finally 块本身由于 return、continue、break 或 throw 语句导致跳转，或者调用的方法抛出了异常，则解释器会抛弃等待的跳转，执行新跳转。例如如果 finally 子句执行了 return 语句，则相应方法正常返回，即使有被抛出且尚未处理的异常。</p>
<p>我们偶尔会使用 catch 子句，只为了检测和停止异常传播，此时我们并不关心异常的类型或者错误消息。在 ES2019 及之后的版本中，类似这种情况下可以省略圆括号和其中的标识符，只使用 catch 关键字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parseJSON</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(s);</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他语句"><a href="#其他语句" class="headerlink" title="其他语句"></a>其他语句</h2><p>接下来介绍剩下的三个 JavaScript 语句：with、debugger 和 “use strict”。</p>
<h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>with 会运行一个代码块，就好像指定对象的属性是该代码块作用域中的变量一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (object)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>

<p>这个语句创建了一个临时作用域，以 object 的属性作为变量，然后在这个作用域中执行 statement。注意，如果在 with 语句体中使用 <code>const</code>、<code>let</code> 或 <code>var</code> 声明一个变量或常量，那么只会创建一个普通变量，不会在指定的对象上定义新属性。</p>
<p>with 在严格模式下是被禁用的，在非严格模式下也应该认为已经废弃了。换句话说，尽可能不使用它。使用 with 语句主要是为了更方便地使用深度嵌套的对象。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="property">name</span>.<span class="property">value</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="property">address</span>.<span class="property">value</span> = <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>可以改写为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (<span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>]) &#123;</span><br><span class="line">    name.<span class="property">value</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    address.<span class="property">value</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="debugger"><a href="#debugger" class="headerlink" title="debugger"></a>debugger</h3><p>debugger 语句一般什么也不做。不过，包含 debugger 的程序在运行时，实现可以（但不是必需）执行某种调试操作。实践中，这个语句就像一个断点，执行中的 JavaScript 会停止，我们可以使用调试器打印变量的值、检查调用栈，等等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (o === <span class="literal">undefined</span>) <span class="keyword">debugger</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="“use-strict”"><a href="#“use-strict”" class="headerlink" title="“use strict”"></a>“use strict”</h3><p>“use strict” 是 ES5 引入的一个指令。指令不是语句（但非常近似，所以在这里介绍 “use strict”）​。”use strict” 与常规语句有两个重要的区别：</p>
<ul>
<li>不包含任何语言关键字：指令是由（包含在单引号或双引号中的）特殊字符串字面量构成的表达式语句</li>
<li>只能出现在脚本或函数体的开头，位于所有其他真正的语句之前。</li>
</ul>
<p>“use strict” 指令的目的是表示（在脚本或函数中）它后面的代码是严格代码：</p>
<ul>
<li>如果脚本中有 “use strict” 指令，则脚本的顶级（非函数）代码是严格代码</li>
<li>如果函数体是在严格代码中定义的，或者函数体中有一个 “use strict” 指令，那么它就是严格代码</li>
<li>如果严格代码中调用了 eval()，那么传给 eval() 的代码也是严格代码。如果传给 eval() 的字符串包含 “use strict” 指令，那么相应的代码也是严格代码</li>
<li>除了显式声明为严格的代码，任何位于 class 体或 ES6 模块中的代码全部默认为严格代码，而无须把 “use strict” 指令显式地写出来</li>
</ul>
<p>严格模式是 JavaScript 的一个受限制的子集，这个子集修复了重要的语言缺陷，提供了更强的错误检查，也增强了安全性。因为严格模式并不是默认的，那些使用语言中有缺陷的遗留特性的旧代码依然可以正确运行。</p>
<p>严格模式与非严格模式的区别如下：</p>
<ul>
<li>严格模式下不允许使用 with 语句</li>
<li>在严格模式下，所有变量都必须声明（在非严格模式下，给非声明的变量赋值会隐式地在全局对象中添加一个属性，创建一个全局变量）</li>
<li>在严格模式下，函数如果作为函数（而非方法）被调用，其 this 值为undefined（在非严格模式，作为函数调用的函数始终以全局对象作为 this 的值）​。另外，在严格模式下，如果函数通过 call() 或 apply() 调用，则 this 值就是作为第一个参数传给 call() 或 apply() 的值（在非严格模式下，null 和 undefined 值会被替换为全局对象，而非对象值会被转换为对象）​</li>
<li>在严格模式下，给不可写的属性赋值或尝试在不可扩展的对象上创建新属性会抛出 TypeError（在非严格模式下，这些尝试会静默失败）​</li>
<li>在严格模式下，传给 eval() 的代码不能像在非严格模式下那样在调用者的作用域中声明变量或定义函数。</li>
<li>在严格模式下，函数中的 Arguments 对象保存着一份传给函数的值的静态副本。在非严格模式下，这个 Arguments 对象具有 <code>魔法</code> 行为，即这个数组中的元素与函数的命名参数引用相同的值</li>
<li>在严格模式下，如果delete操作符后面跟一个未限定的标识符，比如变量、函数或函数参数，则会导致抛出SyntaxError（在非严格模式下，这样的 delete 表达式什么也不做，且返回 false）​</li>
<li>在严格模式下，尝试删除一个不可配置的属性会导致抛出 TypeError</li>
<li>在严格模式下，对象字面量定义两个或多个同名属性是语法错误（在非严格模式下，不会发生错误）​</li>
<li>在严格模式下，函数声明中有两个或多个同名参数是语法错误（在非严格模式下，不会发生错误）​</li>
<li>在严格模式下，不允许使用八进制整数字面量（以 0 开头后面没有 x）​（在非严格模式下，某些实现允许使用八进制字面量）​</li>
<li>在严格模式下，标识符 eval 和 arguments 被当作关键字，不允许修改它们的值</li>
<li>在严格模式下，检查调用栈的能力是受限制的。<code>arguments.caller</code> 和 <code>arguments.callee</code> 在严格模式函数中都会抛出 TypeError</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">delete</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">  <span class="keyword">delete</span> t; <span class="comment">// SyntaxError: Delete of an unqualified identifier in strict mode.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f1</span>();</span><br><span class="line"><span class="title function_">f2</span>();</span><br></pre></td></tr></table></figure>

<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>关键字 const、let、var、function、class、import 和 export 严格来讲并不是语句，这些关键字更准确地讲应该叫作声明而非语句。当程序运行时，解释器会对程序中的表达式求值，而且会执行程序的语句。<strong>程序中的声明并不以同样的方式 <code>运行</code>​，但它们定义程序本身的结构</strong>。宽泛地说，可以把声明看成程序的一部分，这一部分会在代码运行前预先处理。</p>
<h3 id="const、let-和-var"><a href="#const、let-和-var" class="headerlink" title="const、let 和 var"></a>const、let 和 var</h3><p>在 ES6 及之后的版本中，const 声明常量而 let 声明变量。在 ES6 之前，使用 var 是唯一一个声明变量的方式，无法声明常量。使用 var 声明的变量，其作用域为包含函数，而非包含块。这可能会导致隐含的错误。现代 JavaScript 推荐使用 let 而不是 var。</p>
<h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><p>function 声明用于定义函数，如下是一个示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">area</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * radius * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数声明会创建一个函数对象，并把这个函数对象赋值给指定的名字。位于任何 JavaScript 代码块中的函数声明都会在代码运行之前被处理，而在整个代码块中函数名都会绑定到相应的函数对象。<strong>无论在作用域中的什么地方声明函数，这些函数都会被 <code>提升</code>​，就好像它们是在该作用域顶部定义的一样</strong>。于是在程序中，调用函数的代码可能位于声明函数的代码之前**。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">test</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">test2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">  <span class="title function_">test2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>在 ES6 及之后的版本中，class 声明会创建一个新类并为其赋予一个名字，以便将来引用。以下是一个类声明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">radius</span> = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">area</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="variable language_">this</span>.<span class="property">radius</span> * <span class="variable language_">this</span>.<span class="property">radius</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>与函数不同，类声明不会被提升。因此在代码中，不能在还没有声明类之前就使用类</strong>。</p>
<h3 id="import-和-export"><a href="#import-和-export" class="headerlink" title="import 和 export"></a>import 和 export</h3><p>import 和 export 声明共同用于让一个 JavaScript 模块中定义的值可以在另一个模块中使用。一个模块就是一个 JavaScript 代码文件，有自己的全局作用域，完全与其他模块无关。如果要在一个模块中使用另一个模块中定义的值（如函数或类）​，唯一的方式就是在定义值的模块中使用 export 导出值，在使用值的模块中使用 import 导入值。</p>
<p>import 指令用于从另一个 JavaScript 代码文件中导入一个或多个值，并在当前模块中为这些值指定名字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Circle</span> <span class="keyword">from</span> <span class="string">&quot;./geometry/circle.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">PI</span>, <span class="variable constant_">TAU</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./geometry/constants.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; magnitude <span class="keyword">as</span> hypotenuse &#125; <span class="keyword">from</span> <span class="string">&quot;./geometry/utils.js&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>JavaScript 模块中的值是私有的，除非被显式导出，否则其他模块都无法导入。export 指令就是为此而生的，它声明把当前模块中定义的一个或多个值导出，因而其他模块可以导入这些值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="title class_">Math</span>.<span class="property">PI</span>;</span><br><span class="line">comst <span class="variable constant_">TAU</span> = <span class="number">2</span> * <span class="variable constant_">PI</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; <span class="variable constant_">PI</span>, <span class="variable constant_">TAU</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>export 关键字有时候也用作其他声明的修饰符，从而构成一种复合声明，在定义常量、变量、函数或类的同时又导出它们。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="title class_">Math</span>.<span class="property">PI</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">area</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable constant_">PI</span> * radius * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个模块只导出一个值，可以使用特殊的 <code>export default</code> 形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="title class_">Math</span>.<span class="property">PI</span>;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/%E5%89%8D%E7%AB%AF/" rel="tag"># 前端</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/01/13/javascript-guide-06/" rel="prev" title="JavaScript 权威指南 06：对象">
      <i class="fa fa-chevron-left"></i> JavaScript 权威指南 06：对象
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/01/11/javascript-guide-04/" rel="next" title="JavaScript 权威指南 04：表达式与操作符">
      JavaScript 权威指南 04：表达式与操作符 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.</span> <span class="nav-text">表达式语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E8%AF%AD%E5%8F%A5%E4%B8%8E%E7%A9%BA%E8%AF%AD%E5%8F%A5"><span class="nav-number">2.</span> <span class="nav-text">复合语句与空语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="nav-number">3.</span> <span class="nav-text">条件语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="nav-number">4.</span> <span class="nav-text">循环语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#while-%E8%AF%AD%E5%8F%A5"><span class="nav-number">4.1.</span> <span class="nav-text">while 语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#do-x2F-while-%E8%AF%AD%E5%8F%A5"><span class="nav-number">4.2.</span> <span class="nav-text">do&#x2F;while 语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for-%E8%AF%AD%E5%8F%A5"><span class="nav-number">4.3.</span> <span class="nav-text">for 语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for-of-%E8%AF%AD%E5%8F%A5"><span class="nav-number">4.4.</span> <span class="nav-text">for&#x2F;of 语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for-in-%E8%AF%AD%E5%8F%A5"><span class="nav-number">4.5.</span> <span class="nav-text">for&#x2F;in 语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5"><span class="nav-number">5.</span> <span class="nav-text">跳转语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E5%8F%A5%E6%A0%87%E7%AD%BE"><span class="nav-number">5.1.</span> <span class="nav-text">语句标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#break-%E8%AF%AD%E5%8F%A5"><span class="nav-number">5.2.</span> <span class="nav-text">break 语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#continue-%E8%AF%AD%E5%8F%A5"><span class="nav-number">5.3.</span> <span class="nav-text">continue 语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#return-%E8%AF%AD%E5%8F%A5"><span class="nav-number">5.4.</span> <span class="nav-text">return 语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#yield"><span class="nav-number">5.5.</span> <span class="nav-text">yield</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#throw"><span class="nav-number">5.6.</span> <span class="nav-text">throw</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E8%AF%AD%E5%8F%A5"><span class="nav-number">6.</span> <span class="nav-text">其他语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#with"><span class="nav-number">6.1.</span> <span class="nav-text">with</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#debugger"><span class="nav-number">6.2.</span> <span class="nav-text">debugger</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%80%9Cuse-strict%E2%80%9D"><span class="nav-number">6.3.</span> <span class="nav-text">“use strict”</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E"><span class="nav-number">7.</span> <span class="nav-text">声明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#const%E3%80%81let-%E5%92%8C-var"><span class="nav-number">7.1.</span> <span class="nav-text">const、let 和 var</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#function"><span class="nav-number">7.2.</span> <span class="nav-text">function</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#class"><span class="nav-number">7.3.</span> <span class="nav-text">class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#import-%E5%92%8C-export"><span class="nav-number">7.4.</span> <span class="nav-text">import 和 export</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">181</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
