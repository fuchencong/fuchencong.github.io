<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="函数是 JavaScript 程序的一个基本组成部分，也是几乎所有编程语言共有的特性。这篇文章将学习 JavaScript 的函数。">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 权威指南 08：函数">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2025/01/15/javascript-guide-08/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="函数是 JavaScript 程序的一个基本组成部分，也是几乎所有编程语言共有的特性。这篇文章将学习 JavaScript 的函数。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-01-15T06:20:15.000Z">
<meta property="article:modified_time" content="2025-04-28T06:54:38.181Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2025/01/15/javascript-guide-08/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JavaScript 权威指南 08：函数 | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2025/01/15/javascript-guide-08/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaScript 权威指南 08：函数
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-15 14:20:15" itemprop="dateCreated datePublished" datetime="2025-01-15T14:20:15+08:00">2025-01-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>函数是 JavaScript 程序的一个基本组成部分，也是几乎所有编程语言共有的特性。这篇文章将学习 JavaScript 的函数。</p>
<span id="more"></span>
<h2 id="函数简介"><a class="markdownIt-Anchor" href="#函数简介"></a> 函数简介</h2>
<p>函数是一个 JavaScript 代码块，定义之后，可以被执行或调用任意多次：</p>
<ul>
<li>JavaScript 函数是参数化的，即函数定义可以包含一组标识符，称为参数或形参（parameter）</li>
<li>这些形参类似函数体内定义的局部变量，函数调用会为这些形参提供值或者称为实参（argument）</li>
<li>函数返回值会成为函数调用表达式的值。</li>
<li>除了实参，每个调用还有另外一个值，即调用上下文（invocation context），也就是 this 关键字的值</li>
</ul>
<p>如果把函数赋值给一个对象的属性，则可以称其为该对象的方法。如果函数是在一个对象上被调用或通过一个对象被调用，这个对象就是函数的调用上下文或 this 值。</p>
<p>JavaScript 中的函数是对象。因为函数是对象，所以可以在函数上设置属性，甚至调用函数的方法。</p>
<p>JavaScript 函数可以嵌套定义在其他函数里，内嵌的函数可以访问定义在函数作用域的任何变量。这意味着JavaScript 函数是闭包（closure），基于闭包可以实现重要且强大的编程技巧。</p>
<h2 id="定义函数"><a class="markdownIt-Anchor" href="#定义函数"></a> 定义函数</h2>
<p>在 JavaScript 中定义函数最直观的方式就是使用 function 关键字，这个关键字可以用作声明或表达式。ES6定义了一种新的方式，可以不通过 function 关键字定义函数，即 <code>箭头函数</code>。</p>
<h3 id="函数声明"><a class="markdownIt-Anchor" href="#函数声明"></a> 函数声明</h3>
<p>函数声明由 function 关键字后跟如下组件构成：</p>
<ul>
<li>命名函数的标识符：这个作为函数名的标识符对于函数声明是必需的，它作为一个变量名使用，新定义的函数对象会赋值给这个变量</li>
<li>一对圆括号：中间包含逗号分隔的零或多个标识符。这些标识符是函数的参数名，它们就像是函数体内的局部变量</li>
<li>一对花括号：其中包含零或多个 JavaScript 语句。这些语句构成函数体，会在函数被调用时执行</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">square</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里最关键的是，理解函数的名字变成了一个变量，这个变量的值就是函数本身。函数声明语句会被 <code>提升</code> 到包含脚本、函数或代码块的顶部，因此调用以这种方式定义的函数时，调用代码可以出现在函数定义代码之前。</p>
<p>return 语句导致函数停止执行并将其表达式（如果有）的值返回给调用者。如果 return 语句没有关联的表达式，则函数的返回值是 undefined。</p>
<h3 id="函数表达式"><a class="markdownIt-Anchor" href="#函数表达式"></a> 函数表达式</h3>
<p>函数表达式看上去很像函数声明，但是出现在复杂表达式或者语句的上下文中，而且函数名是可选的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="keyword">function</span>(<span class="params">x</span>) &#123; <span class="keyword">return</span> x * x; &#125;;</span><br><span class="line"><span class="comment">// 函数表达式中可以包含名字，这对递归有用</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">function</span> <span class="title function_">fact</span>(<span class="params">x</span>) &#123; <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">else</span> <span class="keyword">return</span> x * <span class="title function_">fact</span>(x - <span class="number">1</span>); &#125;;</span><br></pre></td></tr></table></figure>
<p>函数名对定义为表达式的函数而言是可选的（如果需要引用自身，也可以带函数名），前面看到的多数函数表达式都没有名字。函数声明实际上会声明一个变量，然后把函数对象赋值给它。而函数表达式不会声明变量，至于要把新定义的函数赋值给一个常量还是变量都取决于你。</p>
<p>如果函数表达式包含名字，则该函数的局部作用域中也会包含一个该名字与函数对象的绑定。<strong>实际上，函数名就变成了函数体内的一个局部变量</strong>。</p>
<p>在使用声明形式时，先创建好函数对象，然后再运行包含它们的代码，而且函数的定义会被提升到顶部，因此在定义函数的语句之前就可以调用它们。但对于定义为表达式的函数就不一样了，这些函数在定义它们的表达式实际被求值以前是不存在的。因此定义为表达式的函数不能在它们的定义之前调用。</p>
<h3 id="箭头函数"><a class="markdownIt-Anchor" href="#箭头函数"></a> 箭头函数</h3>
<p>在 ES6 中，我们可以使用一种特别简洁的语法来定义函数，叫作 <code>箭头函数”</code>。它使用 <code>箭头</code> 分隔函数的参数和函数体。箭头函数的一般形式是圆括号中逗号分隔的参数列表，后跟箭头 =&gt;，再跟包含在花括号中的函数体：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">x, y</span>) =&gt; &#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure>
<p>如果函数体只有一个 return 语句，那么可以省略 return 关键字、语句末尾的分号以及花括号，将函数体写成一个表达式，它的值将被返回：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">x, y</span>) =&gt; x + y;</span><br></pre></td></tr></table></figure>
<p>如果箭头函数只有一个参数，也可以省略包围参数列表的圆括号：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">polynomial</span> = x =&gt; x * x + <span class="number">2</span> * x + <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>但是如果没有参数，箭头函数一定要把空圆括号写出来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">func</span> = (<span class="params"></span>) =&gt; <span class="number">42</span>;</span><br></pre></td></tr></table></figure>
<p>在写箭头函数时，不能在函数参数和箭头之间放换行符，否则会出现类似于 <code>const func = x</code>，这本身就是合法的赋值语句。另外，如果箭头函数的函数体是一个 return 语句，但要返回的表达式是对象字面量，那必须把这个对象字面量放在一对圆括号中，以避免解释器分不清花括号到底是函数体的花括号，还是对象字面量的花括号</p>
<p>箭头函数的简洁语法让它们非常适合作为值传给其他函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; [<span class="number">1</span>, <span class="literal">null</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> x != <span class="literal">null</span>)</span><br><span class="line">[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ]</span><br></pre></td></tr></table></figure>
<p>它们从定义自己的环境继承 this 关键字的值，而不是像以其他方式定义的函数那样定义自己的调用上下文。箭头函数与其他函数还有一个区别，就是它们没有 prototype 属性。这意味着箭头函数不能作为新类的构造函数。</p>
<h3 id="嵌套函数"><a class="markdownIt-Anchor" href="#嵌套函数"></a> 嵌套函数</h3>
<p>在 JavaScript 中，函数可以嵌套在其他函数中。关于嵌套函数，最重要的是理解它们的变量作用域规则：它们可以访问包含自己的函数（或更外层函数）的参数和变量。下文将详细介绍。</p>
<h2 id="调用函数"><a class="markdownIt-Anchor" href="#调用函数"></a> 调用函数</h2>
<p>构成函数体的 JavaScript 代码不在定义函数的时候执行，而在调用函数的时候执行。</p>
<h3 id="函数调用"><a class="markdownIt-Anchor" href="#函数调用"></a> 函数调用</h3>
<p>函数是通过调用表达式来进行调用的，此时函数可以是常规函数或者方法。调用表达式包括求值为函数对象的函数表达式，后跟一对圆括号，圆括号中是逗号分隔的零或多个参数表达式列表。如果函数表达式是属性访问表达式，即函数是对象的属性或数组的元素，那么它是一个方法调用表达式。</p>
<p>在一次调用中，每个（位于括号中的）实参表达式都会被求值，求值结果会变成函数的实参。在函数体内，对形参的引用会求值为对应的实参值。</p>
<p>在 ES2020中，可以在函数表达式后面、左圆括号前面插入 <code>?.</code>，从而只在函数不是 null 或 undefined 时调用函数。因此 <code>f?.(x)</code> 等价于</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(f !== <span class="literal">null</span> &amp;&amp; f !== <span class="literal">undefined</span>) ? <span class="title function_">f</span>(x) : <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
<p>对于非严格模式下的函数调用，调用上下文（this值）是全局对象。但在严格模式下，调用上下文是 undefined。要注意的是，使用箭头语法定义的函数又有不同：它们总是继承自身定义所在环境的 this 值。</p>
<h3 id="方法调用"><a class="markdownIt-Anchor" href="#方法调用"></a> 方法调用</h3>
<p>方法其实就是 JavaScript 的函数，只不过它保存为对象的属性而已。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> o = &#123;&#125;</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt; o.<span class="property">m</span> = <span class="function"><span class="params">x</span> =&gt;</span> x*x</span><br><span class="line">&gt; o.<span class="title function_">m</span>(<span class="number">10</span>)</span><br><span class="line"><span class="number">100</span></span><br><span class="line">&gt; o[<span class="string">&quot;m&quot;</span>](<span class="number">100</span>)</span><br><span class="line"><span class="number">10000</span></span><br></pre></td></tr></table></figure>
<p>当函数表达式本身是个属性访问表达式，这意味着函数在这里是作为方法而非常规函数被调用的。方法调用的参数和返回值与常规函数调用的处理方式完全一样。但方法调用与函数调用有一个重要的区别：调用上下文。属性访问表达式由两部分构成：对象（这里的 o）和属性名（m）。在像这样的方法调用表达式中，对象 o 会成为调用上下文，<strong>而函数体可以通过关键字 this 引用这个对象</strong>。</p>
<p>多数方法调用使用点号进行属性访问，但使用方括号的属性访问表达式也可以实现方法调用。</p>
<p>方法和 this 关键字是面向对象编程范式的核心。任何用作方法的函数实际上都会隐式收到一个参数，即调用它的对象。通常，方法会在对象上执行某些操作，而方法调用语法是表达函数操作对象这一事实的直观方式。</p>
<p>如果方法返回对象，那么基于这个方法调用的返回值还可以继续调用其他方法。这样就会得到表现为一个表达式的一系列方法调用（或方法调用链）​。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">doStepOne</span>().<span class="title function_">then</span>(doStepTwo).<span class="title function_">then</span>(doFinalAction).<span class="title function_">catch</span>(handleError);</span><br></pre></td></tr></table></figure>
<p>如果你写的方法没有自己的返回值，可以考虑让它返回 this。如果能在自己的 API 中统一这么做，那就可以支持一种被称为方法调用链（method channing）的编程风格。这样只要给对象命名，之后就可以连续调用这个对象的方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Square</span>().<span class="title function_">x</span>(<span class="number">100</span>).<span class="title function_">y</span>(<span class="number">100</span>).<span class="title function_">color</span>(<span class="string">&quot;red&quot;</span>).<span class="title function_">show</span>();</span><br></pre></td></tr></table></figure>
<p>注意，this 是个关键字，不是变量也不是属性名。JavaScript 语法不允许给 this 赋值。this 关键字不具有变量那样的作用域机制，除了箭头函数，嵌套函数不会继承包含函数的 this 值。这里有一个常见的错误，就是对于定义在方法中的嵌套函数，如果将其当作函数来调用，以为可以使用 this 获得这个方法的调用上下文：</p>
<ul>
<li>如果嵌套函数被当作方法来调用，那它的 this 值就是调用它的对象</li>
<li>如果嵌套函数（不是箭头函数）被当作函数来调用，则它的 this 值要么是全局对象（非严格模式）​，要么是 undefined（严格模式）​。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  <span class="attr">m</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === o); <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === o); <span class="comment">// =&gt; false</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(self === o); <span class="comment">// =&gt; true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">f</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.<span class="title function_">m</span>()</span><br></pre></td></tr></table></figure>
<p>上面代码也展示了如何在嵌套行数中访问得到 o 对象，即通过在外层函数中额外定义 self 变量。在 ES6 及之后的版本中，解决这个问题的另一个技巧是把嵌套函数 f 转换为箭头函数，<strong>因为箭头函数可以继承 this 值</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === o); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="title function_">f</span>();</span><br></pre></td></tr></table></figure>
<p>还有一个技巧是调用嵌套函数的 bind() 方法，来定义一个在指定对象上被隐式调用的新函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span> === o; <span class="comment">// =&gt; true</span></span><br><span class="line">&#125;).<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br></pre></td></tr></table></figure>
<h3 id="构造函数调用"><a class="markdownIt-Anchor" href="#构造函数调用"></a> 构造函数调用</h3>
<p>如果函数或方法调用前面加了一个关键字 new，那它就是构造函数调用。构造函数调用与常规函数和方法调用的区别在于参数处理、调用上下文和返回值。</p>
<ul>
<li>假如没有参数列表，构造函数调用时其实也可以省略空圆括号</li>
<li>构造函数调用会创建一个新的空对象，这个对象继承构造函数的 prototype 属性指定的对象</li>
</ul>
<p>在构造函数中可以通过 this 关键字引用这个新创建的对象。即使构造函数调用看起来像方法调用，构造函数的调用上下文也是新创建的对象，而不是方法调用所对应的对象。即在 <code>new o.m</code> o 不会用作调用上下文。</p>
<ul>
<li>构造函数正常情况下不使用 return 关键字，而是初始化新对象并在到达函数体末尾时隐式返回这个对象。此时，这个新对象就是构造函数调用表达式的值</li>
<li>但是，如果构造函数显式使用了 return 语句返回某个对象，那该对象就会变成调用表达式的值</li>
<li>如果构造函数使用 return 但没有返回值，或者返回的是一个原始值，则这个返回值会被忽略，仍然以新创建的对象作为调用表达式的值</li>
</ul>
<h3 id="间接调用"><a class="markdownIt-Anchor" href="#间接调用"></a> 间接调用</h3>
<p>JavaScript 函数是对象，与其他 JavaScript 对象一样，JavaScript 函数也有方法。其中有两个方法 <code>call()</code> 和 <code>apply()</code>，可以用来间接调用函数。这两个方法允许我们指定调用时的 this 值，这意味着可以将任意函数作为任意对象的方法来调用，即使这个函数实际上并不是该对象的方法。</p>
<h3 id="隐式函数调用"><a class="markdownIt-Anchor" href="#隐式函数调用"></a> 隐式函数调用</h3>
<p>有一些 JavaScript 语言特性看起来不像函数调用，但实际上会导致某些函数被调用。</p>
<ul>
<li>如果对象有获取方法或设置方法，则查询或设置其属性值可能会调用这些方法</li>
<li>当对象在字符串上下文中使用时（比如当拼接对象与字符串时）​，会调用对象的 toString() 方法。类似地，当对象用于数值上下文时，则会调用它的 valueOf() 方法</li>
<li>在遍历可迭代对象的元素时，也会涉及一系列方法调用</li>
<li>标签模板字面量是一种伪装的函数调用</li>
<li>代理对象的行为完全由函数控制。这些对象上的几乎任何操作都会导致一个函数被调用</li>
</ul>
<h2 id="函数实参与形参"><a class="markdownIt-Anchor" href="#函数实参与形参"></a> 函数实参与形参</h2>
<p>JavaScript 函数定义不会指定函数形参的类型，函数调用也不对传入的实参进行任何类型检查。事实上，JavaScript 函数调用连传入实参的个数都不检查。</p>
<ul>
<li>当调用函数时传入的实参少于声明的形参时，额外的形参会获得默认值，通常是 undefined（因此可选参数一定要放到参数列表的后面，这样调用时才可以省略）</li>
<li>在 ES6 及更高的版本中，可以在函数形参列表中直接为每个参数定义默认值。语法是在形参名后面加上等于号和默认值，这样在没有给该形参传值时就会使用这个默认值</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getPropertyNames</span>(<span class="params">o, a = []</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> property <span class="keyword">in</span> o) &#123;</span><br><span class="line">        a.<span class="title function_">push</span>(property);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数的形参默认值表达式会在函数调用时求值，不会在定义时求值。因此每次调用 <code>getPropertyNames()</code> 函数时如果只传一个参数，都创建并传入一个新的空数组</li>
<li>可以使用变量或函数调用计算形参的默认值。即如果函数有多个形参，则可以使用前面参数的值来定义后面参数的默认值</li>
<li>形参默认值也可以在箭头函数中使用</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> <span class="title function_">rectangle</span> = (<span class="params">width, height = width * <span class="number">2</span></span>) =&gt; (&#123;width, height&#125;)</span><br><span class="line">&gt; <span class="title function_">rectangle</span>(<span class="params"><span class="number">1</span></span>)</span><br><span class="line">&#123; <span class="attr">width</span>: <span class="number">1</span>, <span class="attr">height</span>: <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="剩余形参与可变长度实参列表"><a class="markdownIt-Anchor" href="#剩余形参与可变长度实参列表"></a> 剩余形参与可变长度实参列表</h2>
<p>剩余形参（rest parameter）是一种允许你将不定数量的参数表示为一个数组的函数参数。这对于处理未知数量的参数非常有用，特别是在创建可变参数的函数时。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">max</span>(<span class="params">first=-<span class="literal">Infinity</span>, ...rest</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> maxValue = first;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> rest) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v &gt; maxValue) &#123;</span><br><span class="line">      maxValue = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> maxValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">max</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>剩余形参前面有 3 个点，而且必须是函数声明中最后一个参数</li>
<li>在调用有剩余形参的函数时，传入的实参首先会赋值到非剩余形参，然后所有剩余的实参（也是剩余参数）会保存在一个数组中赋值给剩余形参</li>
<li>函数体内，剩余形参的值始终是数组。数组有可能为空，但剩余形参永远不可能是 undefined（所以不要给剩余形参定义默认值，这样既没用，也不合法）</li>
</ul>
<p>一定要分清在函数定义中用于定义剩余形参的 <code>...</code> 和扩展操作符 <code>...</code>，后者可以在函数调用中使用。</p>
<h3 id="arguments-对象"><a class="markdownIt-Anchor" href="#arguments-对象"></a> Arguments 对象</h3>
<p>剩余形参是 ES6 引入 JavaScript 的。在 ES6 之前，变长函数是基于 Arguments 对象实现的。在任何函数体内，标识符 arguments 引用该次调用的 Arguments 对象。Arguments 对象是一个类数组对象。它允许通过数值而非名字取得传给函数的参数值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">max</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> maxValue = -<span class="title class_">Infinity</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">arguments</span>[i] &gt; maxValue) &#123;</span><br><span class="line">      maxValue = <span class="variable language_">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> maxValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">max</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>
<p>Arguments 对象可以追溯到 JavaScript 诞生之初，它效率低且难以优化，但在新写的代码中应该避免使用它。</p>
<h3 id="在函数调用中使用扩展操作符"><a class="markdownIt-Anchor" href="#在函数调用中使用扩展操作符"></a> 在函数调用中使用扩展操作符</h3>
<p>扩展操作符 <code>...</code> 用于展开或 <code>扩展</code> 数组（或任何可迭代对象，如字符串）的元素。该操作符可以出现在函数调用中。</p>
<p>从求值并产生一个值的角度说，…并不是真正的操作符。应该说，它是一种可以针对数组字面量或函数调用使用的特殊 JavaScript 语法。</p>
<p>剩余形参和扩展操作符经常同时出现。</p>
<h3 id="把函数实参解构为形参"><a class="markdownIt-Anchor" href="#把函数实参解构为形参"></a> 把函数实参解构为形参</h3>
<p>调用函数时如果传入一个实参列表，则所有参数值都会被赋给函数定义时声明的形参。函数调用的这个初始化阶段非常类似变量赋值。因此在函数调用时可以进行解构赋值。</p>
<ul>
<li>如果我们定义了一个函数，它的形参名包含在方括号中，那说明这个函数期待对每对方括号都传入一个数组值。作为调用过程的一部分，我们传入的数组实参会被解构赋值为单独的命名形参。</li>
<li>类似地，如果定义的函数需要一个对象实参，也可以把传入的对象解构赋值给形参</li>
<li>在解构赋值中也可以为形参定义默认值</li>
<li>解构数组时，可以为被展开数组中的额外元素定义一个剩余形参</li>
<li>在 ES2018 中，解构对象时也可以使用剩余形参。此时剩余形参的值是一个对象，包含所有未被解构的属性。对象剩余形参经常与对象扩展操作一起使用，</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">vectorAdd</span>(<span class="params">[x1, y1], [x2, y2]</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [x1 + x2, y1 + y2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">vectorAdd</span>([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// =&gt; [4, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">vectorMultiply</span>(<span class="params">&#123;x, y&#125;, scalar</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">x</span>: x*scalar, <span class="attr">y</span>: y*scalar&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">vectorMultiply</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;, <span class="number">2</span>); <span class="comment">// =&gt; &#123; x: 2, y: 4 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">vectorObjectAdd</span>(<span class="params">&#123;x:x1, y:y1&#125;, &#123;x:x2, y:y2&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">x</span>: x1 + x2, <span class="attr">y</span>: y1 + y2&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">vectorObjectAdd</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;, &#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">4</span>&#125;); <span class="comment">// =&gt; &#123; x: 4, y: 6 &#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">vectorMultiply</span>(<span class="params">&#123;x, y, z=<span class="number">0</span>, ...props&#125;, scalar</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">x</span>: x*scalar, <span class="attr">y</span>: y*scalar, <span class="attr">z</span>:z*scalar, ...props&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">vectorMultiply</span>(&#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>, <span class="attr">w</span>:-<span class="number">1</span>&#125;, <span class="number">2</span>)) <span class="comment">// &#123; x: 2, y: 4, z: 0, w: -1 &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="参数类型"><a class="markdownIt-Anchor" href="#参数类型"></a> 参数类型</h3>
<p>JavaScript 方法的参数没有预定义的类型，在调用传参时也没有类型检查。可以用描述性强的名字作为函数参数，同时通过在注释中解释函数的参数来解决这个问题。</p>
<p>有时候需要函数检查参数的类型，对函数来说，在发现传入的值不对时立即失败，一定好过先执行逻辑再以出错告终，而且前者比后者更清晰。</p>
<h2 id="函数作为值"><a class="markdownIt-Anchor" href="#函数作为值"></a> 函数作为值</h2>
<p>在 JavaScript 中，函数不仅是语法，也是值。这意味着可以把函数赋值给变量、保存为对象的属性或者数组的元素、作为参数传给其他函数等等。</p>
<p>之前说过，函数声明就是创建一个新函数对象并将其赋值给一个变量，而该变量名就是函数名字。我们可以将该函数对象赋值给其他变量，之后再通过新的变量名进行函数调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">function</span> <span class="title function_">square</span>(<span class="params">x</span>) &#123; <span class="keyword">return</span> x*x; &#125;</span><br><span class="line">&gt; <span class="keyword">typeof</span> square</span><br><span class="line"><span class="string">&#x27;function&#x27;</span></span><br><span class="line">&gt; <span class="keyword">let</span> s = square</span><br><span class="line">&gt; <span class="title function_">s</span>(<span class="number">4</span>)</span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure>
<p>除了变量，也可以把函数赋值给对象的属性。如前所述，这时候把函数称作 <code>方法</code>。函数甚至可以没有名字，比如可以把匿名函数作为一个数组元素：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> a = [<span class="function"><span class="params">x</span> =&gt;</span> x*x, <span class="number">20</span>];</span><br><span class="line">&gt; a[<span class="number">0</span>](a[<span class="number">1</span>])</span><br><span class="line"><span class="number">400</span></span><br></pre></td></tr></table></figure>
<p><strong>函数在 JavaScript 中并不是原始值，而是一种特殊的对象。这意味着函数也可以有属性。</strong></p>
<ul>
<li>如果一个函数需要一个 <code>静态</code> 变量，且这个变量的值需要在函数每次调用时都能访问到，则通常把这个变量定义为函数自身的一个属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uniqInteger.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">uniqInteger</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> uniqInteger.<span class="property">count</span>++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">uniqInteger</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">uniqInteger</span>());</span><br></pre></td></tr></table></figure>
<ul>
<li>如下代码则更加灵活，它使用 <code>[]</code> 语法来给函数本身添加属性，此时函数本身有点类似于数组了。可以通过该方式来缓存某些计算结果</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>) &#123; <span class="keyword">return</span> f[x]; &#125;</span><br><span class="line">&gt; f[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt; f[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt; <span class="title function_">f</span>(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt; <span class="title function_">f</span>(<span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt; f</span><br><span class="line">[<span class="title class_">Function</span>: f] &#123; <span class="string">&#x27;1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数作为命名空间"><a class="markdownIt-Anchor" href="#函数作为命名空间"></a> 函数作为命名空间</h2>
<p>在函数体内声明的变量在函数外部不可见。为此，有时候可以把函数用作临时的命名空间，这样可以保证在其中定义的变量不会污染全局命名空间。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// your code</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>在一个表达式中定义并调用匿名函数的技术非常常用，因此甚至有了别称，叫 <code>立即调用函数表达式</code>（immediately invoked function expression）。</p>
<p>注意，function 外围的圆括号是必须的。因为如果没有它，JavaScript 解释器会把 function 关键字作为函数声明语句来解析。有了这对括号，解释器会把它正确地识别为函数定义表达式。</p>
<h2 id="闭包"><a class="markdownIt-Anchor" href="#闭包"></a> 闭包</h2>
<p>与多数现代编程语言一样，JavaScript 使用词法作用域（lexical scoping）。这意味着函数执行时使用的是定义函数时生效的变量作用域，而不是调用函数时生效的变量作用域。为了实现词法作用域，JavaScript 函数对象的内部状态不仅要包括函数代码，还要包括对函数定义所在作用域的引用。<strong>这种函数对象与作用域（即一组变量绑定）组合起来解析函数变量的机制，在计算机科学文献中被称作闭包（closure）</strong>。</p>
<p>严格来讲，所有JavaScript函数都是闭包。但由于多数函数调用与函数定义都在同一作用域内，所以闭包的存在无关紧要。<strong>闭包真正值得关注的时候，是定义函数与调用函数的作用域不同的时候</strong>。最常见的情形就是一个函数返回了在它内部定义的嵌套函数。很多强大的编程技术都是建立在这种嵌套函数闭包之上的，因此嵌套函数闭包在 JavaScript 程序中也变得比较常见。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scope = <span class="string">&quot;global scope&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkscope</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> scope = <span class="string">&quot;local scope&quot;</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> scope;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">checkscope</span>()());</span><br></pre></td></tr></table></figure>
<p>JavaScript 函数是使用定义它们的作用域来执行的。在定义嵌套函数 <code>f()</code> 的作用域中，变量 scope 绑定的值是 <code>local scope</code>​，该绑定在 f 执行时仍然有效，无论它在哪里执行。</p>
<p><strong>这正是闭包惊人且强大的本质：它们会捕获自身定义所在外部函数的局部变量（及参数）绑定</strong>。闭包可以捕获一次函数调用的局部变量，可以将这些变量作为私有状态。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> uniqCounter = (<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">let</span> counter = <span class="number">0</span>; <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> counter++; &#125;; &#125;)()</span><br><span class="line">&gt; <span class="title function_">uniqCounter</span>()</span><br><span class="line"><span class="number">0</span></span><br><span class="line">&gt; <span class="title function_">uniqCounter</span>()</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt; <span class="title function_">uniqCounter</span>()</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>类似 counter 这样的私有变量并非只能由一个闭包独享。同一个外部函数中完全可以定义两个或更多嵌套函数，而它们共享相同的作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> n++; &#125;,</span><br><span class="line">    <span class="attr">reset</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; n = <span class="number">0</span>; &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="title function_">counter</span>(), d = <span class="title function_">counter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="title function_">count</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="title function_">count</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d.<span class="title function_">count</span>());</span><br><span class="line">c.<span class="title function_">reset</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="title function_">count</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d.<span class="title function_">count</span>());</span><br></pre></td></tr></table></figure>
<p>每次调用 counter() 都会创建一个新作用域（与之前调用创建的作用域相互独立），作用中域中创建的一个新私有变量。因此如果调用两次 counter()，就会得到拥有两个不同私有变量的计数器对象。在一个计数器上调用count() 或 reset() 不会影响另一个计数器。</p>
<p>有一点需要指出的是，可以将这种闭包技术与属性获取方法和设置方法组合使用。下面的例子使用自己的参数n 保存供属性访问器方法共享的私有状态：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">count</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">count</span>() &#123; <span class="keyword">return</span> n++; &#125;,</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">count</span>(<span class="params">value</span>) &#123; n = value &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="title function_">count</span>(<span class="number">10</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="property">count</span>) <span class="comment">// =&gt; 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="property">count</span>) <span class="comment">// =&gt; 11</span></span><br><span class="line">c.<span class="property">count</span> = <span class="number">20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="property">count</span>) <span class="comment">// =&gt; 21</span></span><br></pre></td></tr></table></figure>
<p>与闭包关联的作用域是 <code>活的</code>​，嵌套函数不会创建作用域的私有副本或截取变量绑定的静态快照。再来看一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">funcs1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> funcs = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs[i] = <span class="function">() =&gt;</span> i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> funcs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">funcs2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> funcs = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs[i] = <span class="function">() =&gt;</span> i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> funcs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">funcs1</span>()[<span class="number">5</span>]()) <span class="comment">// =&gt; 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">funcs2</span>()[<span class="number">5</span>]()) <span class="comment">// =&gt; 5</span></span><br></pre></td></tr></table></figure>
<p>这里很容易犯错：</p>
<ul>
<li>通过 var 声明的变量在整个函数作用域内都有定义。代码中的 for 循环使用 <code>var i</code> 声明循环变量，因此变量 i 的作用域是整个函数体，因此所有闭包都捕获的是同一个 i 变量。当调用闭包时，它们都访问的是同一个变量 i 的最新值，即 10</li>
<li>通过 let 声明的变量只在声明它们的块作用域内有效。因此，每次迭代都会创建一个新的、与其他循环不同的独立作用域，每个闭包捕获的都是迭代时所创建的 i 变量，该变量的值不会被后续迭代改变（因为每次迭代都会创建一个新的 i 值）</li>
</ul>
<p>在写闭包的时候，要注意：this 是 JavaScript 关键字，不是变量。如前所述，箭头函数继承包含它们的函数中的 this 值，但使用 function 定义的函数并非如此。因此如果你要写的闭包需要使用其包含函数的 this 值，那么可以通过以下任意方式来解决：</p>
<ul>
<li>使用箭头函数</li>
<li>调用 bind()</li>
<li>把外部的 this 值赋给你的闭包将继承的变量</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br></pre></td></tr></table></figure>
<h2 id="函数属性-方法与构造函数"><a class="markdownIt-Anchor" href="#函数属性-方法与构造函数"></a> 函数属性、方法与构造函数</h2>
<p>对函数使用 typeof 操作符会返回字符串 <code>function</code>​，但函数实际上是一种特殊的 JavaScript 对象。由于函数是对象，因此它们也有属性和方法，甚至还有一个 Function() 构造函数可以用来创建新函数对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">typeof</span> (<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;)</span><br><span class="line"><span class="string">&#x27;function&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="length-属性"><a class="markdownIt-Anchor" href="#length-属性"></a> length 属性</h3>
<p>函数有一个只读的 length 属性，表示函数在参数列表中声明的形参个数。如果函数有剩余形参，则这个剩余形参不包含在 length 属性内。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> a = <span class="keyword">function</span>(<span class="params">x, y</span>) &#123;&#125;</span><br><span class="line">&gt; a.<span class="property">length</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt; a = <span class="keyword">function</span>(<span class="params">x, ...rest</span>) &#123;&#125;</span><br><span class="line">&gt; a.<span class="property">length</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="name-属性"><a class="markdownIt-Anchor" href="#name-属性"></a> name 属性</h3>
<p>函数有一个只读的 name 属性，表示定义函数时使用的名字。如果是未命名的函数，表示在第一次创建这个函数时赋给该函数的变量名或属性名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> b = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&gt; b.<span class="property">name</span></span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br><span class="line">&gt; b = <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&gt; b.<span class="property">name</span></span><br><span class="line"><span class="string">&#x27;test&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="prototype-属性"><a class="markdownIt-Anchor" href="#prototype-属性"></a> prototype 属性</h3>
<p>除了箭头函数，所有函数都有一个 prototype 属性，这个属性引用一个被称为原型对象的对象。每个函数都有自己的原型对象。当函数被作为构造函数使用时，新创建的对象从这个原型对象继承属性。</p>
<h3 id="call-和-apply-方法"><a class="markdownIt-Anchor" href="#call-和-apply-方法"></a> call() 和 apply() 方法</h3>
<p><code>call()</code> 和 <code>apply()</code> 允许间接调用一个函数，就像这个函数是某个其他对象的方法一样：</p>
<ul>
<li>call() 和 apply() 的第一个参数都是要在其上调用这个函数的对象。也就是函数的调用上下文，在函数体内它会变成 this 关键字的值</li>
<li>箭头函数从定义它的上下文中继承 this 值。这个 this 值不能通过 call() 和 apply() 方法重写。如果对箭头函数调用这两个方法，那第一个参数实际上会被忽略</li>
<li>除了作为调用上下文传给 call() 的第一参数，后续的所有参数都会传给被调用的函数</li>
<li>apply() 方法与 call() 方法类似，只不过要传给函数的参数需要以数组的形式提供</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">m</span>) &#125;</span><br><span class="line">&gt; <span class="keyword">let</span> o = &#123;<span class="attr">m</span>: <span class="number">10</span>, <span class="attr">n</span>: <span class="number">20</span>&#125;</span><br><span class="line">&gt; test.<span class="title function_">apply</span>(o)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>如下是一个更复杂的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">trace</span>(<span class="params">o, m</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> orignal = o[m]</span><br><span class="line">  o[m] = <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="string">&quot;Enterning: &quot;</span>, m);</span><br><span class="line">    <span class="keyword">let</span> result = orignal.<span class="title function_">apply</span>(o, args);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="string">&quot;Exiting: &quot;</span>, m);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  <span class="attr">m</span>: <span class="keyword">function</span>(<span class="params">x, y</span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(x, y, <span class="variable language_">this</span>.<span class="property">n</span>)&#125;,</span><br><span class="line">  <span class="attr">n</span>: <span class="number">20</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">trace</span>(o, <span class="string">&quot;m&quot;</span>);</span><br><span class="line">o.<span class="title function_">m</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># node trace.js</span></span><br><span class="line">2025-01-22T03:12:21.142Z Enterning:  m</span><br><span class="line">1 2 20</span><br><span class="line">2025-01-22T03:12:21.144Z Exiting:  m</span><br></pre></td></tr></table></figure>
<h3 id="bind"><a class="markdownIt-Anchor" href="#bind"></a> bind</h3>
<p>bind() 方法的主要目的是把函数绑定到对象。如果在函数 f 上调用 <code>bind()</code> 方法并传入对象 o，则这个方法会返回一个新函数。如果作为函数来调用这个新函数，就会像 f 是 o 的方法一样调用原始函数。传给这个新函数的所有参数都会传给原始函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">y</span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">x</span> + y; &#125;</span><br><span class="line">&gt; <span class="keyword">let</span> o = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line">&gt; <span class="keyword">let</span> g = f.<span class="title function_">bind</span>(o)</span><br><span class="line">&gt; <span class="title function_">g</span>(<span class="number">10</span>)</span><br><span class="line"><span class="number">11</span></span><br><span class="line">&gt; <span class="keyword">let</span> p = &#123;<span class="attr">x</span>:<span class="number">10</span>, g&#125;;</span><br><span class="line">&gt; p.<span class="title function_">g</span>(<span class="number">10</span>)</span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure>
<p><strong>箭头函数从定义它们的环境中继承this值，且这个值不能被 bind() 覆盖</strong>。因此 bind() 对箭头函数是不起作用的。</p>
<p>事实上，除了把函数绑定到对象，bind() 方法还会做其他事：</p>
<ul>
<li>第一个参数之后传给bind() 的参数也会随着this值一起被绑定，从而可以实现 <code>部分应用</code>。部分应用是函数式编程中的一个常用技术，有时候也被称为柯里化（currying）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> <span class="title function_">sum</span> = (<span class="params">x, y</span>) =&gt; x + y;</span><br><span class="line">&gt; <span class="keyword">let</span> succ = sum.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="number">1</span>);</span><br><span class="line">&gt; <span class="title function_">succ</span>(<span class="number">2</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="tostring-方法"><a class="markdownIt-Anchor" href="#tostring-方法"></a> toString() 方法</h3>
<p>与所有 JavaScript 对象一样，函数也有 toString() 方法。ECMAScript 规范要求这个方法返回一个符合函数声明语句的字符串。</p>
<ul>
<li>很多实现都是返回函数的源代码</li>
<li>内置函数返回的字符串中通常包含 <code>[native code]​</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; sum.<span class="title function_">toString</span>()</span><br><span class="line"><span class="string">&#x27;(x, y) =&gt; x + y&#x27;</span></span><br><span class="line">&gt; sum.<span class="property">toString</span>.<span class="title function_">toString</span>()</span><br><span class="line"><span class="string">&#x27;function toString() &#123; [native code] &#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="function-构造函数"><a class="markdownIt-Anchor" href="#function-构造函数"></a> Function() 构造函数</h3>
<p>因为函数是对象，所以就有一个 <code>Function()</code> 构造函数可以用来创建新函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> f0 = <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;return x * y&quot;</span>);</span><br><span class="line">&gt; <span class="title function_">f0</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Function() 构造函数可以接收任意多个字符串参数，其中最后一个参数是函数体的文本</li>
<li>这个函数体文本中可以包含任意 JavaScript 语句，相互以分号分隔</li>
<li>传给这个构造函数的其他字符串都用于指定新函数的参数名</li>
<li>Function() 构造函数不接收任何指定新函数名字的参数</li>
</ul>
<p>要理解Function()构造函数，需要理解以下几点：</p>
<ul>
<li>Function() 函数允许在运行时动态创建和编译 JavaScript 函数</li>
<li>Function() 构造函数每次被调用时都会解析函数体并创建一个新函数对象。如果在循环中或者被频繁调用的函数中出现了对它的调用，可能会影响程序性能。相对而言，出现在循环中的嵌套函数和函数表达式不会每次都被重新编译</li>
<li>最后，也是关于Function()非常重要的一点，就是它创建的函数不使用词法作用域，而是始终编译为如同顶级函数一样</li>
</ul>
<h2 id="函数式编程"><a class="markdownIt-Anchor" href="#函数式编程"></a> 函数式编程</h2>
<p>JavaScript 可以把函数作为对象来操作意味着可以在 JavaScript 中使用函数式编程技巧。像 map() 和 reduce() 这样的数组方法就特别适合函数式编程风格。</p>
<h3 id="使用函数处理数组"><a class="markdownIt-Anchor" href="#使用函数处理数组"></a> 使用函数处理数组</h3>
<p>如下使用函数式编程风格，计算数组元素的平均值和标准差：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">x, y</span>) =&gt; x + y;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">square</span> = x =&gt; x * x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> mean = data.<span class="title function_">reduce</span>(sum) / data.<span class="property">length</span></span><br><span class="line"><span class="keyword">let</span> deviations = data.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x - mean);</span><br><span class="line"><span class="keyword">let</span> stddev = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(deviations.<span class="title function_">map</span>(square).<span class="title function_">reduce</span>(sum) / (data.<span class="property">length</span> - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mean, stddev);</span><br></pre></td></tr></table></figure>
<p>如果想把里面的一些面向对象编程风格也去除，可以再重新定义 map 和 reduce 方法。</p>
<h3 id="高阶函数"><a class="markdownIt-Anchor" href="#高阶函数"></a> 高阶函数</h3>
<p>高阶函数就是操作函数的函数，它接收一个或多个函数作为参数并返回一个新函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mapper</span>(<span class="params">f</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">a</span> =&gt;</span> a.<span class="title function_">map</span>(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">increment</span> = x =&gt; x + <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">mapper</span>(increment)([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])); <span class="comment">// =&gt; [2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p>再看一个示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params">f, g</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// f 和 g 被调用时，使用与 h 相同的 this 值</span></span><br><span class="line">    <span class="keyword">return</span> f.<span class="title function_">call</span>(<span class="variable language_">this</span>, g.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">m</span>: <span class="number">10</span>, <span class="attr">n</span>: <span class="number">20</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> dumpM = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">m</span>); &#125;;</span><br><span class="line"><span class="keyword">let</span> dumpN = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">n</span>); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 20</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line">o.<span class="property">h</span> = <span class="title function_">compose</span>(dumpM, dumpN);</span><br><span class="line">o.<span class="title function_">h</span>();</span><br></pre></td></tr></table></figure>
<h3 id="函数的部分应用"><a class="markdownIt-Anchor" href="#函数的部分应用"></a> 函数的部分应用</h3>
<p>bind 方法可以返回一个新的函数，这个新函数在指定的上下文中以指定的参数调用 f。我们称之为 <code>把函数绑定到一个对象上并应用了部分的参数</code>。<code>bind()</code> 左侧部分应用参数，即传给 <code>bind()</code> 的参数会放在传给原始函数参数列表的开头。但是也有可能在右侧部分应用参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">partialLeft</span>(<span class="params">f, ...outerArgs</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...innerArgs</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = [...outerArgs, ...innerArgs];</span><br><span class="line">    <span class="keyword">return</span> f.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">partialRight</span>(<span class="params">f, ...outerArgs</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...innerArgs</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = [...innerArgs, ...outerArgs];</span><br><span class="line">    <span class="keyword">return</span> f.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">partial</span>(<span class="params">f, ...outerArgs</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...innerArgs</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = [...outerArgs];</span><br><span class="line">    <span class="keyword">let</span> innerIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; args.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (args[i] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        args[i] = innerArgs[innerIndex++];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    args.<span class="title function_">push</span>(...innerArgs.<span class="title function_">slice</span>(innerIndex));</span><br><span class="line">    <span class="keyword">return</span> f.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">function</span>(<span class="params">x, y, z</span>) &#123; <span class="keyword">return</span> x * (y - z); &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">partialLeft</span>(f, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>))        <span class="comment">// 2 * (3- 4) = -2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">partialRight</span>(f, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>))       <span class="comment">// 3 * (4 - 2) = 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">partial</span>(f, <span class="literal">undefined</span>, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>)) <span class="comment">// 3 * (2 - 4) = -6</span></span><br></pre></td></tr></table></figure>
<h3 id="函数记忆"><a class="markdownIt-Anchor" href="#函数记忆"></a> 函数记忆</h3>
<p>如下展示了高阶函数 memorize，它可以接受一个函数参数，并返回这个函数的记忆版本（即可以缓存之前的计算结果）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">memorize</span>(<span class="params">f</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = args.<span class="property">length</span> + args.<span class="title function_">join</span>(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (cache.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache.<span class="title function_">get</span>(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> result = f.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      cache.<span class="title function_">set</span>(key, result);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> factorial = <span class="title function_">memorize</span>(<span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (n &lt;= <span class="number">1</span>) ? <span class="number">1</span> : n * <span class="title function_">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">factorial</span>(<span class="number">5</span>));</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/%E5%89%8D%E7%AB%AF/" rel="tag"># 前端</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/01/16/javascript-guide-09/" rel="prev" title="JavaScript 权威指南 09：类">
      <i class="fa fa-chevron-left"></i> JavaScript 权威指南 09：类
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/01/14/javascript-guide-07/" rel="next" title="JavaScript 权威指南 07：数组">
      JavaScript 权威指南 07：数组 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text"> 函数简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="nav-number">2.</span> <span class="nav-text"> 定义函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="nav-number">2.1.</span> <span class="nav-text"> 函数声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">2.2.</span> <span class="nav-text"> 函数表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.</span> <span class="nav-text"> 箭头函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0"><span class="nav-number">2.4.</span> <span class="nav-text"> 嵌套函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-number">3.</span> <span class="nav-text"> 调用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">3.1.</span> <span class="nav-text"> 函数调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="nav-number">3.2.</span> <span class="nav-text"> 方法调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">3.3.</span> <span class="nav-text"> 构造函数调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%B4%E6%8E%A5%E8%B0%83%E7%94%A8"><span class="nav-number">3.4.</span> <span class="nav-text"> 间接调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">3.5.</span> <span class="nav-text"> 隐式函数调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9E%E5%8F%82%E4%B8%8E%E5%BD%A2%E5%8F%82"><span class="nav-number">4.</span> <span class="nav-text"> 函数实参与形参</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%A9%E4%BD%99%E5%BD%A2%E5%8F%82%E4%B8%8E%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E5%AE%9E%E5%8F%82%E5%88%97%E8%A1%A8"><span class="nav-number">5.</span> <span class="nav-text"> 剩余形参与可变长度实参列表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#arguments-%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.1.</span> <span class="nav-text"> Arguments 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">5.2.</span> <span class="nav-text"> 在函数调用中使用扩展操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%8A%E5%87%BD%E6%95%B0%E5%AE%9E%E5%8F%82%E8%A7%A3%E6%9E%84%E4%B8%BA%E5%BD%A2%E5%8F%82"><span class="nav-number">5.3.</span> <span class="nav-text"> 把函数实参解构为形参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.4.</span> <span class="nav-text"> 参数类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%80%BC"><span class="nav-number">6.</span> <span class="nav-text"> 函数作为值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">7.</span> <span class="nav-text"> 函数作为命名空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AD%E5%8C%85"><span class="nav-number">8.</span> <span class="nav-text"> 闭包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7-%E6%96%B9%E6%B3%95%E4%B8%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">9.</span> <span class="nav-text"> 函数属性、方法与构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#length-%E5%B1%9E%E6%80%A7"><span class="nav-number">9.1.</span> <span class="nav-text"> length 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#name-%E5%B1%9E%E6%80%A7"><span class="nav-number">9.2.</span> <span class="nav-text"> name 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#prototype-%E5%B1%9E%E6%80%A7"><span class="nav-number">9.3.</span> <span class="nav-text"> prototype 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#call-%E5%92%8C-apply-%E6%96%B9%E6%B3%95"><span class="nav-number">9.4.</span> <span class="nav-text"> call() 和 apply() 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bind"><span class="nav-number">9.5.</span> <span class="nav-text"> bind</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tostring-%E6%96%B9%E6%B3%95"><span class="nav-number">9.6.</span> <span class="nav-text"> toString() 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#function-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">9.7.</span> <span class="nav-text"> Function() 构造函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="nav-number">10.</span> <span class="nav-text"> 函数式编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84"><span class="nav-number">10.1.</span> <span class="nav-text"> 使用函数处理数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="nav-number">10.2.</span> <span class="nav-text"> 高阶函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E9%83%A8%E5%88%86%E5%BA%94%E7%94%A8"><span class="nav-number">10.3.</span> <span class="nav-text"> 函数的部分应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%AE%B0%E5%BF%86"><span class="nav-number">10.4.</span> <span class="nav-text"> 函数记忆</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">215</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">


  

</body>
</html>
