<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="如果说常规编程是写代码去操作数据，那么元编程就是写代码去操作其他代码。在像 JavaScript 这样的动态语言中，编程与元编程之间的界限是模糊的。在更习惯于静态语言的程序员眼里，即便是迭代对象属性的 for&#x2F;in 循环这个小小的能力都可能被打上 元 标签。">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 权威指南 14：元编程">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2025/01/21/javascript-guide-14/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="如果说常规编程是写代码去操作数据，那么元编程就是写代码去操作其他代码。在像 JavaScript 这样的动态语言中，编程与元编程之间的界限是模糊的。在更习惯于静态语言的程序员眼里，即便是迭代对象属性的 for&#x2F;in 循环这个小小的能力都可能被打上 元 标签。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-01-21T06:17:53.000Z">
<meta property="article:modified_time" content="2025-06-18T06:25:56.913Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2025/01/21/javascript-guide-14/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JavaScript 权威指南 14：元编程 | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2025/01/21/javascript-guide-14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaScript 权威指南 14：元编程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-21 14:17:53" itemprop="dateCreated datePublished" datetime="2025-01-21T14:17:53+08:00">2025-01-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>如果说常规编程是写代码去操作数据，那么元编程就是写代码去操作其他代码。在像 JavaScript 这样的动态语言中，编程与元编程之间的界限是模糊的。在更习惯于静态语言的程序员眼里，即便是迭代对象属性的 <code>for/in</code> 循环这个小小的能力都可能被打上 <code>元</code> 标签。</p>
<span id="more"></span>
<h2 id="属性的特性"><a class="markdownIt-Anchor" href="#属性的特性"></a> 属性的特性</h2>
<p>JavaScript 的属性有名字和值，但每个属性也有 3 个关联的特性，用于指定属性的行为以及你可以对它执行什么操作：</p>
<ul>
<li>可写（writable）特性：指定是否可以修改属性的值</li>
<li>可枚举（enumerable）特性：指定是否可以通过 <code>for/in</code> 循环返回属性</li>
<li>可配置（configurable）特性：指定是否可以删除属性，以及是否可以修改属性的特性</li>
</ul>
<p><strong>对象字面量中定义的属性，或者通过常规赋值方式给对象定义的属性都可写、可枚举和可配置</strong>。之前说过，<code>数据属性</code> 有一个值 ，而 <code>访问器属性</code> 有一个获取方法和设置方法。我们可以把 value、get 和 set 方法都作为属性的特性来看待：</p>
<ul>
<li>数据属性的 4 个特性是 value、writable、enumerable 和 configurable</li>
<li>访问器属性的 4 个特性是 get、set、enumerable 和 configurable</li>
</ul>
<p>用于查询和设置属性特性的 JavaScript 方法使用一个被称为属性描述符（<code>property descriptor</code>）的对象，这个对象用于描述属性的 4 个特性。属性描述符对象拥有与它所描述的属性的特性相同的属性名。</p>
<p>要获得特定对象某个属性的属性描述符，可以调用 <code>Object.getOwnPropertyDescriptor()</code>。<code>Object.getOwnPropertyDescriptor()</code> 只对自有属性有效，对继承的属性或者不存在的属性返回 undefined。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="params">&#123;x:<span class="number">1</span>&#125;, <span class="string">&quot;x&quot;</span></span>)</span><br><span class="line">&#123; <span class="attr">value</span>: <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">const</span> random = &#123; <span class="keyword">get</span> <span class="title function_">octet</span>() &#123; <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">256</span>); &#125; &#125;;</span><br><span class="line">&gt; <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="params">random, <span class="string">&quot;octet&quot;</span></span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">get</span>: [<span class="title class_">Function</span>: get octet],</span><br><span class="line">  <span class="attr">set</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要设置属性的特性或者要创建一个具有指定特性的属性，可以调用 <code>Object.defineProperty()</code> 方法：传入要修改的对象、要创建或修改的属性的名字，以及属性描述符对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(o, <span class="string">&quot;x&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o.<span class="property">x</span>); <span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(o)); <span class="comment">// =&gt; []</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(o, <span class="string">&quot;x&quot;</span>, &#123;<span class="attr">writable</span>: <span class="literal">false</span>&#125;);</span><br><span class="line">o.<span class="property">x</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o.<span class="property">x</span>); <span class="comment">// =&gt; 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个属性依然是可配置的，因此可以通过修改它的 value 特性来改变该属性的值</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(o, <span class="string">&quot;x&quot;</span>, &#123;<span class="attr">value</span>: <span class="number">2</span>&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o.<span class="property">x</span>); <span class="comment">// =&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(o, <span class="string">&quot;x&quot;</span>, &#123;<span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o.<span class="property">x</span>); <span class="comment">// =&gt; 0</span></span><br></pre></td></tr></table></figure>
<p>传给 <code>Object.defineProperty()</code> 的属性描述符不一定 4 个特性都包含：</p>
<ul>
<li>如果是创建新属性，那么省略的特性会取得 false 或 undefined 值</li>
<li>如果是修改已有的属性，那么省略的特性就不会被修改</li>
</ul>
<p>这个方法只修改已经存在的自有属性，或者创建新的自有属性，不会修改继承的属性。如果想一次性创建或修改多个属性，可以使用 <code>Object.defineProperties()</code>：</p>
<ul>
<li>第一个参数是要修改的对象</li>
<li>第二个参数也是一个对象，该对象将要创建或修改的属性的名称映射到这些属性的属性描述符</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> p = <span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(&#123;&#125;, &#123;<span class="attr">x</span>: &#123;<span class="attr">value</span>:<span class="number">1</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>&#125;, <span class="attr">y</span>: &#123;<span class="attr">value</span>:<span class="number">2</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>&#125;&#125;)</span><br><span class="line">&gt; p</span><br><span class="line">&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure>
<p>之前介绍过 <code>Object.create()</code> 方法，这个方法的第一个参数是新创建对象的原型对象。这个方法也接收第二个可选的参数，该参数与 <code>Object.defineProperties()</code> 的第二个参数一样。给 <code>Object.create()</code> 传入一组属性描述符，可以为新创建的对象添加属性。</p>
<p><code>Object.defineProperty()</code>、<code>Object.defineProperties()</code> 都是返回修改后的对象。当违反如下规则时，就会抛出 <code>TypeError</code> 异常：</p>
<ul>
<li>如果对象不可扩展，可以修改其已有属性，但不能给它添加新属性</li>
<li>如果属性不可配置，不能修改其 configurable 或 enumerable 特性</li>
<li>如果访问器属性不可配置，不能修改其获取方法或设置方法，也不能把它修改为数据属性</li>
<li>如果数据属性不可配置，不能把它修改为访问器属性</li>
<li>如果数据属性不可配置，不能把它的 writable 特性由 false 修改为true，但可以由 true 修改为 false</li>
<li>如果数据属性不可配置且不可写，则不能修改它的值。不过，如果这个属性可配置但不可写，则可以修改它的值（相当于先把它配置为可写，然后修改它的值，再把它配置为不可写）​</li>
</ul>
<p>另外需要注意，之前介绍过 <code>Object.assign()</code> 函数，该函数可以把一个或多个源对象的属性值复制到目标对象。<code>Object.assign()</code> 只复制可枚举属性和属性值，但不复制属性的特性。这意味着如果源对象有一个访问器属性，那么复制到目标对象的是获取函数的返回值，而不是获取函数本身。</p>
<p>如下实现了一个 <code>Object.assign()</code> 的变体，它能够复制全部属性描述符而不仅仅复制属性值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Object</span>, <span class="string">&quot;assignDescriptors&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="keyword">function</span>(<span class="params">target, ...sources</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> source <span class="keyword">of</span> sources) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(source)) &#123;</span><br><span class="line">        <span class="keyword">let</span> desc = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(source, name);</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, name, desc);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> symbol <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(source)) &#123;</span><br><span class="line">        <span class="keyword">let</span> desc = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(source, symbol);</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, symbol, desc);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">c</span>: <span class="number">1</span>, <span class="keyword">get</span> <span class="title function_">count</span>() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">c</span>++; &#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> p = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, o);</span><br><span class="line"><span class="keyword">let</span> q = <span class="title class_">Object</span>.<span class="title function_">assignDescriptors</span>(&#123;&#125;, o);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">count</span>); <span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">count</span>); <span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(q.<span class="property">count</span>); <span class="comment">// =&gt; 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(q.<span class="property">count</span>); <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>
<h2 id="对象的可扩展能力"><a class="markdownIt-Anchor" href="#对象的可扩展能力"></a> 对象的可扩展能力</h2>
<p>对象的可扩展 <code>extensible</code> 特性控制是否可以给对象添加新属性，即是否可扩展。普通 JavaScript 对象默认是可扩展的。</p>
<ul>
<li>要确定一个对象是否可扩展，把它传给 <code>Object.isExtensible()</code> 即可</li>
<li>要让一个对象不可扩展，把它传给 <code>Object.preventExtensions()</code> 即可</li>
<li>修改不可扩展对象的原型始终都会抛出 TypeError</li>
</ul>
<p>把对象修改为不可扩展是不可逆的（即无法再将其改回可扩展）​。另外，调用 <code>Object.preventExtensions()</code> 只会影响对象本身的可扩展能力。如果给一个不可扩展对象的原型添加了新属性，则这个不可扩展对象仍然会继承这些新属性。</p>
<p><code>extensible</code> 特性的作用是把对象 <code>锁定</code> 在已知状态，阻止外部篡改。对象的 extensible 特性经常需要与属性的 configurable 和 writable 特性协同发挥作用。JavaScript 定义了一些函数，可以一起设置这些特性：</p>
<ul>
<li><code>Object.seal()</code> 把对象标记为不可扩展，并把所有自有属性的 configurable 特性设置为 false。这意味着不能给对象添加新属性，也不能删除或配置已有属性。不过，可写的已有属性依然可写。可以使用 <code>Object.isSealed()</code> 确定对象是否被封存</li>
<li><code>Object.freeze()</code> 除了让对象不可扩展、让它的属性不可配置外，该函数还会把对象的全部自有属性变成只读的（如果对象有访问器属性，且该访问器属性有设置方法，则这些属性不会受影响，仍然可以调用它们给属性赋值）。可以使用 <code>Object.isFrozen()</code> 确定对象是否被冻结</li>
</ul>
<p>对于 <code>Object.seal()</code> 和 <code>Object.freeze()</code>，关键在于理解它们只影响传给自己的对象，而不会影响该对象的原型。如果你想彻底锁定一个对象，那可能也需要封存或冻结其原型链上的对象。</p>
<p><code>Object.preventExtensions()</code>、<code>Object.seal()</code> 和 <code>Object.freeze()</code> 全都返回传给它们的对象，这意味着可以在嵌套函数调用中使用它们。</p>
<p>如果你写的 JavaScript 库要把某些对象传给用户写的回调函数，为避免用户代码修改这些对象，可以使用 <code>Object.freeze()</code> 冻结它们。</p>
<h2 id="prototype-特性"><a class="markdownIt-Anchor" href="#prototype-特性"></a> prototype 特性</h2>
<p>对象的 prototype 特性指定对象从哪里继承属性，这个特性非常重要，平常我们只会说 <code>o 的原型</code>，而不会说 <code>o 的 prototype 特性</code>。注意，一定要区分对象的 prototype 特性（即对象的原型）和对象的 prototype 属性。<strong>之前介绍过，构造函数的 prototype 属性用于指定通过该构造函数创建的对象的 prototype 特性（即指定所创建对象的原型）</strong>。</p>
<p>对象的 prototype 特性是在对象被创建时设定的：</p>
<ul>
<li>使用对象字面量创建的对象使用 Object.prototype 作为其原型</li>
<li>使用 new 创建的对象使用构造函数的 prototype 属性的值作为其原型</li>
<li>而使用 Object.create() 创建的对象使用传给它的第一个参数（可能是 null ）作为其原型</li>
</ul>
<p>要查询任何对象的原型，都可以把该对象传给 <code>Object.getPrototypeOf()</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(&#123;&#125;) === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>([]) === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;) === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>要确定一个对象是不是另一个对象的原型（或原型链中的一环）​，可以使用 isPrototypeOf() 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> p = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line">&gt; <span class="keyword">let</span> o = <span class="title class_">Object</span>.<span class="title function_">create</span>(p)</span><br><span class="line">&gt; p.<span class="title function_">isPrototypeOf</span>(o)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(p)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(o)</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>对象的 prototype 特性在它创建时会被设定，且通常保持不变。不过，可以使用Object.setPrototypeOf()修改对象的原型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> o = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;</span><br><span class="line">&gt; <span class="keyword">let</span> p = &#123;<span class="attr">y</span>: <span class="number">2</span>&#125;</span><br><span class="line">&gt; o.<span class="property">y</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt; <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(o, p)</span><br><span class="line">&gt; o.<span class="property">y</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>JavaScript 的一些早期浏览器实现通过 <code>__proto__</code>（前后各有两个下划线）属性暴露了对象的 prototype 特性。这个属性很早以前就已经被废弃了，但网上仍然有很多已有代码依赖 <code>__proto__</code>。ECMAScript 标准为此也要求所有浏览器的 JavaScript 实现都必须支持它（尽管标准并未要求，但 Node 也支持它）​。</p>
<p>在现代 JavaScript 中，<code>__proto__</code> 是可读且可写的，你可以使用它代替 <code>Object.getPrototypeOf()</code> 和 <code>Object.setPrototypeOf()</code>（但是不推荐）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; o.<span class="property">__proto__</span></span><br><span class="line">&#123; <span class="attr">y</span>: <span class="number">2</span> &#125;</span><br><span class="line">&gt; o.<span class="property">__proto__</span> = &#123;<span class="attr">z</span>: <span class="number">3</span>&#125;</span><br><span class="line">&gt; o.<span class="property">y</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt; o.<span class="property">z</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="公认符号"><a class="markdownIt-Anchor" href="#公认符号"></a> 公认符号</h2>
<p>Symbol 类型是在 ES6 中添加到 JavaScript 中的。之所以增加这个新类型，主要是为了便于扩展 JavaScript 语言，同时又不会破坏对已有代码的向后兼容性。</p>
<p><code>Symbol.iterator</code> 是最为人熟知的 <code>公认符号</code>（well-known symbol）。所谓 <code>公认符号</code>​，其实就是 <code>Symbol()</code> 工厂函数的一组属性，也就是一组符号值。通过这些符号值，我们可以控制 JavaScript 对象和类的某些底层行为。</p>
<h3 id="symboliterator-和-symbolasynciterator"><a class="markdownIt-Anchor" href="#symboliterator-和-symbolasynciterator"></a> Symbol.iterator 和 Symbol.asyncIterator</h3>
<p><code>Symbol.iterator</code> 和 <code>Symbol.asyncIterator</code> 符号可以让对象或类把自己变成可迭代对象和异步可迭代对象，之前已经详细介绍过。</p>
<h3 id="symbolhasinstance"><a class="markdownIt-Anchor" href="#symbolhasinstance"></a> Symbol.hasInstance</h3>
<p>之前介绍过 instanceof 运算符，其右侧必须是一个构造函数，而表达式 <code>o instanceof f</code> 在求值时会在 o 的原型链中查找 f.prototype 的值。在 ES6 及之后的版本中，<code>Symbol.hasInstance</code> 提供了一个替代选择：</p>
<ul>
<li>instanceof 的右侧是一个有 <code>Symbol.hasInstance</code> 方法的对象，那么就会以左侧的值作为参数来调用这个方法并返回这个方法的值，返回值会被转换为布尔值，变成 intanceof 操作符的值</li>
</ul>
<p><code>Symbol.hasInstance</code> 意味着我们可以使用 instanceof 操作符对适当定义的伪类型对象去执行通用类型检查。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义了一个作为 `类型` 的对象</span></span><br><span class="line"><span class="keyword">let</span> uint8 = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](x) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Number</span>.<span class="title function_">isInteger</span>(x) &amp;&amp; x &gt;= <span class="number">0</span> &amp;&amp; x &lt;= <span class="number">255</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">128</span> <span class="keyword">instanceof</span> uint8); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">256</span> <span class="keyword">instanceof</span> uint8); <span class="comment">// =&gt; false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="property">PI</span> <span class="keyword">instanceof</span> uint8); <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure>
<h3 id="symboltostringtag"><a class="markdownIt-Anchor" href="#symboltostringtag"></a> Symbol.toStringTag</h3>
<p>调用一个简单 JavaScript 对象的 toString() 方法会得到字符串 <code>[object Object]</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123;&#125;.<span class="title function_">toString</span>()</span><br><span class="line"><span class="string">&#x27;[object Object]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>但是如果在内置类型实例上调用 <code>Object.prototype.toString()</code> 函数，会得到一些有趣的结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;)</span><br><span class="line"><span class="string">&#x27;[object Object]&#x27;</span></span><br><span class="line">&gt; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([])</span><br><span class="line"><span class="string">&#x27;[object Array]&#x27;</span></span><br><span class="line">&gt; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="regexp">/.*/</span>)</span><br><span class="line"><span class="string">&#x27;[object RegExp]&#x27;</span></span><br><span class="line">&gt; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line"><span class="string">&#x27;[object Function]&#x27;</span></span><br><span class="line">&gt; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="string">&#x27;[object String]&#x27;</span></span><br><span class="line">&gt; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">0</span>)</span><br><span class="line"><span class="string">&#x27;[object Number]&#x27;</span></span><br><span class="line">&gt; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">false</span>)</span><br><span class="line"><span class="string">&#x27;[object Boolean]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>使用这种 <code>Object.prototype.toString().call()</code> 技术检查任何 JavaScript 值，都可以从一个包含类型信息的对象中获取以其他方式无法获取的“类特性”​。</p>
<p>下面实现的 classof 函数比 typeof 操作符更有用，因为 typeof 操作符无法区分不同对象的类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">classof</span>(<span class="params">o</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(o).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">classof</span>(<span class="literal">null</span>)); <span class="comment">// Null</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">classof</span>(<span class="literal">undefined</span>)); <span class="comment">// Undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">classof</span>(<span class="number">1</span>)); <span class="comment">// Number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">classof</span>(<span class="number">10n</span>*<span class="number">10n</span>)); <span class="comment">// BigInt</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">classof</span>(<span class="string">&quot;&quot;</span>)); <span class="comment">// String</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">classof</span>(<span class="literal">false</span>)); <span class="comment">// Boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">classof</span>(<span class="title class_">Symbol</span>())); <span class="comment">// Symbol</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">classof</span>(&#123;&#125;)); <span class="comment">// Object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">classof</span>([])); <span class="comment">// Array</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">classof</span>(<span class="function">() =&gt;</span> &#123;&#125;)); <span class="comment">// Function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">classof</span>(<span class="keyword">new</span> <span class="title class_">Map</span>())); <span class="comment">// Map</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">classof</span>(<span class="keyword">new</span> <span class="title class_">Set</span>())); <span class="comment">// Set</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">classof</span>(<span class="keyword">new</span> <span class="title class_">Date</span>())); <span class="comment">// Date</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在 ES6 之前，<code>Object.prototype.toString()</code> 这种特殊的用法只对内置类型的实例有效。如果你对自己定义的类的实例调用 <code>classof()</code>，那只能得到 <code>Object</code></li>
<li>在 ES6 中，<code>Object.prototype.toString()</code> 会查找自己参数中有没有一个属性的符号名是 Symbol.toStringTag，如果有这样一个属性，则使用这个属性的值作为输出</li>
</ul>
<p>这意味着如果你自己定义了一个类，那很容易可以让它适配 <code>classof()</code> 这样的函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Range</span> &#123;</span><br><span class="line">  get [<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Range&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> <span class="title class_">Range</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">classof</span>(r)); <span class="comment">// Range</span></span><br></pre></td></tr></table></figure>
<h3 id="symbolspecies"><a class="markdownIt-Anchor" href="#symbolspecies"></a> Symbol.species</h3>
<p>在ES6之前，JavaScript 没有提供任何实际的方式去创建内置类（如Array）的子类。但在 ES6 中，我们使用 class 和 extends 关键字就可以方便地扩展任何内置类。当我们定义 Array 的子类时，会继承 map()、slice() 等方法，这些方法的特点是会返回一个数组。那这些方法应该返回 Array 的实例，还是返回子类的实例呢？</p>
<p>以下是实现过程：</p>
<ul>
<li>在 ES6 及之后版本中，Array() 构造函数有一个名字为 Symbol.species 符号属性（注意是构造函数的属性）</li>
<li>在使用 extends 创建子类时，子类构造函数会从超类构造函数继承属性（这是除子类实例继承超类方法这种常规继承之外的一种继承）。这意味着 Array 的每个子类的构造函数也会继承名为 <code>Symbol.species</code> 的属性</li>
<li>ES6 及之后版本中，map()、slice() 等方法，会调用 <code>new this.constructor[Symbol.species]()</code> 创建新数组</li>
<li><code>Array[Symbol.species]</code> 是一个只读的访问器属性，其获取函数简单地返回 this。由于子类继承该属性，因此子类构造函数继承了这个获取函数，这意味着默认情况下，每个子类构造函数都是它自己的 <code>物种</code>。</li>
</ul>
<p>有时候我们可能需要修改这个默认行为，例如返回常规 Array 对象。只需要重新设置子类构造函数的 名为 <code>Symbol.species</code> 属性即可：但由于这个继承的属性是一个只读的访问器，不能直接用赋值操作符来设置这个值。需要用到 <code>defineProperty()</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">EZArray</span>, <span class="title class_">Symbol</span>.<span class="property">species</span>, &#123;<span class="attr">value</span>: <span class="title class_">Array</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>或者直接在创建子类时，就定义自己的 <code>Symbol.species</code> 获取方法（注意定义为 static 函数）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EZArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> get [<span class="title class_">Symbol</span>.<span class="property">species</span>]() &#123; <span class="keyword">return</span> <span class="title class_">Array</span>; &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">first</span>() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>[<span class="number">0</span>]; &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">last</span>() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>[<span class="variable language_">this</span>.<span class="property">length</span>-<span class="number">1</span>]; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了 Array，像定型数组、Promise 都使用这种 <code>物种协议</code> 来决定某些方法的返回值是父类还是子类的实例。</p>
<h3 id="symbolisconcatspreadable"><a class="markdownIt-Anchor" href="#symbolisconcatspreadable"></a> Symbol.isConcatSpreadable</h3>
<p>之前在介绍数组的 concat 方法时介绍过，数组的 <code>concat()</code> 方法对待自己的 this 值和它的数组参数不同于对待非数组参数。</p>
<ul>
<li>非数组参数会被简单地追加到新数组末尾</li>
<li>但对于数组参数，this数组和参数数组都会被打平或 <code>展开</code>​，从而实现数组元素的拼接，而不是拼接数组参数本身</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; [].<span class="title function_">concat</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br></pre></td></tr></table></figure>
<p>在 ES6 之前，<code>concat()</code> 只使用 <code>Array.isArray()</code> 确定是否将某个值作为数组来对待。在 ES6 中，这个算法进行了一些调整：</p>
<ul>
<li>如果 <code>concat()</code> 的参数（或 this 值）是对象且有一个 <code>Symbol.isConcatSpreadable</code> 符号属性，那么就根据这个属性的布尔值来确定是否应该 <code>展开</code> 参数</li>
<li>如果这个属性不存在，那么就像语言之前的版本一样使用 <code>Array.isArray()</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> arrayLike = &#123;<span class="attr">length</span>:<span class="number">1</span>, <span class="number">0</span>:<span class="number">1</span>, [<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>]: <span class="literal">true</span>&#125;;</span><br><span class="line">&gt; [].<span class="title function_">concat</span>(arrayLike)</span><br><span class="line">[ <span class="number">1</span> ]</span><br></pre></td></tr></table></figure>
<h3 id="模式匹配符号"><a class="markdownIt-Anchor" href="#模式匹配符号"></a> 模式匹配符号</h3>
<p>之前介绍过使用 <code>RegExp 参数</code> 执行模式匹配操作的 String 方法。在 ES6 及之后的版本中，这些方法都统一泛化为既能够使用 RegExp 对象，也能使用任何 <code>通过特定名称的属性定义了模式匹配行为</code> 的对象。<code>match()</code>、<code>matchAll()</code>、<code>search()</code>、<code>replace()</code> 和 <code>split()</code> 方法都有对应的公认符号：<code>Symbol.match</code>、<code>Symbol.matchAll</code> 等等。</p>
<p>一般来说，在像下面这样调用上面的字符串方法时：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string.<span class="title function_">method</span>(pattern, arg);</span><br></pre></td></tr></table></figure>
<p>该调用会转换为对模式对象上相应符号化命名方法的调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern[<span class="title class_">Symbol</span>.<span class="property">method</span>](string, arg);</span><br></pre></td></tr></table></figure>
<h3 id="symboltoprimitive"><a class="markdownIt-Anchor" href="#symboltoprimitive"></a> Symbol.toPrimitive</h3>
<p>之前介绍过，JavaScript 有 3 个稍微不同的算法，用于将对象转换为原始值。大致来讲：</p>
<ul>
<li>对于预期或偏好为字符串值的转换，JavaScript 会先调用对象的 toString() 方法。如果 <code>toString()</code> 方法没有定义或者返回的不是原始值，还会再调用对象的 <code>valueOf()</code> 方法</li>
<li>对于偏好为数值的转换，JavaScript 会先尝试调用 <code>valueOf()</code> 方法，然后在 <code>valueOf()</code> 没有定义或者返回的不是原始值时再调用 <code>toString()</code></li>
<li>最后，如果没有偏好，JavaScript 会让类来决定如何转换。Date 对象首先使用 <code>toString()</code>，其他所有类型则首先调用 <code>valueOf()</code></li>
</ul>
<p>在 ES6 中，公认符号 <code>Symbol.toPrimitive</code> 允许我们覆盖这个默认的对象到原始值的转换行为，让我们完全控制自己的类实例如何转换为原始值。这个方法必须返回一个能够表示对象的原始值。这个方法在被调用时会收到一个字符串参数，用于告诉你 JavaScript 打算对你的对象做什么样的转换。</p>
<ul>
<li>如果这个参数是 <code>string</code>，则表示 JavaScript 是在一个预期或偏好（但不是必需）为字符串的上下文中做这个转换，比如，把对象作为字符串插值到一个模板字面量中。</li>
<li>如果这个参数是 <code>number</code>，则表示 JavaScript 是在一个预期或偏好（但不是必需）为数值的上下文中做这个转换，在通过 <code>&lt;</code> 或 <code>&gt;</code> 操作符比较对象，或者使用算术操作符 <code>-</code> 或 <code>*</code> 来计算对象时属于这种情况</li>
<li>如果这个参数是 <code>default</code>，则表示 JavaScript 做这个转换的上下文可以接受数值也可以接受字符串。在使用 <code>+</code>、<code>==</code> 或 <code>!=</code> 操作符时就是这样。</li>
</ul>
<h3 id="symbolunscopables"><a class="markdownIt-Anchor" href="#symbolunscopables"></a> Symbol.unscopables</h3>
<p>Symbol.unscopables 是针对废弃的 with 语句所导致的兼容性问题而引入的一个变通方案。with 语句会取得一个对象，而在执行语句体时，就好像在相应的作用域中该对象的属性是变量一样。这样当给 Array 类添加新的方法时可能会导致兼容性问题，有可能破坏某些既有代码。</p>
<p>在 ES6 及之后的版本中，with 语句被稍微进行了修改。在取得对象 o 时，with 语句会计算 <code>Object.keys(o[Symbol.unscopables]||&#123;&#125;)</code> 并在创建用于执行语句体的模拟作用域时，忽略名字包含在结果数组中的那些属性。</p>
<p>ES6 使用这个机制给 <code>Array.prototype</code> 添加新方法，同时又不会破坏线上已有的代码。这意味着可以通过如下方式获取最新 Array 方法的列表：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">unscopables</span>])</span><br><span class="line">[</span><br><span class="line">  <span class="string">&#x27;copyWithin&#x27;</span>,    <span class="string">&#x27;entries&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;fill&#x27;</span>,          <span class="string">&#x27;find&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;findIndex&#x27;</span>,     <span class="string">&#x27;flat&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;flatMap&#x27;</span>,       <span class="string">&#x27;includes&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;keys&#x27;</span>,          <span class="string">&#x27;values&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;at&#x27;</span>,            <span class="string">&#x27;findLast&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;findLastIndex&#x27;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="模版标签"><a class="markdownIt-Anchor" href="#模版标签"></a> 模版标签</h2>
<p>位于反引号之间的字符串被称为 <code>模板字面量</code>，之前介绍过，如果一个求值为函数的表达式后面跟着一个模板字面量，那就会转换为一个函数调用，而我们称其为 <code>标签化模板字面量</code>。可以把定义使用标签化模板字面量的标签函数看成是元编程，因为标签化模板经常用于定义 DSL（Domain-Specific Language，领域专用语言）​。而定义新的标签函数类似于给 JavaScript 添加新语法。</p>
<p>标签函数并没有什么特别之处，它们就是普通的 JavaScript 函数，定义它们不涉及任何特殊语法。当函数表达式后面跟着一个模板字面量时，这个函数会被调用：</p>
<ul>
<li>第一个参数是一个字符串数组</li>
<li>然后是 0 或多个额外参数，这些参数可以是任何类型的值。</li>
<li>参数的个数取决于被插值到模板字面量中值的个数</li>
<li>字符串数组的参数是以差值进行分割的（例如如果模版字面量包含一个插值，那么数组参数中会包含两个字符串，一个是插入值左侧的字符串，另一个是插入值右侧的字符串。而且这两个字符串都可能是空字符串）</li>
</ul>
<p>如下是一个 html`` 模版的示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">html</span>(<span class="params">strings, ...values</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> escaped = values.<span class="title function_">map</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="title class_">String</span>(v)</span><br><span class="line">                                .<span class="title function_">replace</span>(<span class="string">&quot;&amp;&quot;</span>, <span class="string">&quot;&amp;amp;&quot;</span>)</span><br><span class="line">                                .<span class="title function_">replace</span>(<span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&amp;lt;&quot;</span>)</span><br><span class="line">                                .<span class="title function_">replace</span>(<span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;&amp;gt;&quot;</span>)</span><br><span class="line">                                .<span class="title function_">replace</span>(<span class="string">&#x27;&quot;&#x27;</span>, <span class="string">&quot;&amp;quot;&quot;</span>)</span><br><span class="line">                                .<span class="title function_">replace</span>(<span class="string">&quot;&#x27;&quot;</span>, <span class="string">&quot;&amp;#39;&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = strings[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; escaped.<span class="property">length</span>; i++) &#123;</span><br><span class="line">     result += escaped[i] + strings[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> operator = <span class="string">&quot;&lt;&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(html`<span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span>x </span><span class="subst">$&#123;operator&#125;</span><span class="language-xml"> y<span class="tag">&lt;/<span class="name">b</span>&gt;</span>`</span>);</span><br></pre></td></tr></table></figure>
<p>当标签函数被调用时，它的第一个参数是一个字符串数组。不过这个数组也有一个名为 raw 的属性，该属性的值是另一个字符串数组，数组元素个数保持不变：</p>
<ul>
<li>参数数组中包含的字符串和往常一样解释了转义序列</li>
<li>而未处理数组中包含的字符串并没有解释转义序列</li>
</ul>
<h2 id="反射-api"><a class="markdownIt-Anchor" href="#反射-api"></a> 反射 API</h2>
<p>与 Math 对象类似，Reflect 对象不是类，它的属性只是定义了一组相关函数。这些添加的函数为 <code>反射</code> 对象及其属性定义了一套 API。Reflect 函数虽然没有提供新特性，但它们在一个命名空间下提供了一组 API 来模拟核心语言语法的行为、以及各种已经存在的 <code>Object</code> 函数：</p>
<ul>
<li>
<p><code>Reflect.apply(f, o, args)</code>：这个函数将函数 f 作为 o 的方法进行调用，并传入 args 数组的值作为参数。相当于 <code>f.apply(o, args)</code></p>
</li>
<li>
<p><code>Reflect.construct(c, args, newTarget)</code>：这个函数像使用了 new 关键字一样调用构造函数 c，并传入 args 数组的元素作为参数</p>
</li>
<li>
<p><code>Reflect.defineProperty(o, name, descriptor)</code>：这个函数在对象 o 上定义一个属性，使用 name（字符串或符号）作为属性名。描述符对象 descriptor 应该定义这个属性的特性</p>
</li>
<li>
<p><code>Reflect.deleteProperty(o, name)</code>：这个函数根据指定的字符串或符号名 name 从对象 o 中删除属性。</p>
</li>
<li>
<p><code>Reflect.get(o, name, receiver)</code>：这个函数根据指定的字符串或符号名 name 返回属性的值。如果属性是一个有获取方法的访问器属性，且指定了可选的 receiver 参数，则将获取方法作为 receiver 而非 o 的方法调用。调用这个函数类似于求值 <code>o[name]​</code></p>
</li>
<li>
<p><code>Reflect.set(o, name, value, receiver)</code>：这个函数根据指定的 name 将对象 o 的属性设置为指定的value。如果指定的属性是一个有设置方法的访问器属性，且如果指定了可选的 receiver 参数，则将设置方法作为receiver 而非 o 的方法进行调用</p>
</li>
<li>
<p><code>Reflect.getOwnPropertyDescriptor(o, name)</code>：这个函数返回描述对象 o 的 name 属性的特性的描述符对象</p>
</li>
<li>
<p><code>Reflect.getPrototypeOf(o)</code>：这个函数返回对象o的原型，如果o没有原型则返回null。如果o是原始值而非对象，则抛出TypeError</p>
<ul>
<li>这个函数基本等于 <code>Object.getPrototypeOf()</code>，只不过 <code>Object.getPrototypeOf()</code> 只对 <code>null</code> 和 <code>undefined</code> 参数抛出 <code>TypeError</code>，且会将其他原始值转换为相应的包装对象</li>
</ul>
</li>
<li>
<p><code>Reflect.has(o, name)</code>：这个函数在对象 o 有指定的属性 name（必须是字符串或符号）时返回 true</p>
</li>
<li>
<p><code>Reflect.isExtensible(o)</code>：这个函数在对象 o 可扩展时返回 true，否则返回 false。如果 o 不是对象则抛出 TypeError</p>
</li>
<li>
<p><code>Relfect.ownKeys(o)</code>：这个函数返回包含对象 o 属性名的数组，如果 o 不是对象则抛出TypeError</p>
</li>
<li>
<p><code>Reflect.preventExtensions(o)</code>：这个函数将对象 o 的可扩展特性设置为 false，并返回表示成功 true。如果 o 不是对象则抛出 TypeError</p>
</li>
<li>
<p><code>Reflect.setPrototypeOf(o, p)</code>：这个函数将对象 o 的原型设置为 p</p>
</li>
</ul>
<h2 id="代理对象"><a class="markdownIt-Anchor" href="#代理对象"></a> 代理对象</h2>
<p>ES6 及之后版本中的 Proxy 类是 JavaScript 中最强大的元编程特性。使用它可以修改 JavaScript 对象的基础行为。Proxy 类则提供了一种途径，让我们能够自己实现基础操作，并创建具有普通对象无法企及能力的代理对象。</p>
<p>创建代理对象时，需要指定另外两个对象，即 <code>目标对象</code>（target）和 <code>处理器对象</code>（handlers）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handlers);</span><br></pre></td></tr></table></figure>
<p>得到的代理对象没有自己的状态或行为。每次对它执行某个操作（读属性、写属性、定义新属性、查询原型、把它作为函数调用）时，它只会把相应的操作发送给处理器对象或目标对象。代理对象支持的操作就是反射 API 定义的那些操作。对所有基础操作，代理都这样处理：</p>
<ul>
<li>如果处理器对象上存在对应方法，代理就调用该方法执行相应操作</li>
<li>如果处理器对象上不存在对应方法，则代理就在目标对象上执行基础操作</li>
</ul>
<p>这意味着代理可以从目标对象或处理器对象获得自己的行为。如果处理器对象是空的，那代理本质上就是目标对象的一个透明包装器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span>  t = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;</span><br><span class="line">&gt; <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(t, &#123;&#125;);</span><br><span class="line">&gt; p.<span class="property">x</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt; <span class="keyword">delete</span> p.<span class="property">y</span></span><br><span class="line">&gt; t.<span class="property">y</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt; p.<span class="property">z</span> = <span class="number">3</span></span><br><span class="line">&gt; t.<span class="property">z</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt; t</span><br><span class="line">&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">z</span>: <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure>
<p>透明包装代理本质上就是底层目标对象，这意味着没有理由使用代理来代替包装的对象。但是，透明包装器在创建 <code>可撤销代理</code> 时有用。创建可撤销代理不使用 <code>Proxy()</code> 构造函数，而要使用 <code>Proxy.revocable()</code> 工厂函数。这个函数返回一个对象，其中包含代理对象和一个 revoke() 函数。一旦调用 <code>revoke()</code> 函数，代理立即失效：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">function</span> <span class="title function_">accessTheDatabase</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line">&gt; <span class="keyword">let</span> &#123;proxy, revoke&#125; = <span class="title class_">Proxy</span>.<span class="title function_">revocable</span>(accessTheDatabase, &#123;&#125;)</span><br><span class="line">&gt; <span class="title function_">proxy</span>()</span><br><span class="line"><span class="number">42</span></span><br><span class="line">&gt; <span class="title function_">revoke</span>()</span><br><span class="line">&gt; <span class="title function_">proxy</span>()</span><br><span class="line"><span class="title class_">Uncaught</span> <span class="title class_">TypeError</span>: <span class="title class_">Cannot</span> perform <span class="string">&#x27;apply&#x27;</span> on a proxy that has been revoked</span><br></pre></td></tr></table></figure>
<p>可撤销代理充当了某种代码隔离的机制，而这可以在我们使用不信任的第三方库时派上用场。</p>
<p>如果我们给 <code>Proxy()</code> 构造函数传一个非空的处理器对象，那定义的就不再是一个透明包装器对象了，而是要在代理中实现自定义行为。例如如下代码为目标对象创建一个只读包装器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">readOnlyProxy</span>(<span class="params">o</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">readonly</span>(<span class="params"></span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Readonly&quot;</span>); &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span><br><span class="line">    o,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">set</span>: readonly,</span><br><span class="line">      <span class="attr">defineProperty</span>: readonly,</span><br><span class="line">      <span class="attr">deleteProperty</span>: readonly,</span><br><span class="line">      <span class="attr">setPrototypeOf</span>: readonly,</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> p = <span class="title function_">readOnlyProxy</span>(o);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">x</span>);</span><br><span class="line">p.<span class="property">x</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">delete</span> p.<span class="property">y</span>;</span><br><span class="line">p.<span class="property">z</span> = <span class="number">3</span>;</span><br><span class="line">p.<span class="property">__proto__</span> = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>另一种使用代理的技术是为它定义处理器方法，拦截对象操作，但仍然把操作委托给目标对象。另一种使用代理的技术是为它定义处理器方法，拦截对象操作，但仍然把操作委托给目标对象。反射API的函数与处理器方法具有完全相同的签名，从而实现这种委托也很容易。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loggingProxy</span>(<span class="params">o, objname</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> handlers = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, property, receiver</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Handler get(<span class="subst">$&#123;objname&#125;</span>, <span class="subst">$&#123;property.toString()&#125;</span>)`</span>);</span><br><span class="line">      <span class="keyword">let</span> value = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, property, receiver);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target).<span class="title function_">includes</span>(property) &amp;&amp;</span><br><span class="line">        (<span class="keyword">typeof</span> value === <span class="string">&quot;Object&quot;</span> || <span class="keyword">typeof</span> value === <span class="string">&quot;function&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">loggingProxy</span>(value, <span class="string">`<span class="subst">$&#123;objname&#125;</span>.<span class="subst">$&#123;property.toString()&#125;</span>`</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, prop, value, receiver</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Handler set(<span class="subst">$&#123;objname&#125;</span>, <span class="subst">$&#123;prop.toString()&#125;</span>, <span class="subst">$&#123;value&#125;</span>)`</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, prop, value, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">apply</span>(<span class="params">target, receiver, args</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Handler <span class="subst">$&#123;objname&#125;</span>(<span class="subst">$&#123;args&#125;</span>)`</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(target, receiver, args);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">construct</span>(<span class="params">target, args, receiver</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Handler <span class="subst">$&#123;objname&#125;</span>(<span class="subst">$&#123;args&#125;</span>)`</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(target, args, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(<span class="title class_">Reflect</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">handlerName</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!handlerName <span class="keyword">in</span> handlers) &#123;</span><br><span class="line">      handlers[handlerName] = <span class="keyword">function</span>(<span class="params">target, ...args</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Handler <span class="subst">$&#123;handlerName&#125;</span>(<span class="subst">$&#123;objname&#125;</span>,<span class="subst">$&#123;args&#125;</span>)`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>[handlerName](target, ...args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(o, handlers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = [<span class="number">10</span>, <span class="number">20</span>];</span><br><span class="line"><span class="keyword">let</span> methods = &#123;<span class="attr">square</span>: <span class="function"><span class="params">x</span> =&gt;</span> x*x &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxyData = <span class="title function_">loggingProxy</span>(data, <span class="string">&quot;data&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> proxyMethods = <span class="title function_">loggingProxy</span>(methods, <span class="string">&quot;methods&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handler get(data, map)</span></span><br><span class="line"><span class="comment">// Handler get(data, length)</span></span><br><span class="line"><span class="comment">// Handler get(data, constructor)</span></span><br><span class="line"><span class="comment">// Handler get(data, 0)</span></span><br><span class="line"><span class="comment">// Handler get(data, 1)</span></span><br><span class="line">proxyData.<span class="title function_">map</span>(methods.<span class="property">square</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handler get(methods, square)</span></span><br><span class="line"><span class="comment">// Handler methods.square(10,0,10,20)</span></span><br><span class="line"><span class="comment">// Handler methods.square(20,1,10,20)</span></span><br><span class="line">data.<span class="title function_">map</span>(proxyMethods.<span class="property">square</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handler get(data, Symbol(Symbol.iterator))</span></span><br><span class="line"><span class="comment">// Handler get(data, length)</span></span><br><span class="line"><span class="comment">// Handler get(data, 0)</span></span><br><span class="line"><span class="comment">// Datum 10</span></span><br><span class="line"><span class="comment">// Handler get(data, length)</span></span><br><span class="line"><span class="comment">// Handler get(data, 1)</span></span><br><span class="line"><span class="comment">// Datum 20</span></span><br><span class="line"><span class="comment">// Handler get(data, length)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> proxyData) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Datum&quot;</span>, x);</span><br></pre></td></tr></table></figure>
<h3 id="代理不变式"><a class="markdownIt-Anchor" href="#代理不变式"></a> 代理不变式</h3>
<p>之前通过 readOnlyProxy 函数创建的代理对象实际上是冻结的，即修改属性值或属性特性，添加或删除属性，都会抛出异常。但是，只要目标对象没有被冻结，那么通过 <code>Reflect.isExtensible()</code> 和 <code>Reflect.getOwnPropertyDescriptor()</code> 查询代理对象，都会告诉我们应该可以设置、添加或删除属性。也就是说，<code>readOnlyProxy()</code> 创建的对象处于不一致的状态。</p>
<p>之前说过，代理是一种没有自己的行为的对象，因为它们只负责把所有操作转发给处理器对象和目标对象。其实这么说也不全对：转发完操作后，Proxy 类会对结果执行合理性检查，以确保不违背重要的 JavaScript 不变式(invariant)。如果检查发现违背了，代理会抛出 TypeError。</p>
<p>如下是一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> target = <span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(&#123;&#125;);</span><br><span class="line">&gt; <span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123; <span class="title function_">isExtensible</span>(<span class="params"></span>) &#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;&#125;);</span><br><span class="line">&gt; <span class="title class_">Reflect</span>.<span class="title function_">isExtensible</span>(proxy);</span><br><span class="line"><span class="title class_">Uncaught</span>:</span><br><span class="line"><span class="title class_">TypeError</span>: <span class="string">&#x27;isExtensible&#x27;</span> on <span class="attr">proxy</span>: trap result does not reflect extensibility <span class="keyword">of</span> proxy target (which is <span class="string">&#x27;false&#x27;</span>)</span><br><span class="line">    at <span class="title class_">Reflect</span>.<span class="property">isExtensible</span> (&lt;anonymous&gt;)</span><br></pre></td></tr></table></figure>
<p>在这个例子中，为一个不可扩展对象创建了代理，而它的 <code>isExtensible()</code> 处理器返回true，代理就会抛出 TypeError。Proxy还遵循其他一些不变式，几乎都与不可扩展的目标对象和目标对象上不可配置的属性有关。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/%E5%89%8D%E7%AB%AF/" rel="tag"># 前端</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/01/22/javascript-guide-15/" rel="prev" title="JavaScript 权威指南 15：浏览器中的 JavaScript">
      <i class="fa fa-chevron-left"></i> JavaScript 权威指南 15：浏览器中的 JavaScript
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/01/20/javascript-guide-13/" rel="next" title="JavaScript 权威指南 13：异步 JavaScript">
      JavaScript 权威指南 13：异步 JavaScript <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">1.</span> <span class="nav-text"> 属性的特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E8%83%BD%E5%8A%9B"><span class="nav-number">2.</span> <span class="nav-text"> 对象的可扩展能力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#prototype-%E7%89%B9%E6%80%A7"><span class="nav-number">3.</span> <span class="nav-text"> prototype 特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AC%E8%AE%A4%E7%AC%A6%E5%8F%B7"><span class="nav-number">4.</span> <span class="nav-text"> 公认符号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#symboliterator-%E5%92%8C-symbolasynciterator"><span class="nav-number">4.1.</span> <span class="nav-text"> Symbol.iterator 和 Symbol.asyncIterator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#symbolhasinstance"><span class="nav-number">4.2.</span> <span class="nav-text"> Symbol.hasInstance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#symboltostringtag"><span class="nav-number">4.3.</span> <span class="nav-text"> Symbol.toStringTag</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#symbolspecies"><span class="nav-number">4.4.</span> <span class="nav-text"> Symbol.species</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#symbolisconcatspreadable"><span class="nav-number">4.5.</span> <span class="nav-text"> Symbol.isConcatSpreadable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AC%A6%E5%8F%B7"><span class="nav-number">4.6.</span> <span class="nav-text"> 模式匹配符号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#symboltoprimitive"><span class="nav-number">4.7.</span> <span class="nav-text"> Symbol.toPrimitive</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#symbolunscopables"><span class="nav-number">4.8.</span> <span class="nav-text"> Symbol.unscopables</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E7%89%88%E6%A0%87%E7%AD%BE"><span class="nav-number">5.</span> <span class="nav-text"> 模版标签</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84-api"><span class="nav-number">6.</span> <span class="nav-text"> 反射 API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1"><span class="nav-number">7.</span> <span class="nav-text"> 代理对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E4%B8%8D%E5%8F%98%E5%BC%8F"><span class="nav-number">7.1.</span> <span class="nav-text"> 代理不变式</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">201</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">


  

</body>
</html>
