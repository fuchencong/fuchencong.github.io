<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="有些计算机程序（例如科学模拟和机器学习模型）属于计算密集型，这些程序会持续不断地运行，不会暂停，直到计算出结果为止。不过，大多数现实中的计算机程序则明显是异步的，这意味着它们常常必须停止计算，等待数据到达或某个事件发生。 这种异步编程在 JavaScript 中是司空见惯的，这篇文章将介绍三种重要的语言特性，可以让编写异步代码更容易。">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 权威指南 13：异步 JavaScript">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2025/01/20/javascript-guide-13/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="有些计算机程序（例如科学模拟和机器学习模型）属于计算密集型，这些程序会持续不断地运行，不会暂停，直到计算出结果为止。不过，大多数现实中的计算机程序则明显是异步的，这意味着它们常常必须停止计算，等待数据到达或某个事件发生。 这种异步编程在 JavaScript 中是司空见惯的，这篇文章将介绍三种重要的语言特性，可以让编写异步代码更容易。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-01-20T06:18:55.000Z">
<meta property="article:modified_time" content="2025-06-17T06:21:24.249Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2025/01/20/javascript-guide-13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JavaScript 权威指南 13：异步 JavaScript | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2025/01/20/javascript-guide-13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaScript 权威指南 13：异步 JavaScript
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-20 14:18:55" itemprop="dateCreated datePublished" datetime="2025-01-20T14:18:55+08:00">2025-01-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>有些计算机程序（例如科学模拟和机器学习模型）属于计算密集型，这些程序会持续不断地运行，不会暂停，直到计算出结果为止。不过，大多数现实中的计算机程序则明显是异步的，这意味着它们常常必须停止计算，等待数据到达或某个事件发生。</p>
<p>这种异步编程在 JavaScript 中是司空见惯的，这篇文章将介绍三种重要的语言特性，可以让编写异步代码更容易。</p>
<span id="more"></span>

<h2 id="使用回调的异步编程"><a href="#使用回调的异步编程" class="headerlink" title="使用回调的异步编程"></a>使用回调的异步编程</h2><p>在最基本的层面上，JavaScript 异步编程是使用回调实现的。</p>
<ul>
<li>回调就是函数，可以传给其他函数</li>
<li>而其他函数会在满足某个条件或发生某个（异步）事件时调用这个函数</li>
<li>回调函数被调用，相当于通知你满足了某个条件或发生了某个事件，有时这个调用还会包含函数参数，能够提供更多细节</li>
</ul>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>一种最简单的异步操作就是在一定时间过后运行某些代码，例如 <code>setTimeout</code> 函数就可以实现该目的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(checkForUpdates, <span class="number">60</span> * <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>setTimeout() 只会调用一次指定的回调函数，而 <code>setInteval()</code> 会每隔一段时间重复调用注册的 <code>回调函数</code>。</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>客户端 JavaScript 编程几乎全都是事件驱动的。也就是说，不是运行某些预定义的计算，而是等待用户做一些事，然后响应用户的动作。</p>
<ul>
<li>用户在按下键盘按键、移动鼠标、单击鼠标或轻点触摸屏设备时，浏览器会生成事件</li>
<li>事件驱动的 JavaScript 程序在特定上下文中为特定类型的事件注册回调函数</li>
<li>浏览器在指定的事件发生时调用这些函数</li>
</ul>
<p>这些回调函数叫作事件处理程序或者事件监听器，是通过 <code>addEventListener()</code> 注册的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> okay = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#confirmUpdateDialog button.okay&#x27;</span>);</span><br><span class="line"><span class="comment">// 注册回调函数，回调函数为 applyUpdate</span></span><br><span class="line">okay.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, applyUpdate);</span><br></pre></td></tr></table></figure>

<ul>
<li>addEventListener() 的第一个参数是一个字符串，指定要注册的事件类型</li>
<li>applyUpdate 则是所注册的事件回调函数</li>
<li>如果用户单击或轻点了网页中指定的那个元素，浏览器就会调用 applyUpdate()&#96; 回调函数，并给它传入一个对象，其中包含有关事件的详细信息</li>
</ul>
<h3 id="网络事件"><a href="#网络事件" class="headerlink" title="网络事件"></a>网络事件</h3><p>JavaScript编程中另一个常见的异步操作来源是网络请求。浏览器中运行的 JavaScript 可以通过类似下面的代码从 Web 服务器获取数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getCurrentVersionNumber</span>(<span class="params">versionCheck</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> request = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line">  request.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://www.example.com/api/version&quot;</span>);</span><br><span class="line">  request.<span class="title function_">send</span>();</span><br><span class="line"></span><br><span class="line">  request.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (request.<span class="property">status</span> == <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> currentVersion = <span class="built_in">parseFloat</span>(request.<span class="property">responseText</span>);</span><br><span class="line">      <span class="title function_">versionCheck</span>(<span class="literal">null</span>, currentVersion);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">versionCheck</span>(response.<span class="property">statusText</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  request.<span class="property">onerror</span> = request.<span class="property">ontimeout</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="title function_">versionCheck</span>(e.<span class="property">type</span>, <span class="literal">null</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端 JavaScript 代码可以使用 XMLHttpRequest 类及回调函数来发送 HTTP 请求并异步处理服务器返回的响应</li>
<li>这个例子并没有像之前的示例一样调用 addEventListener()。对于大多数 Web API（包括XMLHttpRequest）来说：<ul>
<li>可以通过在生成事件的对象上调用 addEventListener() 并提供相关事件的名字、事件的回调函数来注册事件处理程序</li>
<li>也可以通过将回调函数赋值给这个对象的一个属性来注册事件监听器（这个例子所采用的方法），按照惯例，像这样的事件监听器属性的名字总是以 on 开头</li>
</ul>
</li>
<li>因为发送的是异步请求，所以它不能同步返回调用者关心的值（当前版本号）​。为此，调用者给它传了一个回调函数（即参数 versionCheck），在结果就绪或错误发生时会被调用</li>
</ul>
<h3 id="Node-中的回调与事件"><a href="#Node-中的回调与事件" class="headerlink" title="Node 中的回调与事件"></a>Node 中的回调与事件</h3><p><code>Node.js</code> 服务器端 JavaScript 环境底层就是异步的，定义了很多使用回调和事件的 API。例如读取文件内容的默认 API 就是异步的，会在读取文件内容后调用一个回调函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&quot;config.json&quot;</span>, <span class="string">&quot;utf-8&quot;</span>, <span class="function">(<span class="params">err, text</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&quot;Could not read config file:&quot;</span>, err);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">assign</span>(options, <span class="title class_">JSON</span>.<span class="title function_">parse</span>(text));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">startProgram</span>(options);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Node 也定义一些基于事件的 API，例如如下的示例，展示了在 Node 中如何通过 HTTP 请求获取 URL 的内容：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; request &#125; = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">&quot;https&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getText</span>(<span class="params">url, callback</span>) &#123;</span><br><span class="line">  request = https.<span class="title function_">get</span>(url);</span><br><span class="line"></span><br><span class="line">  request.<span class="title function_">on</span>(<span class="string">&quot;response&quot;</span>, <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> httpStatus = response.<span class="property">statusCode</span>;</span><br><span class="line"></span><br><span class="line">    response.<span class="title function_">setEncoding</span>(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> body = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    response.<span class="title function_">on</span>(<span class="string">&quot;data&quot;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123; body += chunk; &#125;);</span><br><span class="line">    response.<span class="title function_">on</span>(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (httpStatus === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">callback</span>(<span class="literal">null</span>, body);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">callback</span>(httpStatus, <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  request.<span class="title function_">on</span>(<span class="string">&quot;error&quot;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">callback</span>(err, <span class="literal">null</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="期约"><a href="#期约" class="headerlink" title="期约"></a>期约</h2><p>期约（Promise）是一种为简化异步编程而设计的核心语言特性。期约是一个对象，表示异步操作的结果。这个结果可能就绪也可能未就绪。而期约 API 在这方面故意含糊：没有办法同步取得期约的值，只能要求期约在值就绪时调用一个回调函数。</p>
<p>在最简单的情况下，期约就是一种处理回调的不同方式，但是使用期约也有实际的好处。基于回调的异步编程有一个现实问题，就是经常会出现回调多层嵌套的情形，造成代码缩进过多以致难以阅读。期约可以让这种嵌套回调以一种更线性的期约链形式表达出来，因此更容易阅读和推断。</p>
<p>回调的另一个问题是难以处理错误：如果一个异步回调函数抛出异常，该异常没有办法传播到异步操作的发起者。一个补救方式是使用回调参数和返回值来严密跟踪和传播错误，但这种方式复杂且容易出错。期约则标准化了异步错误处理，通过期约链提供了一种让错误正确传播的途径。</p>
<p>期约表示的是一次异步计算的未来结果，不能用它们来表示重复的异步计算。</p>
<h3 id="使用期约"><a href="#使用期约" class="headerlink" title="使用期约"></a>使用期约</h3><p>假设有一个 <code>getJSON()</code> 函数，它不接收回调函数作为参数，而是把 HTTP 响应体解析成 JSON 格式并返回一个期约。那么可以这样使用这个函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(url).<span class="title function_">then</span>(<span class="function"><span class="params">json</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这是一个回调函数，在得到 JSON 值之后会被异步调用</span></span><br><span class="line">    <span class="comment">// 它以 JSON 值作为参数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>getJSON()</code> 向指定的 URL 发送一个异步 HTTP 请求，然后在请求结果待定期间返回一个期约对象</li>
<li>这个期约对象有一个实例方法叫 then()，回调函数被传给了 then() 方法</li>
<li>当 HTTP 响应到达时，响应体会被解析为 JSON 格式，而解析后的值会被传给作为 <code>then()</code> 的参数的函数</li>
</ul>
<p>如果多次调用一个期约对象的 <code>then()</code> 方法，则指定的每个函数都会在预期计算完成后被调用。<strong>但期约表示的是一次计算，每个通过 <code>then()</code> 方法注册的函数都只会被调用一次</strong>。而且，即便调用 <code>then()</code> 时异步计算已经完成，传给 <code>then()</code> 的函数也会被异步调用。</p>
<ul>
<li>直接在返回期约的函数调用上继续调用 <code>.then()</code> 方法是一种惯用操作，不需要先把期约对象赋值给某个中间变量</li>
<li>以动词开头来命名返回期约的函数以及使用期约结果的函数也是一种惯例</li>
</ul>
<p>异步操作，尤其是那些涉及网络的操作，通常都会有多种失败原因。健壮的代码必须处理各种无法避免的错误。对期约而言，可以通过给 <code>then()</code> 方法传第二个函数来实现错误处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/api/user/profile&quot;</span>).<span class="title function_">then</span>(displayUserProfile, handleProfileError);</span><br></pre></td></tr></table></figure>

<p>期约表示在期约对象被创建之后发生的异步计算的未来结果，因为计算是在返回期约对象之后执行的，所以没办法让该计算像以往那样返回一个值，或者抛出一个可以捕获的异常。我们传给 <code>then()</code> 的函数可以提供一个替代手段。基于期约的异步计算把异常（通常是某种 Error 对象，尽管不是必需的）传给作为 then() 的第二个参数的函数。</p>
<p>但实际开发中，很少看到给 <code>then()</code> 传两个函数的情况。因为在使用期约时，还有一种更好也更符合传统的错误处理方式。首先来看一下，假设 <code>getJSON()</code> 正常结束但 <code>displayUserProfile()</code> 中发生错误会怎么样，由于回调函数是异步是异步执行的，不能明确抛出一个异常（因为调用栈里没有处理这种异常的代码）。</p>
<p>处理这个代码中错误的更符合传统的方式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;api/user/profile&quot;</span>).<span class="title function_">then</span>(displayUserProfile).<span class="title function_">catch</span>(handleProfileError);</span><br></pre></td></tr></table></figure>

<p>这意味着 <code>getJSON()</code> 和 <code>displayUserProfile()</code> 在执行时发生的任何错误（包括 displayUserProfile() 抛出的任何异常）都会传递给 <code>handleProfileError()</code> 函数。这个 <code>catch()</code> 方法只是对调用 <code>then()</code> 时以 null 作为第一个参数，以指定的错误处理函数作为第二个参数的一种简写形式。</p>
<p>调用一个期约的then()方法时传入了两个回调函数：</p>
<ul>
<li>如果第一个回调被调用，我们说期约得到兑现（fulfill）</li>
<li>而如果第二个回调被调用，我们说期约被拒绝（reject）</li>
<li>如果期约既未兑现，也未被拒绝，那它就是待定（pending）</li>
<li>而期约一旦兑现或被拒绝，我们说它已经落定（settle）</li>
</ul>
<p>期约是一个对象，表示异步操作的结果。”关键是要记住期约不仅是在某些异步代码完成时注册回调的抽象方式，它还表示该异步代码的结果。<strong>任何已经落定的期约都有一个与之关联的值，而这个值不会再改变。</strong></p>
<ul>
<li>如果期约兑现，那这个值会传给作为 then() 的第一个参数注册的回调函数</li>
<li>如果期约被拒绝，那这个值是一个错误，会传给使用 <code>catch()</code> 注册的或作为 <code>then()</code> 的第二个参数注册的回调函数</li>
</ul>
<h3 id="期约链"><a href="#期约链" class="headerlink" title="期约链"></a>期约链</h3><p>期约有一个最重要的优点，就是以 <code>线性 then() 方法调用链</code> 的形式表达一连串异步操作，而无须把每个操作嵌套在前一个操作的回调函数内部。如下是一个示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(documentURL)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">document</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">render</span>(<span class="variable language_">document</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">rendered</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">cacheInDatabase</span>(rendered);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">handle</span>(error);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>在之前使用 XMLHttpRequest 对象发送 HTTP 请求的示例里，它的 API 是比较古老而捡漏的，现在已经基本上被更新的、基于期约的 Fetch API 所取代了。这个新 <code>HTTP API</code> 的最简单形式就是函数 fetch()。传给它一个 URL，它返回一个期约。这个期约会在 HTTP 响应开始到达且 HTTP 状态和头部可用时兑现：</p>
<ul>
<li>在 fetch() 返回的期约兑现时，传给它的then() 方法的函数会被调用，这个函数会收到一个Response 对象，通过这个响应对象可以访问请求状态和头部（响应体还未就绪）</li>
<li>Response 对象也定义了 text() 和 json() 等方法，通过它们分别可以取得文本和 JSON 格式的响应体。取得响应体的 text() 和 json() 方法本身也返回期约</li>
</ul>
<p>我们可能会写出如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;api/user/profile&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    response.<span class="title function_">json</span>().<span class="title function_">then</span>(<span class="function"><span class="params">profile</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">displayUserProfile</span>(profile);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>但这种风格的代码不是推荐做法，<strong>是因为我们像嵌套回调一样嵌套了它们，而这违背了期约的初衷。使用期约的首选方式是像以下代码这样写成一串期约链</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;api/user/profile&quot;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">profile</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">displayUserProfile</span>(profile);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>像这样在一个表达式中调用多个方法，我们称其为方法链。有时候，当 API 被设计为使用这种方法链时只会有一个对象，它的每个方法都返回对象本身，以便后续调用。<strong>然而这并不是期约的工作方式</strong>：</p>
<ul>
<li>我们在写 <code>.then()</code> 调用链时，并不会在一个期约上注册多个回调。相反，每个 <code>then()</code> 方法调用都返回一个新期约对象。直到传递给其 then 方法的回调函数执行结束前，这个新的期约对象都不会兑现</li>
<li>注意一点，每个 <code>.then()</code> 方法总是会返回一个新的期约对象，这与传递给 <code>.then()</code> 方法的回调函数的返回值无关（这一点在理解下文的 <code>解决期约</code> 中很重要）</li>
</ul>
<h3 id="解决期约（Resolving-Promises）"><a href="#解决期约（Resolving-Promises）" class="headerlink" title="解决期约（Resolving Promises）"></a>解决期约（Resolving Promises）</h3><p>对于上面的 HTTP 响应示例，我们简化为如下方法链：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="variable constant_">URL</span>)              <span class="comment">// 任务 1，返回期约 1</span></span><br><span class="line">    .<span class="title function_">then</span>(callback1)    <span class="comment">// 任务 2，返回期约 2</span></span><br><span class="line">    .<span class="title function_">then</span>(callback2)    <span class="comment">// 任务 3，返回期约 3</span></span><br></pre></td></tr></table></figure>

<p>这里看上去只有 3 个期约，其实不是，而是存在 4 个期约，因为 callback1 的实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response =&gt; <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br></pre></td></tr></table></figure>

<p>由于读取响应体是以一个异步操作，所以 <code>response.json()</code> 本身的返回值也是一个期约。这就是第 4 个期约，即 callback1() 函数的返回值。我们使用如下方式重写这段代码，可以理解地更清晰：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">c1</span>(<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> p4 = response.<span class="title function_">json</span>();</span><br><span class="line">    <span class="keyword">return</span> p4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">c2</span>(<span class="params">profile</span>) &#123;</span><br><span class="line">    <span class="title function_">displayUserProfile</span>(profile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title function_">fetch</span>(<span class="string">&quot;api/user/profile&quot;</span>); <span class="comment">// 任务 1</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="title function_">then</span>(c1); <span class="comment">// 任务 2</span></span><br><span class="line"><span class="keyword">let</span> p3 = p2.<span class="title function_">then</span>(c2); <span class="comment">// 任务 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>回调函数 c1 的返回值并不是一个 JSON 对象，而是该表示该 JSON 对象的期约 p4</li>
<li>当 p1 兑现后，p1 的值会成为回调函数 c1 的输入，c1 被调用</li>
<li>但 c1 调用结束后，并不意味着 p2 就兑现了，因为 c1 本身是一个异步操作，所以 c1 返回的是一个期约对象 p4。期约就是用于管理异步任务的</li>
</ul>
<p>这里的关键是，当把回调函数 c 传给 then() 方法时，then() 总是返回一个期约 p，而回调函数 c 会在将来某个时刻被异步调用，回调函数 c 执行某些计算并返回值 v。<strong>当回调函数返回值 v 时，我们就说 p 得到了解决</strong></p>
<ul>
<li>当期约 p 以非期约值解决时（即 v 本身不是一个期约），就会立刻以这个值兑现。因此如果 c 返回期约值，那个这个返回值就会变成 p 的值，然后 p 兑现，结束</li>
<li>当期约 p 以期约值解决时（即 v 本身是一个期约），那么 p 就只是得到解决，但是未得到兑现。此时 p 要等到 v 落定后才能落定<ul>
<li>如果 v 兑现了，那么 p 也会以相同的值兑现</li>
<li>如果 v 被拒绝了，那么 p 也会以相同的错误被拒绝</li>
</ul>
</li>
</ul>
<p>这就是期约 <code>解决</code> 状态的含义：</p>
<ul>
<li>即一个期约与另一个期约发生了关联（或 <code>锁定</code> 了另一个期约）​</li>
<li>此时我们并不知道 p 将会兑现还是被拒绝。但回调 c 已经无法控制这个结果了</li>
<li>说 p 得到了 <code>解决</code> ​，意思就是现在它的命运完全取决于期约 v 会怎么样</li>
</ul>
<p>回到具体例子：</p>
<ul>
<li>当 <strong>c1 返回 p4 时，p2 得到解决。但解决并不等同于兑现，因此任务 3 还不会开始</strong>。</li>
<li>当 HTTP 响应体全部可用，<code>.json</code> 方法得到 JSON 格式的响应后，期约 p4 才得到兑现</li>
<li>p4 兑现后，<strong>p2 也会自动以该解析后的 JSON 值兑现</strong></li>
<li>此后，p2 所表示的 JSON 对象值才会作为 c2 回调函数的输入，任务 3 才开始执行</li>
</ul>
<h3 id="再谈期约和错误"><a href="#再谈期约和错误" class="headerlink" title="再谈期约和错误"></a>再谈期约和错误</h3><p>上文说过，基于期约的错误一般是通过给期约链添加一个 <code>.catch()</code> 方法调用来处理的，给一个 <code>then()</code> 方法传两个回调函数反而是很少见的（甚至并非惯用方法）​。接下来我们再详细地讨论错误处理。细致的错误处理在异步编程中确实非常重要：</p>
<ul>
<li>在同步代码中，如果不编写错误处理逻辑，你至少会看到异常和栈追踪信息，从而能够查找出错的原因</li>
<li>而在异步代码中，未处理的异常往往不会得到报告，错误只会静默发生，导致它们更难调试</li>
</ul>
<p>期约的 <code>.catch()</code> 方法实际上是对以 null 为第一个参数、以错误处理回调为第二个参数的 <code>.then()</code> 调用的简写，以下两行代码是等价的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="title function_">then</span>(<span class="literal">null</span>, c);</span><br><span class="line">p.<span class="title function_">catch</span>(c);</span><br></pre></td></tr></table></figure>

<p>传统的异常处理在异步代码中并不适用。当同步代码出错时，我们可以说一个异常会 <code>沿着调用栈向上冒泡</code>​，直到碰上一个 catch 块。<strong>而对于异步期约链，类似的比喻可能是一个错误 <code>沿着期约链向下流淌</code>​，直到碰上一个 .catch() 调用</strong>。</p>
<p>在 ES2018 中，期约对象还定义了一个 <code>.finally()</code> 方法，其用途类似 <code>try/catch/finally</code> 语句的 <code>finally</code> 子句：</p>
<ul>
<li>如果你在期约链中添加一个 <code>.finally()</code> 调用，那么传给 <code>.finally()</code> 的回调会在期约落定时被调用</li>
<li>无论这个期约是兑现还是被拒绝，你的回调都会被调用，而且调用时不会给它传任何参数，因此你也无法知晓期约是兑现了还是被拒绝了</li>
<li><code>.finally()</code> 的返回值也是一个期约对象</li>
<li><code>.finally()</code> 中注册的回调函数的返回值，通常会被忽略。<code>.finally()</code> 所返回期约的值，通常会以调用 <code>.finally()</code> 的期约的值进行兑现或拒绝</li>
<li>如果 <code>.finally()</code> 中回调函数抛出异常，则 <code>.finally()</code> 所返回的期约会以该值进行拒绝</li>
</ul>
<p>如下修改了上述获取 HTTP 响应示例，增加了错误处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetch 返回期约 p1</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;/api/user/profile&quot;</span>)</span><br><span class="line">   <span class="comment">// then 返回期约 p2，回调函数为 c1</span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> type = response.<span class="property">headers</span>.<span class="title function_">get</span>(<span class="string">&quot;content-type&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (type != <span class="string">&quot;application/json&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">`Expected JSON, got <span class="subst">$&#123;type&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">   <span class="comment">// then 返回期约 p3，回调函数为 c2</span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">profile</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (profile) &#123;</span><br><span class="line">      <span class="title function_">displayUserProfile</span>(profile);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">displayLoggedOutProfilePage</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="title class_">NetworkError</span>) &#123;</span><br><span class="line">      <span class="title function_">displayErrorMessage</span>(<span class="string">&quot;check your internet connection&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="title class_">TypeError</span>) &#123;</span><br><span class="line">      <span class="title function_">displayErrorMessage</span>(<span class="string">&quot;Somthing wrong with server&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>假设 fetch 请求本身因为网络故障失败，那么期约 p1 会以一个 NetworkError 对象被拒绝</li>
<li>由于我们并没有在 p1 的 then() 方法中传入第二个回调函数，因此 p2 也会以同一个 NetworkError 对象被拒绝（如果我们给第一个 <code>.then()</code> 调用传了错误处理程序，该程序就会被调用。如果它正常返回，p2 会以该处理程序返回的值解决或兑现）</li>
<li>同样，p3 也是以同一个 NetworkError 对象被拒绝</li>
<li>catch 注册的错误处理函数会被调用，NetworkError 相关的错误处理代码被调用</li>
</ul>
<p>在 <code>.then</code>（或者 <code>.catch()</code>）的回调函数中如果抛出一个值，则这个 <code>.then</code> 方法返回的期约会以这个抛出的错误被拒绝：</p>
<ul>
<li>当 c1 的代码抛出 TypeError 时，其会导致 p2 以该 TypeError 对象值被拒绝</li>
<li>因为我们没有给 p2 指定错误处理程序，所以 p3 也会被拒绝。此时不会调用 c2，TypeError 会直接传给 c3，其中包含显式检查和处理这种错误的代码</li>
</ul>
<p>从上面的分析可以看出，在期约链的任何地方使用 <code>.catch()</code> 是完全有效的。如果期约链的某一环会因错误而失败，而该错误属于某种可恢复的错误，不应该停止后续环节代码的运行。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">startAsyncOperation</span>()</span><br><span class="line">    .<span class="title function_">then</span>(doStageTwo)</span><br><span class="line">    .<span class="title function_">catch</span>(recoverFromStageTwoError)</span><br><span class="line">    .<span class="title function_">then</span>(doStageThree)</span><br><span class="line">    .<span class="title function_">then</span>(doStageFour)</span><br><span class="line">    .<span class="title function_">catch</span>(logStageThreeAndFourErrors);</span><br></pre></td></tr></table></figure>

<ul>
<li>此时无论 <code>startAsyncOperation()</code> 还是 <code>doStageTwo()</code> 抛出错误，都会调用 <code>recoverFromStageTwoError()</code> 函数</li>
<li>如果 <code>recoverFromStageTwoError()</code> 正常返回，那么它的返回值会传给 <code>doStageThree()</code>，异步操作将正常继续</li>
<li>如果 <code>recoverFromStageTwoError()</code> 不能恢复，它自己应该抛出一个错误（或者把传给它的错误再抛出来)。​此时，<code>doStageThree()</code> 和 <code>doStageFour()</code> 都不会被调用， <code>recoverFromStageTwoError()</code> 抛出的错误会直接传给 <code>logStageThreeAndFourErrors()</code></li>
</ul>
<p>在期约链中，一个环节返回（或抛出）的值会成为下一个环节的输入。因此每个环节返回什么至关重要。实际开发中，<strong>忘记从回调函数中返回值是导致期约相关问题的常见原因</strong>。而箭头函数快捷语法会让这个问题更加隐蔽，对比如下两行代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="title function_">wait</span>(<span class="number">500</span>).<span class="title function_">then</span>(queryDatabase))</span><br><span class="line"></span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123; <span class="title function_">wait</span>(<span class="number">500</span>).<span class="title function_">then</span>(queryDatabase) &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>第一行代码中：函数体就是一个表达式，因此省略了包括函数体的大括号，此时表达式的值就是函数的返回值，即返回的是一个期约</li>
<li>第二行代码中，由于加上了大括号，此时就无法利用自动返回了，这个函数的返回值就是 undefined，这可能不是所预期的</li>
</ul>
<h3 id="并行期约"><a href="#并行期约" class="headerlink" title="并行期约"></a>并行期约</h3><p>上述讨论的期约链，主要针对的是一个较大异步操作里的多个顺序运行的异步环节。有时候，我们希望并行执行多个异步操作。函数 <code>Promise.all()</code> 可以做到这一点。</p>
<ul>
<li><code>Promise.all()</code> 接收一个期约对象的数组作为输入，返回一个期约</li>
<li>如果输入期约中的任意一个拒绝，返回的期约也将拒绝</li>
<li>否则，返回的期约会以每个输入期约兑现值的数组兑现</li>
</ul>
<p>例如如下代码从多个 URL 获取内容：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> urls = [ <span class="comment">/* 多个 URL */</span> ];</span><br><span class="line">promises = urls.<span class="title function_">map</span>(<span class="function"><span class="params">url</span> =&gt;</span> <span class="title function_">fetch</span>(url).<span class="title function_">then</span>(<span class="function"><span class="params">r</span> =&gt;</span> r.<span class="title function_">text</span>()));</span><br><span class="line">promises.<span class="title function_">all</span>(promises)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">results</span> =&gt;</span> &#123; <span class="comment">/* 处理得到的字符串数组 */</span> &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(e));</span><br></pre></td></tr></table></figure>

<p>其实 <code>Promise.all()</code> 还要灵活：其输入数组可以包含期约对象和非期约值。如果这个数组的某个元素不是期约，那么它就会被当成一个已兑现期约的值，被原封不动地复制到输出数组中。</p>
<p><code>Promise.all()</code> 返回的期约会在任何一个输入期约被拒绝时拒绝。这会在第一个拒绝发生时立即发生，此时其他期约的状态可能还是待定。在 ES2020 中，<code>Promise.allSettled()</code> 也接收一个输入期约的数组，与 但是，Promise.allSettled()永远不拒绝返回的期约，<strong>而是会等所有输入期约全部落定后兑现</strong>：</p>
<ul>
<li>这个返回的期约解决为一个对象数组，其中每个对象都对应一个输入期约</li>
<li>对象有一个status属性，值为 fulfilled 或 rejected。<ul>
<li>如果 status 属性值为 fulfilled，那么该对象还会有一个 value 属性，包含兑现的值</li>
<li>如果 status 属性值为 rejected，那么该对象还会有一个 reason 属性，包含对应期约的错误或拒绝理由</li>
</ul>
</li>
</ul>
<p>你可能偶尔想同时运行多个期约，但只关心第一个兑现的值。此时，可以使用 <code>Promise.race()</code> 而不是 <code>Promise.all()</code>。<code>Promise.race()</code> 返回一个期约，这个期约会在输入数组中的期约有一个兑现或拒绝时马上兑现或拒绝（如果输入数组中有非期约值，则直接返回其中第一个非期约值）。</p>
<h3 id="创建期约"><a href="#创建期约" class="headerlink" title="创建期约"></a>创建期约</h3><p>让函数返回期约是很有用的，接下来将展示如何创建你自己基于期约的 API。</p>
<p><strong>基于其他期约的期约：</strong></p>
<p>给定一个期约，调用 then 就可以创建并返回一个新的期约。</p>
<p><strong>基于同步值的期约：</strong></p>
<p>有时候我们的函数想返回一个期约，但函数执行的计算实际上并不涉及异步操作。在这种情况下，静态方法 <code>Promise.resolve()</code> 和 <code>Promise.reject()</code> 可以帮你达成目的：</p>
<ul>
<li><code>Promise.resolve()</code> 接收一个值作为参数，并返回一个会立即（但异步）以该值解决的期约。</li>
<li><code>Promise.reject()</code> 也接收一个参数，并返回一个以该参数作为理由拒绝的期约</li>
</ul>
<p>需要明确，这两个静态方法返回的期约在被返回时并未兑现或拒绝，但它们会在当前同步代码块运行结束后立即兑现或拒绝（通常，这在很短的时间内就会发生，除非有很多待定的异步任务等待运行）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;10&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise resolved value&quot;</span>, x));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sync code run 1&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sync code run 2&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sync code run done&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># node resolve.<span class="property">js</span></span><br><span class="line">sync code run <span class="number">1</span></span><br><span class="line">sync code run <span class="number">2</span></span><br><span class="line">sync code run done</span><br><span class="line">promise resolved value <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>解决期约并不等同于兑现期约。调用 <code>Promise.resolve()</code> 时，我们通常会传入兑现值，创建一个很快就兑现为该值的期约对象。但是这个方法的名字并不叫 <code>Promise.fulfill()</code>。如果把期约 p1 传给 Promise.resolve()，它会返回一个新期约 p2，p2 会立即解决，但要等到 p1 兑现或被拒绝时才会兑现或被拒绝。</p>
<p>有时候异步函数里会存在同步处理的特殊情况，此时就可以通过 <code>Promise.resolve()</code> 或者 <code>Promise.reject()</code> 来处理这种同步情况的值。例如在异步操作开始前，检查参数条件，如果失败，就可以直接通过 <code>Promise.reject()</code> 返回一个被拒绝的期约。</p>
<p>最后，<code>Promise.resolve()</code> 有时候也可以用来创建一个期约链的第一个期约。</p>
<p><strong>从头开始创建期约：</strong></p>
<p>如果想从头创建一个返回期约的函数，就可以使用 <code>Promise</code> 构造函数。使用 <code>Promise()</code> 构造函数来创建一个新期约对象，而且可以完全控制这个新期约。过程如下：</p>
<ul>
<li>调用 Promise() 构造函数，给它传一个函数作为唯一参数</li>
<li>传的这个函数需要写成接收两个参数，按惯例要将它们命名为 resolve 和 reject</li>
<li>构造函数同步调用你的函数并为 resolve 和 reject 参数传入对应的函数值。</li>
<li>调用你的函数后，Promise() 构造函数返回新创建的期约。这个返回的期约由你传给 Promise()构造函数的函数控制：<ul>
<li>你传入的函数应该执行某些异步操作</li>
<li>然后调用 resolve 函数解决或兑现返回的期约</li>
<li>或者调用 reject 函数拒绝返回的期约</li>
</ul>
</li>
</ul>
<p>虽然你的函数可以不执行异步操作，而是同步地调用 resolve 或 reject。但是创建的期约仍然会异步地解决、兑现或拒绝。</p>
<p>如下是一个示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">wait</span>(<span class="params">duration</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;wait call start&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise constructor call start&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (duration &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Time travel not yet implemented&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise constructor argument ok&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setTimeout 在调用 resolve 时是不会传参的</span></span><br><span class="line">    <span class="comment">// 这也意味着所返回的期约在兑现时，是以 undefined 兑现的</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, duration);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise constructor call end&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;wait call end&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wait call start</span></span><br><span class="line"><span class="comment">// promise constructor call start</span></span><br><span class="line"><span class="comment">// promise constructor argument ok</span></span><br><span class="line"><span class="comment">// promise constructor call end</span></span><br><span class="line"><span class="comment">// wait call end</span></span><br><span class="line"><span class="comment">// wait promise resolve to undefined</span></span><br><span class="line"><span class="title function_">wait</span>(<span class="number">5</span> * <span class="number">1000</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">x</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`wait promise resolve to <span class="subst">$&#123;x&#125;</span>`</span>)&#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">x</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`wait promise reject to <span class="subst">$&#123;x&#125;</span>`</span>)&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wait call start</span></span><br><span class="line"><span class="comment">// promise constructor call start</span></span><br><span class="line"><span class="comment">// promise constructor argument ok</span></span><br><span class="line"><span class="comment">// promise constructor call end</span></span><br><span class="line"><span class="comment">// wait call end</span></span><br><span class="line"><span class="comment">// wait promise reject to Error: Time travel not yet implemented</span></span><br><span class="line"><span class="title function_">wait</span>(-<span class="number">1000</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">x</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`wait promise resolve to <span class="subst">$&#123;x&#125;</span>`</span>)&#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">x</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`wait promise reject to <span class="subst">$&#123;x&#125;</span>`</span>)&#125;)</span><br></pre></td></tr></table></figure>

<p>用来控制 <code>Promise()</code> 构造函数创建的期约命运的那对函数叫 <code>resolve()</code> 和 <code>reject()</code>，不是 <code>fulfill()</code> 和 <code>reject()</code>。如果把一个期约传给 <code>resolve()</code>，返回的期约将会解决为传入的期约值。不过，通常在这里都会传一个非期约值，所返回的期约会兑现为该值。</p>
<p>如下是一个更复杂的示例，实现了在 Node 中所使用的 <code>getJSON()</code> 函数。它很好地示范了如何在其他异步编程风格基础上实现基于期约的 API：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getJSON</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    request = http.<span class="title function_">get</span>(url, <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (response.<span class="property">statusCode</span> !== <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`HTTP status <span class="subst">$&#123;response.statusCode&#125;</span>`</span>));</span><br><span class="line">        response.<span class="title function_">resume</span>(); <span class="comment">// don&#x27;t leak memory</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response.<span class="property">headers</span>[<span class="string">&quot;content-type&quot;</span>] !== <span class="string">&quot;application/json&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Invalid content-type`</span>));</span><br><span class="line">        response.<span class="title function_">resume</span>(); <span class="comment">// don&#x27;t leak memory</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> body = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        response.<span class="title function_">setEncoding</span>(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        response.<span class="title function_">on</span>(<span class="string">&quot;data&quot;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> body += chunk);</span><br><span class="line">        response.<span class="title function_">on</span>(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> parsed = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(body);</span><br><span class="line">            <span class="title function_">resolve</span>(parsed);</span><br><span class="line">          &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收到响应之前就请求失败，也会正确拒绝期约</span></span><br><span class="line">    request.<span class="title function_">on</span>(<span class="string">&quot;error&quot;</span>, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(error);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="串行期约"><a href="#串行期约" class="headerlink" title="串行期约"></a>串行期约</h3><p>有时候我们需要按顺序运行任意数量的期约，由于数量未知，我们无法在期约链中硬编码这些期约，而是要像以下代码这样动态构建：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fetchSequentially</span>(<span class="params">urls</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> bodies = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fetchOne</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fetch</span>(url)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="property">text</span>)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function"><span class="params">body</span> =&gt;</span> &#123;</span><br><span class="line">        bodies.<span class="title function_">push</span>(body);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="literal">undefined</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> url <span class="keyword">of</span> urls) &#123;</span><br><span class="line">    p = p.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">fetchOne</span>(url));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p.<span class="title function_">then</span>(<span class="function">() =&gt;</span> bodies);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetchSequentially</span>(urls)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">bodies</span> =&gt;</span> &#123; <span class="comment">/* 处理抓到的字符串数组 */</span>&#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(e));</span><br></pre></td></tr></table></figure>

<p>这种实现方式创建了一串期约，第一个期约是一个能够能够立即兑现的特殊期约，之后每个期约按照创建顺序逐个落定，最后一个期约兑现时，会返回 bodies 数组，这种方式创建的是类似于多米诺骨牌形式的期约链。</p>
<p>还有一种实现思路，它并不事先创建期约链，不是事先创建期约，而是让每个期约的回调创建并返回下一个期约。我们的代码可以返回第一个（最外层的）期约，知道它最终会兑现（或拒绝）为序列中最后一个（最内层的）期约兑现（或拒绝）的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">promiseSequence</span>(<span class="params">inputs, promiseMaker</span>) &#123;</span><br><span class="line">  inputs = [...inputs];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleNextInput</span>(<span class="params">outputs</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inputs.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> outputs;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> nextInput = inputs.<span class="title function_">shift</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">promiseMaker</span>(nextInput)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">output</span> =&gt;</span> outputs.<span class="title function_">concat</span>(output))</span><br><span class="line">        .<span class="title function_">then</span>(handleNextInput);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从一个以空数组兑现的期约开始</span></span><br><span class="line">  <span class="comment">// 使用上面的函数作为它的回调</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>([]).<span class="title function_">then</span>(handleNextInput);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fetchBody</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fetch</span>(url).<span class="title function_">then</span>(<span class="function"><span class="params">r</span> =&gt;</span> r.<span class="title function_">text</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">promiseSequence</span>(urls, fetchBody)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">bodies</span> =&gt;</span> &#123; <span class="comment">/* 处理字符串数组 */</span> &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">error</span>);</span><br></pre></td></tr></table></figure>

<h2 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h2><p>ES2017 新增了两个关键字：<code>async</code> 和 <code>await</code>，代表异步 JavaScript 编程范式的迁移。这两个新关键字极大简化了期约的使用。当等待网络响应或者其他异步事件时，它允许我们编写看上去像同步阻塞式代码一样的基于期约的异步代码。</p>
<p>异步代码不能像常规同步代码那样返回一个值或抛出一个异常，这也是期约会这么设计的原因所在。兑现期约的值就像一个同步函数返回的值，而拒绝期约的值就像一个同步函数抛出的值。async&#x2F;await 使用基于期约的高效代码，同时又隐藏了期约的复杂性，让你的异步代码像同步代码（通常是阻塞式的、低效的）一样容易理解。</p>
<h3 id="await-表达式"><a href="#await-表达式" class="headerlink" title="await 表达式"></a>await 表达式</h3><p>await 关键字接收一个期约并将其转换为一个返回值或一个抛出的异常，即给定一个期约 p，表达式<code>await p</code> 会一直等到 p 落定：</p>
<ul>
<li>如果 p 兑现，那么 <code>await p</code> 的值就是兑现 p 的值</li>
<li>如果 p 被拒绝，那么 <code>await p</code> 表达式就会抛出拒绝 p 的值</li>
</ul>
<p>我们通常并不会使用 await 来接收一个保存期约的变量，更多的是把它放在一个会返回期约的函数调用前面：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;/api/user/profile&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> profile = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br></pre></td></tr></table></figure>

<p>这里的关键是，await 关键字并不会导致你的程序阻塞或者在指定的期约落定前什么都不做。<strong>你的代码仍然是异步的，而 await 只是掩盖了这个事实。这意味着任何使用 await 的代码本身都是异步的</strong>。</p>
<h3 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h3><p>因为任何使用 await 的代码都是异步的，所以有一条重要的规则：只能在以 async 关键字声明的函数内部使用 await 关键字。使用 <code>async</code>&#x2F;<code>await</code> 改写前面的 <code>getHighScore()</code> 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getHighScore</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;/api/user/profile&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> profile = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">    <span class="keyword">return</span> profile.<span class="property">highScore</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>把函数声明为 async 意味着该函数的返回值将是一个期约，即便函数体中不出现期约相关的代码</strong>：</p>
<ul>
<li>如果 async 函数会正常返回，那么作为该函数真正返回值的期约对象将解决为这个显式的返回值</li>
<li>如果 async 函数抛出异常，那么它返回的期约对象将以该异常值被拒绝</li>
</ul>
<p>由于 getHightScore() 函数前面加上了 async 关键字，因此它返回一个期约。由于它返回期约，所以可以对它使用 await 关键字：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">displayHighScore</span>(<span class="keyword">await</span> <span class="title function_">getHighScore</span>());</span><br></pre></td></tr></table></figure>

<p>由于这行代码使用了 await 关键字，因此只有在位于另一个 async 函数内部时才能运行。await 表达式可以嵌套出现在 async 函数中，多深都没有问题。但如果是在顶级或因为某种原因在一个非 async 函数内部，那么就不能使用 await 关键字，而是必须以常规方式来处理返回的期约：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getHighScore</span>().<span class="title function_">then</span>(displayHighScore).<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">error</span>);</span><br></pre></td></tr></table></figure>

<p>可以对任何函数使用 async 关键字。例如，可以在 function 关键字作为语句和作为表达式时使用，也可以对箭头函数和类及对象字面量中的简写方法使用。</p>
<h3 id="等候多个期约"><a href="#等候多个期约" class="headerlink" title="等候多个期约"></a>等候多个期约</h3><p>假设我们编写了如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value1 = <span class="keyword">await</span> <span class="title function_">getJSON</span>(url1);</span><br><span class="line"><span class="keyword">let</span> value2 = <span class="keyword">await</span> <span class="title function_">getJSON</span>(url2);</span><br></pre></td></tr></table></figure>

<p>这段代码的问题在于：必须等到抓取第一个 URL 的结果之后才会开始抓取第二个 URL。如果想同时抓取两个 URL，可以通过如下代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let [value1, value2] = await Promise.all([getJSON(url1), getJSON(url2)]);</span><br></pre></td></tr></table></figure>

<p>因为 async 函数本质上是基于期约的，它也返回一个期约对象，因此要等候一组并发执行的 async 函数，可以像使用期约一样直接使用 Promise.all()。</p>
<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><p>最后，为了理解 async 函数的工作原理，可以了解一下后台发生了什么。当编写了一个这样的 async 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>) &#123; <span class="comment">/* 函数体 */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>可以把这个函数想象成一个返回期约的包装函数，它包装了你原始函数的函数体：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>((<span class="keyword">function</span>(<span class="params">x</span>) &#123; <span class="comment">/* 函数体 */</span> &#125;)(x));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像这样以语法转换的形式来解释 await 关键字比较困难。但可以把 await 关键字想象成分隔代码体的记号，它们把函数体分隔成相对独立的同步代码块。ES2017 解释器可以把函数体分割成一系列独立的子函数，每个子函数都将传递给该子函数之前的、以 await 所标记的那个期约的 then 方法。</p>
<h2 id="异步迭代"><a href="#异步迭代" class="headerlink" title="异步迭代"></a>异步迭代</h2><p>在介绍期约时，强调过它只适合单次运行的异步计算，不适合与重复性异步事件来源一起使用，由于一个期约无法用于连续的异步事件，我们也不能使用常规的 async 函数和 await 语句来处理这些事件。</p>
<p>ES2018 提供了异步迭代器，它们是基于期约的，使用时需要配合 <code>for/await</code> 循环。</p>
<h3 id="for-x2F-await-循环"><a href="#for-x2F-await-循环" class="headerlink" title="for&#x2F;await 循环"></a>for&#x2F;await 循环</h3><p><code>Node 12</code> 的可读流实现了异步可迭代。这意味着可以像下面这样使用 <code>for/await</code> 循环从一个流中读取连续的数据块：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">parseFile</span>(<span class="params">filename</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> stream = fs.<span class="title function_">createReadStream</span>(filename, &#123; <span class="attr">encoding</span>: <span class="string">&quot;utf-8&quot;</span>&#125;);</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> chunk <span class="keyword">of</span> stream) &#123;</span><br><span class="line">    <span class="title function_">parseChunk</span>(chunk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与常规的 await 表达式类似，<code>for/await</code> 循环也是基于期约的。大体上说:</p>
<ul>
<li>这里的异步迭代器会产生一个期约</li>
<li>而 <code>for/await</code> 循环等待该期约兑现，将兑现值赋给循环变量，然后再运行循环体</li>
<li>之后再从头开始，从迭代器取得另一个期约并等待这个新期约兑现</li>
</ul>
<p>例如，假设有如下 URL fetch 对应的期约：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> urls = [url1, url2, url3];</span><br><span class="line"><span class="keyword">const</span> promises = urls.<span class="title function_">map</span>(<span class="function"><span class="params">url</span> =&gt;</span> <span class="title function_">fetch</span>(url));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    response = <span class="keyword">await</span> promise;</span><br><span class="line">    <span class="title function_">handle</span>(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例代码使用了常规的 <code>for/of</code> 循环和一个常规迭代器。但由于这个迭代器返回期约，所以我们也可以使用新的 for&#x2F;await 循环让代码更简单：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> response <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    <span class="title function_">handle</span>(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个示例都只能在以 async 声明的函数内部才能使用。从这方面来说，<code>for/await</code> 循环与常规的 await 表达式没什么不同。</p>
<p>我们对一个常规的迭代器使用了 <code>for/await</code>。如果是完全异步的迭代器，那么还会更有意思。</p>
<h3 id="异步迭代器"><a href="#异步迭代器" class="headerlink" title="异步迭代器"></a>异步迭代器</h3><p>可迭代对象是可以在 <code>for/of</code> 循环中使用的对象。它以一个符号名字 <code>Symbol.iterator</code> 定义了一个方法，该方法返回一个迭代器对象。这个迭代器对象有一个 next() 方法，可以反复调用它获取可迭代对象的值。迭代器对象的这个 <code>next()</code> 方法返回迭代结果对象。迭代结果对象有一个 value 属性或一个 done 属性。</p>
<p>异步迭代器与常规迭代器非常相似，但有两个重要区别：</p>
<ul>
<li>异步可迭代对象以符号名字 <code>Symbol.asyncIterator</code> 而非 <code>Symbol.iterator</code> 实现了一个方法。上面的例子我们可以看到，for&#x2F;await 与常规迭代器兼容，但它更适合异步可迭代对象，因此会在尝试 <code>Symbol.iterator</code> 法前先尝试 <code>Symbol.asyncIterator</code> 方法</li>
<li>异步迭代器的 next() 方法返回一个期约，解决为一个迭代器结果对象，而不是直接返回一个迭代器结果对象。</li>
</ul>
<p>当我们对一个常规同步可迭代的期约数组使用 for&#x2F;await 时，操作的是同步迭代器结果对象。其中，value 属性是一个期约对象，但 done 属性是一个同步值。真正的异步迭代器返回的是迭代结果对象的期约，因此 value 和 done 属性都是异步的。<strong>两者的区别很微妙：对于异步迭代器，关于迭代何时结束的选择可以异步实现</strong>。</p>
<h3 id="异步生成器"><a href="#异步生成器" class="headerlink" title="异步生成器"></a>异步生成器</h3><p>实现迭代器的最简单方式通常是使用生成器。同理，对于异步迭代器也是如此，我们可以使用声明为 async 的生成器函数来实现它。<strong>声明为 async 的异步生成器同时具有异步函数和生成器的特性</strong>：</p>
<ul>
<li>可以像在常规异步函数中一样使用 await，也可以像在常规生成器中一样使用 yield</li>
<li>但通过 yield 生成的值会自动包装到期约中</li>
<li>异步生成器函数通过 <code>async function*</code> 来声明</li>
</ul>
<p>如下是一个示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">elapsedTime</span>(<span class="params">ms</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, ms));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span>* <span class="title function_">clock</span>(<span class="params">interval, max=<span class="literal">Infinity</span></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> count = <span class="number">1</span>; count &lt; max; count++) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">elapsedTime</span>(interval);</span><br><span class="line">    <span class="keyword">yield</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> tick <span class="keyword">of</span> <span class="title function_">clock</span>(<span class="number">300</span>, <span class="number">100</span>)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(tick);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="实现异步迭代器"><a href="#实现异步迭代器" class="headerlink" title="实现异步迭代器"></a>实现异步迭代器</h3><p>除了使用异步生成器实现异步迭代器，还可以直接实现异步迭代器：</p>
<ul>
<li>需要定义一个包含 <code>Symbol.asyncIterator()</code> 方法的对象，该方法要返回一个包含 <code>next()</code> 方法的对象</li>
<li>而这个 next() 方法要返回解决为一个 <code>迭代器结果对象的期约</code></li>
</ul>
<p>如下是一个示例，这里的 <code>next()</code> 方法并没有显式返回一个期约，而是通过将它声明为 <code>async next</code> 来返回一个期约：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clock</span>(<span class="params">interval, max=<span class="literal">Infinity</span></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">until</span>(<span class="params">time</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(</span><br><span class="line">      <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, time - <span class="title class_">Date</span>.<span class="title function_">now</span>())</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">startTime</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>(),</span><br><span class="line">    <span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">count</span> &gt; max) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> targetTime = <span class="variable language_">this</span>.<span class="property">startTime</span> + <span class="variable language_">this</span>.<span class="property">count</span> * interval;</span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">until</span>(targetTime);</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">count</span>++&#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">asyncIterator</span>]() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>异步迭代器的优点的是它允许我们表示异步事件流或数据流</strong>。下面看一个更复杂的示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncQueue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">values</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">resolvers</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">closed</span> = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">enqueue</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">closed</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;AsyncQueue closed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">resolvers</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> resolve = <span class="variable language_">this</span>.<span class="property">resolvers</span>.<span class="title function_">shift</span>();</span><br><span class="line">      <span class="comment">// 期约解决为 value</span></span><br><span class="line">      <span class="title function_">resolve</span>(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">values</span>.<span class="title function_">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">dequeue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">values</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 队列中已经有值，</span></span><br><span class="line">      <span class="comment">// 基于同步值产生期约</span></span><br><span class="line">      <span class="comment">// 期约解决为队列中的第一个值</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">values</span>.<span class="title function_">shift</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">closed</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title class_">AsyncQueue</span>.<span class="property">EOS</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(</span><br><span class="line">        <span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123; <span class="variable language_">this</span>.<span class="property">resolvers</span>.<span class="title function_">push</span>(resolve) &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">close</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">resolvers</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">resolvers</span>.<span class="title function_">shift</span>()(<span class="title class_">AsyncQueue</span>.<span class="property">EOS</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">closed</span> = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">asyncIterator</span>]() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">dequeue</span>().<span class="title function_">then</span>(</span><br><span class="line">      <span class="function"><span class="params">value</span> =&gt;</span> (value === <span class="title class_">AsyncQueue</span>.<span class="property">EOS</span>)</span><br><span class="line">      ? &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">      : &#123; <span class="attr">value</span>: value, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">AsyncQueue</span>.<span class="property">EOS</span> = <span class="title class_">Symbol</span>(<span class="string">&quot;end-of-stream&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">eventStream</span>(<span class="params">elt, type</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> q = <span class="keyword">new</span> <span class="title class_">AsyncQueue</span>();</span><br><span class="line">  elt.<span class="title function_">addEventListener</span>(type, <span class="function"><span class="params">e</span> =&gt;</span> q.<span class="title function_">enqueue</span>(e));</span><br><span class="line">  <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">handleKeys</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> event <span class="keyword">of</span> <span class="title function_">eventStream</span>(<span class="variable language_">document</span>, <span class="string">&quot;keypress&quot;</span>)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">key</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>AsyncQueue类封装了期约队列的逻辑，基于这个类来编写异步迭代器会简单地多</li>
<li>AsyncQueue 类的 dequeue() 方法返回一个期约而不是一个实际值，这意味着在尚未调用  <code>enqueue()</code> 之前调用 <code>dequeue()</code> 是没有问题的</li>
<li>AsyncQueue 类也是一个异步迭代器，这样就能配合 for&#x2F;await 循环使用了。其 next() 方法借助了 <code>dequeue()</code> 方法来返回 <code>迭代器结果对象的期约</code></li>
<li>基于 AsyncQueue 类，产生了一个浏览器事件流，可以通过 for&#x2F;await 循环来处理</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/%E5%89%8D%E7%AB%AF/" rel="tag"># 前端</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/01/21/javascript-guide-14/" rel="prev" title="JavaScript 权威指南 14：元编程">
      <i class="fa fa-chevron-left"></i> JavaScript 权威指南 14：元编程
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/01/19/javascript-guide-12/" rel="next" title="JavaScript 权威指南 12：迭代器与生成器">
      JavaScript 权威指南 12：迭代器与生成器 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9B%9E%E8%B0%83%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">使用回调的异步编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">1.1.</span> <span class="nav-text">定时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.2.</span> <span class="nav-text">事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.3.</span> <span class="nav-text">网络事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Node-%E4%B8%AD%E7%9A%84%E5%9B%9E%E8%B0%83%E4%B8%8E%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.4.</span> <span class="nav-text">Node 中的回调与事件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%9F%E7%BA%A6"><span class="nav-number">2.</span> <span class="nav-text">期约</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%9C%9F%E7%BA%A6"><span class="nav-number">2.1.</span> <span class="nav-text">使用期约</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%9F%E7%BA%A6%E9%93%BE"><span class="nav-number">2.2.</span> <span class="nav-text">期约链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%9C%9F%E7%BA%A6%EF%BC%88Resolving-Promises%EF%BC%89"><span class="nav-number">2.3.</span> <span class="nav-text">解决期约（Resolving Promises）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%8D%E8%B0%88%E6%9C%9F%E7%BA%A6%E5%92%8C%E9%94%99%E8%AF%AF"><span class="nav-number">2.4.</span> <span class="nav-text">再谈期约和错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E6%9C%9F%E7%BA%A6"><span class="nav-number">2.5.</span> <span class="nav-text">并行期约</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%9C%9F%E7%BA%A6"><span class="nav-number">2.6.</span> <span class="nav-text">创建期约</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E8%A1%8C%E6%9C%9F%E7%BA%A6"><span class="nav-number">2.7.</span> <span class="nav-text">串行期约</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#async-%E5%92%8C-await"><span class="nav-number">3.</span> <span class="nav-text">async 和 await</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#await-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">3.1.</span> <span class="nav-text">await 表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#async-%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.</span> <span class="nav-text">async 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%89%E5%80%99%E5%A4%9A%E4%B8%AA%E6%9C%9F%E7%BA%A6"><span class="nav-number">3.3.</span> <span class="nav-text">等候多个期约</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="nav-number">3.4.</span> <span class="nav-text">实现细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E8%BF%AD%E4%BB%A3"><span class="nav-number">4.</span> <span class="nav-text">异步迭代</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#for-x2F-await-%E5%BE%AA%E7%8E%AF"><span class="nav-number">4.1.</span> <span class="nav-text">for&#x2F;await 循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">4.2.</span> <span class="nav-text">异步迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E7%94%9F%E6%88%90%E5%99%A8"><span class="nav-number">4.3.</span> <span class="nav-text">异步生成器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">4.4.</span> <span class="nav-text">实现异步迭代器</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">196</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
