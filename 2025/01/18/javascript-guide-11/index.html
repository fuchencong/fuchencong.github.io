<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="接下来将学习一些重要却没有那么基础的 API，可以将它们看作 JavaScript 的标准库，包括 JavaScript 内置的、在浏览器和 Node 中对所有 JavaScript 程序都可用的类和函数。">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 权威指南 11：JavaScript 标准库">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2025/01/18/javascript-guide-11/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="接下来将学习一些重要却没有那么基础的 API，可以将它们看作 JavaScript 的标准库，包括 JavaScript 内置的、在浏览器和 Node 中对所有 JavaScript 程序都可用的类和函数。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-01-18T06:36:52.000Z">
<meta property="article:modified_time" content="2025-06-12T06:37:16.445Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2025/01/18/javascript-guide-11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JavaScript 权威指南 11：JavaScript 标准库 | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2025/01/18/javascript-guide-11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaScript 权威指南 11：JavaScript 标准库
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-18 14:36:52" itemprop="dateCreated datePublished" datetime="2025-01-18T14:36:52+08:00">2025-01-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>接下来将学习一些重要却没有那么基础的 API，可以将它们看作 JavaScript 的标准库，包括 JavaScript 内置的、在浏览器和 Node 中对所有 JavaScript 程序都可用的类和函数。</p>
<span id="more"></span>
<h2 id="集合与映射"><a class="markdownIt-Anchor" href="#集合与映射"></a> 集合与映射</h2>
<p>JavaScript 的 Object 类型是一种万能数据结构，可用于把字符串（对象的属性名）映射为任意值，当映射为固定值（例如 true），对象就可以作为字符串的集合。对象在 JavaScript 编程中经常被用作映射和集合，但却要受到对字符串约束的限制。另外对象正常都会继承带名字（如toString）的属性，这就会带来一些干扰。</p>
<p>为此，ES6 新增了真正的 Set 和 Map类。</p>
<h3 id="set"><a class="markdownIt-Anchor" href="#set"></a> Set</h3>
<p>集合就是一组值，集合没有索引或顺序，也不允许重复：一个值要么是集合的成员，要么不是；这个值不可能在一个集合中出现多次。</p>
<ul>
<li>使用 <code>Set()</code> 构造函数创建集合对象</li>
<li><code>Set()</code> 构造函数的参数不一定是数组，但必须是一个可迭代对象（可以是其他集合）</li>
<li>集合的 size 属性类似数组的 length 属性，保存着集合包含多少个值</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">&gt; <span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, s])</span><br><span class="line">&gt; s1</span><br><span class="line"><span class="title class_">Set</span>(<span class="number">2</span>) &#123; <span class="number">1</span>, <span class="title class_">Set</span>(<span class="number">0</span>) &#123;&#125; &#125;</span><br><span class="line">&gt; <span class="keyword">let</span> u = <span class="keyword">new</span> <span class="title class_">Set</span>(<span class="string">&quot;AABBCC&quot;</span>)</span><br><span class="line">&gt; u</span><br><span class="line"><span class="title class_">Set</span>(<span class="number">3</span>) &#123; <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span> &#125;</span><br><span class="line">&gt; u.<span class="property">size</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>集合不一定在创建时初始化，可以在创建之后再通过 <code>add()</code>、<code>delete()</code> 和 <code>clear()</code> 方法给它添加元素或从中删除元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">&gt; s.<span class="property">size</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line">&gt; s.<span class="title function_">add</span>(<span class="number">1</span>)</span><br><span class="line"><span class="title class_">Set</span>(<span class="number">1</span>) &#123; <span class="number">1</span> &#125;</span><br><span class="line">&gt; s.<span class="title function_">add</span>(<span class="number">1</span>)</span><br><span class="line"><span class="title class_">Set</span>(<span class="number">1</span>) &#123; <span class="number">1</span> &#125;</span><br><span class="line">&gt; s.<span class="title function_">add</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="title class_">Set</span>(<span class="number">2</span>) &#123; <span class="number">1</span>, [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ] &#125;</span><br><span class="line"></span><br><span class="line">&gt; s.<span class="title function_">delete</span>(<span class="number">1</span>)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; s</span><br><span class="line"><span class="title class_">Set</span>(<span class="number">1</span>) &#123; [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ] &#125;</span><br><span class="line">&gt; s.<span class="title function_">delete</span>(<span class="string">&quot;no&quot;</span>)</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&gt; s.<span class="title function_">clear</span>()</span><br><span class="line">&gt; s.<span class="property">size</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line">&gt; s.<span class="title function_">add</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="title class_">Set</span>(<span class="number">1</span>) &#123; [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ] &#125;</span><br><span class="line">&gt; s.<span class="title function_">delete</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&gt; s.<span class="title function_">has</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>add() 方法接收一个参数，如果传入一个数组，它会把数组而不是数组的元素添加到集合中。add() 始终返回调用它的集合，因此如果想给集合添加多个值，可以连缀调用 add()</li>
<li>delete() 方法一次也只删除一个集合元素。delete() 返回一个布尔值。如果指定的值确实是一个集合成员，那么 delete() 删除它并返回 true；否则，delete() 什么也不做并返回 false</li>
<li>最后，很重要的一点是要记住集合成员是根据严格相等来判断是否重复的。所以对于引用类型，即使两个对象（包括数组）的内容相同，它们也被认为是不同的值</li>
</ul>
<p>检查某个值是不是集合的成员，可以使用 has() 方法。而且该方法专门做了优化，无论集合有多少成员，<code>has()</code> 方法都非常快。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">&gt; s.<span class="title function_">has</span>(<span class="number">1</span>)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; s.<span class="title function_">has</span>(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>Set类是可迭代的，这意味着可以使用 for/of 循环枚举集合的所有元素。因为 Set 象是可迭代的，所以可以使用扩展操作符 <code>...</code> 把集合转换为数组或参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; [...s]</span><br><span class="line">[ <span class="number">1</span>, <span class="number">2</span> ]</span><br></pre></td></tr></table></figure>
<p>JavaScript 的 Set 类会记住元素的插入顺序，而且始终按该顺序迭代集合：第一个元素第一个迭代（假定之前没有删除它）​，刚刚添加的元素最后一个迭代。</p>
<p>除了可以迭代，Set 类也实现了一个 <code>forEach()</code> 方法，与数组的同名方法类似，但是第一个和第二个参数都是元素的值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; s.<span class="title function_">forEach</span>(<span class="function">(<span class="params">n, m</span>) =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(n, m) &#125;)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="map-类"><a class="markdownIt-Anchor" href="#map-类"></a> Map 类</h3>
<p>Map 对象表示一组键值对，它可以使用任何值作为 key。无论映射有多大，查询与某个键关联的值都很快（虽然没有通过索引访问数组那么快）​。</p>
<ul>
<li>可以使用 <code>Map()</code> 构造函数创建映射对象</li>
<li>Map() 构造函数的可选参数应该是一个可迭代对象，产出值为包含两个元素的数组 <code>[key,value]​</code></li>
<li>这意味着如果想在创建映射时初始化它，通常需要把关联的键和值写成数组的数组的形式</li>
<li>也可以使用 <code>Map()</code> 构造函数复制其他映射</li>
<li>或者从已有对象复制属性名和值</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">&gt; <span class="keyword">let</span> n = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&quot;one&quot;</span>, <span class="number">1</span>], [<span class="string">&quot;two&quot;</span>, <span class="number">2</span>]])</span><br><span class="line">&gt; n</span><br><span class="line"><span class="title class_">Map</span>(<span class="number">2</span>) &#123; <span class="string">&#x27;one&#x27;</span> =&gt; <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span> =&gt; <span class="number">2</span> &#125;</span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">let</span> n1 = <span class="keyword">new</span> <span class="title class_">Map</span>(n)</span><br><span class="line">&gt; <span class="keyword">let</span> n2 = <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(&#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;))</span><br><span class="line"></span><br><span class="line">&gt; n1</span><br><span class="line"><span class="title class_">Map</span>(<span class="number">2</span>) &#123; <span class="string">&#x27;one&#x27;</span> =&gt; <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span> =&gt; <span class="number">2</span> &#125;</span><br><span class="line">&gt; n2</span><br><span class="line"><span class="title class_">Map</span>(<span class="number">2</span>) &#123; <span class="string">&#x27;x&#x27;</span> =&gt; <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span> =&gt; <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure>
<p>创建 Map 对象后，可以使用 <code>get()</code> 方法和键来查询关联的值，可以使用 <code>set()</code> 方法添加新的键/值对</p>
<ul>
<li>如果调用 <code>set()</code> 传入一个映射中已经存在的键，将会修改与该键关联的值</li>
<li>映射的 <code>set()</code> 方法可以连缀调用（即 <code>set()</code> 返回修改后的映射对象本身）</li>
<li><code>has()</code> 检查映射中是否包含指定键</li>
<li><code>delete()</code> 从映射中删除指定键（及其关联值）</li>
<li><code>clear()</code> 删除映射中的所有键/值对</li>
<li><code>size</code> 属性保存映射中键/值对的数量</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; n2.<span class="title function_">set</span>(<span class="string">&quot;x&quot;</span>, <span class="number">2</span>)</span><br><span class="line"><span class="title class_">Map</span>(<span class="number">2</span>) &#123; <span class="string">&#x27;x&#x27;</span> =&gt; <span class="number">2</span>, <span class="string">&#x27;y&#x27;</span> =&gt; <span class="number">2</span> &#125;</span><br><span class="line">&gt; n2.<span class="title function_">get</span>(<span class="string">&quot;x&quot;</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt; n2.<span class="title function_">delete</span>(<span class="string">&quot;x&quot;</span>)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; n2.<span class="title function_">get</span>(<span class="string">&quot;x&quot;</span>)</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">&gt; n2.<span class="title function_">has</span>(<span class="string">&quot;y&quot;</span>)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line">&gt; n2.<span class="title function_">clear</span>()</span><br><span class="line">&gt; n2.<span class="property">size</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>与集合一样，任何 JavaScript 值都可以在映射中作为键或值。这包括 <code>null</code>、<code>undefined</code> 和 <code>NaN</code>，以及对象和数组等引用类型。<strong>同样与集合类一样，映射按照全等性而非相等性比较键</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> n3 = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">&gt; n3.<span class="title function_">set</span>(&#123;&#125;, <span class="number">1</span>)</span><br><span class="line"><span class="title class_">Map</span>(<span class="number">1</span>) &#123; &#123;&#125; =&gt; <span class="number">1</span> &#125;</span><br><span class="line">&gt; n3.<span class="title function_">set</span>(&#123;&#125;, <span class="number">2</span>)</span><br><span class="line"><span class="title class_">Map</span>(<span class="number">2</span>) &#123; &#123;&#125; =&gt; <span class="number">1</span>, &#123;&#125; =&gt; <span class="number">2</span> &#125;</span><br><span class="line">&gt; n3.<span class="title function_">get</span>(&#123;&#125;)</span><br><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
<p>映射对象是可迭代的，迭代的每个值是一个两个元素的数组，其中第一个元素是键，第二个元素是与该键关联的值：</p>
<ul>
<li>如果对映射对象使用扩展操作符，会得到一个数组的数组，就像传给 Map() 构造函数的一样。</li>
<li>在使用 for/of 循环迭代映射时，习惯上通过解构赋值把键和值赋给不同的变量：</li>
<li>与 Set 类一样，Map 类也是按照插入顺序迭代的，即迭代的第一个键/值对是最早添加到映射中的，最后一个键/值对是最晚添加的</li>
<li>如果只想迭代映射的键或关联的值，可以使用 keys() 和 values() 方法，它们也是按照插入顺序返回键或值</li>
<li>entries() 方法返回的可迭代对象用于迭代键/值对，与直接迭代映射一样</li>
<li>映射也实现了 forEach() 方法，可以迭代映射。但是特别注意，这里传给回调的参数值在前、键在后（可以把映射想象成一种通用数组，只不过整数索引被替换为任何键值。数组的 forEach() 方法是先传数组元素，后传数组索引，映射的 forEach() 方法也先传映射的值，后传映射的键）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; [...n]</span><br><span class="line">[ [ <span class="string">&#x27;one&#x27;</span>, <span class="number">1</span> ], [ <span class="string">&#x27;two&#x27;</span>, <span class="number">2</span> ] ]</span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">for</span> ( <span class="keyword">let</span> [k, v] <span class="keyword">of</span> n ) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(k, v); &#125;</span><br><span class="line">one <span class="number">1</span></span><br><span class="line">two <span class="number">2</span></span><br><span class="line"></span><br><span class="line">&gt; [...n.<span class="title function_">keys</span>()]</span><br><span class="line">[ <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span> ]</span><br><span class="line">&gt; [...n.<span class="title function_">values</span>()]</span><br><span class="line">[ <span class="number">1</span>, <span class="number">2</span> ]</span><br><span class="line">&gt; [...n.<span class="title function_">entries</span>()]</span><br><span class="line">[ [ <span class="string">&#x27;one&#x27;</span>, <span class="number">1</span> ], [ <span class="string">&#x27;two&#x27;</span>, <span class="number">2</span> ] ]</span><br><span class="line"></span><br><span class="line">&gt; n.<span class="title function_">forEach</span>(<span class="function">(<span class="params">v, k</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v, k))</span><br><span class="line"><span class="number">1</span> one</span><br><span class="line"><span class="number">2</span> two</span><br></pre></td></tr></table></figure>
<h3 id="weakmap-和-weakset"><a class="markdownIt-Anchor" href="#weakmap-和-weakset"></a> WeakMap 和 WeakSet</h3>
<p>WeakMap（弱映射）类是 Map 类的一个变体（不是子类），它不会阻止键被当作垃圾收集。垃圾收集是 JavaScript 解释器收回内存空间的过程，凡是已经 <code>无法访问</code> 因而无法被程序使用的对象，都会被当作垃圾收回。</p>
<ul>
<li>常规映射对自己的键保持着 <code>强</code> 引用，即使对它们的所有其他引用都不存在了，仍然可以通过映射访问这些键</li>
<li>WeakMap 保持着对它们键的 <code>弱</code> 引用，因此无法通过 WeakMap 访问这些键</li>
</ul>
<p>WeakMap 的存在并不妨碍它们的键被回收。WeakMap 的主要用途是实现值与对象的关联而不导致内存泄漏。</p>
<ul>
<li>WeakMap 的键必须是对象或数组，原始值不受垃圾收集控制，不能作为键</li>
<li>WeakMap 只实现了 get()、set()、has()和 delete() 方法。特别地，WeakMap 不是可迭代对象，所以没有定义 keys()、values() 和 forEach()方法。如果 WeakMap 是可迭代的，那么它的键就是可访问的，也就谈不上 <code>弱</code> 了</li>
<li>WeakMap 没有实现 size 属性，因为弱映射的大小可能随着对象被当作垃圾收集而随时改变</li>
</ul>
<p>WeakSet（弱集合）实现了一组对象，不会妨碍这些对象被作为垃圾收集：</p>
<ul>
<li>WeakSet 不允许原始值作为成员</li>
<li>WeakSet 只实现了 add()、has() 和 delete()方法，而且不可迭代</li>
<li>WeakSet 没有 size 属性</li>
</ul>
<p>WeakSet 的使用场景不多，其主要应用场景与 WeakMap 类似。</p>
<h2 id="定型数组与二进制数据"><a class="markdownIt-Anchor" href="#定型数组与二进制数据"></a> 定型数组与二进制数据</h2>
<p>常规 JavaScript 数组可以包含任意类型的元素，可以动态扩展或收缩。ES6 新增了定型数组（typed array），与 C 语言的低级数组非常接近。定型数组严格来讲并不是数组（Array.isArray()对它们返回false）​，但它们实现了所有数组方法，外加几个它们自己的方法。</p>
<p>定型数组与常规数组存在如下几个非常重要的区别：</p>
<ul>
<li>定型数组的元素全部都是数值，定型数组允许指定存储在数组中的数值的类型（有符号和无符号数组以及IEEE-754浮点数）和大小（8 位到 64 位）</li>
<li>创建定型数组时必须指定长度，且该长度不能再改变</li>
<li>定型数组的元素在创建时始终都会被初始化为 0</li>
</ul>
<h3 id="定型数组的类型"><a class="markdownIt-Anchor" href="#定型数组的类型"></a> 定型数组的类型</h3>
<p>JavaScript 定义了 11 种定型数组，每种都有自己的元素类型和构造函数：</p>
<ul>
<li>Int8Array()：有符号 8 位字节</li>
<li>Uint8Array()：无符号 8 位字节</li>
<li>Uint8ClampedArray()：无符号 8 位字节（上溢不归 0）</li>
<li>Int16Array()：有符号 16 位整数</li>
<li>Uint16Array()：无符号 16 位整数</li>
<li>Int32Array()：有符号 32 位整数</li>
<li>Uint32Array()：无符号 32 位整数</li>
<li>BigInt64Array()：有符号 64 位 BigInt 值</li>
<li>BigUint64Array()：无符号 64 位 BigInt 值</li>
<li>Float32Array()：32 位浮点数</li>
<li>Float64Array()：64 位浮点数（对应 JavaScript 的浮点数）</li>
</ul>
<p>上面每种定型数组构造函数都有一个 BYTES_PER_ELEMENT 属性，根据类型不同，这个属性的值可能是 1、2、4、8。</p>
<h3 id="创建定型数组"><a class="markdownIt-Anchor" href="#创建定型数组"></a> 创建定型数组</h3>
<ul>
<li>创建定型数组最简单的方式就是调用相应的构造函数，并传入一个表示数组元素个数的数值参数。如果以这种方式创建定型数组，则数组元素一定会全部初始化为 0、0n 或 0.0</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> bytes = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">1024</span>)</span><br><span class="line">&gt; bytes.<span class="property">length</span></span><br><span class="line"><span class="number">1024</span></span><br></pre></td></tr></table></figure>
<ul>
<li>每种定型数组构造函数都有静态的工厂方法 from() 和 of()，类似于 Array.from() 和 Array.of()：</li>
<li>构造函数和 from() 工厂方法都支持复制已有的定型数组，尽管类型可能会改变</li>
<li>在通过已有数组、可迭代或类数组对象创建新定型数组时，为适应类型限制，已有的值可能被截短。在此过程中，不会有警告，也不会报错</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> a = <span class="title class_">Uint8Array</span>.<span class="title function_">of</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&gt; a</span><br><span class="line"><span class="title class_">Uint8Array</span>(<span class="number">4</span>) [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ]</span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">let</span> a1 = <span class="title class_">Uint8Array</span>.<span class="title function_">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>)</span><br><span class="line">&gt; a1</span><br><span class="line"><span class="title class_">Uint8Array</span>(<span class="number">4</span>) [ <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span> ]</span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">let</span> a11 = <span class="title class_">Uint32Array</span>.<span class="title function_">from</span>(a1)</span><br><span class="line">&gt; a11</span><br><span class="line"><span class="title class_">Uint32Array</span>(<span class="number">4</span>) [ <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span> ]</span><br></pre></td></tr></table></figure>
<ul>
<li>还有一种创建定型数组的方式，该方式要用到 ArrayBuffer 类型。ArrayBuffer是对一块内存的不透明引用。可以通过构造函数创建 ArrayBuffer，只要传入想分配内存的字节数即可</li>
<li>ArrayBuffer 类不允许读取或写入分配的任何字节。但是可以创建使用该缓冲区内存的定型数组，通过这个数组来读取或写入该内存
<ul>
<li>在调用定型数组的构造函数时需要将 ArrayBuffer 作为第一个参数</li>
<li>将该缓冲区内的字节偏移量作为第二个参数（可选）</li>
<li>将数组的长度（单位是元素而非字节）作为第三个参数（可选）</li>
<li>如果省略第二个和第三个参数，则数组会使用缓冲区的所有内存</li>
<li>如果只省略长度参数，则数组会使用从起点位置到缓冲区结束的所有可用内存</li>
<li>数组的内存必须是对齐的，所以如果你指定了字节偏移量，那么这个值应该是类型大小的倍数</li>
<li>当通过同一个 ArrayBuffer 创建多个定型数组时，它们底层共享该 ArrayBuffer，可以认为不同的定型数组是该 ArrayBuffer 的不同视图</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> a0 = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(buf)</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt; a0.<span class="property">length</span></span><br><span class="line"><span class="number">262144</span></span><br><span class="line">&gt; buf.<span class="property">byteLength</span> / <span class="number">4</span></span><br><span class="line"><span class="number">262144</span></span><br></pre></td></tr></table></figure>
<p>如果调用定型数组构造函数时没有传缓冲区对象，则会自动以适当大小创建一个缓冲区。所有定型数组都有一个 buffer 属性，引用自己底层的 ArrayBuffer 对象。</p>
<h2 id="使用定型数组"><a class="markdownIt-Anchor" href="#使用定型数组"></a> 使用定型数组</h2>
<ul>
<li>创建定型数组后，可以通过常规的中括号语法读取或写入其元素，与操作其他类数组对象一样。</li>
<li>定型数组并不是真正的数组，但它们重新实现了多数数组方法，因此几乎可以像使用常规数组一样使用它们</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="title class_">Uint16Array</span>(<span class="number">10</span>);</span><br><span class="line">&gt; ints[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line"><span class="number">10</span></span><br><span class="line">&gt; ints</span><br><span class="line"><span class="title class_">Uint16Array</span>(<span class="number">10</span>) [</span><br><span class="line">  <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">   <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&gt; ints.<span class="title function_">fill</span>(<span class="number">3</span>).<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x *x).<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="string">&#x27;9999999999&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>定型数组的长度是固定的，因此 length 属性是只读的，而定型数组并未实现改变数组长度的方法（例如 push()、pop() 等），但实现了修改数组内容而不改变长度的方法（如 sort()、reverse() 和 fill()）</p>
</li>
<li>
<p>诸如 <code>map()</code> 和 <code>slice()</code> 等返回新数组的方法，则返回与调用它们的定型数组相同类型的数组</p>
</li>
</ul>
<h2 id="定型数组的方法与属性"><a class="markdownIt-Anchor" href="#定型数组的方法与属性"></a> 定型数组的方法与属性</h2>
<p>除了标准的数组方法，定型数组也实现了它们自己的一些方法。</p>
<ul>
<li>
<p><code>set()</code> 方法用于一次性设置定型数组的多个元素，即把其他常规数组或定型数组的元素复制到当前定型数组中</p>
<ul>
<li>以一个数组或定型数组作为其第一个参数</li>
<li>以一个元素偏移量作为其可选的第二个参数，如果不指定则默认为 0。</li>
</ul>
</li>
<li>
<p>定型数组也有一个 subarray 方法，返回调用它的定型数组的一部分</p>
<ul>
<li><code>subarray()</code> 接收与 <code>slice()</code> 方法相同的参数</li>
<li>但二者有个重要区别：<code>slice()</code> 以新的、独立的定型数组返回指定的元素，不与原始数组共享内存；而 <code>subarray()</code> 则不复制内存，只返回相同底层值的一个新视图：</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> bytes = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">1024</span>)</span><br><span class="line">&gt; <span class="keyword">let</span> pattern = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">&gt; bytes.<span class="title function_">set</span>(pattern)</span><br><span class="line">&gt; bytes.<span class="title function_">set</span>(pattern, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">let</span> s1 = bytes.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">8</span>)</span><br><span class="line">&gt; <span class="keyword">let</span> s2 = bytes.<span class="title function_">subarray</span>(<span class="number">0</span>, <span class="number">8</span>)</span><br><span class="line">&gt; bytes[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">&gt; s1</span><br><span class="line"><span class="title class_">Uint8Array</span>(<span class="number">8</span>) [</span><br><span class="line">  <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line">  <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">]</span><br><span class="line">&gt; s2</span><br><span class="line"><span class="title class_">Uint8Array</span>(<span class="number">8</span>) [</span><br><span class="line">  <span class="number">100</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>每个定型数组都有 3 个属性与底层的缓冲区（ArrayBuffer）相关：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; s2.<span class="property">buffer</span> === bytes.<span class="property">buffer</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; s2.<span class="property">byteOffset</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">&gt; s2.<span class="property">byteLength</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<ul>
<li>buffer 属性是数组的 ArrayBuffer，byteOffset 是数组数据在这个底层缓冲区的起点位置，而 byteLength 是数组数据的字节长度</li>
<li><code>a.length * a.BYTES_PER_ELEMENT === a.byteLength</code></li>
</ul>
<p>需要注意，ArrayBuffer 只是不透明的字节块。通过定型数组可以访问其中的字节，但 ArrayBuffer 本身并不是定型数组。你可以像对任何 JavaScript 对象一样对 ArrayBuffer 使用数值索引。但这样做并不会访问缓冲区中的字节，而是在 ArrayBuffer 对象上设置一个属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">2</span>)</span><br><span class="line">&gt; b.<span class="property">buffer</span></span><br><span class="line"><span class="title class_">ArrayBuffer</span> &#123; [<span class="title class_">Uint8Contents</span>]: &lt;00 00&gt;, byteLength: 2 &#125;</span><br><span class="line"></span><br><span class="line">&gt; b.buffer[1] = &quot;test&quot;</span><br><span class="line">&#x27;test&#x27;</span><br><span class="line">&gt; b.buffer</span><br><span class="line">ArrayBuffer &#123; [Uint8Contents]: &lt;00 00&gt;, byteLength: 2, &#x27;1&#x27;: &#x27;test&#x27; &#125;</span><br><span class="line"></span><br><span class="line">&gt; b[1]</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h3 id="dataview-与字节序"><a class="markdownIt-Anchor" href="#dataview-与字节序"></a> DataView 与字节序</h3>
<p>使用定型数组可以查看相同字节序列的 8、16、32 或 64 位视图。这就涉及 <code>字节序</code> 问题了。为效率考虑，定型数组使用底层硬件的原生字节序。在小端系统中，ArrayBuffer 中的字节排列顺序为低字节到高字节。在大端系统中，字节排列顺序为高字节到低字节：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> littleEndian = <span class="keyword">new</span> <span class="title class_">Int8Array</span>(<span class="keyword">new</span> <span class="title class_">Int32Array</span>([<span class="number">1</span>]).<span class="property">buffer</span>)[<span class="number">0</span>] === <span class="number">1</span></span><br><span class="line">&gt; littleEndian</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>DataView 类定义的方法可以显式指定读、写 ArrayBuffer 值时的字节序：</p>
<ul>
<li>
<p>DataView 为 10种定型数组类（不包括 Uint8ClampedArray）定义了 10 个 get 方法。这些方法的名字类似 getInt16、getUint32()、getBigInt64() 和 getFloat64()</p>
<ul>
<li>它们的第一个参数是 ArrayBuffer 中的字节偏移量，表示读取值的开始位置</li>
<li>这些读取方法（除 getInt8() 和 getUint8() 之外）都接收一个可选的布尔值作为第二个参数。true 表示使用小端字节序，false 或者省略则表示大端</li>
</ul>
</li>
<li>
<p>DataView 也定义了 10 个对应的设置方法，用于向底层 ArrayBuffer 写入值。</p>
<ul>
<li>这些方法的第一个参数是偏移量，表示写入值的开始位置。</li>
<li>第二个参数是要写入的值</li>
<li>第三个参数（可选）则表示字节序：true 表示使用小端字节序，false 或者省略则表示大端</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>([<span class="number">0x01020304</span>])</span><br><span class="line">&gt; view = <span class="keyword">new</span> <span class="title class_">DataView</span>(b.<span class="property">buffer</span>, b.<span class="property">byteOffset</span>, b.<span class="property">byteLength</span>)</span><br><span class="line"><span class="title class_">DataView</span> &#123;</span><br><span class="line">  <span class="attr">byteLength</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">byteOffset</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">buffer</span>: <span class="title class_">ArrayBuffer</span> &#123; [<span class="title class_">Uint8Contents</span>]: <span class="language-xml">&lt;04 03 02 01&gt;, byteLength: 4 &#125;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">&gt; view.getUint32(0, true).toString(16)</span></span><br><span class="line"><span class="language-xml">&#x27;1020304&#x27;</span></span><br><span class="line"><span class="language-xml">&gt; view.getUint32(0, false).toString(16)</span></span><br><span class="line"><span class="language-xml">&#x27;4030201&#x27;</span></span><br></pre></td></tr></table></figure>
<p>定型数组和 DataView 提供了处理二进制数据所需的全部工具。</p>
<h2 id="正则表达式与模式匹配"><a class="markdownIt-Anchor" href="#正则表达式与模式匹配"></a> 正则表达式与模式匹配</h2>
<p>正则表达式是一种描述文本模式的对象。JavaScript 的 RegExp 类表示正则表达式。String 和 RegExp 都定义了使用正则表达式对文本执行强大模式匹配和搜索替换功能的方法。</p>
<h3 id="定义正则表达式"><a class="markdownIt-Anchor" href="#定义正则表达式"></a> 定义正则表达式</h3>
<p>RegExp 对象可以使用 RegExp() 构造函数来创建，但更多的是通过一种特殊的字面量语法来创建。正则表达式字面量就是包含在一对斜杠 <code>/</code> 字符之间的字符，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> pattern = <span class="regexp">/s$/</span></span><br><span class="line">&gt; <span class="keyword">typeof</span> pattern</span><br><span class="line"><span class="string">&#x27;object&#x27;</span></span><br><span class="line">&gt; pattern <span class="keyword">instanceof</span> <span class="title class_">RegExp</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>同样的正则表达式对象用 <code>RegExp()</code> 构造函数创建：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;s$&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>正则表达式也支持一个或多个标志字符，用于控制匹配的方式：</p>
<ul>
<li>在正则表达式字面量中，标志需要放在第二个斜杠字符后面</li>
<li>在 RegExp() 构造函数中，标志要作为第二个字符串参数</li>
</ul>
<h3 id="正则表达式字符"><a class="markdownIt-Anchor" href="#正则表达式字符"></a> 正则表达式字符</h3>
<p>接下来快速介绍 JavaScript 正则表达式中使用的各种字符和元字符。</p>
<p><strong>字符字面量：</strong></p>
<ul>
<li>所有字母字符和数字在正则表达式中都匹配自身的字面值。JavaScript 正则表达式语法通过以反斜杠 <code>\</code> 开头的转义序列也支持一些非字母字符，例如 <code>\n</code> 匹配换行符。</li>
<li>有一些英文标点符号在正则表达式中具有特殊含义，如果想在正则表达式中包含这些标点符号的字面值，必须在这些字符前面加个反斜杠 <code>\</code></li>
<li>如果记不住哪些标点符号字符需要使用反斜杠转义，可以给所有标点符号字符前面都加上反斜杠。但也要记住，也要知道很多字母和数字前面如果加了反斜杠也会具有特殊含义，因此任何想匹配字面值的字母和数字都不应该加反斜杠</li>
<li>如果要匹配反斜杠本身，则要使用 <code>\\</code></li>
<li>如果使用 RegExp() 构造函数，则要记住，正则表达式中的任何反斜杠都要写两次，因为字符串也使用反斜杠作为转义字符</li>
</ul>
<p><strong>字符类：</strong></p>
<ul>
<li>把个别字面值字符放到方括号中可以组合成字符类。字符类匹配方括号中包含的任意字符</li>
<li>也可以定义排除性的字符类，匹配除方括号中包含的字符之外的任意字符。排除性字符类就是把插入符号 <code>^</code> 作为方括号中的第一个字符</li>
<li>字符类可以使用连字符表示字符范围，例如 <code>[a-z]</code> 表示所有小写字母。如果想通过字符类匹配真正的连字符，只要把它放到右方括号前面，作为字符类的最后一个字符即可</li>
<li>某些字符类很常用，JavaScript 正则表达式语法中包含一些特殊字符和转义序列来表示这些字符类
<ul>
<li>\w：任意 ASCII 单词字符</li>
<li>\W：任意 ASCII 非单词字符</li>
<li>\s：任意 Unicode 空白字符</li>
<li>\S：任意非 Unicode 空白字符</li>
<li>\d：任意 ASCII 数字字符</li>
<li>\D：任意非 ASII 数字字符</li>
<li><code>.</code>：任意单个字符（换行符除外）。如果 RegExp 对象设置了 s 标志，<code>.</code> 也匹配换行符</li>
</ul>
</li>
</ul>
<p>所有特殊字符类转义序列本身也可以出现在方括号中。例如 \s 匹配任意空白字符，而 \d 匹配任意数字，所以 <code>/[\s\d]/</code> 匹配任意空白字符或数字。</p>
<p>在 ES2018 中，如果正则表达式使用了 u 标志，则支持字符类 <code>\p&#123;...&#125;</code> 及其排除性形式 <code>\P&#123;...&#125;</code>。</p>
<p><strong>指定重复：</strong></p>
<p>指定重复的字符始终跟在应用它们的模式后面。由于某些重复的形式非常常用，还会有特殊字符表示这些情况。</p>
<ul>
<li>{n, m}：匹配前项至少 n  次，但不超过 m 次</li>
<li>{n, }：匹配前项 n 或更多次</li>
<li>{n}：匹配前项恰好 n 次</li>
<li>?：匹配前项 0 次或 1 次，即前项是可选的</li>
<li>+：匹配前项 1 次或更多次</li>
<li>*：匹配前项 0 次或更多次</li>
</ul>
<p><strong>非贪婪重复：</strong></p>
<p>上面所介绍的这些重复字符会尽可能多地匹配，同时也允许正则表达式剩余的部分继续匹配。我们说这种重复是 <code>贪婪的</code>。在重复字符后面简单地加个问号，就可以指定非贪婪地重复。</p>
<p><strong>任选、分组和引用：</strong></p>
<p>正则表达式的语法中也包含指定任选、分组子表达式和引用前面子表达式的特殊字符：</p>
<ul>
<li>竖线字符 | 用于分隔任选模式，例如 <code>/abc|def/</code> 可以匹配字符串 “abc” 或 “def”。</li>
<li>圆括号在正则表达式中有几种不同的作用，一种作用是把独立的模式分组为子表达式，从而让这些模式可以被 |、*、+、? 等当作一个整体</li>
<li>圆括号在正则表达式中的另一个作用是在完整的模式中定义子模式。当正则表达式成功匹配一个目标字符串后，可以从目标字符串中提取出与圆括号包含的子模式对应的部分</li>
<li>与圆括号分组的子表达式相关的一个用途是在同一个正则表达式中回引子表达式。回引前面的子表达式要使用 <code>\</code> 字符加上数字。这里的数字指的是圆括号分组的子表达式在整个正则表达式中的位置，例如 <code>\1</code> 回引第一个子表达式。</li>
<li>注意，由于子表达式可能会嵌套，所以它们的位置是按照左括号来计算的</li>
<li>回引表达式可以引用得到对应子模式所匹配的文本，如下展示了一个示例，它可以保证前后的引号是匹配的：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/([<span class="string">&#x27;&quot;])[^&#x27;</span><span class="string">&quot;]*\1/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果不想让圆括号分组的子表达式生成数字引用，那么可以在圆括号的开头添加 <code>?:</code>。这样只会产生一个分组，无法引用该分组</li>
</ul>
<p><strong>命名捕获组：</strong></p>
<p>ES2018 标准化了一个新特性，让正则表达式可以自我解释且更容易理解。这个新特殊被称为 <code>命名捕获组</code>（named capture gorup）。可以给正则表达式中的每个左圆括号指定一个关联的名字，以便后面使用这个名字而不是数字来引用匹配的文本。</p>
<ul>
<li>要命名一个分组，使用 <code>(?&lt;...&gt;)</code> 而不是 <code>()</code>，把分组的名字放在尖括号内</li>
<li>如果想在正则表达式中回引某个命名捕获组，可以使用名字。<code>\k&lt;quote&gt;</code> 是一个命名反向引用，引用捕获的命名分组</li>
</ul>
<p><strong>指定匹配位置：</strong></p>
<p>一些正则表达式组件匹配字符间的位置而非实际的字符，有时候，这些组件也被称作正则表达式锚点，因为它们把模式锚定到被搜索字符串中特定的位置</p>
<ul>
<li><code>^</code> 匹配字符串开头</li>
<li><code>$</code> 匹配字符串末尾</li>
<li><code>\b</code> 匹配 ASCII 单词边界</li>
<li><code>\B</code> 匹配非单词边界</li>
<li>可以使用任意正则表达式作为锚定条件。如果在 <code>(?=</code> 和 <code>)</code> 字符之间包含一个表达式，它构成向前查找断言。即该表达式必须存在，但又不在匹配结果中</li>
<li><code>(?!)</code> 和 <code>)</code> 之间的表达式构成否定向前查找断言。即该表达式必须不存在</li>
</ul>
<p>ES2018 扩展了正则表达式语法，支持 <code>向后查找</code> 断言。向后查找断言与向前查找断言类似，但关注的是当前匹配位置之前的文本。肯定式向前查找使用 <code>(?&lt;=...)</code>，否定式向后查找断言使用 <code>(?&lt;!...)</code>。例如要搜索美国邮件地址，希望从中匹配 5 位邮政编码，但仅限于前面是两位字母的州简写的情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/(?&lt;= [A-Z]&#123;<span class="number">2</span>&#125;)\d&#123;<span class="number">5</span>&#125;/</span><br></pre></td></tr></table></figure>
<p><strong>标志：</strong></p>
<p>每个正则表达式都可以带一个或多个标志，用于修改其行为：</p>
<ul>
<li>g 标志表示正则表达式是 <code>全局性的</code>（global），即使用这个标志意味着想要找到字符串中包含的所有匹配项，而不只是找到第一个匹配项</li>
<li>i 标志表示模式匹配应该不区分大小写</li>
<li>m 标志表示匹配应该以 <code>多行（multiline）</code> 模式进行，即这个 RegExp 要用于多行字符串</li>
<li>s 标志同样可以用在要搜索的文本包含换行符的时候</li>
<li>u 标志代表 Unicode，可以让正则表达式匹配完整的码点而不是匹配 16 位值。这个标志是 ES6 新增的</li>
<li>y 标志表示正则表达式是 <code>有粘性的</code>（sticky），应该在字符串开头匹配或在紧跟前一个匹配后的第一个字符处匹配。它会导致 String的match() 方法和 RegExp的exec() 方法产生特殊行为，强制将每个后续匹配都锚定到前一个匹配（在字符串中）的结束位置</li>
</ul>
<p>以上这些标志可以任意组合，顺序也不分先后。</p>
<h3 id="模式匹配的字符串方法"><a class="markdownIt-Anchor" href="#模式匹配的字符串方法"></a> 模式匹配的字符串方法</h3>
<p>String 支持 4 个使用正则表达式的方法：</p>
<ul>
<li>
<p>search() 方法接收一个正则表达式参数，返回第一个匹配项起点字符的位置，如果没有找到匹配项，则返回-1</p>
<ul>
<li>如果 search() 方法的参数不是正则表达式，它会先把这个参数传给 RegExp() 构造函数，把它转换为正则表达式</li>
<li>search() 方法不支持全局搜索，因此其正则表达式参数中包含的 g 标志会被忽略。</li>
</ul>
</li>
<li>
<p>replace() 方法执行搜索替换操作。它接收一个正则表达式作为第一个参数，接收一个替换字符串作为第二个参数</p>
<ul>
<li>如果 replace() 的第一个参数是字符串而非正则表达式，它不会将字符串通过 RegExp() 转换为正则表达式，而是会按照字面值搜索</li>
<li>如果替换字符串中出现了 $ 符号后跟一个数字，<code>replace()</code> 会将这两个字符替换为与指定子表达式匹配的文本</li>
<li>如果 RegExp 中使用的是命名捕获组，可以通过名字而非数字来引用匹配的文本</li>
<li>除了给 <code>replace()</code> 传替换字符串，还可以传一个函数，这个函数会被调用以计算替换的值。这个替换函数在被调用时会接收到几个参数：
<ul>
<li>第一个是匹配的整个文本</li>
<li>然后是，如果 RegExp 有捕获组，则后面几个参数分别是这些捕获组匹配的子字符串</li>
<li>然后是，匹配项在整个字符串中的位置</li>
<li>然后是，调用 replace 方法的整个字符串</li>
<li>最后如果 RegExp 包含命名捕获组，替换函数还会收到一个参数，这个参数是一个对象，其属性名是捕获组的名字，属性值是匹配的文本</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="string">&quot;JavaScript&quot;</span>.<span class="title function_">search</span>(<span class="regexp">/script/ui</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line">&gt; <span class="string">&quot;JavaScript&quot;</span>.<span class="title function_">search</span>(<span class="regexp">/script/u</span>)</span><br><span class="line">-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="string">&quot;Hello, java, JAVAScript&quot;</span>.<span class="title function_">replace</span>(<span class="regexp">/java/gui</span>, <span class="string">&quot;Java&quot;</span>)</span><br><span class="line"><span class="string">&#x27;Hello, Java, JavaScript&#x27;</span></span><br><span class="line">&gt; <span class="string">&quot;she said: &#x27;hello&#x27;&quot;</span>.<span class="title function_">replace</span>(<span class="regexp">/&#x27;([^&#x27;]*)&#x27;/gu</span>, <span class="string">&quot;&lt;&lt;$1&gt;&gt;&quot;</span>)</span><br><span class="line"><span class="string">&#x27;she said: &lt;&lt;hello&gt;&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="string">&quot;she said: &#x27;hello&#x27;&quot;</span>.<span class="title function_">replace</span>(<span class="regexp">/&#x27;(?&lt;content&gt;[^&#x27;]*)&#x27;/gu</span>, <span class="string">&quot;|$&lt;content&gt;|&quot;</span>)</span><br><span class="line"><span class="string">&#x27;she said: |hello|&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="string">&quot;10 is 10&quot;</span>.<span class="title function_">replace</span>(<span class="regexp">/\d+/gu</span>, <span class="function"><span class="params">n</span> =&gt;</span> <span class="built_in">parseInt</span>(n).<span class="title function_">toString</span>(<span class="number">16</span>))</span><br><span class="line"><span class="string">&#x27;a is a&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>match() 是字符串最通用的正则表达式方法，它只有一个正则表达式参数（或者如果参数不是正则表达式，会把它传给 RegExp() 构造函数）​，返回一个数组，其中包含匹配的结果；如果没有找到匹配项，就返回 null
<ul>
<li>如果正则表达式有 g 标志，这个方法返回的数组会包含在字符串中找到的所有匹配项</li>
<li>如果正则表达式没有 g 标志，match() 不会执行全局搜索，只会查找第一个匹配项。在非全局搜索时，match() 仍然返回数组，但数组元素完全不同。此时数组第一个元素是匹配的字符串，剩下的所有元素是正则表达式中括号分组的捕获组匹配的子字符串。</li>
<li>在非全局搜索的情况下，match()返回的数组除了可以通过数值索引的元素，也有一些对象属性，包括 index（匹配项在字符串中的位置）、input（原始字符串）和 groups（命名捕获组的对象）</li>
<li>y 标志对 match 的行为也有影响：第一个匹配项必须始于字符串开头，每个后续的匹配项必须从前一个匹配项的后一个字符开始。默认的起始位置可以通过 RegExp 的 lastIndex 属性设置。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="string">&quot;1, 2, 3&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/\d+/gu</span>)</span><br><span class="line">[ <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span> ]</span><br><span class="line"></span><br><span class="line">&gt; <span class="string">&quot;1, 2, 3&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/\d+/u</span>)</span><br><span class="line">[ <span class="string">&#x27;1&#x27;</span>, <span class="attr">index</span>: <span class="number">0</span>, <span class="attr">input</span>: <span class="string">&#x27;1, 2, 3&#x27;</span>, <span class="attr">groups</span>: <span class="literal">undefined</span> ]</span><br><span class="line"></span><br><span class="line">&gt; <span class="string">&quot;http://www.google.com/api&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/(\w+):\/\/([\w.]+)\/(\S*)/</span>)</span><br><span class="line">[</span><br><span class="line">  <span class="string">&#x27;http://www.google.com/api&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;http&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;www.google.com&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;api&#x27;</span>,</span><br><span class="line">  <span class="attr">index</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">input</span>: <span class="string">&#x27;http://www.google.com/api&#x27;</span>,</span><br><span class="line">  <span class="attr">groups</span>: <span class="literal">undefined</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> p = <span class="regexp">/[aeiou]/y</span>;</span><br><span class="line"></span><br><span class="line">&gt; <span class="string">&quot;test&quot;</span>.<span class="title function_">match</span>(p)</span><br><span class="line"><span class="literal">null</span></span><br><span class="line">&gt; p.<span class="property">lastIndex</span> = <span class="number">1</span>;</span><br><span class="line">&gt; <span class="string">&quot;test&quot;</span>.<span class="title function_">match</span>(p)</span><br><span class="line">[ <span class="string">&#x27;e&#x27;</span>, <span class="attr">index</span>: <span class="number">1</span>, <span class="attr">input</span>: <span class="string">&#x27;test&#x27;</span>, <span class="attr">groups</span>: <span class="literal">undefined</span> ]</span><br><span class="line">&gt; p.<span class="property">lastIndex</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="string">&quot;test&quot;</span>.<span class="title function_">match</span>(p)</span><br><span class="line"><span class="literal">null</span></span><br><span class="line">&gt; p.<span class="property">lastIndex</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>matchAll() 方法是 ES2020 中定义的，在 2020 年年初已经被现代浏览器和 Node 实现</p>
<ul>
<li>matchAll() 接收一个带 g 标志的正则表达式</li>
<li>返回一个迭代器，每次迭代都产生一个与使用 match() 时传入非全局 RegExp 得到的匹配对象相同的对象。</li>
<li>也可以设置 RegExp 对象的lastIndex属性，告诉 matchAll() 从字符串中的哪个索引开始匹配。但是，与其他模式匹配方法不同的是，matchAll() 不会修改传入 RegExp 的 lastIndex 属性</li>
</ul>
</li>
<li>
<p>split() 方法使用传入的参数作为分隔符，将调用它的字符串拆分为子字符串保存到一个数组中</p>
<ul>
<li>该参数可以是一个正则表达式，这样就可以指定更通用的分隔符。</li>
<li>如果调用 <code>split()</code> 时传入 RegExp 作为分隔符，且这个正则表达式中包含捕获组，则捕获组匹配的文本也会包含在返回的数组中</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> s = <span class="string">&quot;1, 2, 3,\n4, 5&quot;</span></span><br><span class="line">&gt; s.<span class="title function_">split</span>()</span><br><span class="line">[ <span class="string">&#x27;1, 2, 3,\n4, 5&#x27;</span> ]</span><br><span class="line">&gt; s.<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">[ <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27; 2&#x27;</span>, <span class="string">&#x27; 3&#x27;</span>, <span class="string">&#x27;\n4&#x27;</span>, <span class="string">&#x27; 5&#x27;</span> ]</span><br><span class="line">&gt; s.<span class="title function_">split</span>(<span class="regexp">/\s*,\s*/</span>)</span><br><span class="line">[ <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span> ]</span><br></pre></td></tr></table></figure>
<h3 id="regexp-类"><a class="markdownIt-Anchor" href="#regexp-类"></a> RegExp 类</h3>
<p>RegExp() 构造函数接收一个或两个字符串参数，创建一个新 RegExp 对象。</p>
<ul>
<li>第一个参数是正则表达式的文本，即在正则表达式字面量中出现在斜杠中间的部分</li>
<li>注意，字符串字面量和正则表达式都使用 <code>\</code> 字符转义，因此在以字符串字面量形式给 <code>RegExp()</code> 传入正则表达式时，必须把所有 <code>\</code> 字符替换成 <code>\\</code></li>
<li>RegExp() 的第二个参数是可选的。如果提供了这个参数，则代表指定正则表达式的标志</li>
<li>除了给 RegExp() 的第一个参数传字符串，也可以传一个 RegExp 对象。这样可以复制已有的正则表达式，并且修改它的标志</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> zipcode = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;\\d&#123;5&#125;&quot;</span>, <span class="string">&quot;g&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>RegExp() 构造函数主要用于动态创建正则表达式，即创建那些无法用正则表达式字面量语法表示的正则表达式。</p>
<p>RegExp 提供 source、flags、global、ignoreCase、multiline、dotAll、unicode、sticky、lastIndex 等属性。</p>
<p>RegExp 类的 <code>test()</code> 方法是使用正则表达式的最简单方式。该方法接收一个字符串参数，如果字符串与模式匹配则返回 true，如果没有找到匹配项则返回 false。test() 方法的原理很简单，它会调用下面介绍的 <code>exec()</code> 方法，如果 <code>exec()</code> 返回非空值就返回true。</p>
<p>RegExp的 exec() 方法是使用正则表达式最通常、最强大的方式。该方法接收一个字符串参数，并从这个字符串寻找匹配：</p>
<ul>
<li>如果没有找到匹配项，则返回 null</li>
<li>如果找到了匹配项，则会返回一个数组，跟字符串的 <code>match()</code> 方法在非全局搜索时返回的数组一样</li>
</ul>
<p><code>exec()</code> 方法无论正则表达式是否设置了 g 标志都会返回相同的数组，即始终都是返回一个匹配项。在通过设置了全局 g 或粘着 y 标志的正则表达式调用 <code>exec()</code> 时，<code>exec()</code> 会根据 <code>RegExp</code> 对象的 <code>lastIndex</code> 属性来决定从哪里开始查找匹配。</p>
<ul>
<li>如果设置了 y 标志，那么也会限制匹配项必须从该位置开始</li>
<li>每次 <code>exec()</code> 成功执行，找到一个匹配项，都会更新 RegExp 的 lastIndex 属性，将其改写为匹配文本之后第一个字符的索引。如果 exec() 没有找到匹配项，它会将 lastIndex 重置为 0</li>
<li>这个特殊行为让我们得以重复调用 exec()，从而逐个找到字符串中所有的匹配项</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/Java/g</span>;</span><br><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;JavaScript &gt; Java&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> match;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((match = pattern.<span class="title function_">exec</span>(text)) !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Matched <span class="subst">$&#123;match[<span class="number">0</span>]&#125;</span> at <span class="subst">$&#123;match.index&#125;</span>`</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Next search begins at <span class="subst">$&#123;pattern.lastIndex&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># node exec.js</span></span><br><span class="line">Matched Java at 0</span><br><span class="line">Next search begins at 4</span><br><span class="line">Matched Java at 13</span><br><span class="line">Next search begins at 17</span><br></pre></td></tr></table></figure>
<p>JavaScript 正则表达式 API 其实挺复杂的。其中配合 <code>g</code> 和 <code>y</code> 标志的 lastIndex 属性则是这套 API 中最费解的地方。每当使用这两个标志时，都要在调用 <code>match()</code>、<code>exec()</code> 或 <code>test()</code> 方法时特别小心。因为这些方法的行为依赖于 lastIndex，而 lastIndex 的值依赖于之前对 RegExp 对象做了什么。</p>
<p>如下是两个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> match, positions = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可能无限循环，因为在循环结构中使用正则表达式字面量</span></span><br><span class="line"><span class="comment">// 每次循环都创建新的 RegExp 对象，每次都是 lastIndex 0 处开始搜索</span></span><br><span class="line"><span class="keyword">while</span> ((match = <span class="regexp">/&lt;p&gt;/g</span>.<span class="title function_">exec</span>(html)) !== <span class="literal">null</span>) &#123;</span><br><span class="line">  positions.<span class="title function_">push</span>(match.<span class="property">index</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;book&quot;</span>, <span class="string">&quot;coffee&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> results = [];</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/(\w)\1/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复用 pattern，再第一次匹配 apple 后，其 lastIndex 就更新为 3</span></span><br><span class="line"><span class="comment">// 因此匹配不到 book</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> w <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="keyword">if</span> (pattern.<span class="title function_">test</span>(w)) &#123;</span><br><span class="line">    results.<span class="title function_">push</span>(w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(results); <span class="comment">// =&gt; [ &#x27;apple&#x27;, &#x27;coffee&#x27; ]</span></span><br></pre></td></tr></table></figure>
<p>lastIndex 让 RegExp API 很容易出错。因此在使用 g 或 y 标志和循环时要格外注意。在ES2020 及之后的版本中，应该使用 String 的 matchAll() 方法而不是 exec() 来避开这个问题，因为 matchAll() 不会修改 lastIndex。</p>
<h2 id="日期与时间"><a class="markdownIt-Anchor" href="#日期与时间"></a> 日期与时间</h2>
<p>Date 类是 JavaScript 中用于操作日期和时间的 API。使用 Date() 构造函数可以创建一个日期对象。</p>
<ul>
<li>在不传参数的情况下，这个构造函数会返回一个表示当前日期和时间的 Date 对象</li>
<li>如果传入一个数值参数，Date() 构造函数会将其解释为自 1970 年至今经过的毫秒数：</li>
<li>如果传入两个或多个整数参数，它们会被解释为本地时区的年、月、日、时、分、秒和毫秒，</li>
<li>在使用多个参数调用时，Date()构造函数会使用本地计算机的时区来解释它们。如果想以 UTC 指定日期和时间，可以使用 Date.UTC() 静态方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">&gt; d</span><br><span class="line"><span class="number">2025</span>-<span class="number">01</span>-24<span class="attr">T09</span>:<span class="number">07</span>:<span class="number">26.</span>916Z</span><br><span class="line">&gt; d2</span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-01<span class="attr">T00</span>:<span class="number">00</span>:<span class="number">00</span>.000Z</span><br></pre></td></tr></table></figure>
<p>如果要打印日期​，默认会以本地时区打印。如果想以 UTC 显示日期，应该先使用 <code>toUTCString()</code> 或 <code>toISOString()</code> 转换它。</p>
<p>如果给 Date() 构造函数传入字符串，它会尝试按照日期和时间格式来解析该字符串。这个构造函数可以解析 toString()、toUTCString() 和 toISOString() 方法产生的格式</p>
<p>有了一个 Date 对象后，可以通过很多方法获取或设置这个对象的年、月、日、时、分、秒和毫秒字段。这些方法都有两种形式，一种使用本地时间获取和设置，另一种使用 UTC 时间获取和设置。例如 getFullYear()/getUTCFullYear()、setFullYear()/setUTCFullYear() 等。</p>
<h3 id="时间戳"><a class="markdownIt-Anchor" href="#时间戳"></a> 时间戳</h3>
<p>JavaScript 在内部将日期表示为整数，代表自 1970 年 1 月 1 日半夜 12 点起（或之前）的毫秒数。对于任何 Date 对象，getTime()方法返回这个内部值，而setTime()方法设置这个值。</p>
<p>这些毫秒值有时候也被称为时间戳 <code>timestamp</code>，有时候直接使用这些值比使用 Date 对象更方便。静态的 <code>Date.now()</code> 方法返回当前时间的时间戳。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">&gt; d.<span class="title function_">getTime</span>()</span><br><span class="line"><span class="number">1737710290117</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line"><span class="number">1737710400557</span></span><br></pre></td></tr></table></figure>
<h3 id="高精度时间戳"><a class="markdownIt-Anchor" href="#高精度时间戳"></a> 高精度时间戳</h3>
<p>Date.now() 返回的时间戳是以毫秒为单位的。毫秒对计算机来说实际上是个比较长的时间单位。有时候可能需要使用更高的精度来表示经历的时间。此时可以使用 <code>performance.now()</code>，虽然它返回的也是以毫秒为单位的时间戳，但返回值并不是整数，包含毫秒后面的小数部分。</p>
<ul>
<li>performance.now() 返回的值并不是像 <code>Date.now()</code> 那样返回一个绝对时间戳，而是相对于网页加载完成后或 Node 进程启动后经过的时间</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; performance.<span class="title function_">now</span>()</span><br><span class="line"><span class="number">253795.39952754974</span></span><br></pre></td></tr></table></figure>
<h3 id="日期计算"><a class="markdownIt-Anchor" href="#日期计算"></a> 日期计算</h3>
<ul>
<li>Date对象可以使用 JavaScript 标准的 &lt;、&lt;=、&gt; 和 &gt;= 等比较操作符进行比较</li>
<li>可以用一个 Date 对象减去另一个以确定两个日期相关的毫秒数</li>
<li>要完成涉及天数、月数和年数的计算，可以使用 setDate()、setMonth() 和 setYear()。日期设置方法即使在数值溢出的情况下也能正确工作</li>
</ul>
<h3 id="格式化与解析日期字符串"><a class="markdownIt-Anchor" href="#格式化与解析日期字符串"></a> 格式化与解析日期字符串</h3>
<p>Date 类定义了如下字符串格式方法：</p>
<ul>
<li>toString()：使用本地时区但不按照当地惯例格式化日期和时间</li>
<li>toUTCString()：使用 UTC 时区但不按照当地惯例格式化日期和时间</li>
<li>toISOString()：使用 UTC 时区（结尾的 Z 可以看出）并以 ISO 8601 标准格式化日期和时间</li>
<li>toLocaleString()：使用本地时区并根据当地惯例格式化日期和时间</li>
<li>toDateString()：使用本地时区格式化日期（不包含时间）。它使用本地时区，但不与当地惯例适配</li>
<li>toLocaleDateString()：使用本地时区并根据当地惯例格式化日期部分（不包含时间）</li>
<li>toTimeString()：使用本地时区格式化时间部分（不包含日期）</li>
<li>toLocaleTimeString()：使用本地时区并根据当地惯例格式化时间部分（不包含日期）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; d.<span class="title function_">toString</span>()</span><br><span class="line"><span class="string">&#x27;Fri Jan 24 2025 17:29:07 GMT+0800 (China Standard Time)&#x27;</span></span><br><span class="line">&gt; d.<span class="title function_">toUTCString</span>()</span><br><span class="line"><span class="string">&#x27;Fri, 24 Jan 2025 09:29:07 GMT&#x27;</span></span><br><span class="line">&gt; d.<span class="title function_">toISOString</span>()</span><br><span class="line"><span class="string">&#x27;2025-01-24T09:29:07.987Z&#x27;</span></span><br><span class="line">&gt; d.<span class="title function_">toLocaleString</span>()</span><br><span class="line"><span class="string">&#x27;1/24/2025, 5:29:07 PM&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt; d.<span class="title function_">toDateString</span>()</span><br><span class="line"><span class="string">&#x27;Fri Jan 24 2025&#x27;</span></span><br><span class="line">&gt; d.<span class="title function_">toLocaleDateString</span>()</span><br><span class="line"><span class="string">&#x27;1/24/2025&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt; d.<span class="title function_">toTimeString</span>()</span><br><span class="line"><span class="string">&#x27;17:29:07 GMT+0800 (China Standard Time)&#x27;</span></span><br><span class="line">&gt; d.<span class="title function_">toLocaleTimeString</span>()</span><br><span class="line"><span class="string">&#x27;5:29:07 PM&#x27;</span></span><br></pre></td></tr></table></figure>
<p>Date.parse() 静态方法接收一个字符串参数，并尝试将其作为日期和时间来解析，返回一个表示该日期的时间戳。</p>
<h2 id="error-类"><a class="markdownIt-Anchor" href="#error-类"></a> Error 类</h2>
<p>JavaScript 的 throw 和 catch 语句可以抛出和捕获任何 JavaScript 值，包括原始值。JavaScript 也定义了一个 Error 类。惯常的做法是使用 Error 类或其子类的实例作为 throw 抛出的错误。</p>
<p>使用 Error 对象的一个主要原因就是在创建 Error 对象时，该对象能够捕获 JavaScript 的栈状态，如果异常未被捕获，则会显示包含错误消息的栈跟踪信息，而这对排查错误很有帮助（栈跟踪信息会展示创建 Error 对象的地方，而不是 throw 语句抛出它的地方）。</p>
<p>Error 对象有两个属性：message 和 name，还有一个 toString() 方法：</p>
<ul>
<li>message 属性的值是我们传给 Error() 构造函数的值，必须时会被转换为字符串</li>
<li>通过 <code>Error()</code> 创建的错误对象，其 name 属性值为 “Error”</li>
<li>toString() 方法返回一个字符串，由 name 属性的值后跟一个冒号和一个空格，再后跟 message 属性的值构成。</li>
</ul>
<p>虽然 ECMAScript 标准并没有定义，但 Node 和所有现代浏览器也都在 Error 对象上定义了 stack 属性：包含创建错误对象时 JavaScript 调用栈的栈跟踪信息。在捕获到异常错误时，可以将这个属性的信息作为日志收集起来。</p>
<p>除了 Error 类，JavaScript 还定义了一些它的子类，以便触发 ECMAScript 定义的一些特殊类型的错误。这些子类包括：EvalError、RangeError、ReferenceError、SyntaxError、TypeError 和 URIError。</p>
<p>作为开发者，我们可以自己定义 Error 的子类，以便更好地封装自己程序的错误信息。自定义错误对象可以不限于 message 和 name 属性，可以任意添加新属性以提供更多的错误细节。</p>
<h2 id="json-序列化与解析"><a class="markdownIt-Anchor" href="#json-序列化与解析"></a> JSON 序列化与解析</h2>
<p>当程序需要保存数据或需要通过网络连接向另一个程序传输数据时，必须将内存中的数据结构转换为字节或字符的序列，才可以保存或传输。这个将数据结构转换为字节或字符流的方式称为序列化。</p>
<p>JavaScript 中序列化数据的最简单方式是使用一种称为 JSON 的序列化格式。JSON 是<code>JavaScript Object Notation</code>​（JavaScript 对象表示法）的简写形式。这种格式使用JavaScript 对象和数组字面量语法，将对象和数组形式的数据结构转换为字符串：</p>
<ul>
<li>JSON 支持原始数值和字符串，也支持 true、false 和 null值，以及在这些原始值基础上构建起来的对象和数组</li>
<li>JSON 不支持其他 JavaScript 类型，如 Map、Set、RegExp、Date 或定型数组</li>
</ul>
<p>JavaScript 通过两个函数 <code>JSON.stringify</code> ()和 <code>JSON.parse()</code> 支持 JSON 序列化和反序列化。可以使用这对函数（以没有那么高效的方式）创建对象的深度副本：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Json</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(o));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据被序列化为 JSON 格式后，结果是有效的 JavaScript 表达式源代码，可以求值为原始数据结构的一个副本。</p>
<p>JSON 有时候也被用为人类友好的配置文件格式。如果你发现自己在手工编辑 JSON 文件，注意 JSON 格式是 JavaScript 的严格子集。不允许有注释，属性名也必须包含在双引号中。</p>
<p>JSON.stringify()的第三个参数告诉它应该把数据格式化为多行缩进格式。如果第三个参数是个数值，则该数值表示每级缩进的空格数。如果第三个参数是空白符（如’\t’）字符串，则每级缩进就使用该字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> o = &#123;<span class="attr">s</span>: <span class="string">&quot;test&quot;</span>, <span class="attr">n</span>: <span class="number">10</span>&#125;</span><br><span class="line">&gt; <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(o, <span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line"><span class="string">&#x27;&#123;\n  &quot;s&quot;: &quot;test&quot;,\n  &quot;n&quot;: 10\n&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="params"><span class="built_in">JSON</span>.stringify(o, <span class="literal">null</span>, <span class="number">2</span>)</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;s&quot;</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">  <span class="string">&quot;n&quot;</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="params"><span class="built_in">JSON</span>.stringify(o)</span>)</span><br><span class="line">&#123;<span class="string">&quot;s&quot;</span>:<span class="string">&quot;test&quot;</span>,<span class="string">&quot;n&quot;</span>:<span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="json-自定义"><a class="markdownIt-Anchor" href="#json-自定义"></a> JSON 自定义</h3>
<p>如果 <code>JSON.stringify()</code> 在序列化时碰到了 JSON 格式原生不支持的值，它会查找这个值是否有 toJSON() 方法。如果有这个方法，就会调用它，然后将其返回值字符串化以代替原始值。例如 Date 对象就实现了 toJSON() 方法，返回和 toISOStrin() 相同的字符串。但是在解析序列化之后的字符串时，重新创建的数据结构就不会与开始时的完全一样了，因为原来的 Date 值变成了字符串。</p>
<p>如果想重新创建这个 Date 对象（或以其他方式修改解析后的对象）​，可以给 <code>JSON.parse()</code> 的第二个参数传一个 <code>复活</code>（reiver）函数。如果指定了这个 <code>复活</code> 函数，该函数就会在解析输入字符串中的每个原始值时被调用（但解析包含这些原始值的对象和数组时不会调用）​。复活函数的参数如下：</p>
<ul>
<li>第一个是属性名，可能是对象属性名，也可能是转换为字符串的数组索引名</li>
<li>第二个参数是该对象属性或数组元素对应的原始值</li>
<li>这个函数会作为包含上述原始值的对象或数组的方法调用，因此可以在其中通过 this 关键字引用包含对象</li>
</ul>
<p>复活函数的返回值会变成命名属性的新值：</p>
<ul>
<li>如果复活函数返回它的第二个参数，那么属性保持不变</li>
<li>如果它返回 undefined，则相应的命名属性会从对象或数组中删除，即 JSON.parse() 返回给用户的对象中将不包含该属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(text, <span class="keyword">function</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&quot;_&quot;</span>) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&quot;string&quot;</span> &amp;&amp;</span><br><span class="line">    <span class="regexp">/^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\dd.\d\d\dZ$/</span>.<span class="title function_">text</span>(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>除了前面提到的 <code>toJSON()</code>，<code>JSON.stringify()</code> 也支持给它传入一个数组或函数作为第二个参数来自定义其输出字符串。</p>
<ul>
<li>如果第二个参数传入的是一个字符串数组（或者数值数组，其中的数值会转换为字符串）​，那么这些字符串会被当作对象属性（或数组元素）的名字。任何名字不在这个数组之列的属性会被字符串化过程忽略</li>
<li>如果给 JSON.stringify() 的第二个参数传入一个函数，则该函数就是一个替代函数（作用与传给 JSON.parse() 的可选的复活函数恰好相反）​
<ul>
<li>这个替代函数的第一个参数是对象属性名或值在对象中的数组索引，第二个参数是值本身</li>
<li>这个替代函数会作为包含要被字符串化的值的对象或数组的方法调用</li>
<li>替代函数的返回值会替换原始值。如果替代函数返回 undefined 或什么也不返回，则该值（及其数组元素或对象属性）将在字符串化过程中被忽略</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> json = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(o, <span class="function">(<span class="params">k, v</span>) =&gt;</span> v <span class="keyword">instanceof</span> <span class="title class_">RegExp</span> ? <span class="literal">undefined</span> : v);</span><br></pre></td></tr></table></figure>
<h2 id="国际化-api"><a class="markdownIt-Anchor" href="#国际化-api"></a> 国际化 API</h2>
<p>JavaScript 国际化 API 包括 3 个类：</p>
<ul>
<li>Intl.NumberFormat</li>
<li>Intl.DateTimeFormat</li>
<li>Intl.Collator</li>
</ul>
<p>这 3 个类允许我们以适合当地的方式格式化数值（包括货币数量和百分数）​、日期和时间，以及以适合当地的方式比较字符串。</p>
<h3 id="格式化数值"><a class="markdownIt-Anchor" href="#格式化数值"></a> 格式化数值</h3>
<p>世界各地的用户对数值格式的预期是不同的，Intl.NumberFormat 类定义了一个 format() 方法，以满足各种格式化需求：</p>
<ul>
<li>这个构造函数接收两个参数，第一个参数指定作为数值格式化依据的地区，第二个参数是用于指定格式化细节的对象。
<ul>
<li>如果第一个参数忽略或者为 undefined，则使用系统设置中的地区</li>
<li>第二个参数为一个对象，包含一个或多个如下属性：style（数值的格式类型）、useGrouping（是否使用千位分隔符）等等。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> euros = <span class="title class_">Intl</span>.<span class="title class_">NumberFormat</span>(<span class="string">&quot;en&quot;</span>, &#123;<span class="attr">style</span>: <span class="string">&quot;currency&quot;</span>, <span class="attr">currency</span>: <span class="string">&quot;EUR&quot;</span>&#125;)</span><br><span class="line">&gt; euros.<span class="title function_">format</span>(<span class="number">10</span>)</span><br><span class="line"><span class="string">&#x27;€10.00&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>Intl.NumberFormat</code>（及其他Intl类）有一个很有用的特性，即它的 <code>format()</code> 方法会绑定到自己所属的 NumberFormat 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> format =  <span class="title class_">Intl</span>.<span class="title class_">NumberFormat</span>(<span class="string">&quot;en&quot;</span>, &#123;<span class="attr">style</span>: <span class="string">&quot;currency&quot;</span>, <span class="attr">currency</span>: <span class="string">&quot;EUR&quot;</span>&#125;).<span class="property">format</span></span><br><span class="line">&gt; [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>].<span class="title function_">map</span>(format)</span><br><span class="line">[ <span class="string">&#x27;€10.00&#x27;</span>, <span class="string">&#x27;€20.00&#x27;</span>, <span class="string">&#x27;€30.00&#x27;</span> ]</span><br></pre></td></tr></table></figure>
<h3 id="格式化日期和时间"><a class="markdownIt-Anchor" href="#格式化日期和时间"></a> 格式化日期和时间</h3>
<p><code>Intl.DateTimeFormat()</code> 构造函数与 <code>Intl.NumberFormat()</code> 接收相同的两个参数：一个地区或地区数组，另一个是格式化选项的对象。使用 <code>Intl.DateTimeFormat</code> 实例的方式也是调用其 format() 方法，将 Date 对象转换为字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="title class_">Intl</span>.<span class="title class_">DateTimeFormat</span>(<span class="string">&quot;en-US&quot;</span>, &#123;<span class="attr">weekday</span>: <span class="string">&quot;long&quot;</span>, <span class="attr">month</span>:<span class="string">&quot;long&quot;</span>, <span class="attr">year</span>:<span class="string">&quot;numeric&quot;</span>&#125;).<span class="title function_">format</span>(d)</span><br><span class="line"><span class="string">&#x27;January 2025 Sunday&#x27;</span></span><br></pre></td></tr></table></figure>
<p>Intl.DateTimeFormat默认使用儒略历，但也可以使用其他日历。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; d</span><br><span class="line"><span class="number">2025</span>-<span class="number">01</span>-26<span class="attr">T01</span>:<span class="number">57</span>:<span class="number">00</span>.232Z</span><br><span class="line">&gt; <span class="title class_">Intl</span>.<span class="title class_">DateTimeFormat</span>(<span class="string">&quot;en-U-ca-chinese&quot;</span>).<span class="title function_">format</span>(d)</span><br><span class="line"><span class="string">&#x27;12/27/2024&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="比较字符串"><a class="markdownIt-Anchor" href="#比较字符串"></a> 比较字符串</h3>
<p>可以创建一个 <code>Intl.Collator</code> 对象，可以将这个对象的 <code>compare()</code> 方法传给 <code>sort()</code> 方法，以执行适合当地的字符串排序。与 <code>Intl.NumberFormat()</code> 和 <code>Intl.DateTimeFormat()</code> 类似，<code>Intl.Collator()</code> 构造函数也接收两个参数：</p>
<ul>
<li>第一个参数指定地区或地区数组</li>
<li>第二个参数是一个可选的对象，其属性指定具体执行哪种比较</li>
</ul>
<p>在通过选项为目标地区创建 <code>Intl.Collator</code> 对象之后，可以使用它的 <code>compare()</code> 方法比较两个字符串：</p>
<ul>
<li><code>compare()</code> 方法接收两个字符串参数，返回一个小于、等于或大于 0 的数值</li>
<li><code>Intl.Collator</code> 也会自动将 <code>compare()</code> 方法绑定到它的实例</li>
<li>因此可以直接把这个方法传给 <code>sort()</code> 而无须编写包装函数再通过整理器调用它</li>
</ul>
<h2 id="控制台-api"><a class="markdownIt-Anchor" href="#控制台-api"></a> 控制台 API</h2>
<p>我们一直使用 <code>console.log</code> 来输出信息：</p>
<ul>
<li>在浏览器中，<code>console.log()</code> 会在开发者工具面板的 <code>控制台</code> 标签页中打印字符串，这是排查问题时非常有用的功能</li>
<li>在 Node 中，<code>console.log()</code> 是通用的输出函数，可以将其参数打印到进程的标准输出流，通常会作为程序输出显示在用户的终端窗口中</li>
</ul>
<p>控制台 API 并不是 ECMAScript 标准，但已经被浏览器和 Node 支持：</p>
<ul>
<li>console.log()：它将参数转换为字符串并输出到控制台。它会在参数之间输出空格，并在输出所有参数后重新开始一行</li>
<li>console.debug()、<a target="_blank" rel="noopener" href="http://console.info">console.info</a>()、console.warn()、console.error()：这几个函数与console.log() 几乎相同
<ul>
<li>在 Node 中，<code>console.error()</code> 将其输出发送到标准错误流，而不是标准输出流。除此之外的其他函数都是 <code>console.log()</code> 的别名。</li>
<li>在浏览器中，这几个函数生成的输出消息前面可能会带一个图标，表示级别或严重程度</li>
</ul>
</li>
<li>console.assert()：
<ul>
<li>如果这个函数的第一个参数是真值（也就是断言通过）​，则这个函数什么也不做</li>
<li>但如果第一个参数是假值，则剩余参数会像被传给 console.error() 一样打印出来，且前面带一个 <code>Assertion failed</code> 前缀，该函数不会抛出异常</li>
</ul>
</li>
<li>console.clear()：清空控制台</li>
<li>console.table()：产生表列数据输出</li>
<li>console.trace()：这个函数会像 <code>console.log()</code> 一样打印它的参数，此外在输出之后还会打印栈跟踪信息</li>
<li>console.count()：这个函数接收一个字符串参数，并打印该字符串，后面跟着已经通过该字符串调用的次数。在调试事件处理程序时，如果需要知道事件处理程序被触发的次数，可以使用这个函数</li>
<li>console.countReset()：接收一个字符串参数，并重置针对该字符串的计数器</li>
<li>console.group()：可以将控制台的输出消息以缩进的形式形成分组</li>
<li>console.groupCollapsed()：与 console.group() 类似，但默认情况下分组会被折叠</li>
<li>console.groupEnd()：结束一个分组</li>
<li>console.time()：接收一个字符串参数，并记录以该字符串调用自身时的时间，没有输出</li>
<li>console.timeLog()：接收一个字符串作为第一个参数，如果这个字符串之前传给过 <code>console.time()</code>，那么它会打印该字符串及自上次调用 <code>console.time()</code> 之后经过的时间。其他参数则像传递给 <code>console.log()</code> 一样处理</li>
<li>console.timeEnd()：接收一个字符串参数，如果该参数之前传给过 <code>console.time()</code>，则它打印该参数及经过的时间。在调用 <code>console.timeEnd()</code> 之后，如果不再调用 <code>console.time()</code>，则调用 <code>console.timeLog()</code> 将是不合法的</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> a = [&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;, &#123;<span class="attr">x</span>:<span class="number">3</span>, <span class="attr">y</span>:<span class="number">4</span>&#125;, &#123;<span class="attr">x</span>:<span class="number">5</span>, <span class="attr">y</span>:<span class="number">6</span>&#125;]</span><br><span class="line">&gt; <span class="variable language_">console</span>.<span class="title function_">table</span>(a)</span><br><span class="line">┌─────────┬───┬───┐</span><br><span class="line">│ (index) │ x │ y │</span><br><span class="line">├─────────┼───┼───┤</span><br><span class="line">│    <span class="number">0</span>    │ <span class="number">1</span> │ <span class="number">2</span> │</span><br><span class="line">│    <span class="number">1</span>    │ <span class="number">3</span> │ <span class="number">4</span> │</span><br><span class="line">│    <span class="number">2</span>    │ <span class="number">5</span> │ <span class="number">6</span> │</span><br><span class="line">└─────────┴───┴───┘</span><br></pre></td></tr></table></figure>
<h3 id="通过控制台格式化输出"><a class="markdownIt-Anchor" href="#通过控制台格式化输出"></a> 通过控制台格式化输出</h3>
<p>像 <code>console.log()</code> 这样打印自己参数的控制台函数都有一个不太为人所知的特性：如果第一个参数是包含 <code>%s</code>、<code>%i</code>、<code>%d</code>、<code>%f</code>、<code>%o</code>、<code>%O</code> 或 <code>%c</code> 的字符串，则这个参数会被当成格式字符串。后续参数的值会被代入这个字符串，以取代这些两个字符的 % 序列。</p>
<p>但一般在使用控制台函数时，通常并不需要格式字符串。一般来说，只要把一个或多个值（包括对象）传给这些函数，由实现决定如何以有用的方式显示它们就可以了。</p>
<h2 id="url-api"><a class="markdownIt-Anchor" href="#url-api"></a> URL API</h2>
<p>由于 JavaScript 多用于浏览器和服务器，因此 JavaScript 代码经常需要操作 URL。URL API 并不是 ECMAScript 标准定义的，但 Node 和所有浏览器都实现了它。</p>
<p>使用 <code>URL()</code> 构造函数创建 URL 对象时，</p>
<ul>
<li>可以传入一个绝对 URL 作为参数</li>
<li>也可以将一个相对 URL 作为第一个参数，将其相对的绝对 URL 作为第二个参数</li>
</ul>
<p>创建了 URL 对象后，可以通过它的各种属性查询 URL 不同部分的非转义值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&quot;https://www.example.com:8000/test?id=1#fragment&quot;</span>)</span><br><span class="line">&gt; url</span><br><span class="line"><span class="variable constant_">URL</span> &#123;</span><br><span class="line">  <span class="attr">href</span>: <span class="string">&#x27;https://www.example.com:8000/test?id=1#fragment&#x27;</span>,</span><br><span class="line">  <span class="attr">origin</span>: <span class="string">&#x27;https://www.example.com:8000&#x27;</span>,</span><br><span class="line">  <span class="attr">protocol</span>: <span class="string">&#x27;https:&#x27;</span>,</span><br><span class="line">  <span class="attr">username</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">host</span>: <span class="string">&#x27;www.example.com:8000&#x27;</span>,</span><br><span class="line">  <span class="attr">hostname</span>: <span class="string">&#x27;www.example.com&#x27;</span>,</span><br><span class="line">  <span class="attr">port</span>: <span class="string">&#x27;8000&#x27;</span>,</span><br><span class="line">  <span class="attr">pathname</span>: <span class="string">&#x27;/test&#x27;</span>,</span><br><span class="line">  <span class="attr">search</span>: <span class="string">&#x27;?id=1&#x27;</span>,</span><br><span class="line">  <span class="attr">searchParams</span>: <span class="title class_">URLSearchParams</span> &#123; <span class="string">&#x27;id&#x27;</span> =&gt; <span class="string">&#x27;1&#x27;</span> &#125;,</span><br><span class="line">  <span class="attr">hash</span>: <span class="string">&#x27;#fragment&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管并不常用，但 URL 可以包含用户名或者用户和密码，URL 类也可以解析这些 URL 组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&quot;https://user:password@example.com/api/data&quot;</span>)</span><br><span class="line">&gt; url</span><br><span class="line"><span class="variable constant_">URL</span> &#123;</span><br><span class="line">  <span class="attr">href</span>: <span class="string">&#x27;https://user:password@example.com/api/data&#x27;</span>,</span><br><span class="line">  <span class="attr">origin</span>: <span class="string">&#x27;https://example.com&#x27;</span>,</span><br><span class="line">  <span class="attr">protocol</span>: <span class="string">&#x27;https:&#x27;</span>,</span><br><span class="line">  <span class="attr">username</span>: <span class="string">&#x27;user&#x27;</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="string">&#x27;password&#x27;</span>,</span><br><span class="line">  <span class="attr">host</span>: <span class="string">&#x27;example.com&#x27;</span>,</span><br><span class="line">  <span class="attr">hostname</span>: <span class="string">&#x27;example.com&#x27;</span>,</span><br><span class="line">  <span class="attr">port</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">pathname</span>: <span class="string">&#x27;/api/data&#x27;</span>,</span><br><span class="line">  <span class="attr">search</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">searchParams</span>: <span class="title class_">URLSearchParams</span> &#123;&#125;,</span><br><span class="line">  <span class="attr">hash</span>: <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>URL 类有一个重要特性，即它会在需要时正确地在 URL 中添加标点符号及转义特殊字符</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&quot;https://example.com&quot;</span>);</span><br><span class="line">&gt; url.<span class="property">pathname</span> = <span class="string">&quot;path with space&quot;</span></span><br><span class="line"><span class="string">&#x27;path with space&#x27;</span></span><br><span class="line">&gt; url.<span class="property">search</span> = <span class="string">&quot;q=foo#bar&quot;</span></span><br><span class="line"><span class="string">&#x27;q=foo#bar&#x27;</span></span><br><span class="line">&gt; url.<span class="property">pathname</span></span><br><span class="line"><span class="string">&#x27;/path%20with%20space&#x27;</span></span><br><span class="line">&gt; url.<span class="property">search</span></span><br><span class="line"><span class="string">&#x27;?q=foo%23bar&#x27;</span></span><br><span class="line">&gt; url.<span class="property">href</span></span><br><span class="line"><span class="string">&#x27;https://example.com/path%20with%20space?q=foo%23bar&#x27;</span></span><br></pre></td></tr></table></figure>
<p>读取 <code>href</code> 属性相当于调用 <code>toString()</code>，即将 URL 的所有部分组合成一个字符串形式的正式 URL。将 <code>href</code> 设置为一个新字符串会返回该新字符串上的 URL 解析器，就好像再次调用了 <code>URL()</code> 构造函数一样。</p>
<p>HTTP 请求经常会使用 <code>application/x-www-form-urlencoded</code> 格式将多个表单字段的值或多个 API 参数编码为 URL 的查询部分。在这个格式中，URL的查询部分以问号开头，然后是一个或多个由 <code>&amp;</code> 分隔的名/值对。此时，searchParams 属性比 search 属性更有用。search 属性是一个对 URLSearchParams 对象的只读引用，而 URLSearchParams 对象具有获取、设置、添加、删除和排序参数（该参数编码为URL的查询部分）的 API：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&quot;https://example.com/search&quot;</span>)</span><br><span class="line">&gt; url.<span class="property">search</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span></span><br><span class="line">&gt; url.<span class="property">searchParams</span></span><br><span class="line"><span class="title class_">URLSearchParams</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">&gt; url.<span class="property">searchParams</span>.<span class="title function_">append</span>(<span class="string">&quot;q&quot;</span>, <span class="string">&quot;term&quot;</span>)</span><br><span class="line">&gt; url.<span class="property">search</span></span><br><span class="line"><span class="string">&#x27;?q=term&#x27;</span></span><br><span class="line">&gt; url.<span class="property">searchParams</span>.<span class="title function_">get</span>(<span class="string">&quot;q&quot;</span>)</span><br><span class="line"><span class="string">&#x27;term&#x27;</span></span><br><span class="line">&gt; url.<span class="property">searchParams</span>.<span class="title function_">get</span>(<span class="string">&quot;p&quot;</span>)</span><br><span class="line"><span class="literal">null</span></span><br><span class="line">&gt; url.<span class="property">searchParams</span>.<span class="title function_">has</span>(<span class="string">&quot;p&quot;</span>)</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&gt; url.<span class="property">searchParams</span>.<span class="title function_">append</span>(<span class="string">&quot;opts&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">&gt; url.<span class="property">searchParams</span>.<span class="title function_">append</span>(<span class="string">&quot;opts&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">&gt; url.<span class="property">search</span></span><br><span class="line"><span class="string">&#x27;?q=term&amp;opts=1&amp;opts=2&#x27;</span></span><br><span class="line">&gt; url.<span class="property">searchParams</span>.<span class="title function_">get</span>(<span class="string">&quot;opts&quot;</span>)</span><br><span class="line"><span class="string">&#x27;1&#x27;</span></span><br><span class="line">&gt; url.<span class="property">searchParams</span>.<span class="title function_">getAll</span>(<span class="string">&quot;opts&quot;</span>)</span><br><span class="line">[ <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span> ]</span><br></pre></td></tr></table></figure>
<p>searchParams 属性的值是一个 URLSearchParams 对象。如果想把 URL 参数编码为查询字符串，可以创建 URLSearchParams 对象，追加参数，然后再将它转换为字符串并将其赋值给 URL 的 search 属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&quot;https://example.com&quot;</span>)</span><br><span class="line">&gt; <span class="keyword">let</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>()</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt; params.<span class="title function_">append</span>(<span class="string">&quot;q&quot;</span>, <span class="string">&quot;term&quot;</span>)</span><br><span class="line">&gt; params.<span class="title function_">append</span>(<span class="string">&quot;opts&quot;</span>, <span class="string">&quot;exact&quot;</span>)</span><br><span class="line">&gt; url.<span class="property">search</span> = params.<span class="title function_">toString</span>()</span><br><span class="line"><span class="string">&#x27;q=term&amp;opts=exact&#x27;</span></span><br><span class="line">&gt; url.<span class="property">href</span></span><br><span class="line"><span class="string">&#x27;https://example.com/?q=term&amp;opts=exact&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="遗留-url-函数"><a class="markdownIt-Anchor" href="#遗留-url-函数"></a> 遗留 URL 函数</h3>
<p>在前面介绍的 URL API 标准化之前，JavaScript 语言也曾多次尝试支持对 URL 的转义和反转义。例如 <code>escape()</code> 和 <code>unescape()</code> 函数，如今这两个函数已经被废弃，ECMAScript 增加了两对替代性的全局函数。</p>
<ul>
<li>encodeURI() 和 decodeURI()：
<ul>
<li>实现对字符串的 URL 编码/解码</li>
<li><code>encodeURI()</code> 是要编码整个 URL，所以不会转义 URL 分隔符（如 <code>/</code>、<code>?</code> 和 <code>#</code>）​。这意味着 <code>encodeURI()</code> 不能正确地处理其组件中包含这些字符的 URL</li>
</ul>
</li>
<li>encodeURIComponent() 和 decodeURIComponent()：
<ul>
<li>它们专门用于转义 URL 的单个组件，因此它们也会转义用于分隔 URL 组件的 <code>/</code>、<code>?</code> 和 <code>#</code> 字符</li>
<li>但它也有缺陷：例如会转义路径名中的/字符，而这可能并不是我们想要的；把查询参数中的空格转换为 <code>%20</code>，而实际上查询参数中的空格应该被转义为+。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">encodeURI</span>(<span class="string">&quot;https://example.com/path?q=?1&quot;</span>)</span><br><span class="line"><span class="string">&#x27;https://example.com/path?q=?1&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>这些遗留函数的根本问题在于它们都在寻求把一种编码模式应用给 URL 的所有部分，而事实却是 URL 的不同部分使用的是不同的编码方案</strong>。如果想正确地格式化和编码 URL，最简单的办法就是使用 URL 类完成所有 URL 相关的操作。</p>
<h2 id="计时器"><a class="markdownIt-Anchor" href="#计时器"></a> 计时器</h2>
<p>利用 <code>setTimeout()</code> 和 <code>setInterval()</code> 这两个函数，程序可以让浏览器在指定的时间过后调用一个函数，或者每经过一定时间就重复调用一次某个函数。</p>
<ul>
<li>
<p>setTimeout() 的第一个参数是函数，第二个参数是数值，数值表示过多少毫秒之后调用第一个函数</p>
<ul>
<li><code>setTimeout()</code> 并不会等到指定时间之后再返回</li>
<li>如果省略传给 <code>setTimeout()</code> 的第二个参数，则该参数默认值为 0，这意味着注册的函数会被尽快被调用</li>
<li>setTimeout() 注册的函数只会被调用一次</li>
</ul>
</li>
<li>
<p><code>setInterval()</code> 接收的参数与 <code>setTimeout()</code> 相同，但会导致每隔指定时间（同样是个近似的毫秒值）就调用一次指定函数。</p>
</li>
<li>
<p><code>setTimeout()</code> 和 <code>setInterval()</code> 都返回一个值。如果把这个值保存在变量中，之后可以把它传给 <code>clearTimeout()</code> 或 <code>clearInterval()</code> 以取消对函数的调用</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;called&quot;</span>), <span class="number">3000</span>)</span><br><span class="line">&gt; called</span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;called&quot;</span>), <span class="number">3000</span>)</span><br><span class="line">&gt; called</span><br><span class="line">called</span><br><span class="line">called</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> clock = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">clear</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toLocaleString</span>());</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="built_in">clearInterval</span>(clock); &#125;, <span class="number">10000</span>);</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/%E5%89%8D%E7%AB%AF/" rel="tag"># 前端</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/01/19/javascript-guide-12/" rel="prev" title="JavaScript 权威指南 12：迭代器与生成器">
      <i class="fa fa-chevron-left"></i> JavaScript 权威指南 12：迭代器与生成器
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/01/17/javascript-guide-10/" rel="next" title="JavaScript 权威指南 10：模块">
      JavaScript 权威指南 10：模块 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E4%B8%8E%E6%98%A0%E5%B0%84"><span class="nav-number">1.</span> <span class="nav-text"> 集合与映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#set"><span class="nav-number">1.1.</span> <span class="nav-text"> Set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-%E7%B1%BB"><span class="nav-number">1.2.</span> <span class="nav-text"> Map 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#weakmap-%E5%92%8C-weakset"><span class="nav-number">1.3.</span> <span class="nav-text"> WeakMap 和 WeakSet</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E5%9E%8B%E6%95%B0%E7%BB%84%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE"><span class="nav-number">2.</span> <span class="nav-text"> 定型数组与二进制数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E5%9E%8B%E6%95%B0%E7%BB%84%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.</span> <span class="nav-text"> 定型数组的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%9A%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="nav-number">2.2.</span> <span class="nav-text"> 创建定型数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9A%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="nav-number">3.</span> <span class="nav-text"> 使用定型数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E5%9E%8B%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%8E%E5%B1%9E%E6%80%A7"><span class="nav-number">4.</span> <span class="nav-text"> 定型数组的方法与属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dataview-%E4%B8%8E%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="nav-number">4.1.</span> <span class="nav-text"> DataView 与字节序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">5.</span> <span class="nav-text"> 正则表达式与模式匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">5.1.</span> <span class="nav-text"> 定义正则表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%97%E7%AC%A6"><span class="nav-number">5.2.</span> <span class="nav-text"> 正则表达式字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95"><span class="nav-number">5.3.</span> <span class="nav-text"> 模式匹配的字符串方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#regexp-%E7%B1%BB"><span class="nav-number">5.4.</span> <span class="nav-text"> RegExp 类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4"><span class="nav-number">6.</span> <span class="nav-text"> 日期与时间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3"><span class="nav-number">6.1.</span> <span class="nav-text"> 时间戳</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E6%97%B6%E9%97%B4%E6%88%B3"><span class="nav-number">6.2.</span> <span class="nav-text"> 高精度时间戳</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E8%AE%A1%E7%AE%97"><span class="nav-number">6.3.</span> <span class="nav-text"> 日期计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8E%E8%A7%A3%E6%9E%90%E6%97%A5%E6%9C%9F%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">6.4.</span> <span class="nav-text"> 格式化与解析日期字符串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#error-%E7%B1%BB"><span class="nav-number">7.</span> <span class="nav-text"> Error 类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#json-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E8%A7%A3%E6%9E%90"><span class="nav-number">8.</span> <span class="nav-text"> JSON 序列化与解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#json-%E8%87%AA%E5%AE%9A%E4%B9%89"><span class="nav-number">8.1.</span> <span class="nav-text"> JSON 自定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BD%E9%99%85%E5%8C%96-api"><span class="nav-number">9.</span> <span class="nav-text"> 国际化 API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%95%B0%E5%80%BC"><span class="nav-number">9.1.</span> <span class="nav-text"> 格式化数值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4"><span class="nav-number">9.2.</span> <span class="nav-text"> 格式化日期和时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">9.3.</span> <span class="nav-text"> 比较字符串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0-api"><span class="nav-number">10.</span> <span class="nav-text"> 控制台 API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="nav-number">10.1.</span> <span class="nav-text"> 通过控制台格式化输出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#url-api"><span class="nav-number">11.</span> <span class="nav-text"> URL API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%97%E7%95%99-url-%E5%87%BD%E6%95%B0"><span class="nav-number">11.1.</span> <span class="nav-text"> 遗留 URL 函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E6%97%B6%E5%99%A8"><span class="nav-number">12.</span> <span class="nav-text"> 计时器</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">224</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">


  

</body>
</html>
