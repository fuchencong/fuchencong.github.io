<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Node 是 JavaScript 与底层操作系统绑定的结合，因而可以让 JavaScript 程序读写文件、执行子进程，以及实现网络通信，为此 Node 得到了广泛应用。Node 的典型特点是由其默认异步的 API 赋能的单线程基于事件的并发能力。">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 权威指南 16：Node 服务端 JavaScript">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2025/01/23/javascript-guide-16/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="Node 是 JavaScript 与底层操作系统绑定的结合，因而可以让 JavaScript 程序读写文件、执行子进程，以及实现网络通信，为此 Node 得到了广泛应用。Node 的典型特点是由其默认异步的 API 赋能的单线程基于事件的并发能力。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-01-23T06:16:20.000Z">
<meta property="article:modified_time" content="2025-06-24T06:17:42.873Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2025/01/23/javascript-guide-16/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JavaScript 权威指南 16：Node 服务端 JavaScript | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2025/01/23/javascript-guide-16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaScript 权威指南 16：Node 服务端 JavaScript
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-23 14:16:20" itemprop="dateCreated datePublished" datetime="2025-01-23T14:16:20+08:00">2025-01-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Node 是 JavaScript 与底层操作系统绑定的结合，因而可以让 JavaScript 程序读写文件、执行子进程，以及实现网络通信，为此 Node 得到了广泛应用。Node 的典型特点是由其默认异步的 API 赋能的单线程基于事件的并发能力。</p>
<span id="more"></span>
<h2 id="node-编程基础"><a class="markdownIt-Anchor" href="#node-编程基础"></a> Node 编程基础</h2>
<p>首先介绍 Node 程序的构成，看一看它们如何与操作系统交互。</p>
<h3 id="控制台输出"><a class="markdownIt-Anchor" href="#控制台输出"></a> 控制台输出</h3>
<p><code>console.log</code> 是 Node 向用户显示消息的最简单方式，它向标准输出流（stdout）发送输出。<code>console.error</code> 类似，但向标准错误流（stderr）发送输出。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;output stdout&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;output stderr&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="命令行参数和环境变量"><a class="markdownIt-Anchor" href="#命令行参数和环境变量"></a> 命令行参数和环境变量</h3>
<p>Node程序可以从字符串数组 <code>process.argv</code> 中读取其命令行参数:</p>
<ul>
<li>这个数组的第一个元素始终是 Node 可执行文件的路径</li>
<li>第二个参数是 Node 执行的 JavaScript 代码文件的路径</li>
<li>数组中剩下的所有元素都是你在调用 Node 时，通过命令行传给它的空格分隔的参数</li>
<li>给 Node 可执行文件且由它解释的命令行参数会被 Node 可执行文件使用，不会出现在 <code>process.argv</code> 中。出现在 JavaScript 文件名之后的任何参数都会出现在 <code>process.argv</code> 中</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(process.<span class="property">argv</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># node --trace-uncaught args.<span class="property">js</span>  --arg1 <span class="number">1</span> --arg2 <span class="number">2</span></span><br><span class="line">[</span><br><span class="line">  <span class="string">&#x27;/usr/local/bin/node&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;/root/code/private/javascript/javascript_guide/15/args.js&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;--arg1&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;--arg2&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;2&#x27;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>Node 程序也会从 Unix 风格的环境变量中获取输入。Node 把这些变量保存在 <code>process.env</code> 对象中使用。这个对象的属性名是环境变量的属性名，而属性值（始终是字符串）是对应变量的值。</p>
<h3 id="程序生命周期"><a class="markdownIt-Anchor" href="#程序生命周期"></a> 程序生命周期</h3>
<p>node 命令期待命令行参数指定要执行的 JavaScript 文件。这个初始的文件通常会导入其他 JavaScript 代码的模块，也可能定义它自己的类和函数。Node 基本上是自顶向下执行指定文件中的 JavaScript 代码。Node 程序在运行完初始文件、调用完所有回调、不再有未决事件之前不会退出。</p>
<ul>
<li>程序通过调用 <code>process.exit()</code> 可以强制自己退出</li>
<li>用户通常需要在终端窗口中按 <code>Ctrl-C</code> 来终止运行中的 Node 程序。程序通过使用 <code>process.on(&quot;SIGINT&quot;, ()=&gt;&#123;&#125;)</code> 注册信号处理函数可以忽略 <code>Ctrl-C</code></li>
<li>如果程序中的代码抛出异常，也没有 catch 子句捕获该异常，程序会打印栈追踪信息并退出。类似地，如果你的程序创建的一个期约被拒绝，而且没有 <code>.catch()</code> 调用处理它，也会遇到这种问题</li>
<li>如果你不想让这些异常导致程序崩溃，可以注册一个全局处理程序，以备调用，防止崩溃</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">process.<span class="title function_">setUncaughtExceptionCaptureCallback</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Uncaught exception:&quot;</span>, err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&quot;unhandledRejection&quot;</span>, <span class="function">(<span class="params">reason, promise</span>) =&gt;</span> &#123;)</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="node-模块"><a class="markdownIt-Anchor" href="#node-模块"></a> Node 模块</h3>
<p>之前介绍过 JavaScript 模块系统，包括 Node 模块和 ES6 模块。因为 Node 是在 JavaScript 有模块系统之前创造的，所以它必须自己创造一个模块系统。Node 的模块系统使用 <code>require()</code> 函数向模块中导入值，使用 <code>exports</code> 对象或 <code>module.exports</code> 属性从模块中导出值</p>
<p>Node 13 增加了对标准 ES6 模块的支持，同时仍支持基于 <code>require()</code> 的模块（Node 称其为 <code>CommonJS 模块</code>。这两个模块系统并非完全兼容，因此两者并存有些棘手：</p>
<ul>
<li>Node 在加载模块前，需要知道该模块会使用 <code>require()</code> 和 <code>module.exports</code>，还是 import 和 export</li>
<li>Node 在把一个 JavaScript 文件加载为 CommonJS 模块时，会自动定义 <code>require()</code> 函数以及标识符 exports 和 module，不会启用 import 和 export 关键字</li>
<li>在把一个文件加载为 ES6 模块时，它必须启用 import 和 export 声明，同时必须不定义 require、module 和 exports 等额外的标识符</li>
</ul>
<p>告诉 Node 它要加载的是什么模块的最简单方式，就是将信息编码到不同的扩展名中：</p>
<ul>
<li>如果你把 JavaScript 代码保存在 <code>.mjs</code> 结尾的文件中，那么 Node 始终会将它作为一个 ES6 模块来加载</li>
<li>如果把代码保存在 <code>.cjs</code> 结尾的文件中，那么 Node 始终会将它作为一个 CommonJSS 模块来对待</li>
</ul>
<p>对于没有明确给出 <code>.mjs</code> 或 <code>cjs</code> 扩展名的文件，Node 会在同级目录及所有包含目录中查找一个名为 <code>package.json</code> 的文件。一旦找到最近的 <code>package.json</code> 文件，Node 会检查其中 JSON 对象的顶级 type 属性：</p>
<ul>
<li>如果这个 type 属性的值是 module，Node 将该文件按 ES6 模块来加载</li>
<li>如果这个属性的值是 commonjs，那么 Node 就按 CommonJS 模块来加载该文件</li>
<li>如果没有找到这个文件（或找到该文件但它没有 type 属性）​，Node 默认会使用 CommonJS 模块</li>
</ul>
<p>因为大量现有的 Node 代码使用的都是 CommonJS 模块格式，Node 允许 ES6 模块使用 import 关键字加载 CommonJS 模块。但反之则不可以：CommonJS 模块不能使用 require() 加载 ES6 模块。</p>
<h3 id="node-包管理器"><a class="markdownIt-Anchor" href="#node-包管理器"></a> Node 包管理器</h3>
<p>你在安装 Node 的同时，也会得到一个名为 npm 的程序。这个程序就是 Node 的包管理器，它可以帮你下载和管理程序的依赖库。npm 通过位于程序根目录下的 <code>package.json</code> 文件跟踪依赖（以及与程序相关的其他信息）​。</p>
<p>假设你打算开发一个 Web 服务器，为了省事计划使用 <a target="_blank" rel="noopener" href="https://expressjs.com/">Express 框架</a>：</p>
<ul>
<li>那么首先你需要为这个项目创建一个目录，然后在该目录中运行 <code>npm init</code></li>
<li>npm 会询问项目名、版本号等信息，最终根据你的回答创建一个初始的 <code>package.json</code> 文件</li>
<li>为了使用 Express，需要运行 <code>npm install express</code>。这个命令告诉 npm 下载 <code>Express</code> 库及其所有依赖，并把所有包都安装到本地的 node_modules 目录下</li>
<li>在通过 npm 安装一个包时，npm 会在 <code>package.json</code> 文件中记录这个依赖</li>
<li>之后其他 Node 程序员依据这个文件就可以自动下载并安装运行你的程序所需的全部依赖库</li>
</ul>
<h2 id="node-默认异步"><a class="markdownIt-Anchor" href="#node-默认异步"></a> Node 默认异步</h2>
<p>JavaScript是一门通用的编程语言，因此完全可能用于计算密集型的应用程序。然而，Node是针对 <code>I/O</code> 密集型程序（如网络服务器）进行设计和优化的。特别地，Node 的设计让实现高并发（同时处理大量请求的）服务器非常容易。</p>
<p>与很多编程语言不同，Node 并不是通过线程来实现并发的。Node 采用了 Web 使用的单线程 JavaScript 编程模型，使得创建网络服务器变得极其简单，只需常规操作，没有神秘可言。</p>
<p>Node 程序可以运行多个操作系统进程，而 <code>Node 10</code> 及之后支持的 <code>Worker 对象</code> 是一种借鉴自浏览器的线程。如果你使用多个进程或者创建了一或多个 Worker 线程，并且你的程序运行在多核 CPU 的系统上，那么你的程序就不再是单线程，而是变成了真正的并行执行。</p>
<p>但是 Node 的进程和 Worker 避免了典型多线程编程的复杂性。因为它的进程或线程间通信是通过消息传递实现的，相互之间很难共享内存。</p>
<p><strong>Node通过让其 API 默认异步和非阻塞实现了高层次的并发，同时保持了单线程的编程模型</strong>。Node 很严格地采用非阻塞并将其运用到了极致。Node API 中有些函数虽然是同步的但也不会阻塞。这些函数运行完成就立即返回，根本不需要阻塞。</p>
<p>Node 诞生于 JavaScript 有 Promise 类之前，因此异步 Node API 是基于回调的：</p>
<ul>
<li>一般来说，你传给异步 Node 函数的最后一个参数始终是一个回调</li>
<li>Node 使用错误在先的回调，函数调用时通常会传两个参数：
<ul>
<li>如果没有发生错误，那么这个错误在先的回调的第一个参数通常是 null</li>
<li>第二个参数就是你最初调用的异步函数产生的数据或返回的响应</li>
<li>之所以把错误参数放在第一位，是为了让你不可能忽略它，从而始终检查这个参数是否不是空值</li>
</ul>
</li>
</ul>
<p>如下演示了如何使用非阻塞的 <code>readFile()</code> 函数读取一个配置文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readConfigFile</span>(<span class="params">path, callback</span>) &#123;</span><br><span class="line">  fs.<span class="title function_">readFile</span>(path, <span class="string">&quot;utf8&quot;</span>, <span class="function">(<span class="params">err, text</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">      <span class="title function_">callback</span>(<span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> data = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(text);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">callback</span>(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">r</span><br></pre></td></tr></table></figure>
<p>Node 虽然先于标准化的期约问世，但由于它错误在先的回调相当一致，所以使用 <code>util.promisify()</code> 包装函数能够轻易创建其基于回调 API 的期约版：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">&quot;util&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pfs = &#123;</span><br><span class="line">  <span class="attr">readFile</span>: util.<span class="title function_">promisify</span>(fs.<span class="property">readFile</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readConfigFile</span>(<span class="params">path</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> pfs.<span class="title function_">readFile</span>(path, <span class="string">&quot;utf-8&quot;</span>).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">text</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用 async 和 await 简化前面这个基于期约的函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">readConfigFile</span>(<span class="params">path</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> text = <span class="keyword">await</span> pfs.<span class="title function_">readFile</span>(path, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>util.promisify() 包装函数可以生成很多Node函数的基于期约的版本。在 Node 10 及之后，<code>fs.promises</code> 对象提供了一些预定义的基于期约的函数，用于操作文件系统。</p>
<p>我们已经说过 Node 的编程模型默认是异步的。但考虑到程序员的方便，Node 也为其很多函数定义了阻塞、同步的版本，特别是文件系统模块中的函数。这些函数的名字最后通常都有明确的 Sync 字样。例如，服务器在初次启动并读取配置文件时，还不能处理网络请求，几乎也没有并发执行的可能。因此这时候没有必要避免阻塞，可以放心地使用 <code>fs.readFileSync()</code> 等阻塞函数。</p>
<p>Node 内置的非阻塞函数使用了操作系统的回调和事件处理程序。这种并发通常被称为基于事件的并发。其核心是 Node 用单线程运行一个 <code>事件循环</code>。对于 Web 服务器和其他主要把时间花在等待输入和输出的 I/O 密集型应用，这种基于事件的并发效率又高、效果又好。</p>
<h3 id="缓冲区"><a class="markdownIt-Anchor" href="#缓冲区"></a> 缓冲区</h3>
<p>Node 中有一个比较常用的数据类型就是 Buffer，常用于从文件或网络读取数据。Buffer 类（或称缓冲区）非常类似字符串，只不过它是字节序列而非字符序列。在 JavaScript 语言支持 Uint8Array 之后，Node 的 Buffer 类就成为 Uint8Array 的子类。</p>
<p>Buffer 与其超类 Uint8Array 的区别在于，它是设计用来操作 JavaScript 字符串的。因此缓冲区里的字节可以从字符串初始化而来，也可以转换为字符串。Node 的 Buffer 类有执行编码和解码的方法，这些方法都接收一个 encoding 参数，用于指定要使用的编码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> b = <span class="title class_">Buffer</span>.<span class="title function_">from</span>([<span class="number">0x41</span>, <span class="number">0x42</span>, <span class="number">0x43</span>])</span><br><span class="line">&gt; b.<span class="title function_">toString</span>()</span><br><span class="line"><span class="string">&#x27;ABC&#x27;</span></span><br><span class="line">&gt; b.<span class="title function_">toString</span>(<span class="string">&quot;hex&quot;</span>)</span><br><span class="line"><span class="string">&#x27;414243&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="事件与-eventemitter"><a class="markdownIt-Anchor" href="#事件与-eventemitter"></a> 事件与 EventEmitter</h2>
<p>如前所述，所有 Node API 默认都是异步的。对其中很多 API 而言，这种异步性的表现形式为 <code>接收两个参数、且错误在先的回调</code>，当请求的操作完成时回调函数会被调用。但一些更复杂的 API 则是基于事件的。在 API 是围绕对象而非函数设计的。回调需要多次被调用，或者需要多种类型的回调时，通常会是这种情况。</p>
<p>在 Node 中，发送事件的对象都是 EventEmitter 或其子类的实例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> <span class="title class_">EventEmitter</span> = <span class="built_in">require</span>(<span class="string">&quot;events&quot;</span>)</span><br><span class="line">&gt; <span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">&quot;net&quot;</span>)</span><br><span class="line">&gt; <span class="keyword">const</span> <span class="title class_">EventEmitter</span> = <span class="built_in">require</span>(<span class="string">&quot;events&quot;</span>)</span><br><span class="line">&gt; <span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">&quot;net&quot;</span>)</span><br><span class="line">&gt; <span class="keyword">let</span> server = <span class="keyword">new</span> net.<span class="property">Server</span></span><br><span class="line">&gt; server <span class="keyword">instanceof</span> <span class="title class_">EventEmitter</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>EventEmitter 的主要功能是允许我们使用 on() 方法注册事件处理程序：</p>
<ul>
<li>EventEmitter 可以发送多种事件，而事件类型以名字作为标识</li>
<li>要注册一个事件处理程序，可以调用 on() 方法并传入事件类型的名字，以及在该类型事件发生时应该被调用的函数</li>
<li>可以使用 <code>off()</code> 移除注册的事件处理程序</li>
<li>还有一种特殊情况，就是使用 <code>once()</code> 而非 <code>on()</code> 注册的事件监听器在被调用一次之后就会被自动清除</li>
<li>当某个 EventEmitter 对象上发生特定的事件时，Node 会调用在该 EventEmitter 上针对该事件类型注册的所有处理程序，调用顺序是注册的顺序。如果有多个处理程序，它们会在一个线程上被顺序调用。更重要的，事件处理程序会被同步调用，而非异步调用。因此事件处理程序一般也不能执行阻塞操作，需要快速执行完成</li>
<li>EventEmitter 类也定义了一个 <code>emit()</code> 方法，可以导致注册的事件处理程序被调用。这个方法在你定义自己的、基于事件的 API 时有用
<ul>
<li>调用 <code>emit()</code> 时必须在第一个参数传入事件类型的名字</li>
<li>而传给 <code>emit()</code> 的所有后续参数都会成为注册的事件处理程序的参数</li>
<li>事件处理程序被调用时，其 this 值也会被设置为 EventEmitter 对象</li>
<li>事件处理程序返回的任何值都会被忽略。不过，如果某个事件处理程序抛出异常，则该异常会从 <code>emit()</code> 调用中传播出来，从而阻止该事件后续其他处理程序的执行</li>
</ul>
</li>
</ul>
<p>基于事件的 API，当发生错误时，会产生对应的 <code>错误</code>（error）事件。只要使用基于事件的 API，就应该习惯性地为这个 <code>错误</code> 事件注册处理程序。EventEmitter 类对这个 <code>错误</code> 事件进行了特殊处理。如果调用 <code>emit()</code> 发送的是<code>错误</code> 事件，且如果该事件没有注册处理程序，那么就会抛出一个异常。由于这是异步发生的，无法在 <code>catch</code> 块中处理这个异常，所以这种错误通常会导致程序退出。</p>
<h2 id="流"><a class="markdownIt-Anchor" href="#流"></a> 流</h2>
<p>基于流的算法，其本质就是把数据分割成小块，内存中不会保存全部数据。如果能够使用基于流的方案，则这种方案的内存利用率更高，处理速度也更快。Node 的网络 API 是基于流的，Node 的文件系统模块也定义了流 API 用于读写文件。因此你在写 Node 程序时很有可能用到流 API。</p>
<p>Node 支持 4 种基本的流：</p>
<ul>
<li>可读流：可读流是数据源</li>
<li>可写流：可写流是数据的接收地或目的地</li>
<li>双工流：双工流把可读流和可写流组合为一个对象</li>
<li>转换流：转换流也是可读和可写的，但与双工流有一个重要区别：写入转换流的数据在同一个流会变成可读的。比如，<code>zlib.createGzip()</code> 函数返回一个转换流，可以使用 gzip 算法对写入其中的数据进行压缩</li>
</ul>
<p>默认情况下，流读写的是缓冲区。如果你调用了一个可读流的 <code>setEncoding()</code> 方法，它会返回解码后的字符串而非 Buffer 对象。Node 的流 API 也支持 <code>对象模式</code>​，即流会读写比缓冲区和字符串更复杂的对象。</p>
<p>可读流必须从某个地方读取数据，而可写流必须把数据写到某个地方。因此每个流都有两端：输入端和输出端（或称来源和目标）​。使用基于流的 API，最难的地方是流的这两端几乎总是以不同的速度流动。流的实现几乎总会包含一个内部缓冲区，缓冲有助于保证在读取时有数据，而在写入时有空间保存数据。但这两点都无法绝对保证，基于流编程的本质决定了读取器有时候必须要等待数据写入（因为缓冲区空了）​，而写入器有时候必须等待数据读取（因为缓冲区满了）​。</p>
<p>Node 的流 API 是基于事件和回调的。与其他 Node API 不同，本章后面描述的方法没有 <code>同步</code> 版。</p>
<h3 id="管道"><a class="markdownIt-Anchor" href="#管道"></a> 管道</h3>
<p>有时候，我们需要把从流中读取的数据写入另一个流。与其自己写代码来处理这里的读和写，不如把这两个接口连接为一个 <code>管道</code>​，让 Node 帮你实现复杂的操作。只要把可写流简单地传给可读流的 <code>pipe()</code> 方法即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pipeFileToSocket</span>(<span class="params">filename, socket</span>) &#123;</span><br><span class="line">    fs.<span class="title function_">createReadStream</span>(filename).<span class="title function_">pipe</span>(socket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这个实用函数通过管道把一个流导向另一个流，并在完成或发生错误时调用一个回调：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">pipe</span>(<span class="params">readble, writable, callback</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleError</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    readble.<span class="title function_">close</span>();</span><br><span class="line">    writable.<span class="title function_">close</span>();</span><br><span class="line">    <span class="title function_">callback</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  readble</span><br><span class="line">    .<span class="title function_">on</span>(<span class="string">&quot;error&quot;</span>, handleError)</span><br><span class="line">    .<span class="title function_">pipe</span>(writable)</span><br><span class="line">    .<span class="title function_">on</span>(<span class="string">&quot;error&quot;</span>, handleError)</span><br><span class="line">    .<span class="title function_">on</span>(<span class="string">&quot;finish&quot;</span>, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换流特别适合与管道一起使用，可以创建多个流的传输管道。如下代码实现了文件压缩：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">&quot;zlib&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">gzip</span>(<span class="params">filename, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> source = fs.<span class="title function_">createReadStream</span>(filename);</span><br><span class="line">    <span class="keyword">let</span> destination = fs.<span class="title function_">createWriteStream</span>(filename + <span class="string">&quot;.gz&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> gzipper = zlib.<span class="title function_">createGzip</span>();</span><br><span class="line"></span><br><span class="line">    source</span><br><span class="line">        .<span class="title function_">on</span>(<span class="string">&quot;error&quot;</span>, callback)</span><br><span class="line">        .<span class="title function_">pipe</span>(gzipper)</span><br><span class="line">        .<span class="title function_">pipe</span>(destination);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>pipe()</code> 方法从可读流向可写流复制数据很容易。不过在实践中，经常要对流经程序的数据做某些处理。为此，一种方式是实现自己的 Transform 流来完成相应处理，这种方式可以让你避免手工读取和写入流。可以通过继承 <code>stream.Transform</code> 类来实现自定义的转换流。</p>
<h2 id="异步迭代"><a class="markdownIt-Anchor" href="#异步迭代"></a> 异步迭代</h2>
<p>在 Node 12 及之后，可读流是异步迭代器，这意味着在一个 async 函数中可以使用 <code>for/await</code> 循环从流中读取字符串或 Buffer块，而代码结构就像同步代码一样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">grep</span>(<span class="params">source, destination, pattern, encoding=<span class="string">&quot;utf8&quot;</span></span>) &#123;</span><br><span class="line">  source.<span class="title function_">setEncoding</span>(encoding);</span><br><span class="line"></span><br><span class="line">  destination.<span class="title function_">on</span>(<span class="string">&quot;error&quot;</span>, <span class="function"><span class="params">err</span> =&gt;</span> process.<span class="title function_">exit</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> incompleteLine = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> chunk <span class="keyword">of</span> source) &#123;</span><br><span class="line">    <span class="keyword">let</span> lines = (incompleteLine + chunk).<span class="title function_">split</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    incompleteLine = lines.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> lines) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pattern.<span class="title function_">test</span>(line)) &#123;</span><br><span class="line">        destination.<span class="title function_">write</span>(line + <span class="string">&quot;\n&quot;</span>, encoding);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pattern.<span class="title function_">test</span>(incompleteLine)) &#123;</span><br><span class="line">    destination.<span class="title function_">write</span>(incompleteLine + <span class="string">&quot;\n&quot;</span>, encoding);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pattern = <span class="keyword">new</span> <span class="title class_">RegExp</span>(process.<span class="property">argv</span>[<span class="number">2</span>]);</span><br><span class="line"><span class="title function_">grep</span>(process.<span class="property">stdin</span>, process.<span class="property">stdout</span>, pattern).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">error</span>(err); process.<span class="title function_">exit</span>()&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="写入流与背压处理"><a class="markdownIt-Anchor" href="#写入流与背压处理"></a> 写入流与背压处理</h3>
<p>调用写入流的 write() 方法就可以将数据写入到 <code>写入流</code> 中，<code>write()</code> 方法以一个缓冲区或字符串作为第一个参数：</p>
<ul>
<li>如果传入一个缓冲区，则该缓冲区的字节会被直接写入</li>
<li>如果传入一个字符串，则字符串在被写入前会被编码成字节缓冲区（可写流有默认编码，通常为 <code>utf8</code>）</li>
<li>可以同时传入一种编码的名字作为 <code>write()</code> 方法的第二个参数</li>
<li><code>write()</code> 可选地接收一个回调函数作为第三个参数。这个回调会在数据已经实际写入、不再存在于可写流的内部缓冲区时被调用</li>
</ul>
<p>这个 write() 方法有一个非常重要的返回值。在调用一个流的 <code>write()</code> 方法时，它始终会接收并缓冲传入的数据块。如果内部缓冲区未满，它会返回 true。如果内部缓冲区已满或太满，它会返回 false。这个返回值是建议性的，你可以忽略它。可写流会随着你不断调用 <code>write()</code> 而按需增大它的内部缓冲区。</p>
<p><code>write()</code> 方法返回 false 值是一种 <code>背压</code>（backpressure）的表现。背压是一种消息，表示你向流中写入数据的速度超过了它的处理能力。对这种背压的正确反应是停止调用 write()，直到流发出 <code>drain</code>​（耗尽）事件，表明缓冲区又有空间了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">write</span>(<span class="params">stream, chunk, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> hasMoreRoom = stream.<span class="title function_">write</span>(chunk);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasMoreRoom) &#123;</span><br><span class="line">        <span class="title function_">setImmediate</span>(callback);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stream.<span class="title function_">once</span>(<span class="string">&quot;drain&quot;</span>, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面例子中的异步 copy() 函数演示了如何正确处理背压：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">write</span>(<span class="params">stream, chunk</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> hasMoreRoom = stream.<span class="title function_">write</span>(chunk);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hasMoreRoom) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="literal">null</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      stream.<span class="title function_">once</span>(<span class="string">&quot;drain&quot;</span>, resolve);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">copy</span>(<span class="params">source, destination</span>) &#123;</span><br><span class="line">  destination.<span class="title function_">on</span>(<span class="string">&quot;error&quot;</span>, <span class="function"><span class="params">err</span> =&gt;</span> process.<span class="title function_">exit</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> chunk <span class="keyword">of</span> source) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">write</span>(destination, chunk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">copy</span>(process.<span class="property">stdin</span>, process.<span class="property">stdout</span>)</span><br></pre></td></tr></table></figure>
<p>如果不能对背压作出反应，则在可写流的内部缓冲区溢出时，会导致你的程序占用过多内存，而且占用的内存会越来越多。</p>
<h3 id="通过事件读取流"><a class="markdownIt-Anchor" href="#通过事件读取流"></a> 通过事件读取流</h3>
<p>Node 可读流有两种模式，每种模式都有自己的读取 API。如果你不能在程序中使用管道或异步迭代，那就需要从这两种基于事件的 API 中选择一种来处理流。关键在于只能使用其中一种 API，不能两种混用。</p>
<p><strong>流动模式：</strong></p>
<p>在流动模式（flowing mode）下，当可读数据到达时，会立即以 <code>data</code> 事件的形式发送。要在这种模式下读取流，只要为 <code>data</code> 事件注册一个事件处理程序，流就会在可用时立即把数据块（缓冲区或字符串）推送给你：</p>
<ul>
<li>注意，在流动模式下无须调用 <code>read()</code> 方法，只需要处理 <code>data</code> 事件</li>
<li>新创建的流并非一开始就处于流动模式，注册 <code>data</code> 事件处理程序会把流切换为流动模式</li>
<li>可以调用可读流的 <code>pause()</code> 方法暂时停止 <code>data</code> 事件</li>
<li>处于流动模式的流会在到达流末尾时发出一个 <code>end</code> 事件</li>
</ul>
<p><strong>暂停模式：</strong></p>
<p>可读流的另一种模式是 <code>暂停模式</code>​。这个模式是流开始时所处的模式。如果你不注册 <code>data</code> 事件处理程序，也不调用<code>pipe()</code> 方法，那么可读流就一直处于暂停模式。</p>
<ul>
<li>在暂停模式下，流不会以 <code>data</code> 事件的形式向你推送数据。相反，你需要显式调用其 <code>read()</code> 方法从流中拉取数据</li>
<li>这个方法不是阻塞操作，且如果流中已经没有数据可读，它会返回 null</li>
<li>因为没有同步 API 等待数据，所以暂停模式 API 也是基于事件的</li>
<li>可读流在暂停模式下会发送 <code>readable</code> 事件，表示流中有可读数据。相应地，你的代码应该调用 <code>read()</code> 方法读取该数据。而且，必须在一个循环中反复调用 <code>read()</code>，直到它返回 null</li>
<li>只有这样才能完全耗尽流的缓冲区，从而在将来再次触发新的 <code>readable</code> 事件</li>
<li>如果在仍然有可读数据的情况下停止调用 <code>read()</code>，那么就不会再收到下一个 <code>readable</code> 事件，你的程序很可能会被挂起</li>
<li>处于暂停模式的流会像处于流动模式的流一样发送 <code>end</code> 和 <code>error</code> 事件</li>
</ul>
<p>如果你的程序从一个可读流读数据，向一个可写流写数据，那么暂停模式可能并非好的选择。因为我们需要一次性读取所有可读的数据，但是这些数据可能无法写入（因为需要处理写入流的背压状态），这样处理起来很麻烦，不如流动模式更简单。</p>
<p>如下展示了一个使用 <code>暂停模式</code> 的示例，它可以计算指定文件的 <code>SHA256</code> 散列值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&quot;crypto&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sha256</span>(<span class="params">filename, callback</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> input = fs.<span class="title function_">createReadStream</span>(filename);</span><br><span class="line">  <span class="keyword">let</span> hasher = crypto.<span class="title function_">createHash</span>(<span class="string">&#x27;sha256&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  input.<span class="title function_">on</span>(<span class="string">&quot;readable&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> chunk;</span><br><span class="line">    <span class="keyword">while</span> (chunk = input.<span class="title function_">read</span>()) &#123;</span><br><span class="line">      hasher.<span class="title function_">update</span>(chunk);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  input.<span class="title function_">on</span>(<span class="string">&quot;end&quot;</span>, <span class="function">()=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> hash = hasher.<span class="title function_">digest</span>(<span class="string">&quot;hex&quot;</span>);</span><br><span class="line">    <span class="title function_">callback</span>(<span class="literal">null</span>, hash);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  input.<span class="title function_">on</span>(<span class="string">&quot;error&quot;</span>, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">sha256</span>(process.<span class="property">argv</span>[<span class="number">2</span>], <span class="function">(<span class="params">err, hash</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err.<span class="title function_">toString</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(hash);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="进程-cpu-和操作系统细节"><a class="markdownIt-Anchor" href="#进程-cpu-和操作系统细节"></a> 进程、CPU 和操作系统细节</h2>
<p>全局 Process 对象有很多有用的属性和函数，通常与当前运行的 Node 进程的状态相关。Node 文档中有这些属性和函数的详细说明。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; process.<span class="property">arch</span></span><br><span class="line"><span class="string">&#x27;x64&#x27;</span></span><br><span class="line">&gt; process.<span class="property">platform</span></span><br><span class="line"><span class="string">&#x27;linux&#x27;</span></span><br><span class="line">&gt; process.<span class="property">pid</span></span><br><span class="line"><span class="number">3336801</span></span><br><span class="line">&gt; process.<span class="title function_">memoryUsage</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">rss</span>: <span class="number">52207616</span>,</span><br><span class="line">  <span class="attr">heapTotal</span>: <span class="number">8232960</span>,</span><br><span class="line">  <span class="attr">heapUsed</span>: <span class="number">5881376</span>,</span><br><span class="line">  <span class="attr">external</span>: <span class="number">1019551</span>,</span><br><span class="line">  <span class="attr">arrayBuffers</span>: <span class="number">16739</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>os 模块</code>（与 process 不同，需要通过 <code>require()</code> 显式加载）提供对 Node 所在计算机和操作系统的类似的低级细节。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&quot;os&quot;</span>)</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt; os.<span class="title function_">arch</span>()</span><br><span class="line"><span class="string">&#x27;x64&#x27;</span></span><br><span class="line">&gt; os.<span class="title function_">type</span>()</span><br><span class="line"><span class="string">&#x27;Linux&#x27;</span></span><br><span class="line">&gt; os.<span class="title function_">uptime</span>()</span><br><span class="line"><span class="number">9315978.36</span></span><br></pre></td></tr></table></figure>
<h2 id="操作文件"><a class="markdownIt-Anchor" href="#操作文件"></a> 操作文件</h2>
<p>Node的 fs 模块是用于操作文件和目录的综合性 API。path 模块是 fs 模块的补充，定义了操作文件和目录名的常用函数。fs 模块定义了大量 API，主要是因为每种基本操作都有很多变体，例如非阻塞基于回调版本、同步阻塞变体、基于期约的异步变体。另外有些 API 以要操作的文件路径作为参数，有的则以文件描述符作为参数（这样的变体通常以 <code>f</code> 开头）。fs 模块中还有少量函数有名字前面加 <code>l</code>，这个带 <code>l</code> 的变体与基本函数类似，但不会跟踪文件系统中的符号链接，而是直接操作符号链接本身。</p>
<h3 id="路径-文件描述符和-filehandle"><a class="markdownIt-Anchor" href="#路径-文件描述符和-filehandle"></a> 路径、文件描述符和 FileHandle</h3>
<p>文件通常都是通过路径来指定的，由于不同操作系统使用不同的字符来分隔目录名，因此处理路径可能会有点棘手。Node 的 path 模块及其他一些重要的 Node 特性可以帮我们处理路径：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>)</span><br><span class="line">&gt; path.<span class="title function_">normalize</span>(<span class="string">&quot;a/b/c/../d&quot;</span>)</span><br><span class="line"><span class="string">&#x27;a/b/d&#x27;</span></span><br><span class="line">&gt; path.<span class="title function_">join</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line"><span class="string">&#x27;a/b/c&#x27;</span></span><br><span class="line">&gt; path.<span class="property">sep</span></span><br><span class="line"><span class="string">&#x27;/&#x27;</span></span><br><span class="line">&gt; path.<span class="title function_">basename</span>(p)</span><br><span class="line"><span class="string">&#x27;t.js&#x27;</span></span><br><span class="line">&gt; path.<span class="title function_">extname</span>(p)</span><br><span class="line"><span class="string">&#x27;.js&#x27;</span></span><br></pre></td></tr></table></figure>
<p>有一些 <code>fs</code> 函数接收文件描述符，而不是文件名。文件描述符是操作系统级的整数引用，调用 <code>fs.pen()</code>（或 <code>fs.openSync()</code>）函数可以得到一个指定文件的描述符。在文件描述符上调用 <code>fs.close()</code> 可以关闭文件。</p>
<p>在 <code>fs.promises</code> 定义的基于期约的 API 中，与 <code>fs.open()</code> 对应的是 <code>fs.promises.open()</code>。<code>fs.promises.open()</code> 返回一个期约，该期约会解决为一个 FileHandle 对象。这个 FileHandle 对象与文件描述符的作用相同。操作完成后同样要调用它的 <code>close()</code> 方法。</p>
<h3 id="读文件"><a class="markdownIt-Anchor" href="#读文件"></a> 读文件</h3>
<p>Node 允许你一次性读取文件的内容，可以通过流，也可以通过低级 API：</p>
<ul>
<li>如果你的文件很小，或者内存占用或性能并非主要考虑的因素，那么通过一次调用读取文件的全部内容是最简单的。这时，可以使用同步方法，也可以使用异步方法加回调，也可以使用期约</li>
<li>如果可以顺序地处理文件内容，同时不需要把文件内容全都放到内存中，那通过流来读取文件可能是最有效的方式。</li>
<li>如果需要在更低层次上控制要读取文件的哪些字节，可以打开文件取得文件描述符，然后再使用 <code>fs.read()</code>、<code>fs.readSync()</code> 或 <code>fs.promises.read()</code>，从文件中指定的来源位置将指定数量的字节读取到指定目标位置的指定缓冲区</li>
<li>如果你要从文件中读取多个数据块，这个基于回调的 read() API 使用起来会很麻烦。如果可以使用同步API（或基于期约的 API 及 await）​，那从一个文件中读取多个数据块就简单了</li>
</ul>
<h3 id="写文件"><a class="markdownIt-Anchor" href="#写文件"></a> 写文件</h3>
<ul>
<li>
<p>就是通过写入一个并不存在的文件名，可以创建一个新文件</p>
</li>
<li>
<p>与读文件一样，Node中有 3 种写文件的基本方式。如果你有字符串或缓冲区中全部的文件内容</p>
<ul>
<li>基于回调：fs.writeFile()</li>
<li>同步：fs.writeFileSync()</li>
<li>基于期约：fs.promises.writeFile()</li>
</ul>
</li>
<li>
<p>相关函数 <code>fs.appendFile()</code>、<code>fs.appendFileSync()</code> 和 <code>fs.promises.appendFile()</code> 也类似，只不过它们会在指定文件存在时，把数据追加到已有数据的末尾，而不会重写已有的文件内容</p>
</li>
<li>
<p>如果要写入文件的数据并不全在一个块中，或者如果在同一时刻并不全都在内存中，那么使用可写流是个好办法</p>
</li>
<li>
<p>如果你想以多个块的形式将数据写入文件，并且想控制把每个块都写入文件中的确切位置，那么可以使用 <code>fs.open()</code>、 <code>fs.openSync()</code> 或 <code>fs.promises.open()</code> 打开文件，然后把生成的文件描述符再传给 <code>fs.write()</code> 或 <code>fs.writeSync()</code> 函数</p>
</li>
<li>
<p>类似地，用 <code>fs.promises.open()</code> 及其产生的 <code>FileHandle</code> 对象也可以在更低层次写入缓冲区和字符串</p>
</li>
<li>
<p>当使用 <code>fs.open()</code> 和 <code>fs.openSync()</code> 打开文件来写入时，必须同时传入第二个字符串参数，用于指定你准备如何使用这个文件描述符，例如可以是 <code>&quot;w&quot;</code>、<code>&quot;w+&quot;</code>、<code>&quot;a&quot;</code> 等。如果没有指定，则默认为 <code>&quot;r&quot;</code>，即返回只读文件描述符</p>
</li>
<li>
<p>可以通过 <code>fs.truncate()</code>、<code>fs.truncateSync()</code> 或 <code>fs.promises.truncate()</code> 截掉文件后面的内容</p>
</li>
<li>
<p>数据写入成功仅仅代表 Node 已经把数据交给了操作系统。如果想把数据强制写入磁盘，保证数据得到安全存储，可以使用 <code>fs.fsync()</code> 或 <code>fs.fsyncSync()</code></p>
</li>
</ul>
<h3 id="文件操作"><a class="markdownIt-Anchor" href="#文件操作"></a> 文件操作</h3>
<ul>
<li><code>fs.copyFile()</code>、<code>fs.copyFileSync()</code> 和 <code>fs.promises.copyFile()</code> 可以用于复制文件</li>
<li><code>fs.rename()</code> 函数（以及相应的同步和基于期约的变体）可以移动或重命名文件</li>
<li>函数 <code>fs.link()</code> 和 <code>fs.symlink()</code> 分别创建硬链接和符号链接</li>
<li><code>fs.unlink()</code>、<code>fs.unlinkSync()</code> 和 <code>fs.promises.unlink()</code> 是 Node 用来删除文件的函数</li>
</ul>
<h3 id="文件元数据"><a class="markdownIt-Anchor" href="#文件元数据"></a> 文件元数据</h3>
<ul>
<li><code>fs.stat()</code>、<code>fs.statSync()</code> 和 <code>fs.promises.stat()</code> 函数可以让你取得指定文件或目录的元数据</li>
<li><code>fs.lstat()</code> 及其变体与 <code>fs.stat()</code> 类似，只是在指定文件为符号链接时，Node 会返回链接本身的元数据，而不会跟踪链接</li>
<li>如果你已经打开一个文件并得到其文件描述符或 FileHandle 对象，那么可以使用 <code>fs.fstat()</code> 或其变体取得这个打开文件的元数据</li>
<li><code>fs.chmod()</code>、<code>fs.lchmod()</code> 和 <code>fs.fchmod()</code>（以及相应的同步和基于期约的版本）用于设置文件或目录的 <code>模式</code>或权限</li>
<li><code>fs.chown()</code>、<code>fs.lchown()</code> 和 <code>fs.fchown()</code>（以及相应的同步和基于期约的版本）用于为文件或目录设置所有者和组</li>
<li>可以使用 <code>fs.utimes()</code> 和 <code>fs.futimes()</code> 及其变体设置文件或目录的访问时间和修改时间</li>
</ul>
<h3 id="操作目录"><a class="markdownIt-Anchor" href="#操作目录"></a> 操作目录</h3>
<ul>
<li>可以使用 <code>fs.mkdir()</code>、<code>fs.mkdirSync()</code> 或 <code>fs.promises.mkdir()</code> 创建新目录</li>
<li><code>fs.mkdtemp()</code> 及其变体接收一个传入的路径前缀，然后在后面追加一些随机字符（对于安全很重要）​，并以该名字创建一个目录，</li>
<li>要删除一个目录，使用 <code>fs.rmdir()</code> 或它的变体。注意，必须是空目录才能删除</li>
<li>fs 模块提供了两组不同的 API 用于列出目录的内容
<ul>
<li><code>fs.readdir()</code>、<code>fs.readdir Sync()</code> 和 <code>fs.promises.readdir()</code> 一次性读取整个目录</li>
<li>基于流的 <code>fs.opendir()</code> 及其变体返回一个 <code>Dir</code> 对象，表示指定的目录。可以使用这个 Dir 对象的 <code>read()</code> 或 <code>readSync()</code> 方法每次读取一个 Dirent 对象。使用 Dir 对象最简单的方式是将其作为异步迭代器，配合 <code>for/await</code> 循环</li>
</ul>
</li>
</ul>
<p>如下是一个示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">listDirectory</span>(<span class="params">dirpath</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> dir = <span class="keyword">await</span> fs.<span class="property">promises</span>.<span class="title function_">opendir</span>(dirpath);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> dir) &#123;</span><br><span class="line">    <span class="keyword">let</span> name = entry.<span class="property">name</span>;</span><br><span class="line">    <span class="keyword">if</span> (entry.<span class="title function_">isDirectory</span>()) &#123;</span><br><span class="line">      name += <span class="string">&quot;/&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> stats = <span class="keyword">await</span> fs.<span class="property">promises</span>.<span class="title function_">stat</span>(path.<span class="title function_">join</span>(dirpath, name));</span><br><span class="line">    <span class="keyword">let</span> size = stats.<span class="property">size</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(size).<span class="title function_">padStart</span>(<span class="number">10</span>), name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="http-客户端与服务器"><a class="markdownIt-Anchor" href="#http-客户端与服务器"></a> HTTP 客户端与服务器</h2>
<p>Node的 http、https 和 http2 模块是功能完整但相对低级的 HTTP 协议实现。这些模块定义了实现 HTTP 客户端和服务器的所有 API。</p>
<ul>
<li>发送 <code>HTTP GET</code> 请求的最简单方式是使用 <code>http.get()</code> 或 <code>https.get()</code>。</li>
<li>这两个函数的第一个参数是要获取的 URL，第二个参数是一个回调</li>
<li>当服务器响应开始到达时这个回调会以一个 IncomingMessage 对象被调用</li>
<li>调用回调时，HTTP 状态和头部已经可以读取，但响应体尚未就绪。<code>IncomingMessage</code> 对象是一个可读流</li>
</ul>
<p>除了发送 HTTP 和 HTTPS 请求，http 和 https 模块也允许你编写响应这些请求的服务器。基本流程如下。</p>
<ul>
<li>创建一个新 Server 对象</li>
<li>调用它的 listen() 方法，开始监听指定端口的请求</li>
<li>为 <code>request</code> 事件注册处理程序，通过这个处理程序读取客户端请求（特别是 <code>request.url</code> 属性）​，然后写入你的响应</li>
</ul>
<p>Node 的内置模块可以用来编写简单的 HTTP 和 HTTPS 服务器。不过，产品级服务器通常并不直接构建于这些模块之上。多数常用的服务器都是使用外部库（如 Express 框架）实现的，这些外部库提供 <code>中间件</code> 及其他后端 Web 开发者期待的高级实用特性。</p>
<h2 id="非-http-网络服务器及客户端"><a class="markdownIt-Anchor" href="#非-http-网络服务器及客户端"></a> 非 HTTP 网络服务器及客户端</h2>
<p>除了基于 HTTP 协议的客户端/服务器，Node 也完全支持其他类型的网络服务器和客户端。</p>
<p>net 模块定义了 <code>Server</code> 和 <code>Socket</code> 类。要创建服务器：</p>
<ul>
<li>调用 <code>net.createServer()</code>，然后调用返回对象的 <code>listen()</code> 方法告诉服务器监听哪个端口的连接</li>
<li>Server 对象会在客户端连接到该端口时生成 <code>connection</code> 事件，而传给事件监听器的值就是一个 Socket 对象</li>
<li>这个 Socket 对象是一个双工流，可以使用它从客户端读取数据和向客户端写入数据</li>
<li>在这个 Socket 对象上调用 <code>end()</code> 可以断开链接</li>
</ul>
<p>写客户端甚至更容易，只要给 <code>net.createConnection()</code> 传一个端口号和主机名，就可以创建一个套接口，与该主机上监听相应端口的服务器通信。然后使用这个套接口就可以从服务器读取数据或者向服务器写入数据了。</p>
<p>除了支持基于 TCP 的服务器，Node 的 net 模块也支持通过 <code>Unix 域套接口</code>（Unix domain socket）的进程间通信。另外还有支持 UDP 通信的 dgram 模块、支持 tls 加密通信的 tls 模块等，这里就不再详细介绍了。</p>
<h2 id="操作子进程"><a class="markdownIt-Anchor" href="#操作子进程"></a> 操作子进程</h2>
<p><code>child_process</code> 模块定义了一些函数，用于在子进程中运行其他程序。</p>
<h3 id="execsync-与-execfilesync"><a class="markdownIt-Anchor" href="#execsync-与-execfilesync"></a> <code>execSync()</code> 与 <code>execFileSync()</code></h3>
<p>运行其他程序的最简单方式是使用 <code>child_process.execSync()</code>。这个函数的第一个参数是要运行的命令，它会创建一个子进程，并在该进程中运行一个命令行解释器 shell，并使用该解释器执行你传入的命令：</p>
<ul>
<li>执行命令期间会阻塞，直到命令（及命令行解释器）退出</li>
<li>如果命令中存在错误，则 <code>execSync()</code> 会抛出异常</li>
<li>否则，<code>execSync()</code> 将返回该命令写入其标准输出流的任何内容</li>
</ul>
<p>如果你不需要命令行的特性，可以使用 <code>child_process.execFileSync()</code> 来避免启动命令行的开销。这个函数直接执行程序，不调用命令行。</p>
<p><code>execSync()</code> 和其他很多 child_process 函数都有第二或第三个可选参数对象，用于指定子进程如何运行。</p>
<h3 id="exec-与-execfile"><a class="markdownIt-Anchor" href="#exec-与-execfile"></a> <code>exec()</code> 与 <code>execFile()</code></h3>
<p><code>exec()</code> 和 <code>execFile()</code> 与它们的同步变体相似，只不过会立即返回一个 <code>ChildProcess</code> 对象，表示正在运行的子进程，而且接收一个错误在先的回调作为最后的参数，这个回调会在子进程退出时被调用。</p>
<p>exec() 和 execFile() 返回的 ChildProcess 对象允许你终止子进程，向它写入数据（进而可以从其标准输入读取）。</p>
<p>如果你想同时执行多个子进程，那么最简单的方式可能就是使用 <code>exec()</code> 的期约版，它返回一个期约对象。如果子进程无错误退出，这个期约对象会解决为一个包含 stdout 和 stderr 属性的对象。</p>
<h3 id="spawn"><a class="markdownIt-Anchor" href="#spawn"></a> spawn()</h3>
<p><code>child_process.spawn()</code> 函数允许在子进程运行期间流式访问子进程的输出。同时，它也允许向子进程写入数据（子进程将该数据作为自己标准输入流的输入）​。这意味着可以动态与子进程交互，基于它的输出向它发送输入。</p>
<ul>
<li><code>spawn()</code> 与 <code>execFile()</code> 一样，也返回一个 ChildProcess 对象，但它不接收回调参数</li>
<li>虽然不使用回调，但可以监听这个 ChildProcess 对象或它的流发出的事件</li>
<li><code>spawn()</code> 返回的 <code>ChildProcess</code> 对象是一个事件发送器（event emitter），可以监听子进程退出时发出的 <code>exit</code> 事件</li>
<li>ChildProcess 对象也有 3 个流属性。stdout 和 stderr 是可读流：当子进程写入自己的标准输出和标准错误流时，相应的输出通过 ChildProcess 流变成可读的。stdin 属性是可写的流：写入这个流的任何数据都将进入子进程的标准输入</li>
</ul>
<h3 id="fork"><a class="markdownIt-Anchor" href="#fork"></a> fork()</h3>
<p><code>child_process.fork()</code> 是一个特殊的函数，用于在一个 Node 子进程中运行一段 JavaScript 代码。fork() 接收与 spawn() 相同的参数，但第一个参数应该是 JavaScript 代码文件的路径而非可执行二进制文件的路径。</p>
<p>使用 fork() 创建的子进程可以通过子进程的标准输入流和标准输出流与父进程通信。另外，<code>fork()</code> 还在父进程和子进程之间提供了一种更简单的通信方式：</p>
<ul>
<li>在使用 <code>fork()</code> 创建子进程后，可以使用它返回的 ChildProcess 对象的 <code>send()</code> 方法向子进程发送一个对象的副本</li>
<li>可以监听这个 ChildProcess 的 <code>message</code> 事件，从子进程中接收消息</li>
<li>在子进程中运行的代码可以使用 <code>process.send()</code> 向父进程发送消息，也可以监听 process 的 <code>message</code> 事件，从父进程接收消息</li>
</ul>
<p>启动子进程的代价是相当大的，如果子进程不能完成几个大数量级的计算，那么就不值得使用 <code>fork()</code>。</p>
<h2 id="工作线程"><a class="markdownIt-Anchor" href="#工作线程"></a> 工作线程</h2>
<p>Node 的并发模型是单线程、基于事件的。但 Node 从第 10 版开始支持真正的多线程编程，提供了与浏览器定义的 <code>Web Workers API</code> 非常相似的的一套 API。</p>
<p>JavaScript 的工作线程只能通过消息传递来通信：</p>
<ul>
<li>主线程可以调用代表工作线程的 Worker 对象的 <code>postMessage()</code> 方法向工作线程发送消息，工作线程可以通过监听 <code>message</code> 事件，从父线程接收消息</li>
<li>工作线程可以使用自己的 <code>postMessage()</code> 方法向主线程发送消息，而主线程可以通过自己的 <code>message</code> 事件处理程序接收该消息</li>
</ul>
<p>工作线程不像子进程那么重，但也不轻。除非真的有很多工作需要它去完成，否则也不值得创建工作进程。</p>
<h3 id="创建工作线程及传递消息"><a class="markdownIt-Anchor" href="#创建工作线程及传递消息"></a> 创建工作线程及传递消息</h3>
<p>定义工作线程的 Node 模块叫 <code>worker_threads</code>，这个模块定义了 Worker 类来表示工作线程。</p>
<ul>
<li><code>Worker()</code> 构造函数的第一个参数是要在线程中运行的 JavaScript 代码文件的路径。如果传入的是相对路径，则它相对的是 <code>process.cwd()</code>，而非相对于当前运行的模块</li>
<li><code>Worker()</code> 构造函数还可以接收一个对象作为第二个参数，这个对象的属性为要创建的工作线程提供可选的配置。</li>
<li>Node会将传给 <code>postMessage()</code> 的对象制作一个副本，而不是直接将它与工作线程共享。这样可以防止工作线程和主线程共享内存</li>
</ul>
<h3 id="工作线程的执行环境"><a class="markdownIt-Anchor" href="#工作线程的执行环境"></a> 工作线程的执行环境</h3>
<p>很大程度上，Node 工作线程中的 JavaScript 代码在执行时与在主线程中一样。当然也有一些需要注意的区别：</p>
<ul>
<li>threads.isMainThread 在主线程中是 true，但在任何工作线程中都是 false</li>
<li>在工作线程中，可以使用 <code>threads.parentPort.postMessage()</code> 向父线程发送消息，使用 <code>threads.parentPort.on</code> 为来自父线程的消息注册事件处理程序。在主线程中，<code>threads.parentPort</code> 始终是 null</li>
<li>在工作线程中，<code>threads.workerData</code> 被设置为 <code>Worker()</code> 构造函数第二个参数 workerData 属性的一个副本。在主线程中，这个属性始终是 null。可以使用这个 workerData 属性向工作线程传一条最初的消息</li>
<li>默认情况下，<code>process.env</code> 在工作线程中是父线程中 <code>process.env</code> 的一个副本。但父线程可以通过设置 Worker() 构造函数第二个参数的 env 属性指定一组自定义的环境变量</li>
<li>默认情况下，<code>process.stdin</code> 流在工作线程中永远不会有任何可读数据。可以通过给 <code>Worker()</code> 构造函数的第二个参数传 <code>stdin: true</code> 来改变这个默认设置。如此，这个 Worker 对象的 stdin 属性就是一个可写的流。父线程写入 <code>worker.stdin</code> 的任何数据在工作线程中的 <code>process.stdin</code> 中都会变成可读的</li>
<li>默认情况下，<code>process.stdout</code> 和 <code>process.stderr</code> 在工作线程中都会简单地被引流到父线程中对应的流。要重写这个默认设置，可以在 <code>Worker()</code> 构造函数的第二个参数中传入 <code>stdout: true</code> 或 <code>stderr: true</code>。如此，工作线程中写入这些流的任何输出在父线程中的 <code>worker.stdout</code> 和 <code>worker.stderr</code> 上都会变成可读的</li>
<li>如果工作线程调用 <code>process.exit()</code>，只有当前线程会退出，而不是整个进程都退出</li>
<li>工作线程不能改变它们所属进程的共享状态。例如在工作线程中调用 <code>process.chdir()</code> 和 <code>process.setuid()</code> 等函数会抛出异常</li>
<li>操作系统信号（如 SIGINT 和 SIGTERM）只发送到主线程，工作线程不能接收和处理它们</li>
</ul>
<h3 id="通信信道与-messageport"><a class="markdownIt-Anchor" href="#通信信道与-messageport"></a> 通信信道与 MessagePort</h3>
<p>创建一个新工作线程时，也会随之创建一个通信信道，以便在工作线程和父线程之间来回传递消息。创建一个新工作线程时，也会随之创建一个通信信道，以便在工作线程和父线程之间来回传递消息。</p>
<p>工作线程 API 也支持使用 MessageChannel API 创建自定义通信信道（类似于浏览器定义中的 MessageChannel）：</p>
<ul>
<li>使用 <code>MessageChannel()</code> 构造函数可以创建一个新消息信道</li>
<li>MessageChannel 对象有两个属性：<code>port1</code> 和 <code>port2</code>，这两个属性分别引用不同的 MessagePort 对象</li>
<li>在其中一个端口上调用 postMessage() 会导致另一个端口生成 <code>message</code> 事件，并接收到一个Message对象的结构化克隆的副本</li>
<li>在任何一个端口上调用 <code>close()</code> 都可以断开这两个端口之间的连接</li>
</ul>
<h3 id="转移-messageport-和定型数组"><a class="markdownIt-Anchor" href="#转移-messageport-和定型数组"></a> 转移 MessagePort 和定型数组</h3>
<p>postMessage() 函数使用结构化克隆算法，但是它不能复制 Socket 对象和 Stream 对象。它可以处理 MessagePort 对象，但只作为特例且需要使用特殊技巧：</p>
<ul>
<li>postMessage() 方法接收可选的第二个参数。这个参数（名为transferList）​是一个对象数组，其中的对象会在线程间转移而非复制</li>
<li>MessagePort 对象不能通过结构化克隆算法复制，但它可以被转移</li>
<li>如果 postMessage() 的第一个参数已经包含了一个或多个 MessagePort（在 Message 对象中嵌套任意深度）​，那么这些 MessagePort 对象必须也出现在作为第二个参数的数组中，这样将告诉 Node 将这些 MessagePort 对象转交给另一个线程</li>
<li>MessagePort 对象并不是唯一可以转移的对象，定型数组也可以通过类似的方法进行转移。定型数组转移给另一个线程后，当前线程就不能再使用它了，而这也是保证这种转移安全的原因</li>
</ul>
<h3 id="在线程间共享定型数组"><a class="markdownIt-Anchor" href="#在线程间共享定型数组"></a> 在线程间共享定型数组</h3>
<p>除了可以在线程间转移定型数组，也可以在线程间共享它们。只要创建一个自定义大小的 <code>SharedArrayBuffer</code>，然后使用该缓冲区创建一个定型数组即可。在把基于 <code>SharedArrayBuffer</code> 创建的定型数组传给 postMessage() 时，底层的内存会在线程间共享。此时，不应该再在 postMessage() 的第二个参数中包含这个共享缓冲区。</p>
<p>但是一般不应该这样做，因为 JavaScript 设计时并未考虑线程安全。一个可能适合使用 SharedArrayBuffer 的场景，是两个线程分别操作共享内存中完全独立的区域。为此，可以创建两个定型数组，作为共享缓冲区中不重叠的两个视图。然后让两个线程分别使用这两个独立的定型数组。</p>
<p>如果必须允许多线程同时访问共享数组的同一区域，为保证线程安全，可以使用 Atomics 对象定义的函数。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/%E5%89%8D%E7%AB%AF/" rel="tag"># 前端</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/01/24/javascript-guide-17/" rel="prev" title="JavaScript 权威指南 17：JavaScript 工具和扩展">
      <i class="fa fa-chevron-left"></i> JavaScript 权威指南 17：JavaScript 工具和扩展
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/01/22/javascript-guide-15/" rel="next" title="JavaScript 权威指南 15：浏览器中的 JavaScript">
      JavaScript 权威指南 15：浏览器中的 JavaScript <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#node-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text"> Node 编程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA"><span class="nav-number">1.1.</span> <span class="nav-text"> 控制台输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">1.2.</span> <span class="nav-text"> 命令行参数和环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.3.</span> <span class="nav-text"> 程序生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#node-%E6%A8%A1%E5%9D%97"><span class="nav-number">1.4.</span> <span class="nav-text"> Node 模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#node-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8"><span class="nav-number">1.5.</span> <span class="nav-text"> Node 包管理器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#node-%E9%BB%98%E8%AE%A4%E5%BC%82%E6%AD%A5"><span class="nav-number">2.</span> <span class="nav-text"> Node 默认异步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">2.1.</span> <span class="nav-text"> 缓冲区</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E4%B8%8E-eventemitter"><span class="nav-number">3.</span> <span class="nav-text"> 事件与 EventEmitter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81"><span class="nav-number">4.</span> <span class="nav-text"> 流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E9%81%93"><span class="nav-number">4.1.</span> <span class="nav-text"> 管道</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E8%BF%AD%E4%BB%A3"><span class="nav-number">5.</span> <span class="nav-text"> 异步迭代</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%85%A5%E6%B5%81%E4%B8%8E%E8%83%8C%E5%8E%8B%E5%A4%84%E7%90%86"><span class="nav-number">5.1.</span> <span class="nav-text"> 写入流与背压处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E4%BA%8B%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%B5%81"><span class="nav-number">5.2.</span> <span class="nav-text"> 通过事件读取流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B-cpu-%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%86%E8%8A%82"><span class="nav-number">6.</span> <span class="nav-text"> 进程、CPU 和操作系统细节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6"><span class="nav-number">7.</span> <span class="nav-text"> 操作文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8C-filehandle"><span class="nav-number">7.1.</span> <span class="nav-text"> 路径、文件描述符和 FileHandle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="nav-number">7.2.</span> <span class="nav-text"> 读文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-number">7.3.</span> <span class="nav-text"> 写文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">7.4.</span> <span class="nav-text"> 文件操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-number">7.5.</span> <span class="nav-text"> 文件元数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%9B%AE%E5%BD%95"><span class="nav-number">7.6.</span> <span class="nav-text"> 操作目录</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http-%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">8.</span> <span class="nav-text"> HTTP 客户端与服务器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E-http-%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%8A%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">9.</span> <span class="nav-text"> 非 HTTP 网络服务器及客户端</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-number">10.</span> <span class="nav-text"> 操作子进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#execsync-%E4%B8%8E-execfilesync"><span class="nav-number">10.1.</span> <span class="nav-text"> execSync() 与 execFileSync()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exec-%E4%B8%8E-execfile"><span class="nav-number">10.2.</span> <span class="nav-text"> exec() 与 execFile()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spawn"><span class="nav-number">10.3.</span> <span class="nav-text"> spawn()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fork"><span class="nav-number">10.4.</span> <span class="nav-text"> fork()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B"><span class="nav-number">11.</span> <span class="nav-text"> 工作线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E5%8F%8A%E4%BC%A0%E9%80%92%E6%B6%88%E6%81%AF"><span class="nav-number">11.1.</span> <span class="nav-text"> 创建工作线程及传递消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="nav-number">11.2.</span> <span class="nav-text"> 工作线程的执行环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1%E4%BF%A1%E9%81%93%E4%B8%8E-messageport"><span class="nav-number">11.3.</span> <span class="nav-text"> 通信信道与 MessagePort</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E7%A7%BB-messageport-%E5%92%8C%E5%AE%9A%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="nav-number">11.4.</span> <span class="nav-text"> 转移 MessagePort 和定型数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E5%AE%9A%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="nav-number">11.5.</span> <span class="nav-text"> 在线程间共享定型数组</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">215</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">


  

</body>
</html>
