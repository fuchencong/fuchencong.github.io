<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="接下来会介绍几种重要的编程工具，很多 JavaScript 程序员都经常使用。此外还会介绍对核心 JavaScript 语言的两个使用很广泛的扩展。">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 权威指南 17：JavaScript 工具和扩展">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2025/01/24/javascript-guide-17/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="接下来会介绍几种重要的编程工具，很多 JavaScript 程序员都经常使用。此外还会介绍对核心 JavaScript 语言的两个使用很广泛的扩展。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-01-24T06:19:36.000Z">
<meta property="article:modified_time" content="2025-06-25T06:21:22.561Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2025/01/24/javascript-guide-17/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JavaScript 权威指南 17：JavaScript 工具和扩展 | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2025/01/24/javascript-guide-17/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaScript 权威指南 17：JavaScript 工具和扩展
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-24 14:19:36" itemprop="dateCreated datePublished" datetime="2025-01-24T14:19:36+08:00">2025-01-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>接下来会介绍几种重要的编程工具，很多 JavaScript 程序员都经常使用。此外还会介绍对核心 JavaScript 语言的两个使用很广泛的扩展。</p>
<span id="more"></span>
<h2 id="使用-eslint-检查代码"><a class="markdownIt-Anchor" href="#使用-eslint-检查代码"></a> 使用 ESLint 检查代码</h2>
<p>在编程领域，lint 是指代码虽然技术上正确，但书写却不够规范，甚至可能有 bug，或者没有达到最优。linter 是用于检查代码中 lint 的工具。目前最常用的 JavaScript linter 是 ESLint。如果运行它并花时间实际解决它指出的问题，你的代码会更清晰，更不容易出错。</p>
<p>ESLint 定义了很多 linting 规则，而且有一个插件生态，可以增加新规则。但 ESLint 也是完全可以配置的，可以定义一个配置文件，让 ESLint 只执行你想让它执行的规则。</p>
<h2 id="使用-prettier-格式化代码"><a class="markdownIt-Anchor" href="#使用-prettier-格式化代码"></a> 使用 Prettier 格式化代码</h2>
<p>Prettier 工具可以用来自动解析和重新格式化代码。</p>
<ul>
<li>如果调用 Prettier 时带了 <code>--write</code> 选项，它只会重新格式化指定的文件，而不会把结果打印出来</li>
<li>如果使用 git 管理源代码，可以通过提交钩子（hook）以 <code>--write</code> 选项调用 Prettier，从而让代码在检入前自动格式化</li>
</ul>
<h2 id="使用-jest-做单元测试"><a class="markdownIt-Anchor" href="#使用-jest-做单元测试"></a> 使用 Jest 做单元测试</h2>
<p>JavaScript 这样的动态语言支持测试框架，可以大幅减少编写测试的工作量，甚至能让写测试变得很好玩。JavaScript 有很多测试工具和库，很多是以模块化方式编写的。Jest 是一个囊括所有测试功能的流行框架。</p>
<h2 id="使用-npm-管理依赖包"><a class="markdownIt-Anchor" href="#使用-npm-管理依赖包"></a> 使用 npm 管理依赖包</h2>
<p>在现代软件开发中，稍微复杂点的程序都会依赖一些第三方软件库。包管理工具就可以让发现和安装第三方软件包更方便。同样重要的是，包管理工具可以跟踪你的代码依赖哪些包，并把这些信息保存到一个文件中。这样当别人也想尝试运行你的程序时，他们可以下载你的代码以及你的依赖列表，然后使用自己的包管理工具安装你的代码需要的所有第三方包。</p>
<p>npm 是 Node.js 的包管理工具，也是 JavaScript 社区中最流行的包管理器：</p>
<ul>
<li>如果要尝试别人写的 JavaScript 项目，在下载其代码后，通常第一件事就是键入 <code>npm install</code>。这个命令会读取 <code>package.json</code> 文件中的依赖列表，并下载项目依赖的第三方包并保存到 node_modules 目录中</li>
<li>使用 <code>npm install &lt;package-name&gt;</code> 在项目的 node_modules 目录安装特定的包，例如：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express</span><br></pre></td></tr></table></figure>
<ul>
<li>除了使用包名来安装依赖之外，npm 也会在项目的 package.json 文件中添加一条记录。这样把依赖记录下来可以让别人只键入 <code>npm install</code> 就可以安装全部依赖</li>
</ul>
<p><strong>还有一种依赖只对项目的开发者有用，项目运行的时候并不需要</strong>。比如，项目中使用 <code>Prettier</code> 来保证代码格式统一，但 Prettier 属于 <code>开发依赖</code>​，安装它的时候可以添加 <code>--save-dev</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev prettier</span><br></pre></td></tr></table></figure>
<ul>
<li>还可能需要全局安装某个开发者工具，从而即便在没有 package.json 文件和 node_modules 目录的地方也可以使用。为此可以在安装依赖时添加 <code>-g</code>（即 global，全局）选项：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># npm install -g eslint jest</span><br><span class="line"></span><br><span class="line"># which eslint</span><br><span class="line">/usr/local/bin/eslint</span><br><span class="line"># which jest</span><br><span class="line">/usr/local/bin/jest</span><br></pre></td></tr></table></figure>
<ul>
<li>除了 install 命令之外，npm 还支持 uninstall 和 update 命令，用于删除和更新依赖。而 audit 命令可以找到并修复依赖中的安全漏洞</li>
</ul>
<p>在项目中本地安装 ESLint 等工具时，eslint 脚本会保存在 <code>./node_modules/.bin/eslint</code> 目录中，因此运行命令比较麻烦。**好在 npm 也附带了一个 npx 命令，这样就可以用 <code>npx eslint</code> 或 <code>npx jest</code> 命令来运行本地安装的工具：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -l ./node_modules/.<span class="property">bin</span>/eslint</span><br><span class="line">lrwxrwxrwx <span class="number">1</span> root root <span class="number">23</span> <span class="title class_">Feb</span>  <span class="number">4</span> <span class="number">10</span>:<span class="number">14</span> ./node_modules/.<span class="property">bin</span>/eslint -&gt; ../eslint/bin/eslint.<span class="property">js</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># npx eslint t.<span class="property">js</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>:<span class="number">5</span>  error  <span class="string">&#x27;t&#x27;</span> is assigned a value but never used  no-unused-vars</span><br><span class="line"></span><br><span class="line">✖ <span class="number">1</span> problem (<span class="number">1</span> error, <span class="number">0</span> warnings)</span><br></pre></td></tr></table></figure>
<h2 id="代码打包"><a class="markdownIt-Anchor" href="#代码打包"></a> 代码打包</h2>
<p>如果要写一个在浏览器中运行的大型 JavaScript 项目，可能会用到代码打包工具，特别是在使用的外部库是以模块形式提供的时候。Web 开发者已经使用 ES6 模块很多年了，最初浏览器尚未支持 import 和 export 关键字：</p>
<ul>
<li>为了使用 ES6 模块，程序员使用代码打包工具从程序的主入口（或多入口）开始，跟着 import 指令树，从而找到程序依赖的所有模块</li>
<li>然后把所有独立的模块文件组合成一个 JavaScript 代码包，并重写 import 和 export 指令让代码可以在这种新形式下运行</li>
<li>结果是一个代码文件，让不支持模块的浏览器可以加载运行</li>
</ul>
<p>ES6 模块今天已经得到浏览器的普遍支持，但 Web 开发者仍然倾向于使用代码打包工具，至少在发布产品代码时要使用。开发者发现在用户首次访问网站时，相比于加载多个小型模块，加载一个中等大小的代码包时用户体验最佳。</p>
<p>市面上有很多优秀的 JavaScript 打包工具可供选择。其中常用的有 webpack、Rollup 和 Parcel。除了基本的打包功能之外，打包工具也会提供其他一些特性：</p>
<ul>
<li>有些程序可能有多个入口。比如，多页 Web 应用可以为每个页面都写一个入口。打包工具通常支持为每个入口创建一个代码包，或者生成一个支持多入口的独立包</li>
<li>函数可以以函数式而非静态形式使用 <code>import()</code>，避免在程序启动时加载所有代码，而是在需要时再动态加载</li>
<li>打包工具通常会输出源码映射（source map）文件，包含源代码行号与输出包代码行号的映射。这样可以方便浏览器开发者工具自动显示 JavaScript 错误</li>
<li>有时候在向程序中导入一个模块时，实际上只会用到其中少量特性。优秀的打包工具会分析代码，找出未使用的部分并在打包时排除它们，这个特性也被称为 <code>摇树优化</code></li>
<li>打包工具通常有某种基于插件的架构，支持导入和打包非 JavaScript 代码的文件</li>
<li>打包工具通常支持文件系统监控，可以检测项目目录下文件的修改，自动重新生成必要的代码包。有了这个特性，你可以像往常一样保存代码，然后刷新浏览器就能看到效果</li>
<li>有些打包工具也支持 <code>热模块替换</code> 开发模式，即每次重新生成代码包，都会自动把它们加载到浏览器</li>
</ul>
<h2 id="使用-babel-转译"><a class="markdownIt-Anchor" href="#使用-babel-转译"></a> 使用 Babel 转译</h2>
<p>Babel 是一个编译工具，可以把使用现代语言特性编写的 JavaScript 代码编译为不使用那些现代语言特性的 JavaScript 代码。因为是把 JavaScript 代码编译成 JavaScript 代码，Babel 有时候也被称为 <code>转译器</code>（transpiler）。</p>
<p>Babel 的目的就是让开发者可以使用 ES6 及之后的新语言特性，同时仍然可以兼容那些只支持 ES5 的浏览器。一般来说，Babel 输出的代码并没有考虑人类的易读性。不过跟打包工具类似，Babel 也可以生成源码映射，保存转换后的代码与原始代码位置之间的映射，这对使用转换后的代码特别有帮助。</p>
<ul>
<li>可以使用 npm 安装 Babel，使用 npx 运行它</li>
<li>Babel 读取 <code>.babelrc</code> 配置文件，获取你对如何转换 JavaScript 的要求</li>
</ul>
<p>Babel 提供了一些预设（preset），反映了不同的代码转译激进程度。其中一个比较有意思的 Babel 预设是用于代码压缩的（通过删除注释、空格和重命名变量等）​。</p>
<p>如果同时使用 Babel 和代码打包工具，你应该可以设置打包工具在打包时自动对 JavaScript 文件运行 Babel。这样可以简化产生可运行代码的过程。</p>
<p>今天，虽然转换核心 JavaScript 语言的需求已经变少了，但 Babel 仍然常用于转换对语言的非标准扩展。接下来我们会介绍其中两个这样的语言扩展。</p>
<h2 id="jsxjavascript中的标记表达式"><a class="markdownIt-Anchor" href="#jsxjavascript中的标记表达式"></a> JSX：JavaScript中的标记表达式</h2>
<p>JSX 是对核心 JavaScript 的扩展，它使用 HTML 风格的语法定义元素树。JSX 与构建用户界面的 React 框架联系最为紧密。在 React 中，这个使用 JSX 定义的元素树最终会被渲染为 HTML 而进入浏览器。</p>
<p>可以把 JSX 元素想象为一种新的 JavaScript 表达式语法。JavaScript 字符串字面量是以引号来定界的，而正则表达式是以斜杠来定界的。同样，JSX 表达式字面量是以尖括号来定界的。下面是一个简单的 JSX 赋值表达式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> line = <span class="language-xml"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果你使用 JSX，那么需要使用 Babel（或类似工具）把 JSX 表达式编译为常规 JavaScript。例如 Babel 会把上面赋值语句中的 JSX 表达式转换为下面这个简单的函数调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> line = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;hr&quot;</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>JSX 语法类似 HTML，而且与 HTML 元素类似，React 元素也可以像下面这样声明属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> image = <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;log.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;The JSX logo&quot;</span> <span class="attr">hidden</span>/&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>当元素包含一个或多个属性时，这些属性就会成为对象的属性，作为第二个参数传递给 <code>React.createElement</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> image = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;img&quot;</span>, &#123;<span class="attr">src</span>: <span class="string">&quot;log.png&quot;</span>, <span class="attr">alt</span>: <span class="string">&quot;The JSX logo&quot;</span>, <span class="attr">hidden</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>与 HTML 元素类似，JSX 元素可以将字符串或其他元素作为子元素。JSX 元素也可以任意嵌套，从而创建一棵元素树：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sidebar = (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;sidebar&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a sidebar content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这些嵌套的 JSX 表达式会转换为一组嵌套的 <code>createElement()</code> 调用。如果 JSX 元素有子元素，那些子元素（字符串或其他JSX元素）会作为第三个及后续参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sidebar = <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">    <span class="string">&quot;div&quot;</span>, &#123;<span class="attr">className</span>: <span class="string">&quot;sidebar&quot;</span>&#125;,</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;h1&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Title&quot;</span>),</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;hr&quot;</span>, <span class="literal">null</span>),</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;This is a sidebar content&quot;</span>));</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><code>React.createElement()</code> 的返回值是一个普通的 JavaScript 对象，React 可以用来渲染在浏览器窗口中的输出。需要注意，可以配置 Babel 把 JSX 元素编译为对一个不同函数的调用，所以 JSX 也可以用于非 React 场景。</p>
<p>JSX 语法的一个重要特性是可以在 JSX 表达式中嵌入常规的 JavaScript 表达式。在 JSX 表达式中，<strong>位于花括号内的文本会被当成普通的 JavaScript 来解释</strong>。这些嵌套的表达式可以用于生成属性值，也可以用于创建子元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sidebar</span>(<span class="params">className, title, content, drawLine=<span class="literal">true</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;drawLine &amp;&amp; <span class="tag">&lt;<span class="name">hr</span>/&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;content&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然我们知道 JSX 会编译成函数调用，那么自然也就可以理解它能够包含任意表达式了，因为函数调用也可以写成任意表达式的形式。上述代码经过 Babel 转译后会变成如下样子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sidebar</span>(<span class="params">className, title, content, drawLine = <span class="literal">true</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>, &#123;<span class="attr">className</span>: className&#125;,</span><br><span class="line">        <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;h1&quot;</span>, <span class="literal">null</span>, title),</span><br><span class="line">        drawLine &amp;&amp; <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;hr&quot;</span>, <span class="literal">null</span>),</span><br><span class="line">        <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, content));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 JSX 表达式中使用 JavaScript 表达式时，并不限于前面例子中出现的简单字符串值或布尔值。任何 JavaScript 值都是允许的。事实上，在 React 编程中使用对象、数组和函数都相当常见。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">list</span>(<span class="params">items, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">style</span>=<span class="string">&#123;</span> &#123;<span class="attr">padding:10</span>, <span class="attr">border:</span>&quot;<span class="attr">solid</span> <span class="attr">red</span> <span class="attr">4px</span>&quot;&#125; &#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;</span></span><br><span class="line"><span class="language-xml">                items.map((item, index) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">li</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> callback(index)&#125; key=&#123;index&#125;&gt;&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#125;)</span></span><br><span class="line"><span class="language-xml">            &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JSX中对象表达式的另一种使用场景是使用对象扩展操作符一次性指定多个属性。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hebrew = &#123;<span class="attr">lang</span>: <span class="string">&quot;he&quot;</span>, <span class="attr">dir</span>: <span class="string">&quot;rtl&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> shalm = <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;emphasis&quot;</span> &#123;<span class="attr">...hebrew</span>&#125;&gt;</span>xxx<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>Babel 会把这种语法编译为一个 <code>_extends()</code> 函数（这里省略）调用，包含 className 属性和 hebrew 对象中的属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shalom = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;span&quot;</span>, <span class="title function_">_extends</span>(&#123;<span class="attr">className</span>: <span class="string">&quot;emphasis&quot;</span>&#125;, hebrew), <span class="string">&quot;xxx&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>JSX 还有一个更重要的特性，所有 JSX 元素都以一个左尖括号紧跟一个标识符开头：</p>
<ul>
<li>如果这个标识符的第一个字母小写​，则这个标签会以字符串形式传给 <code>createElement()</code></li>
<li>如果这个标识符的第一个字母大写，那么它就会被当成真正的标识符，最终传给 <code>createElement()</code> 的第一个参数是该标识符的 JavaScript 值</li>
</ul>
<p>这意味着 JSX 表达式 <code>&lt;Math/&gt;</code> 编译后的 JavaScript 代码会把全局 Math 对象传给 <code>React.createElement()</code>。</p>
<p>对于 React 而言，给 <code>createElement()</code> 第一个参数传非字符串值的能力是创建组件所必需的。组件是一种用简单 JSX 表达式（使用大写组件名）来表达更复杂表达式的方式（使用小写 HTML 标签名）：</p>
<p>在 React 中定义组件的最简单方式就是写一个函数，让它接收一个 props 对象参数，并返回一个 JSX 表达式。props 对象就是一个简单的 JavaScript 对象，表示属性值，与传给 createElement() 第二个参数的对象一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Sidebar</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;props.title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;props.drawLine &amp;&amp; <span class="tag">&lt;<span class="name">hr</span>/&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;props.content&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在 Sidebar 就是一个 React 组件了，可以在 JSX 表达式中用来替换 HTML 标签名了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sidebar = <span class="language-xml"><span class="tag">&lt;<span class="name">Sidebar</span> <span class="attr">title</span>=<span class="string">&quot;Something snappy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Something wise&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>它会编译为如下调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sidebar = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="title class_">Sidebar</span>, &#123;<span class="attr">title</span>: <span class="string">&quot;Something snappy&quot;</span>, <span class="attr">content</span>: <span class="string">&quot;Something wise&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>对于这个简单的 JSX 表达式，React 在渲染时会把第二个参数 <code>Props 对象</code> 传给第一个参数 <code>Sidebar()</code> 函数​，并使用这个函数返回的 JSX 表达式替换 <code>&lt;Sidebar&gt;</code> 表达式。</p>
<h2 id="使用-flow-检查类型"><a class="markdownIt-Anchor" href="#使用-flow-检查类型"></a> 使用 Flow 检查类型</h2>
<p>Flow 也是一个语言扩展，让我们可以为 <code>JavaScript</code> 代码添加类型注解，同时它也是一个检查 JavaScript 代码中类型错误（包括有注解和无注解）的工具：</p>
<ul>
<li>要使用 Flow，需要一开始就使用 Flow 语言扩展给代码添加类型注解</li>
<li>然后可以运行 Flow 工具分析代码、报告类型错误</li>
<li>等修复错误并准备好运行代码后，可以使用 Babel（作为打包流程中自动执行的一环）从代码中剥离 Flow 类型注解</li>
</ul>
<p>TypeScript 是 Flow 的一个非常流行的替代品。TypeScript 也是一种 JavaScript 扩展，但它除了类型还添加了其他语言特性。TypeScript 编译器 tsc 负责把 TypeScript 程序编译为 JavaScript 程序，在此期间会像 Flow 那样分析并报告类型错误。tsc 不是 Babel 插件，而是一个独立的编译器。TypeScript 中简单的类型注解通常与 Flow 中同样的注解写法相同。对于更高级的类型注解，两种扩展语法存在差异，但它们的意图和价值相同。</p>
<p>TypeScript 是 2012 年发布的，早于 ES6，Flow 是一个相对窄的语言扩展，只给 JavaScript 增加了类型注解。TypeScript 则是一个经过良好设计的新语言。顾名思义，为 JavaScript 添加类型是 TypeScript 的主要目的，也是人们今天使用它的原因。但类型并不是 TypeScript 给 JavaScript 添加的唯一特性。</p>
<p>使用 Flow 需要一定的投入，但我发现对大中型项目来说，这些额外的努力是值得的。主要你对 JavaScript 这门语言有了信心，在 JavaScript 项目中引入 Flow 肯定可以让你的编程技能更上一层楼。</p>
<h3 id="安装和运行-flow"><a class="markdownIt-Anchor" href="#安装和运行-flow"></a> 安装和运行 Flow</h3>
<p>可以使用包管理工具 npm 来安装 Flow，例如 <code>npm install -g flow-bin</code> 或 <code>npm install --save-dev flow-bin</code>：</p>
<ul>
<li>如果使用 <code>-g</code> 全局安装，则直接通过 <code>flow</code> 命令来运行</li>
<li>如果使用 <code>--save-dev</code> 在项目中局部安装，那可以使用 <code>npx flow</code> 来运行它</li>
</ul>
<p>在使用 Flow 做类型检查前，第一次在项目根目录运行 <code>flow init</code> 会创建一个 <code>.flowconfig</code> 配置文件。Flow 需要通过它知道你的项目根目录在哪里。</p>
<p>运行 Flow 时，它会找到项目中所有的 JavaScript 源代码，但它只会针对包含了 <code>// @flow</code> 顶部注释的文件进行类型检查。</p>
<p>即使仅仅在文件顶部加上 <code>// @flow</code> 注释，Flow 也能够发现你代码中的错误。即使没有使用 Flow 语言扩展，也没有在代码中添加类型注解，Flow 类型检查器仍然能够推断程序中的值，并在发现不一致时给出警告。</p>
<h3 id="使用类型注解"><a class="markdownIt-Anchor" href="#使用类型注解"></a> 使用类型注解</h3>
<p>在声明 <code>JavaScript</code> 变量时，可以给变量添加 <code>Flow</code> 类型注解，只要在变量名后面加上冒号和类型即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">message</span>: string = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">flag</span>: boolean = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">n</span>: number = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>
<p>即使不给这些变量添加注解，Flow 也会知道它们的类型。它知道赋给变量的值，然后一直跟踪。不过，要是添加了类型注解，Flow 就既知道变量类型，也知道你希望该变量始终保持该类型。因此如果使用类型注解，Flow 会在你给变量赋不同类型的值时标示出错误。如果你习惯使用前在函数顶部声明所有变量，那么类型注解会特别有用。</p>
<ul>
<li>函数参数的类型注解与变量的注解类似，也是在参数名后面加上冒号和类型名</li>
<li>在注解函数时，通常也需要注解函数返回值的类型。返回值类型放在结尾圆括号与开头花括号之间。不返回值的函数使用 Flow 类型 void</li>
<li>箭头函数也可以增加类型注解</li>
<li>JavaScript 值 null 对应 Flow 类型 null，而 JavaScript 值 undefined 对应 Flow 类型 void</li>
<li>如果想让 null 和 undefined 成为变量或函数参数的合法值，只要在类型前面加个问号即可</li>
<li>问号也可以出现在参数名后面，表示该参数本身可选</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">size</span>(<span class="params">s: string</span>): number &#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> size = (<span class="attr">s</span>: string): <span class="function"><span class="params">number</span> =&gt;</span> s.<span class="property">length</span>;</span><br></pre></td></tr></table></figure>
<h3 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h3>
<p>除了原始类型之外，Flow 也支持 JavaScript 的所有内置类，允许使用它们的类名作为类型。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">dateMatches</span>(<span class="params">d: <span class="built_in">Date</span>, p: <span class="built_in">RegExp</span></span>): boolean &#123;</span><br><span class="line">    <span class="keyword">return</span> p.<span class="title function_">test</span>(d.<span class="title function_">toISOString</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用 class 关键字定义自己的类，那些类也会自动变成有效的 Flow 类型。不过为了使用它们，Flow 要求你必须在类中使用类型注解。特别是，类的每个属性必须有自己的类型声明。</p>
<p>如下是一个示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @flow</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line">    <span class="attr">i</span>: number;</span><br><span class="line">    <span class="attr">r</span>: number;</span><br><span class="line">    <span class="keyword">static</span> <span class="attr">i</span>: <span class="title class_">Complex</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">real: number, imag: number</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">r</span> = r;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">i</span> = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">add</span>(<span class="attr">that</span>: <span class="title class_">Complex</span>): <span class="title class_">Complex</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Complex</span>(<span class="variable language_">this</span>.<span class="property">r</span> + that.<span class="property">r</span>, <span class="variable language_">this</span>.<span class="property">i</span> + that.<span class="property">i</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Complex</span>.<span class="property">i</span> = <span class="keyword">new</span> <span class="title class_">Complex</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="对象"><a class="markdownIt-Anchor" href="#对象"></a> 对象</h3>
<p>描述对象的 Flow 类型看起来很像一个对象字面量，只不过属性值都变成了属性类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">distance</span>(<span class="params">point: &#123;x:number, y:number&#125;</span>): number &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">hypot</span>(point.<span class="property">x</span>, point.<span class="property">y</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，<code>&#123;x:number, y:number&#125;</code> 是一种 Flow 类型，与其他类型一样，也可以在它的前面加上问号表示允许 null 和 undefined。</p>
<ul>
<li>如果对象类型中的属性没有标记为可选，那它就是必需的。Flow 会在实际值中不存在对应属性时报错</li>
<li>正常情况下 Flow 会允许出现额外的属性</li>
<li>如果想让 Flow 严格按照类型注解中出现的属性检查，可以通过在花括号中添加一对竖线来声明确切的对象类型</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;|<span class="attr">x</span>:number, <span class="attr">y</span>:number|&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>JavaScript 的对象有时候会被用作字典或字符串到值的映射。像这样使用时，属性名提前是不知道的，无法用 Flow 类型来声明。如果这样使用对象，仍然可以使用 Flow 描述这个数据结构。例如：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">cidyLocations</span>: &#123;[string]: &#123;<span class="attr">longitude</span>: number, <span class="attr">latitude</span>: number&#125;&#125; = &#123;</span><br><span class="line">    <span class="string">&quot;Seattle&quot;</span>: &#123;<span class="attr">longitude</span>: -<span class="number">122.3321</span>, <span class="attr">latitude</span>: <span class="number">47.6062</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> cidyLocations;</span><br></pre></td></tr></table></figure>
<h3 id="类型别名"><a class="markdownIt-Anchor" href="#类型别名"></a> 类型别名</h3>
<p>对象可能有很多属性，而描述这样一个对象的 Flow 类型可能会很长，输入起来费时间。可以给复杂的 Flow 类型命名，而且事实上，Flow 使用 type 关键字来定义类型。在 type 关键字后面要写标识符、等于号和 Flow 类型。定义了这样一个类型后，标识符就成为该类型的别名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @flow</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">Point</span> = &#123;<span class="attr">x</span>: number, <span class="attr">y</span>: number&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">distance</span>(<span class="params">point: Point</span>): number &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">hypot</span>(point.<span class="property">x</span>, point.<span class="property">y</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里导出了 Point 类型，如果其他模块也想使用该类型定义，可以使用 <code>import type Point from './distance.js'</code> 导入。<code>import type</code> 是 Flow 语言扩展，并非真正的 JavaScript 导入指令。类型导入和导出由 Flow 类型检查器使用，但与其他所有 Flow 语言扩展一样，它们会在代码实际运行之前被剥离掉。</p>
<h3 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h3>
<p>Flow 中描述数组的类型是一个复合类型，其中也包含数组元素的类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">average</span>(<span class="params">data: <span class="built_in">Array</span>&lt;number&gt;</span>): number &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">average</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;three&quot;</span>]);</span><br></pre></td></tr></table></figure>
<ul>
<li>Flow 中的数组类型是 Array 后跟一对尖括号，尖括号中是元素类型。也可以用元素类型后跟一对方括号来表示数组类型。例如 <code>number[]</code> 等价于 <code>Array&lt;number&gt;</code></li>
<li>Flow 有一种不同的语法，用于描述一种元组（tuple）类型，即一个有固定数量元素的数组，每个元素可以是不同的类型。要表示元组类型，只需简单地写出每个元素的类型，以逗号分隔，然后把它们全部放到一对方括号中即可，例如 <code>[number, string]</code></li>
<li><code>Array&lt;mixed&gt;</code> 表示数组元素可以是任意类型，但是 Flow 仍然会在对数组元素执行不安全操作之前使用 typeof 或其他测试手段来确定元素的类型。而 <code>Array&lt;any&gt;</code> 则完全放弃对数组元素的类型检查</li>
</ul>
<h3 id="其他参数化类型"><a class="markdownIt-Anchor" href="#其他参数化类型"></a> 其他参数化类型</h3>
<p>在把一个值注解为 Array 时，Flow 要求在尖括号中指定数组元素的类型。这个额外的类型称为类型参数，而 Array 也不是唯一可以参数化的 JavaScript 类。</p>
<ul>
<li>Set 类型也是使用尖括号中包含类型参数，指定集合中值的类型（如果集合可以包含多种类型值，类型参数也可以是 mixed 或 any）。例如 <code>Set&lt;number&gt;</code></li>
<li>Map 是另一个参数化类型。但 Map 必须指定两种类型参数，即键的类型和值的类型。例如 <code>Map&lt;string, number&gt;</code></li>
</ul>
<p>Flow 也允许你为自己的类定义类型参数。例如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;E, V&gt; &#123;</span><br><span class="line">    <span class="attr">error</span>: ?E;</span><br><span class="line">    <span class="attr">value</span>: ?V;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">e: ?E, v: ?V</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">error</span> = e;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">result</span>: <span class="title class_">Result</span>&lt;<span class="title class_">Error</span>, <span class="title class_">Set</span>&lt;string&gt;&gt;;</span><br></pre></td></tr></table></figure>
<p>甚至可以为函数定义类型参数，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> zip&lt;A,B&gt;(<span class="attr">a</span>: <span class="title class_">Array</span>&lt;A&gt;, <span class="attr">b</span>: <span class="title class_">Array</span>&lt;B&gt;): <span class="title class_">Array</span>&lt;[?A, ?B]&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">result</span>: <span class="title class_">Array</span>&lt;[?A, ?B]&gt;= [];</span><br><span class="line">    <span class="keyword">let</span> len = <span class="title class_">Math</span>.<span class="title function_">max</span>(a.<span class="property">length</span>, b.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        result.<span class="title function_">push</span>([a[i], b[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">pairs</span>: <span class="title class_">Array</span>&lt;[number, string]&gt; = <span class="title function_">zip</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>]);</span><br></pre></td></tr></table></figure>
<h3 id="只读类型"><a class="markdownIt-Anchor" href="#只读类型"></a> 只读类型</h3>
<p>Flow 定义了一些特殊的参数化 <code>实用类型</code>​，这些类型的名字以 <code>$</code> 开头。大多数这种类型都有一些高级使用场景，其中有两个在实践中是非常有用的：</p>
<ul>
<li>如果有一个对象类型 T，你希望得到该类型的只读版本，可以写成 <code>$ReadOnly&lt;T&gt;</code></li>
<li>类似地，可以用 <code>$ReadOnlyArray&lt;T&gt;</code> 描述一个元素类型为 T 的只读数组</li>
</ul>
<p>使用这些类型能够让我们发现由于意外修改导致的隐患。如果我们要写一个函数，接收一个对象或数组参数，并且不会修改任何对象属性或数组元素，那么就可以把这个函数参数注解为一种 Flow 的只读类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Point</span> = &#123;<span class="attr">x</span>: number, <span class="attr">y</span>: number&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">distance</span>(<span class="params">p: $ReadOnly&lt;Point&gt;</span>): number &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">hypot</span>(p.<span class="property">x</span>, p.<span class="property">y</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p</span>: <span class="title class_">Point</span> = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h3>
<p>已经讲解了如何给函数的参数和返回值添加类型注解，但如果函数的某个参数本身又是函数，还需要指定该函数参数的类型。要通过 Flow 表示一个函数类型，就得把每个参数的类型写下来，以逗号分隔，用圆括号括起来，后面再跟一个箭头和函数的返回类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> type <span class="title class_">FetchTextCallback</span> = <span class="function">(<span class="params">?<span class="built_in">Error</span>, ?number, ?string</span>) =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">fetchText</span>(<span class="params">url: string, callback: FetchTextCallback</span>): <span class="keyword">void</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="联合"><a class="markdownIt-Anchor" href="#联合"></a> 联合</h3>
<p>在使用 Flow 时，如果需要一种类型能够允许数组、Set 和 Map，但不允许其他类型的值，可以使用联合（union）类型。通过列出想要的类型并以竖线分隔它们就可以表示这种类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">size</span>(<span class="params">collection: <span class="built_in">Array</span>&lt;mixed&gt;|<span class="built_in">Set</span>&lt;mixed&gt;|<span class="built_in">Map</span>&lt;mixed, mixed&gt;</span>): number &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(collection)) &#123;</span><br><span class="line">        <span class="keyword">return</span> collection.<span class="property">length</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> collection.<span class="property">size</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>?</code> 前缀其实是给类型添加 <code>|null|void</code> 后缀的简写形式。</p>
<p>一般来说，在使用联合类型注解一个值时，Flow 在你判断完值的实际类型前是不允许使用它们的。</p>
<h3 id="枚举和可区分联合"><a class="markdownIt-Anchor" href="#枚举和可区分联合"></a> 枚举和可区分联合</h3>
<p>Flow 允许使用原始值字面量作为只包含那一个值的类型。例如如果写 <code>let x:3;</code> 则 Flow 不允许给这个变量赋 3 之外的任何值。这种字面量类型的联合很有用。但是需要注意，对于由字面量构成的类型，它只允许字面量值。Flow 在检查类型时，并不实际执行计算：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Answer</span> = <span class="string">&quot;yes&quot;</span> | <span class="string">&quot;no&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a1</span>: <span class="title class_">Answer</span> = <span class="string">&quot;yes&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">a2</span>: <span class="title class_">Answer</span> = <span class="string">&quot;Yes&quot;</span>.<span class="title function_">toLowerCase</span>(); <span class="comment">// 错误，相当于把 string 类型的值赋值给 Answer 类型</span></span><br></pre></td></tr></table></figure>
<p>这种字面量联合类型是枚举类型的一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Suit</span> = <span class="string">&quot;Hearts&quot;</span> | <span class="string">&quot;Diamonds&quot;</span> | <span class="string">&quot;Clubs&quot;</span> | <span class="string">&quot;Spades&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>面量类型的另一个重要应用是创建可区分联合（discriminated union）。在使用（由不同类型而非字面量构成的）联合类型时，通常需要写代码区分各种可能的类型。如果你想创建一个 Object 类型的联合，可以在每个 Object 类型中使用一个字面量类型让这些类型容易区分。如下是一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> type <span class="title class_">ResultMessage</span> = &#123;</span><br><span class="line">    <span class="attr">messageType</span>: <span class="string">&quot;result&quot;</span>,</span><br><span class="line">    <span class="attr">result</span>: <span class="title class_">Array</span>&lt;<span class="title class_">ReticulatedSpline</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">ErrorMessage</span> = &#123;</span><br><span class="line">    <span class="attr">messageType</span>: <span class="string">&quot;error&quot;</span>,</span><br><span class="line">    <span class="attr">error</span>: <span class="title class_">Error</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">StatisticsMessage</span> = &#123;</span><br><span class="line">    <span class="attr">messageType</span>: <span class="string">&quot;statistics&quot;</span>,</span><br><span class="line">    <span class="attr">value</span>: number,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">WorkerMessage</span> = <span class="title class_">ResultMessage</span> | <span class="title class_">ErrorMessage</span> | <span class="title class_">StatisticsMessage</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleMessage</span>(<span class="params">message: WorkerMessage</span>): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (message.<span class="property">messageType</span> === <span class="string">&quot;result&quot;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="property">result</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message.<span class="property">messageType</span> === <span class="string">&quot;error&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> message.<span class="property">error</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message.<span class="property">messageType</span> === <span class="string">&quot;statistics&quot;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">info</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/%E5%89%8D%E7%AB%AF/" rel="tag"># 前端</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/03/10/penetration-test-info-collect/" rel="prev" title="渗透测试之信息收集">
      <i class="fa fa-chevron-left"></i> 渗透测试之信息收集
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/01/23/javascript-guide-16/" rel="next" title="JavaScript 权威指南 16：Node 服务端 JavaScript">
      JavaScript 权威指南 16：Node 服务端 JavaScript <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-eslint-%E6%A3%80%E6%9F%A5%E4%BB%A3%E7%A0%81"><span class="nav-number">1.</span> <span class="nav-text"> 使用 ESLint 检查代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-prettier-%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81"><span class="nav-number">2.</span> <span class="nav-text"> 使用 Prettier 格式化代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-jest-%E5%81%9A%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-number">3.</span> <span class="nav-text"> 使用 Jest 做单元测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-npm-%E7%AE%A1%E7%90%86%E4%BE%9D%E8%B5%96%E5%8C%85"><span class="nav-number">4.</span> <span class="nav-text"> 使用 npm 管理依赖包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%89%93%E5%8C%85"><span class="nav-number">5.</span> <span class="nav-text"> 代码打包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-babel-%E8%BD%AC%E8%AF%91"><span class="nav-number">6.</span> <span class="nav-text"> 使用 Babel 转译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jsxjavascript%E4%B8%AD%E7%9A%84%E6%A0%87%E8%AE%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">7.</span> <span class="nav-text"> JSX：JavaScript中的标记表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-flow-%E6%A3%80%E6%9F%A5%E7%B1%BB%E5%9E%8B"><span class="nav-number">8.</span> <span class="nav-text"> 使用 Flow 检查类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E5%92%8C%E8%BF%90%E8%A1%8C-flow"><span class="nav-number">8.1.</span> <span class="nav-text"> 安装和运行 Flow</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="nav-number">8.2.</span> <span class="nav-text"> 使用类型注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">8.3.</span> <span class="nav-text"> 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1"><span class="nav-number">8.4.</span> <span class="nav-text"> 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="nav-number">8.5.</span> <span class="nav-text"> 类型别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">8.6.</span> <span class="nav-text"> 数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%8F%82%E6%95%B0%E5%8C%96%E7%B1%BB%E5%9E%8B"><span class="nav-number">8.7.</span> <span class="nav-text"> 其他参数化类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AA%E8%AF%BB%E7%B1%BB%E5%9E%8B"><span class="nav-number">8.8.</span> <span class="nav-text"> 只读类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">8.9.</span> <span class="nav-text"> 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%94%E5%90%88"><span class="nav-number">8.10.</span> <span class="nav-text"> 联合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E5%92%8C%E5%8F%AF%E5%8C%BA%E5%88%86%E8%81%94%E5%90%88"><span class="nav-number">8.11.</span> <span class="nav-text"> 枚举和可区分联合</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">224</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">


  

</body>
</html>
