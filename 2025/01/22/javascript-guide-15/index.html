<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="JavaScript 创造于 1994 年，其明确的目的就是为浏览器显示的文档赋予动态行为。今天，Web 对 JavaScript 程序员而言已经是一个完善的应用开发平台。我们通常所说的 JavaScript 指的就是在浏览器中运行的 JavaScript 代码。与之相对的是 服务器端 代码，也就是运行在服务器上的程序。客户端和服务器端经常也被称为 前端 和 后端。">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 权威指南 15：浏览器中的 JavaScript">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2025/01/22/javascript-guide-15/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="JavaScript 创造于 1994 年，其明确的目的就是为浏览器显示的文档赋予动态行为。今天，Web 对 JavaScript 程序员而言已经是一个完善的应用开发平台。我们通常所说的 JavaScript 指的就是在浏览器中运行的 JavaScript 代码。与之相对的是 服务器端 代码，也就是运行在服务器上的程序。客户端和服务器端经常也被称为 前端 和 后端。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-01-22T06:16:50.000Z">
<meta property="article:modified_time" content="2025-06-23T06:05:40.298Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2025/01/22/javascript-guide-15/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JavaScript 权威指南 15：浏览器中的 JavaScript | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2025/01/22/javascript-guide-15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaScript 权威指南 15：浏览器中的 JavaScript
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-22 14:16:50" itemprop="dateCreated datePublished" datetime="2025-01-22T14:16:50+08:00">2025-01-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>JavaScript 创造于 1994 年，其明确的目的就是为浏览器显示的文档赋予动态行为。今天，Web 对 JavaScript 程序员而言已经是一个完善的应用开发平台。我们通常所说的 JavaScript 指的就是在浏览器中运行的 JavaScript 代码。与之相对的是 <code>服务器端</code> 代码，也就是运行在服务器上的程序。客户端和服务器端经常也被称为 <code>前端</code> 和 <code>后端</code>。</p>
<span id="more"></span>

<h2 id="Web-编程基础"><a href="#Web-编程基础" class="headerlink" title="Web 编程基础"></a>Web 编程基础</h2><h3 id="HTML-lt-script-gt-标签中的-JavaScript"><a href="#HTML-lt-script-gt-标签中的-JavaScript" class="headerlink" title="HTML &lt;script&gt; 标签中的 JavaScript"></a>HTML <code>&lt;script&gt;</code> 标签中的 JavaScript</h3><p>浏览器显示 HTML 文档。如果想让浏览器执行 JavaScript 代码，那么必须在 HTML 文档中包含（或引用）相应代码，这时候就要用到 HTML <code>&lt;script&gt;</code> 标签。</p>
<ul>
<li>JavaScript 代码可以出现在 HTML 文件的 <code>&lt;script&gt;</code>与 <code>&lt;/script&gt;</code> 标签之间，也就是嵌入 HTML 中</li>
<li>使用 <code>&lt;script&gt;</code> 标签的 src 属性指定 JavaScript 代码文件的 URL。JavaScript 文件只包含纯 JavaScript 代码，不包含 <code>&lt;script&gt;</code> 或其他 HTML 标签。按照约定，JavaScript 代码文件以 <code>.js</code> 结尾。</li>
</ul>
<p>如下将 JavaScript 代码之前嵌入 <code>&lt;script&gt;</code> 标签中，这段代码实现了一个数字时钟：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Digital Clock<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="selector-id">#clock</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">            <span class="attribute">font</span>: bold <span class="number">20px</span> Arial;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">            <span class="attribute">background-color</span>: <span class="number">#ddf</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">            <span class="attribute">padding</span>: <span class="number">15px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">            <span class="attribute">border</span>: solid black <span class="number">2px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">            <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Digital Clock<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;clock&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">function</span> <span class="title function_">displayTime</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">let</span> clock = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#clock&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            clock.<span class="property">textContent</span> = now.<span class="title function_">toLocaleTimeString</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">displayTime</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="built_in">setInterval</span>(displayTime, <span class="number">1000</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>使用 src 有如下优点：</p>
<ul>
<li>简化 HTML 文件，因为可以把大段的 JavaScript 代码从中移走，实现内容与行为的分离</li>
<li>在多个网页共享同一份 JavaScript 代码时，使用 src 属性可以只维护一份代码，而无须在代码变化时修改多个 HTML 文件</li>
<li>如果一个 JavaScript 文件被多个页面共享，那它只会被使用它的第一个页面下载一次，后续页面可以从浏览器缓存中获取该文件</li>
<li>因为 src 以任意 URL 作为值，所以来自一个 Web 服务器的 JavaScript 程序或网页可以利用其他服务器暴露的代码。很多互联网广告就依赖这个事实</li>
</ul>
<p>如果你用模块写了一个 JavaScript 程序（且没有使用代码打包工具把所有模块都整合到一个非 JavaScript 模块文件中）​，那必须使用一个带有 <code>type=&quot;module&quot;</code> 属性的 <code>&lt;script&gt;</code> 标签来加载这个程序的顶级模块。这样，浏览器会加载你指定的模块，并加载这个模块导入的所有模块，以及（递归地）加载所有这些模块导入的模块。</p>
<p>由于 JavaScript 已经是 Web 的默认（也是唯一）语言。因此 <code>&lt;script&gt;</code> 标签的 language 属性被废弃了，而 type 属性也只有两个使用场景：</p>
<ul>
<li>用于指定脚本是模块</li>
<li>在网页中嵌入数据但不会显示</li>
</ul>
<p>浏览器在解析遇到的 <code>&lt;script&gt;</code> 元素时的默认行为是必须要运行脚本，就是为了确保不漏掉脚本可能输出的 HTML 内容，然后才能再继续解析和渲染文档。这有可能严重拖慢网页的解析和渲染过程。</p>
<p>默认的这种同步或阻塞式脚本执行模式并非唯一选项。<code>&lt;script&gt;</code> 标签也支持 <code>defer</code> 和 <code>async</code> 属性，这两个属性会导致脚本以不同的方式执行。这两个属性只对使用 src 属性的 <code>&lt;script&gt;</code> 标签起作用。</p>
<p><code>defer</code> 和 <code>async</code> 属性都会明确告诉浏览器，当前链接的脚本中没有使用 <code>document.write()</code> 生成 HTML 输出（<code>document.write()</code> 方法可以向 HTML 中注入文本）。因此浏览器可以在下载脚本的同时继续解析和渲染文档。</p>
<ul>
<li>defer 属性会让浏览器把脚本的执行推迟到文档完全加载和解析之后，此时已经可以操作文档了</li>
<li>async 属性会让浏览器尽早运行脚本，但在脚本下载期间同样不会阻塞文档解析。如果 <code>&lt;script&gt;</code> 标签上同时存在这两个属性，则 async 属性起作用</li>
<li>推迟（defer）的脚本会按照它们在文档中出现的顺序运行。因为异步（async）脚本会在它们加载完毕后运行，所以其运行顺序无法预测</li>
</ul>
<p>带有 <code>type=&quot;module&quot;</code> 属性的脚本默认会在文档加载完毕后执行，就好像有一个 <code>defer</code> 属性一样。可以通过 async 属性来覆盖这个默认行为，这样会导致代码在模块及其所有依赖加载完毕后就立即执行。</p>
<p>如果不使用 async 和 defer 属性（特别是对那些直接包含在HTML中的代码）​，也可以选择把 <code>&lt;script&gt;</code> 标签放在 HTML 文件的末尾。这样，脚本在运行的时候就知道自己前面的文档内容已经解析，可以操作了。</p>
<p>有时候希望按需加载脚本，例如只有当用户执行了某些操作，才加载对应的 JavaScript 代码。如果你的代码是以模块形式写的，则可以使用 <code>import()</code> 来按需加载。如果没有使用模块，可以通过向文档中动态添加 <code>&lt;script&gt;</code> 标签的方式按需加载脚本：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">importScript</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> s = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">        s.<span class="property">onload</span> = <span class="function">() =&gt;</span> &#123; <span class="title function_">resolve</span>(); &#125;;</span><br><span class="line">        s.<span class="property">onerror</span> = <span class="function">() =&gt;</span> &#123; <span class="title function_">reject</span>(); &#125;;</span><br><span class="line">        s.<span class="property">src</span> = url;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">append</span>(s);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文档对象模型"><a href="#文档对象模型" class="headerlink" title="文档对象模型"></a>文档对象模型</h3><p>客户端 JavaScript 编程中最重要的一个对象就是 Document 对象，它代表浏览器窗口或标签页中显示的 HTML 文档。用于操作 HTML 文档的 API 被称为 <code>文档对象模型</code>（Document Object Model，DOM）。</p>
<p>HTML 文档包含一组相互嵌套的 HTML 元素，构成了一棵树。DOM API 与 HTML 文档的这种树形结构可谓一一对应：</p>
<ul>
<li>文档中的每个 HTML 标签都有一个对应的 JavaScript Element 对象</li>
<li>文档中的每一行文本也都有一个与之对应的 Text 对象</li>
<li>Element 和 Text 类，以及 Document 类本身，都是一个更通用的 Node 类的子类</li>
<li>各种 Node 对象组合成一个树形结构，JavaScript 可以使用 DOM API 对其进行查询和遍历</li>
</ul>
<p>DOM API 包含创建新 Element 和 Text 节点的方法，也包含把它们作为其他 Element 对象的孩子插入文档的方法。还有用来在文档中移动元素的方法，以及把它们从文档中彻底删除的方法。JavaScript 应用可以使用 <code>DOM API</code> 通过构建或操作文档树产生格式化的 HTML 输出。</p>
<p>每个 HTML 标签类型都有一个与之对应的 JavaScript 类，而文档中出现的每个标签在 JavaScript 中都有对应类的一个实例表示。JavaScript 中这些元素对象都有与 HTML 标签的属性对应的属性。例如，表示 <code>&lt;img&gt;</code> 标签的 <code>HTMLImageElement</code> 对象有一个 &#96;src 属性，对应着标签的相应属性。</p>
<ul>
<li>这个属性的初始值就是 HTML 标签中相应属性的值</li>
<li>在 JavaScript 中修改这个属性的值，也会改变 HTML 属性的值（并导致浏览器加载和显示新图片）​</li>
</ul>
<h3 id="浏览器中的全局对象"><a href="#浏览器中的全局对象" class="headerlink" title="浏览器中的全局对象"></a>浏览器中的全局对象</h3><p>每个浏览器窗口或标签页都有一个全局对象，在一个窗口中运行的所有 JavaScript 代码（不包括工作线程中运行的代码）都共享一个全局对象。文档中的所有脚本和模块共享同一个全局对象，如果有脚本在该对象上定义了一个属性，则该属性也将对所有其他脚本可见。全局对象上定义了 JavaScript 标准库，在浏览器中，全局对象也包含各种 Web API 的主入口。例如，document 属性表示当前显示的文档，fetch() 方法用于发送 HTTP 网络请求等等。</p>
<p>在浏览器中，全局对象具有双重角色。它既是定义 JavaScript 语言内置类型和函数的地方，也代表当前浏览器窗口定义了 history 和 innerWidth（表示窗口的像素宽度）等 Web API 的属性。</p>
<p>全局对象的属性中有一个属性叫 window，它的值就是全局对象本身。这意味着在客户端代码中可以直接通过 window 引用全局对象。在使用窗口特定的功能时，最好加上 window 前缀。比如，写 <code>window.innerWidth</code> 比只写 <code>innerWidth</code> 更明确。</p>
<h3 id="脚本共享一个命名空间"><a href="#脚本共享一个命名空间" class="headerlink" title="脚本共享一个命名空间"></a>脚本共享一个命名空间</h3><p>在模块中，定义在模块顶级（即位于任何函数或类定义之外）的常量、变量、函数和类是模块私有的，除非它们被明确地导出。被导出时，这些模块成员可以被其他模块有选择地导入。</p>
<p>不过在非模块脚本中，情况完全不同。如果在顶级脚本中定义了一个常量、变量、函数或类，则该声明将对同一文档中的所有脚本可见。同一个文档中共享同一个命名空间的独立脚本就如同它们是一个更大脚本的组成部分一样。这对于小程序或许会很方便，但在大型程序中避免命名冲突则会变成一件麻烦事，特别是在某些脚本还是第三方库的情况下。</p>
<p>这个共享的命名空间在运行时有一些历史遗留问题：</p>
<ul>
<li>比如，顶级的 var 和 function 声明会在共享的全局对象上创建属性。因此一个脚本定义了顶级函数 <code>f()</code>，那么同一个文档中的另一个脚本可以用 <code>f()</code> 或者 <code>window.f()</code> 调用该函数</li>
<li>而使用 ES6 中 <code>const</code>、<code>let</code> 和 <code>class</code> 的顶级声明则不会在全局对象上创建属性。但是，<strong>它们仍然会定义在一个共享的命名空间内</strong>。如果一个脚本定义了类 <code>C</code>，另一个脚本也可以通过 <code>new C()</code>（但不能通过 <code>new window.C()</code>）创建该类的实例</li>
</ul>
<p>简单来说，在模块中，顶级声明被限制在模块内部，可以明确导出。而在非模块脚本中，顶级声明被限制在包含文档内部，顶级声明由文档中所有的脚本共享。以前的 var 和 function 声明是通过全局对象的属性共享的，而现在的 const、let 和 class 声明也会被共享且拥有相同的文档作用域，但它们不作为 JavaScript 可以访问到的任何对象的属性存在。</p>
<h3 id="JavaScript-程序的执行"><a href="#JavaScript-程序的执行" class="headerlink" title="JavaScript 程序的执行"></a>JavaScript 程序的执行</h3><p>客户端 JavaScript 中没有程序的正式定义，<strong>但我们可以说 JavaScript 程序由文档中包含和引用的所有 JavaScript 代码组成</strong>：</p>
<ul>
<li>这些分开的代码共享同一个全局 Window 对象</li>
<li>它们可以通过 Window 对象访问表示 HTML 文档的同一个底层 Document 对象</li>
<li>不是模块的脚本还额外共享同一个顶级命名空间</li>
</ul>
<p>如果网页中包含嵌入的窗格（<code>&lt;iframe&gt;</code>元素）​，被嵌入文档与嵌入它的文档中的 JavaScript 代码拥有不同的全局对象和 Document 对象，可以看成两个不同的 JavaScript 程序。但要记住，关于 JavaScript 程序的边界在哪里并没有正式的定义。如果包含文档与被包含文档是从同一个服务器加载的，则一个文档中的代码就能够与另一个文档中的代码交互。</p>
<p>我们可以把 JavaScript 程序的执行想象成发生在两个阶段。</p>
<ul>
<li><p>在第一阶段，文档内容被加载，<code>&lt;script&gt;</code> 元素指定的（内部和外部）代码运行。脚本通常按照它们在文档中出现的顺序依次执行，不过也可以使用前面介绍过的 async 和 defer 属性来修改。</p>
<ul>
<li>有的脚本在这个阶段并不真正做任何事，仅仅是定义供第二阶段使用的函数和类</li>
<li>而有的脚本在第一阶段可能会做很多重要的事情，而在第二阶段则什么也不做</li>
</ul>
</li>
<li><p>当文档加载完毕且所有脚本都运行之后，JavaScript执行就进入了第二阶段。这个阶段是异步的、事件驱动的。如果脚本要在第二阶段执行，那么它在第一阶段必须要做一件事，就是至少要注册一个将被异步调用的事件处理程序或其他回调函数</p>
<ul>
<li>在事件驱动的第二阶段，作为对异步事件的回应，浏览器会调用事件处理程序或其他回调</li>
<li>事件处理程序通常是为响应用户操作（如鼠标点击、敲击键盘等）而被调用的，但也可能会被网络活动、文档和资源加载事件、流逝的时间或者 JavaScript 代码中的错误触发</li>
</ul>
</li>
</ul>
<p>事件驱动阶段发生的第一批事件主要有：</p>
<ul>
<li><code>DOMContent-Loaded</code>：在 HTML 文档被完全加载和解析后触发</li>
<li><code>load</code>：事件在所有文档的外部资源（如图片）都完全加载后触发</li>
</ul>
<p>JavaScript 程序的加载阶段相对比较短，理想情况下少于 1 秒。文档加载一完成，事件驱动阶段将在浏览器显示文档的过程中一直持续。因为这个阶段是异步的和事件驱动的，所以可能会有很长一段时间什么也不会发生，也不会执行任何 JavaScript 代码。而这个过程时不时地会被用户操作或网络事件打断。</p>
<p>接下来更详细介绍这两个阶段：</p>
<p><strong>JavaScript 是单线程的语言，而单线程执行让编程更容易：你可以保证自己写的两个事件处理程序永远不会同时运行，在操作文档内容时，你敢肯定不会有别的线程会同时去修改它</strong>。单线程执行意味着浏览器会在脚本和事件处理程序执行期间停止响应用户输入。JavaScript 程序员为此有责任确保 JavaScript 脚本和事件处理程序不会长时间运行。</p>
<p>Web 平台定义了一种受控的编程模型，即 Web 工作线程（<code>Web worker</code>）。工作线程是一个后台线程，可以执行计算密集型任务而不冻结用户界面。工作线程中运行的代码无权访问文档内容，不会与主线程或其他工作线程共享任何状态，只能通过异步消息事件与主线程或其他工作线程通信。因此这种并发对主线程没有影响，工作线程也不会改变JavaScript 程序的单线程执行模型。</p>
<p><strong>客户端 JavaScript 时间线</strong>：</p>
<ul>
<li><p>浏览器创建 Document 对象并开始解析网页，随着对 HTML 元素及其文本内容的解析，不断向文档中添加 Element 对象和 Text 节点。此时，<code>document.readyState</code> 属性的值是 <code>loading</code></p>
</li>
<li><p>HTML解析器在碰到一个没有 async、defer 或 type&#x3D;”module” 属性的 <code>&lt;script&gt;</code> 标签时，会把该标签添加到文档中，然后执行其中的脚本。<strong>脚本是同步执行的，而且在脚本下载（如果需要）和运行期间，HTML 解析器会暂停</strong></p>
<ul>
<li>脚本可以使用 document.write() 向输入流中插入文本，而该文本在解析器恢复时将成为文档的一部分</li>
<li>类似这样的脚本经常只会定义函数和注册事件处理程序，以便后面使用，但它也可以遍历和操作当时已经存在的文档树</li>
<li>因此，不带 async 或 defer 属性的非模块脚本可以看到它自己的 <code>&lt;script&gt;</code> 标签及该标签之前的文档内容</li>
</ul>
</li>
<li><p>解析器在碰到一个有 async 属性集的 <code>&lt;script&gt;</code> 元素时，会开始下载该脚本的代码（如果该脚本是模块，也会递归地下载模块的所有依赖）并继续解析文档。<strong>脚本在下载完成后会尽快执行，但解析器不会停下来等待它下载</strong>。</p>
<ul>
<li>异步（async）脚本必须不使用 <code>document.write()</code> 方法</li>
<li>它们可以看到自己的 <code>&lt;script&gt;</code> 标签及该标签之前的文档内容，同时也有可能访问更多文档内容</li>
</ul>
</li>
<li><p>当文档解析完成后，<code>document.readState</code> 属性变成 <code>interactive</code></p>
</li>
<li><p>任何有 defer 属性集的脚本（以及任何没有 async 属性的模块脚本）都会在按照它们在文档中出现的顺序依次执行</p>
<ul>
<li>延迟脚本可以访问完整的文档，必须不使用 <code>document.write()</code> 方法</li>
</ul>
</li>
<li><p>浏览器在 <code>Document</code> 对象上派发 <code>DOMContentLoaded</code> 事件。这标志着程序执行从同步脚本执行阶段过渡到异步的事件驱动阶段，但要注意，此时仍然可能存在尚未执行的 async 脚本。</p>
</li>
<li><p>此时文档已经解析完全，但浏览器可能仍在等待其他内容（如图片）加载。<strong>当所有外部资源都加载完成，且所有async 脚本都加载并执行完成时</strong>，<code>document.readyState</code> 属性变成 <code>complete</code>​，浏览器在 Window 对象上派发 <code>load</code> 事件</p>
</li>
<li><p>从这一刻起，作为对用户输入事件、网络事件、定时器超时等的响应，浏览器开始异步调用事件处理程序</p>
</li>
</ul>
<h3 id="程序的输入与输出"><a href="#程序的输入与输出" class="headerlink" title="程序的输入与输出"></a>程序的输入与输出</h3><p>与任何程序一样，客户端 JavaScript 程序也处理输入数据，产生输出数据。输入的来源有很多种：</p>
<ul>
<li>文档的内容本身，JavaScript 代码可以通过 DOM API 来访问</li>
<li>事件形式的用户输入</li>
<li>当前显示文档的 URL 可以在客户端 <code>JavaScript</code> 中通过 <code>document.URL</code> 读到</li>
<li>HTTP <code>cookie</code> 请求头的内容在客户端代码中可以通过 <code>document.cookie</code> 读到。cookie 通常被服务器端代码用来维持用户会话，但需要时客户端代码也可以读取 cookie</li>
<li>全局 navigator 属性暴露了关于浏览器、操作系统以及它们能力的信息。类似地，全局 screen 属性暴露了用户显示器尺寸的信息</li>
</ul>
<p>客户端 JavaScript 通常以借助 <code>DOM API</code> 操作 HTML 文档的形式（或者通过使用 React 或 Angular 等高级框架操作文档）产生输出。客户端代码也可以使用 <code>console.log()</code> 及其相关方法产生输出。但这种输出只能在开发者控制台看到，因此只能用于调试，不能用作对用户的输出。</p>
<h3 id="程序错误"><a href="#程序错误" class="headerlink" title="程序错误"></a>程序错误</h3><p>在浏览器中运行的 JavaScript 程序不会真正 <code>崩溃</code>​。如果 JavaScript 程序在运行期间出现异常，且代码中没有 catch 语句处理它，开发者控制台将会显示一条错误消息，但任何已经注册的事件处理程序照样会继续运行和响应事件。</p>
<p>如果你想定义一个终极错误处理程序，希望在出现这种未捕获异常时调用，那可以把 Window 对象的 onerror 属性设置为一个错误处理函数。当未捕获异常沿调用栈一路向上传播，错误消息即将显示在开发者控制台中时，<code>window.onerror</code> 函数将会以三个字符串参数被调用。如果 <code>onerror</code> 处理程序返回 true，意味着通知浏览器它已经处理了错误，不需要进一步行动了。</p>
<p>如果期约被拒绝而没有 <code>.catch()</code> 函数处理它，那么这种情况非常类似未处理异常，也就是程序中意料之外的错误或逻辑错误。可以通过定义 <code>window.onunhandledrejection</code> 函数或者使用 <code>window.addEventListener()</code> 为 <code>unhandledrejection</code> 事件注册一个处理程序来发现它：如果在这个未处理拒绝事件对象上调用<code>preventDefault()</code>，浏览器就会认为错误已经处理，而不会在开发者控制台中显示错误消息了。</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>客户端 JavaScript 程序使用异步事件驱动的编程模型。在这种编程风格下，浏览器会在文档、浏览器或者某些元素或与之关联的对象发生某些值得关注的事情时生成事件。如果 JavaScript 应用关注特定类型的事件，那它可以注册一个或多个函数，让这些函数在该类型事件发生时被调用。</p>
<p>在客户端 JavaScript 中，事件可以在 HTML 文档中的任何元素上发生，这也导致了浏览器的事件模型比 Node 的事件模型明显更复杂。</p>
<ul>
<li>事件类型：事件类型是一个字符串，表示发生了什么事件。有时也被称为 <code>事件名称</code></li>
<li>事件目标：事件目标是一个对象，而事件就发生在该对象上或者事件与该对象有关。例如某个 <code>&lt;button&gt;</code> 元素上发生了单击事件</li>
<li>事件处理程序：事件处理程序或事件监听器是一个函数，负责处理或响应事件。当事件目标上发生指定类型的事件时，浏览器会调用这个处理程序</li>
<li>事件对象：事件对象是与特定事件关联的对象，包含有关该事件的细节。事件对象作为事件处理程序的参数传入。所有事件对象都有 type 和 target 属性，分别表示事件类型和事件目标。每种事件类型都为相关的事件对象定义了一组属性</li>
<li>事件传播：事件传播是一个过程，浏览器在这个过程中会决定对哪些对象触发事件处理程序。对于发生在 HTML 文档中的某些事件，则会 <code>冒泡</code>（bubble）到文档根元素。事件处理程序可以阻止事件传播，从而让事件不再冒泡。为此，事件处理程序需要调用事件对象上的一个方法。在另外一种事件传播形式，即事件捕获（event capturing）中，注册在 <code>包含元素</code> 上的处理程序在事件被发送到实际目标之前，有机会先拦截（或捕获）事件</li>
</ul>
<p>有些事件有与之关联的默认动作（default action）。比如，单击一个超链接，默认动作是让浏览器跟随链接，加载一个新页面。事件处理程序可以通过调用事件对象的一个方法来阻止这个默认动作，有时也称为 <code>取消</code> 事件。</p>
<h3 id="事件类别"><a href="#事件类别" class="headerlink" title="事件类别"></a>事件类别</h3><p>客户端 JavaScript 支持的事件类型非常多，可以将这些事件分成通用的类别:</p>
<ul>
<li>设备相关输入事件：这类事件直接与特定输入设备（例如鼠标或键盘）相关，例如 <code>mouseup</code>、<code>keyup</code> 等</li>
<li>设备无关输入事件：这类输入事件并不与特定输入设备直接相关，例如 <code>input</code> 事件</li>
<li>用户界面事件：UI 事件是高级事件，通常在定义应用界面的 HTML 表单元素上触发。这类事件包括 <code>focus</code>、<code>change</code>、<code>submit</code> 等</li>
<li>状态变化事件：有些事件并不直接由用户活动触发，而是由网络或浏览器活动触发。这类事件表示某种生命期或状态相关的变化。例如分别由 Window 和 Document 对象在文档加载结束时触发的 <code>load</code> 和 <code>DOMContentLoaded</code> 事件</li>
<li>API 特定事件：有一些 HTML 及相关规范定义的 Web API 包含自己的事件类型。例如 HTML 的 <code>&lt;video&gt;</code> 和 <code>&lt;audio&gt;</code> 元素定义了一系列事件</li>
</ul>
<h3 id="注册事件处理程序"><a href="#注册事件处理程序" class="headerlink" title="注册事件处理程序"></a>注册事件处理程序</h3><p>有两种注册事件处理程序的方式：</p>
<ul>
<li>第一种是 Web 早期就有的，即设置作为事件目标的对象或文档元素的一个属性</li>
<li>第二种（更新也更通用）是把处理程序传给这个对象或元素的 addEventListener() 方法</li>
</ul>
<p>注册事件处理程序最简单的方式就是把事件目标的一个属性设置为关联的事件处理程序函数。<strong>按照惯例，事件处理程序属性的名字都由 <code>on</code> 和事件名称组成</strong>，例如 <code>onclick</code>、<code>onload</code> 等。注意，<strong>这些属性名是区分大小写的，必须全部小写</strong>，即便事件类型包含多个单词（如 <code>mousedown</code>​）​。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;form#shipping&quot;</span>);</span><br><span class="line">    form.<span class="property">onsubmit</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_">isFormValid</span>(<span class="variable language_">this</span>)) &#123;</span><br><span class="line">            event.<span class="title function_">preventDefault</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用事件处理程序属性有一个缺点，即这种方式假设事件目标对每种事件最多只有一个处理程序。一般来说，使用 <code>addEventListener()</code> 注册事件处理程序更好，因为该技术不会重写之前注册的处理程序。</p>
<p>文档元素的事件处理程序属性也可以直接在 HTML 文件中作为对应HTML标签的属性来定义（在JavaScript中注册在Window元素上的处理程序在HTML中可以定义为 <code>&lt;body&gt;</code> 标签的属性）。现代 Web 开发中通常不提倡使用这种技术，但它是可能的。</p>
<p>在使用 HTML 属性定义事件处理程序时，属性的值应该是一段 JavaScript 代码字符串。这段代码应该是事件处理程序函数的函数体，不是完整的函数声明。例如</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;hello, js&#x27;);&quot;</span>&gt;</span>Refresh<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果一个 HTML 事件处理程序属性包含多条 JavaScript 语句，则必须用分号分隔这些语句，或者用回车把这个属性值分成多行。在给 HTML 事件处理程序属性指定 JavaScript 代码字符串时，浏览器会把这个字符串转换为一个函数，这个函数类似如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="title function_">with</span>(<span class="params"><span class="variable language_">document</span></span>) &#123;</span><br><span class="line">        <span class="title function_">with</span>(<span class="params"><span class="variable language_">this</span>.form || &#123;&#125;</span>) &#123;</span><br><span class="line">            <span class="title function_">with</span>(<span class="params"><span class="variable language_">this</span></span>) &#123;</span><br><span class="line">                <span class="comment">/* your code */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任何可以作为事件目标的对象（包括 Window 和 Document 对象以及所有文档元素）​，都定义了一个名为 <code>addEventListener()</code> 的方法，可以使用它来注册目标为调用对象的事件处理程序。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#mybutton&quot;</span>);</span><br><span class="line">b.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;clicked1&quot;</span>); &#125;;</span><br><span class="line">b.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;clicked2&quot;</span>); &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数是注册处理程序的事件类型</li>
<li>第二个参数是当指定类型的事件发生时调用的函数</li>
<li>第三个参数是可选的，它可以是一个布尔值或者对象<ul>
<li>如果传入 true，函数就会被注册为捕获事件处理程序，从而在事件派发的另一个阶段调用它</li>
<li>注册捕获事件处理程序只是 <code>addEventListener()</code> 支持的3个选项之一。如果要传入其他选项，可以给第三个参数传一个对象，显式指定这些选项</li>
<li>如果 Options（选项）对象的 capture 属性为 true，那么函数就会被注册为捕获处理程序。如果这个属性为 false 或省略该属性，那么处理程序就不会注册到捕获阶段</li>
<li>如果选项对象有 once 属性且值为 true，那么事件监听器在被触发一次后会自动移除。如果这个属性为false或省略该属性，那么处理程序永远不会被自动移除</li>
<li>如果选项对象有 passive 属性且值为true，则表示事件处理程序永远不调用 <code>prevent Default()</code> 取消默认动作。passive 属性提供了一种机制，即在注册一个可能存在破坏性操作的事件处理程序时，这个属性让浏览器知道可以在事件处理程序运行的同时安全地开始其默认行为（如滚动）​。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, handleClick, &#123;<span class="attr">capture</span>: <span class="literal">true</span>, <span class="attr">once</span>: <span class="literal">true</span>, <span class="attr">passive</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure>


<p>以 <code>click</code> 作为第一参数调用 <code>addEventListener()</code> 不会影响 <code>onclick</code> 属性的值。因此上述代码单击一次按钮会在开发者控制台打印两条消息。更重要的是，可以多次调用 <code>addEventListener()</code> 在同一个对象上为同一事件类型注册多个处理程序。当对象上发生该事件时，所有为这个事件而注册的处理程序都会按照注册它们的顺序被调用。但是在同一个对象上以相同的参数多次调用 <code>addEventListener()</code> 没有作用，同一个处理程序只能注册一次，重复调用不会改变处理程序被调用的顺序。</p>
<p>与 <code>addEventListener()</code> 对应的是 <code>removeEventListener()</code> 方法，它们的前两个参数是一样的（第三个参数也是可选的）​，只不过是用来从同一个对象上移除而不是添加事件处理程序。</p>
<ul>
<li>如果在注册事件监听器时给第三个参数传了 true，那么要移除该事件处理程序，必须在调用 <code>removeEventListener()</code> 时也传入 true 作为第三个参数</li>
<li>可以把选项对象传给 <code>removeEventListener()</code>，但其中只有 capture 属性才是有用的，即使指定了其他属性也会被忽略</li>
</ul>
<h3 id="调用事件处理程序"><a href="#调用事件处理程序" class="headerlink" title="调用事件处理程序"></a>调用事件处理程序</h3><p>注册事件处理程序后，浏览器会在指定对象发生指定事件时自动调用它。事件处理程序被调用时会接收到一个 Event 对象作为唯一的参数，这个 Event 对象的属性提供了事件的详细信息：</p>
<ul>
<li>type：发生事件的类型</li>
<li>target：发生事件的对象</li>
<li>currentTarget：对于传播的事件，这个属性是注册当前事件处理程序的对象</li>
<li>timeStamp：表示事件发生时间的时间戳（毫秒）​，不是绝对时间</li>
<li>isTrusted：如果事件由浏览器自身派发，这个属性为 true；如果事件由 JavaScript 代码派发，这个属性为 false</li>
</ul>
<p>无论是通过哪种方式注册事件处理程序（设置属性还是 <code>addEventListener()</code>），事件处理程序将作为它所在对象的方法被调用。换句话说，<strong>在事件处理程序的函数体中，this 关键字引用的是注册事件处理程序的对象</strong>。对于箭头函数，其 this 的值始终等于定义它的作用域的 this 值。</p>
<p>在现代 JavaScript 中，事件处理程序不应该返回值。在比较老的代码中，我们还可以看到返回值的事件处理程序，而且返回的值通常用于告诉浏览器不要执行与事件相关的默认动作。阻止浏览器执行默认动作的标准且推荐的方式，是调用 Event 对象的 <code>preventDefault()</code> 方法。</p>
<p>一个事件目标可能会为一种事件注册多个处理程序。当这种事件发生时，浏览器会按照注册处理程序的顺序调用它们。即使注册方式不一样，该规则同样适用。</p>
<h3 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h3><p>如果事件的目标是 Window 或其他独立对象，浏览器对这个事件的响应就是简单地调用该对象上对应的事件处理程序。如果事件目标是 Document 或其他文档元素，就没有那么简单了。</p>
<p>注册在目标元素上的事件处理程序被调用后，多数事件都会沿 DOM 树向上 <code>冒泡</code>：</p>
<ul>
<li>目标父元素的事件处理程序会被调用。然后注册在目标祖父元素上的事件处理程序会被调用</li>
<li>就这样一直向上到 Document 对象，然后到 Window 对象</li>
</ul>
<p>由于事件冒泡，我们可以不用给个别文档元素注册很多事件处理程序，而是只在它们的公共祖先元素上注册一个事件处理程序，然后在其中处理事件。多数在文档元素上发生的事件都会冒泡。明显的例外是 <code>focus</code> <code>blur</code> 和 <code>scroll</code>事件。文档元素的 <code>load</code> 事件冒泡，但到 Document 对象就会停止冒泡，不会传播到 Window 对象。</p>
<p>事件冒泡是事件传播的第三个 <code>阶段</code>，调用目标对象本身的事件处理程序是第二个阶段，第一阶段，也就是在目标处理程序被调用之前的阶段，叫作 <code>捕获</code> 阶段：</p>
<ul>
<li>addEventListener() 接收的第三个可选参数吧。如果这个参数是 true 或 <code>&#123;capture:true&#125;</code>，那么就表明该事件处理程序会注册为捕获事件处理程序，将在事件传播的第一阶段被调用</li>
<li>事件传播的捕获阶段差不多与冒泡阶段正好相反，最先调用的是 Window 对象上注册的捕获处理程序，然后才调用 Document 对象的捕获处理程序，接着才是 <code>&lt;body&gt;</code> 元素。然后沿 DOM 树一直向下，直到事件目标父元素的捕获事件处理程序被调用</li>
<li>注册在事件目标本身的捕获事件处理程序不会在这个阶段被调用</li>
</ul>
<p>事件捕获提供了把事件发送到目标之前先行处理的机会。</p>
<h3 id="事件取消"><a href="#事件取消" class="headerlink" title="事件取消"></a>事件取消</h3><p>浏览器对很多用户事件都会作出响应，无论你是否在代码中指定。比如，用户在一个链接上单击鼠标，浏览器就会跟随该链接。如果你为这些事件注册了事件处理程序，那么就可以阻止浏览器执行其默认动作，为此要调用事件对象的 <code>preventDefault()</code> 方法（除非你注册处理程序时传入了 passive 选项，该选项会导致 <code>preventDefault()</code> 无效）。</p>
<p>取消与事件关联的默认动作只是事件取消的一种情况。除此之外，还可以调用事件对象的 <code>stopPropagation()</code> 方法，取消事件传播。</p>
<ul>
<li>如果同一对象上也注册了其他处理程序，则这些处理程序仍然会被调用</li>
<li>但是，在这个对象上调用 stopPropagation() 方法之后，其他对象上的事件处理程序都不会再被调用</li>
<li><code>stopPropagation()</code> 可以在捕获阶段、在事件目标本身，以及在冒泡阶段起作用</li>
</ul>
<p><code>stopImmediatePropagation()</code> 与 <code>stopPropagation()</code> 类似，只不过它也会阻止在同一个对象上注册的后续事件处理程序的执行。</p>
<h3 id="派发自定义事件"><a href="#派发自定义事件" class="headerlink" title="派发自定义事件"></a>派发自定义事件</h3><p>客户端 JavaScript 事件 API 相对比较强大，可以使用它定义和派发自己的事件：</p>
<ul>
<li>如果一个 JavaScript 对象有 <code>addEventListener()</code> 方法，那它就是一个 <code>事件目标</code>​。这意味着该对象也有一个 <code>dispatchEvent()</code> 方法，可以通过该方法向该对象派发事件</li>
<li>可以通过 <code>CustomEvent()</code> 构造函数创建自定义事件对象，然后再把它传给 <code>dispatchEvent()</code>。</li>
<li><code>CustomEvent()</code> 的第一个参数是一个字符串，表示事件类型；第二个参数是一个对象，用于指定事件对象的属性</li>
<li>如果你想在一个文档元素上派发自己的事件，并希望它沿文档树向上冒泡，则要在第二个参数中添加 <code>bubbles:true</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 派发事件，通知 UI，自己忙</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">dispatchEvent</span>(<span class="keyword">new</span> <span class="title class_">CustomEvent</span>(<span class="string">&quot;busy&quot;</span>, &#123;<span class="attr">detail</span>: <span class="literal">true</span>&#125;));</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(url)</span><br><span class="line">  .<span class="title function_">then</span>(handleNetworkResponse)</span><br><span class="line">  .<span class="title function_">catch</span>(handleNetworkError)</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 派发事件，通知 UI，自己已经不忙</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">dispatchEvent</span>(<span class="keyword">new</span> <span class="title class_">CustomEvent</span>(<span class="string">&quot;busy&quot;</span>, &#123;<span class="attr">detail</span>: <span class="literal">false</span>&#125;));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 busy 事件处理程序</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;busy&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">detail</span>) &#123;</span><br><span class="line">        <span class="title function_">showSpinner</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">hideSpinner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="操作-DOM"><a href="#操作-DOM" class="headerlink" title="操作 DOM"></a>操作 DOM</h2><p>客户端 JavaScript 存在的目的就是把静态 HTML 文档转换为交互式 Web 应用。因此通过脚本操作网页内容无疑是 JavaScript 的核心目标。</p>
<p>每个 Window 对象都有一个 document 属性，引用一个 Document 对象。这个 Document 对象代表窗口的内容，它是 DOM 中表示和操作文档内容的核心对象。</p>
<h3 id="选择-Document-元素"><a href="#选择-Document-元素" class="headerlink" title="选择 Document 元素"></a>选择 Document 元素</h3><p>客户端 JavaScript 程序经常需要操作文档中的一个或多个元素。全局 document 属性引用 Document 对象，而Document 对象有 head 和 body 属性，分别引用 <code>&lt;head&gt;</code> 和 <code>&lt;body&gt;</code> 标签对应的 <code>Element</code> 对象。但一个程序要想操作文档中嵌入层级更多的元素，必须先通过某种方式获取或选择表示该元素的 Element 对象。</p>
<p><strong>通过CSS选择符选择元素：</strong></p>
<p>CSS 的选择符可以用来描述文档中元素或元素的集合，CSS 选择符可以通过元素类型（标签）​、ID、类名、属性，以及元素在文档中的位置来引用元素。DOM 方法 querySelector() 和 querySelectorAll() 让我们能够在文档中找到与指定选择符匹配的元素。</p>
<ul>
<li><code>querySelector()</code> 方法接收一个 CSS 选择符字符串作为参数，返回它在文档中找到的第一个匹配的元素；如果没有找到，则返回 null</li>
<li><code>querySelectorAll()</code> 是类似的，只不过返回文档中所有的匹配元素，而不是只返回第一个</li>
</ul>
<p><code>querySelectorAll()</code> 的返回值不是 Element 对象的数组，而是一个类似数组的 NodeList对象：</p>
<ul>
<li>NodeList 对象有一个 length 属性，可以像数组一样通过索引访问，因此可以使用传统的 for 循环遍历</li>
<li>NodeList 也是可迭代对象，因此也可以在 for&#x2F;of 循环中使用它们</li>
<li>如果想把 NodeList 转换为真正的数组，只要把它传给 <code>Array.from()</code> 即可</li>
<li>如果查找结果为空，NodeList 对象的 length 属性为 0</li>
</ul>
<p>Element 类和 Document 类都实现了 <code>querySelector()</code> 和 <code>querySelectorAll()</code>。<strong>当在元素上调用时，这两个方法只返回该元素后代中的元素</strong>。</p>
<p>还有一个基于 CSS 的元素选择方法：<code>closest()</code>。这个方法是 Element 类定义的，以一个选择符作为唯一参数：</p>
<ul>
<li>如果选择符匹配那个调用它的元素，则返回该元素</li>
<li>否则，就返回与选择符匹配的最近祖先元素；如果没有匹配，则返回 null</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找有 href 属性的最近的、外围 &lt;a&gt; 标签</span></span><br><span class="line"><span class="keyword">let</span> hyperlink = event.<span class="property">target</span>.<span class="title function_">closest</span>(<span class="string">&quot;a[href]&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>另一个相关的方法 <code>matches()</code> 既不返回祖先，也不返回后代，只会检查元素是否与选择符匹配。如果匹配，返回 true；否则，返回 false。</p>
<p><strong>其他选择元素的方法：</strong></p>
<p>除了 <code>querySelector()</code> 和 <code>querySelectorAll()</code>，DOM 也定义了一些老式的元素选择方法。如今，这些方法多多少少已经被废弃了，这里还是了解一下：</p>
<ul>
<li><code>getElemenById()</code>：通过 id 属性查找元素（可以通过 CSS 的 id 选择器替代）</li>
<li><code>getElementsByName()</code>：通过元素的 name 属性查找元素（可以通过 CSS 的属性选择器替代）</li>
<li><code>getElementsByTagName()</code>：通过元素类型查找元素（可以通过 CSS 的标签选择器替代）</li>
<li><code>getElementsByClassName()</code>：通过元素的 class 属性查找元素（可以通过 CSS 的类选择器替代）</li>
</ul>
<p>上面代码中的方法也返回 NodeList（除了 getElementById()，它返回一个 Element 对象）​。但是，与 <code>querySelectorAll()</code> 不同的是，这些老式选择方法返回的 <code>NodeList</code> 是 <code>活的</code>​。所谓 <code>活的</code>​，指的是这些 NodeList 的 length 属性和其中包含的元素会随着文档内容或结构的变化而变化。</p>
<p><strong>预选择的元素：</strong></p>
<p>由于历史原因，Document 类定义了一些快捷属性，可以通过它们直接访问某种节点：</p>
<ul>
<li>通过 images、forms 和 links属性可以直接访问文档中的 <code>&lt;img&gt;</code>、<code>&lt;form&gt;</code> 和 <code>&lt;a&gt;</code> 元素（有 href 属性的 <code>&lt;a&gt;</code> 标签）​</li>
<li>这些属性引用的是 HTMLCollection 对象。它与 NodeList 对象非常相似，只是还可以通过元素 ID 或名字来索引其中的元素</li>
<li>document.all 属性包含文档中的所有元素，这个属性引用的对象类似于 HTMLCollection。这个 API 已经被废弃，实际开发中不应该使用</li>
</ul>
<h3 id="文档结构与遍历"><a href="#文档结构与遍历" class="headerlink" title="文档结构与遍历"></a>文档结构与遍历</h3><p>从 Document 中选择一个 Element 之后，常常还需要查找文档结构中相关的部分。如果我们只关心文档中的 Element 而非其中的文本，有一个遍历 API 可以让我们把文档作为一棵 Element 对象树，树中不包含同样属于文档的 Text 节点。这个遍历 API 不涉及任何方法，而只是 Element 对象上的一组属性：</p>
<ul>
<li>parentNode：这个属性引用元素的父节点，也就是另一个 Element 对象，或者 Document 对象</li>
<li>children：这个属性是 NodeList，包含元素的所有子元素，但是不含非 Element 节点（如 Text 节点）</li>
<li>childElementCount：这个属性是元素所有子元素的个数。与 <code>children.length</code> 返回的值相同</li>
<li>firstElementChild、lastElementChild：这两个属性分别引用元素的第一个子元素和最后一个子元素。如果没有子元素，它们的值为 null</li>
<li>previousElementSibling、nextElementSibling：这两个属性分别引用元素左侧紧邻的同辈元素和右侧紧邻的同辈元素，如果没有相应的同辈元素则为 null</li>
</ul>
<p>因此，表达式 <code>document.children[0].children[1]</code> 可以引用 Document 第一个子元素（html 标签）的第二个子元素（body 标签）。</p>
<p>如下代码则实现了对文档的深度遍历：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">traverse</span>(<span class="params">e, f</span>) &#123;</span><br><span class="line">    <span class="title function_">f</span>(e);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> e.<span class="property">children</span>) &#123;</span><br><span class="line">        <span class="title function_">traverse</span>(c, f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在遍历文档或文档中的某些部分时不想忽略 Text 节点，可以使用另一组在所有 Node 对象上都有定义的属性。通过这些属性可以看到 Element、Text 节点，甚至 Comment 节点（表示文档中的 HTML 注释）。所有 Node 对象都定义了以下属性：</p>
<ul>
<li>parentNode：当前节点的父节点，对于没有父节点的节点或 Document 对象则为 null</li>
<li>childNodes：只读的 NodeList 对象，包含节点的所有子节点（不仅仅是 Element 子节点）​</li>
<li>firstChild、lastChild：当前节点的第一个子节点和最后一个子节点，如果没有子节点则为 null</li>
<li>previousSibling、nextSibling：当前节点的前一个同辈节点和后一个同辈节点。这两个属性通过双向链表连接节点</li>
<li>nodeType：表示当前节点类型的数值。Document 节点的值为 9，Element 节点的值为 1，Text 节点的值为 3，Comment 节点的值为 8</li>
<li>nodeValue：Text 或 Comment 节点的文本内容</li>
<li>nodeName：Element 节点的 HTML 标签名，会转换为全部大写</li>
</ul>
<p>不过要注意，这套 API 对于文档中文本的变化极为敏感。如果插入在标签之间插入一个换行符，可能就增加了一个 Text 节点。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>HTML元素由标签名和一组称为属性的名&#x2F;值对构成。Element 类定义了通用的 <code>getAttribute()</code>、<code>setAttribute()</code>、<code>hasAttribute()</code> 和 <code>removeAttribute()</code> 方法，用于查询、设置、检测和删除元素的属性。</p>
<p>同时，HTML 元素的属性（指所有标准 HTML 元素的标准属性）同时也在表示这些元素的 HTMLElement 对象上具有相应的属性。使用 JavaScript 属性来存取它们，通常要比调用 getAttribute() 及其他方法来得更便捷。</p>
<p>HTMLElement 为通用 HTML 属性（如 id、title、lang 和 dir）和事件处理程序属性（如 <code>onclick</code>）定义了属性。特定的 Element 子类型则定义了特定于相应元素的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> image = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#main_image&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> url = image.<span class="property">src</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;form&quot;</span>);</span><br><span class="line">f.<span class="property">action</span> = <span class="string">&quot;https://example.com/submit&quot;</span>;</span><br><span class="line">f.<span class="property">method</span> = <span class="string">&quot;POST&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>HTML 属性是不区分大小写的，但 JavaScript 属性名区分大小写。要把 HTML 属性转换为 JavaScript 属性，全部小写即可。如果 HTML 属性包含多个单词，则从第二个单词开始，每个单词的首字母都大写。不过，事件处理程序属性是例外，比如 onclick，需要全部小写。</p>
</li>
<li><p>有些 HTML 属性名是 JavaScript 中的保留字。对于这些属性，通用规则是对应的 JavaScript 属性包含前缀 <code>html</code>​</p>
</li>
<li><p>JavaScript 中表示 HTML 属性的这些属性通常都是字符串值。但是当 HTML 属性是布尔值或数字值时，相应的 JavaScript 属性值则是布尔值或数值，不是字符串。事件处理程序属性的值则始终是函数</p>
</li>
</ul>
<p>这个基于属性的 API 只能获取和设置 HTML 中对应的属性值，并没有定义从元素中删除属性的方式。特别地，不能用 delete 操作符来删除 HTML 属性。如果真想删除 HTML 属性，可以在 JavaScript 中调用<code>removeAttribute()</code> 方法。</p>
<p>HTML 元素的 class 属性特别重要，由于 class 在 JavaScript 中是保留字，所以这个 HTML 属性是通过 Element 对象上的 className 属性反映出来的。由于它的值是一个字符串列表，为了在这个列表中添加或删除某个类名，Element 对象定义了 <code>classList</code> 属性，支持将 <code>class</code> 属性作为一个列表来操作。</p>
<p>有时候在 HTML 元素上附加一些信息很有用，在HTML中，任何以前缀 <code>data-</code> 开头的小写属性都被认为是有效的，可以将它们用于任何目的。这些 <code>数据集</code>（dataset）属性不影响它们所在元素的展示，在保证文档正确性的前提下定义了一种附加额外数据的标准方式。在 DOM 中，Element 对象有一个 dataset 属性，该属性引用的对象包含与 HTML 中的 <code>data-属性</code> 对应的属性，但不带这个前缀：即 <code>dataset.x</code> 保存的是 HTML 中的 <code>data-x</code> 属性的值（连字符分隔的属性将映射为驼峰式属性名）。</p>
<p>如下是一个示例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;data&quot;</span> <span class="attr">data-section-number</span>=<span class="string">&quot;15.1&quot;</span>&gt;</span>Section 15.1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#data&#x27;</span>).<span class="property">dataset</span>.<span class="property">sectionNumber</span>); <span class="comment">// =&gt; 15.1</span></span><br></pre></td></tr></table></figure>

<h3 id="元素内容"><a href="#元素内容" class="headerlink" title="元素内容"></a>元素内容</h3><p>接下来介绍介绍如何操作元素内容的 <code>HTML表示</code> 和 <code>纯文本表示</code>。</p>
<p>读取一个 Element 的 innerHTML 属性会返回该元素内容的标记字符串。在元素上设置这个属性会调用浏览器的解析器，并以新字符串解析后的表示替换元素当前的内容。</p>
<p>Element 的 outerHTML 属性与 innerHTML 属性类似，只是返回的值包含元素自身。在读取 outerHTML 时，该值包含元素的开始和结束标签。而在设置元素的 outerHTML 时，新内容会取代元素自身。</p>
<p>另一个相关的 Element 方法是 <code>insertAdjacentHTML()</code>，用于插入与指定元素 <code>相邻</code>（adjacent）的任意 HTML 标记字符串。</p>
<p>有时候，我们希望得到元素的纯文本内容，或者向文档中插入纯文本（不转义 HTML 中使用的尖括号和 &amp; 字符）。这样做的标准方式是使用 textContent 属性：</p>
<ul>
<li>这个 textContent 属性是由 Node 类定义的，因此在 Text 节点和 Element 节点上都可以使用</li>
<li>对于 Element 节点，它会找到并返回元素所有后代中的文本</li>
<li>Element 类定义了一个 <code>innerText</code> 属性，与 <code>textContent</code> 类似。但 innerText 有一些少见和复杂的行为，如试图阻止表格格式化。这个属性的定义不严谨，因此不应该再使用</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;data&quot;</span>&gt;</span>Section 15.1<span class="tag">&lt;<span class="name">i</span>&gt;</span>test<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>test2<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// =&gt; Section 15.1&lt;i&gt;test&lt;/i&gt;&lt;p&gt;test2&lt;/p&gt;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#data&#x27;</span>).<span class="property">innerHTML</span>);</span><br><span class="line"><span class="comment">// =&gt; &lt;h1 id=&quot;data&quot; data-section-number=&quot;15.1&quot;&gt;Section 15.1&lt;i&gt;test&lt;/i&gt;&lt;p&gt;test2&lt;/p&gt;&lt;/h1&gt;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#data&#x27;</span>).<span class="property">outerHTML</span>);</span><br><span class="line"><span class="comment">// =&gt; Section 15.1testtest2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#data&#x27;</span>).<span class="property">textContent</span>);</span><br></pre></td></tr></table></figure>

<p>行内（即那些没有 src 属性的）<code>&lt;script&gt;</code> 元素有一个text属性，可以用于获取它们的文本。浏览器永远不会显示 <code>&lt;script&gt;</code> 元素的内容，HTML解析器会忽略脚本中的尖括号和 &amp; 字符。这就让 <code>&lt;script&gt;</code> 元素成为在 Web 应用中嵌入任意文本数据的理想场所。</p>
<ul>
<li>只要把这个元素的 type 属性设置为某个值（如 <code>text/x-custom-data</code>）​，明确它不是可执行的 JavaScript 代码即可。这样，JavaScript 解释器将会忽略这个脚本</li>
<li>但该元素还会出现在文档树中，它的 text 属性可以返回你在其中保存的数据</li>
</ul>
<h3 id="创建、插入和删除节点"><a href="#创建、插入和删除节点" class="headerlink" title="创建、插入和删除节点"></a>创建、插入和删除节点</h3><p>Document 类定义了创建 Element 对象的方法，而 Element 和 Text 对象拥有在树中插入、删除和替换节点的方法。</p>
<ul>
<li><p>使用 Document 类的 <code>createElement()</code> 方法可以创建一个新元素，并通过自己的 <code>append()</code> 和 <code>prepend()</code> 方法为自己添加文本或其他元素</p>
</li>
<li><p><code>append()</code> 和 <code>prepend()</code> 接收任意多个参数，这些参数可以是 Node 对象或字符串</p>
<ul>
<li><code>append()</code> 把参数添加到孩子列表的末尾，<code>prepend()</code> 把参数添加到孩子列表的开头</li>
<li>字符串参数会自动转换为 Text 节点</li>
<li>可以使用 <code>document.createTextNode()</code> 来创建 Text 节点，但很少需要这样做</li>
</ul>
</li>
<li><p>在得到一个同辈节点时，可以调用 <code>before()</code> 在该同辈前面插入新内容，或调用 <code>after()</code> 在该同辈后面插入新内容</p>
<ul>
<li><code>after()</code> 和 <code>before()</code> 也接收任意个数的字符串和元素参数，在将字符串转换为 Text 节点后把它们全部插入文档中</li>
<li><code>append()</code> 和 <code>prepend()</code> 只在 Element 对象上有定义，但 <code>after()</code> 和 <code>before()</code> 同时存在于 Element 和 Text 节点上，因此可以使用它们相对于 Text 节点插入内容</li>
</ul>
</li>
<li><p>要注意的是，元素只能被插入到文档中的一个地方。如果某个元素已经在文档中了，你又把它插入到了其他地方，那它会转移到新位置，而不会复制一个新的过去</p>
</li>
<li><p>如果确实想创建一个元素的副本，可以使用 <code>cloneNode()</code> 方法，传入 true 以复制其全部内容</p>
</li>
<li><p>调用 <code>remove()</code> 方法可以把 Element 或 Text 节点从文档中删除，或者可以调用 replaceWith() 替换它</p>
<ul>
<li>remove() 不接收参数</li>
<li><code>replaceWith()</code> 与 <code>before()</code> 和 <code>after()</code> 一样，接收任意个数的字符串和元素</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> em = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;em&#x27;</span>);</span><br><span class="line">em.<span class="title function_">append</span>(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">p.<span class="title function_">append</span>(<span class="string">&quot;hello&quot;</span>, em, <span class="string">&quot;!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>DOM API 也定义了插入和删除内容的老一代方法。比如，<code>appendChild()</code>、<code>insertBefore()</code>、<code>replaceChild()</code> 和 <code>removeChild()</code>，都比这里介绍的方法难用，因此不应该再使用它们了。</p>
<h3 id="生成目录"><a href="#生成目录" class="headerlink" title="生成目录"></a>生成目录</h3><p>如下 JavaScript 程序演示了如何动态为文档创建目录：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> toc = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#TOC&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!toc) &#123;</span><br><span class="line">      toc = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">      toc.<span class="property">id</span> = <span class="string">&quot;TOC&quot;</span>;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">prepend</span>(toc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> headings = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;h2,h3,h4,h5,h6&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> sectionNumbers = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> heading <span class="keyword">of</span> headings) &#123;</span><br><span class="line">      <span class="keyword">if</span> (heading.<span class="property">parentNode</span> === toc) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> level = <span class="built_in">parseInt</span>(heading.<span class="property">tagName</span>.<span class="title function_">charAt</span>(<span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">      sectionNumbers[level - <span class="number">1</span>]++;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = level; i &lt; sectionNumbers.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        sectionNumbers[i] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> sectionNumber = sectionNumbers.<span class="title function_">slice</span>(<span class="number">0</span>, level).<span class="title function_">join</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> span = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;span&quot;</span>);</span><br><span class="line">      span.<span class="property">className</span> = <span class="string">&quot;TOCSecNum&quot;</span>;</span><br><span class="line">      <span class="comment">//span.textContent = sectionNumber;</span></span><br><span class="line">      heading.<span class="title function_">prepend</span>(span);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> anchor = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">      <span class="keyword">let</span> fragmentName = <span class="string">`TOC<span class="subst">$&#123;sectionNumber&#125;</span>`</span>;</span><br><span class="line">      anchor.<span class="property">name</span> = fragmentName;</span><br><span class="line">      heading.<span class="title function_">before</span>(anchor);</span><br><span class="line">      anchor.<span class="title function_">append</span>(heading);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> link = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">      link.<span class="property">href</span> = <span class="string">`#<span class="subst">$&#123;fragmentName&#125;</span>`</span>;</span><br><span class="line">      link.<span class="property">innerHTML</span> = heading.<span class="property">innerHTML</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> entry = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">      entry.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;TOCEntry&quot;</span>, <span class="string">`TOCLevel<span class="subst">$&#123;level&#125;</span>`</span>);</span><br><span class="line">      entry.<span class="title function_">append</span>(link);</span><br><span class="line"></span><br><span class="line">      toc.<span class="title function_">append</span>(entry);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="操作-CSS"><a href="#操作-CSS" class="headerlink" title="操作 CSS"></a>操作 CSS</h2><p>我们已经知道，JavaScript 可以控制 HTML 文档的逻辑结构和内容。通过对 CSS 编程，JavaScript 也可以控制文档的外观和布局。</p>
<h3 id="CSS-类"><a href="#CSS-类" class="headerlink" title="CSS 类"></a>CSS 类</h3><p>使用 JavaScript 影响文档内容样式的最简单方式是给 HTML 标签的 class 属性添加或删除 CSS 类名。Element 对象的 classList 属性可以用来方便地实现此类操作。</p>
<p>例如假设样式表中包含 <code>hidden</code> 类定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">hidden</span> &#123;</span><br><span class="line">  <span class="attr">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则通过如下代码可以隐藏或者显式元素：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#data&quot;</span>).<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;hidden&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#data&quot;</span>).<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&quot;hidden&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="行内样式"><a href="#行内样式" class="headerlink" title="行内样式"></a>行内样式</h3><p>DOM 在所有 Element 对象上都定义了对应的 style 属性，它对应 HTML 元素的 style 属性。在 JavaScript 中，它是 <code>CSSStyleDeclaration</code> 对象，是对 HTML 中作为 style 属性值的 CSS 样式文本解析之后得到的一个表示。如下代码修改元素的行内样式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">displayAt</span>(<span class="params">tooltip, x, y</span>) &#123;</span><br><span class="line">  tooltip.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;block&quot;</span>;</span><br><span class="line">  tooltip.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&quot;absolute&quot;</span>;</span><br><span class="line">  tooltip.<span class="property">style</span>.<span class="property">left</span> = <span class="string">`<span class="subst">$&#123;x&#125;</span>px`</span>;</span><br><span class="line">  tooltip.<span class="property">style</span>.<span class="property">top</span> = <span class="string">`<span class="subst">$&#123;y&#125;</span>px`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>很多 CSS 样式属性（比如font-size）的名字中都包含连字符，但在 JavaScript 中连字符不能出现在标识符中，如果 CSS 属性名包含一个或多个连字符，对应的 CSSStyleDeclaration 属性名将剔除连字符，并将每个连字符后面的字母变成大写。</li>
<li>在使用 CSSStyleDeclaration 的样式属性时，要记住所有值都必须是字符串（不用在字符串中添加分号）</li>
<li>很多 CSS 属性要求包含单位，此时在 JavaScript 中设置样式属性时单位也是必须的</li>
<li>有些 CSS 属性是其他属性的简写形式（例如 margin 属性是 margin-top、margin-right、margin-bottom 和 margin-left 的简写），在 CSSStyleDeclaration 对象上也有与这些简写属性对应的属性</li>
</ul>
<p>以字符串而非 <code>CSSStyleDeclaration</code> 对象形式设置和读取行内样式会更方便，可以使用 Element 的 <code>getAttribute()</code> 和 <code>setAttribute()</code> 方法，或者也可以使用 CSSStyleDeclaration 对象的 cssText 属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.<span class="title function_">setAttribute</span>(<span class="string">&quot;style&quot;</span>, e.<span class="title function_">getAttribute</span>(<span class="string">&quot;style&quot;</span>));</span><br><span class="line">f.<span class="property">style</span>.<span class="property">cssText</span> = e.<span class="property">style</span>.<span class="property">cssText</span>;</span><br></pre></td></tr></table></figure>

<p><strong>在读取元素的 style 属性时，应该知道它只表示元素的行内样式，而多数元素的多数样式都是在样式表中指定的，不是写在行内的</strong>。一般来说，如果你想知道一个元素的样式，那需要的可能是计算样式。</p>
<h3 id="计算样式"><a href="#计算样式" class="headerlink" title="计算样式"></a>计算样式</h3><p>元素的计算样式（computed style）是浏览器根据一个元素的行内样式和所有样式表中适用的样式规则导出（或计算得到）的一组属性值，浏览器实际上使用这组属性值来显示该元素：</p>
<ul>
<li>与行内样式类似，计算样式同样以 <code>CSSStyleDeclaration</code> 对象表示</li>
<li>但与行内样式不同的是，计算样式是只读的，不能修改计算样式</li>
</ul>
<p>使用 Window 对象的 <code>getComputedStyle()</code> 方法可以获取一个元素的计算样式：</p>
<ul>
<li>第一个参数是要查询的元素，可选的第二个参数用于指定一个 CSS 伪元素</li>
<li>返回值是一个 CSSStyleDeclaration 对象，该对象包含应用给指定元素（或伪元素）的所有样式</li>
</ul>
<p>表示计算样式的 CSSStyleDeclaration 对象与表示行内样式的 CSSStyleDeclaration 对象有一些重要的区别：</p>
<ul>
<li>计算样式的属性是只读的</li>
<li>计算样式的属性是绝对值，百分比和点等相对单位都被转换成了绝对值</li>
<li>简写属性不会被计算，只有它们代表的基础属性会被计算。例如，不能查询 margin 属性，而要查询 marginLeft、 marginTop 等</li>
<li>计算样式的 cssText 属性是 undefined</li>
</ul>
<p>需要注意，尽管 CSS 可以精确指定文档元素的位置和大小，但是查询元素的计算样式并非确定该元素大小和位置的理想方式。后面会介绍一种更简单易用的替代方案。</p>
<h3 id="操作样式表"><a href="#操作样式表" class="headerlink" title="操作样式表"></a>操作样式表</h3><p>除了操作 class 属性和行内样式，JavaScript 也可以操作样式表。样式表是通过 <code>&lt;sytle&gt;</code> 标签或 <code>&lt;link rel=&quot;stylesheet&quot;&gt;</code> 标签与 HTML 文档关联起来的。这两个标签都是普通的 HTML 标签，因此可以为它们指定一个 id 属性，然后使用 <code>document.querySelector()</code> 找到它们</p>
<p><code>&lt;style&gt;</code> 和 <code>&lt;link&gt;</code> 标签对应的 Element 对象都有 disabled 属性，可以用它禁用整个样式表：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toggleTheme</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> ligthTheme = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#light-theme&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> darkTheme = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#dark-theme&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (darkTheme.<span class="property">disabled</span>) &#123;</span><br><span class="line">    lightTheme.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">    darkTheme.<span class="property">disabled</span> = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lightTheme.<span class="property">disabled</span> = <span class="literal">false</span>;</span><br><span class="line">    darkTheme.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个操作样式表的简单方法是使用前面介绍的 DOM API 向文档中插入新的样式表：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setTheme</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> link = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;link&quot;</span>);</span><br><span class="line">  link.<span class="property">id</span> = <span class="string">&quot;theme&quot;</span>;</span><br><span class="line">  link.<span class="property">rel</span> = <span class="string">&quot;stylesheet&quot;</span>;</span><br><span class="line">  link.<span class="property">href</span> = <span class="string">`themes/<span class="subst">$&#123;name&#125;</span>.css`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> currentTheme = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#theme&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (currentTheme) &#123;</span><br><span class="line">    currentTheme.<span class="title function_">replaceWith</span>(link);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">append</span>(link);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者你可会直接向文档中插入一段包含 <code>&lt;style&gt;</code> 标签的HTML字符串：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">insertAdjacentHTML</span>(</span><br><span class="line">  <span class="string">&quot;beforeend&quot;</span>,</span><br><span class="line">  <span class="string">&quot;&lt;style&gt;body &#123; background-color: red; &#125;&lt;/style&gt;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>浏览器定义了一套 API，以便 JavaScript 能够在样式表中查询、修改、插入或删除样式规则。可以在 MDN 上自行搜索 <code>CSS Object Model</code> 或 <code>CSSStyleSheet</code> 了解更多信息。</p>
<h3 id="CSS-动画与事件"><a href="#CSS-动画与事件" class="headerlink" title="CSS 动画与事件"></a>CSS 动画与事件</h3><p>CSS 本身支持通过 <code>transition</code>（过渡属性）来支持 CSS 动画，这个过程不需要 JavaScript 做任何事情，是纯粹的 CSS 动画效果。但 JavaScript 可以用来触发这种动画。</p>
<p>JavaScript 也可以用来监控 CSS 过渡动画的进度，因为浏览器在过渡动画的开始和结束都会触发事件：</p>
<ul>
<li>首次触发过渡时，浏览器会派发 <code>transitionrun</code> 事件</li>
<li>当发生视觉变化时，又会派发 <code>transitionstart</code> 事件</li>
<li>而当动画完成时，则会派发 <code>transitionend</code> 事件</li>
</ul>
<p>当然，所有这些事件的目标都是发生动画的元素。这些事件传给处理程序的事件对象是一个 TransitionEvent 对象。该对象的 propertyName 属性是发生动画的 CSS 属性，</p>
<p>除了过渡之外，CSS 也支持更复杂的动画形式，可以称其为 <code>CSS动画</code>。这会用到 <code>animation-name</code>、<code>animation-duration</code> 和特殊的 <code>@keyframes</code> 规则来定义动画细节。与 CSS 过渡类似，CSS 动画也触发事件，可以供 JavaScript 代码监听。</p>
<h2 id="文档几何与滚动"><a href="#文档几何与滚动" class="headerlink" title="文档几何与滚动"></a>文档几何与滚动</h2><p>当浏览器在窗口中渲染文档时，它会创建文档的一个视觉表示，其中每个元素都有自己的位置和大小。有时候，Web 应用可以把文档看成元素的树，不考虑这些元素在屏幕上如何展示。但有时候，又必须知道某个元素精确的几何位置。因此，<strong>我们要学会在基于树的抽象文档模型和基于几何坐标系的文档视图之间切换</strong>。</p>
<h3 id="文档坐标和视口坐标"><a href="#文档坐标和视口坐标" class="headerlink" title="文档坐标和视口坐标"></a>文档坐标和视口坐标</h3><p>文档元素的位置以 CSS ，其中 x 坐标向右表示增大，y 坐标向下表示增大。但是有两个点可以用作坐标原点：</p>
<ul>
<li>元素的 x 和 y 坐标可以相对于文档的左上角</li>
<li>也可以相对于显示文档的视口（viewport）的左上角，视口就是浏览器窗口中实际显示文档内容的区域</li>
</ul>
<p>因此说到元素位置，必须首先搞清楚是使用文档坐标还是视口坐标。通常情况下，要实现这两种坐标系的转换，都必须加上或减去滚动位移（scroll offset）。客户端 JavaScript 更多地会使用视口坐标。</p>
<p>另外，在使用 CSS 定位时：</p>
<ul>
<li>对于 <code>position: fixed</code>：top 和 left属性相对于视口坐标来解释</li>
<li>对于 <code>position: relative</code>：top 和 left 属性相对于该元素原来的位置来解释</li>
<li>对于 <code>position: absolute</code>：top 和 left 属性相对于最近的、使用定位的祖先元素的位置来解释</li>
</ul>
<p>一个 CSS 像素（也就是客户端 JavaScript 中的像素）​实际上可能相当于多个设备像素。Window 对象的 devicePixelRatio 属性表示多少设备像素对应一个软件像素，例如如果该值为 2，则意味着每个软件像素实际上是一个 <code>2×2</code> 硬件像素的网格。</p>
<h3 id="查询元素的几何大小"><a href="#查询元素的几何大小" class="headerlink" title="查询元素的几何大小"></a>查询元素的几何大小</h3><p>调用 <code>getBoundingClientRect()</code> 方法可以确定元素的大小（包括 CSS 边框和内边距，不包括外边距）和位置（在视口坐标中）​。</p>
<ul>
<li>对于块级元素，它在浏览器的布局中始终是矩形</li>
<li>行内元素则可能跨行，因此可能包含多个矩形。如果向查询行内元素的每个单独矩形，可以调用 <code>getClientRects()</code> 方法</li>
</ul>
<h3 id="确定位于某一点的元素"><a href="#确定位于某一点的元素" class="headerlink" title="确定位于某一点的元素"></a>确定位于某一点的元素</h3><p>有时候想确定在视口中某个给定位置上的是哪个元素，为此可以使用 Document 对象的 <code>elementFromPoint()</code> 方法。调用这个方法并传入一个点的 x 和 y 坐标（视口坐标，而非文档坐标），<code>elementFromPoint()</code> 返回一个位于指定位置的 Element 对象。</p>
<h3 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h3><p>Window 对象的 <code>scrollTo()</code> 方法接收一个点的 x 和 y 坐标（文档坐标）​，并将其设置为滚动位移。也就是说，这个方法会滚动窗口，从而让指定的点位于视口的左上角。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滚动浏览器，让文档最底部的页面显示出来</span></span><br><span class="line"><span class="keyword">let</span> documentHeight = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">offsetHeight</span>;</span><br><span class="line"><span class="keyword">let</span> viewportHeight = <span class="variable language_">window</span>.<span class="property">innerHeight</span>;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>, documentHeight - viewportHeight);</span><br></pre></td></tr></table></figure>

<p>Window 对象的 scrollBy() 方法与 scrollTo() 类似，但它的参数是个相对值，会加在当前滚动位置之上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123; <span class="title function_">scrollBy</span>(<span class="number">0</span>, <span class="number">50</span>); &#125;, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>

<p>如果想让 <code>scrollTo()</code> 和 <code>scrollBy()</code> 平滑滚动，需要传入一个对象，而不是两个数值，对象中需要设置<code>behavior: &quot;smooth&quot;</code> 属性。</p>
<p>可以在某个 HTML 元素上调用 <code>scrollIntoView()</code> 方法，这个方法保证该 HTML 元素在视口中可见。</p>
<h3 id="视口大小、内容大小和滚动位置"><a href="#视口大小、内容大小和滚动位置" class="headerlink" title="视口大小、内容大小和滚动位置"></a>视口大小、内容大小和滚动位置</h3><p>浏览器窗口和一些 HTML 元素可以显示滚动的内容。在这种情况下，我们有时候需要知道视口大小、内容大小和视口中内容的滚动位移：</p>
<ul>
<li>对浏览器窗口而言，视口大小可以通过 <code>window.innerWidth</code> 和 <code>window.innerHeight</code> 属性获得</li>
<li>文档的整体大小与 <code>&lt;html&gt;</code> 元素，即 <code>document.documentElement</code> 的大小相同，要获得文档的宽度和高度：<ul>
<li>可以使用 <code>document.documentElement</code> 的 <code>getBoundingClientRect()</code> 方法</li>
<li>也可以使用 <code>document.documentElement</code> 的 <code>offsetWidth</code> 和 <code>offsetHeight</code> 属性</li>
</ul>
</li>
<li>文档在视口中的滚动位移可以通过 <code>window.scrollX</code> 和 <code>window.scrollY</code> 获得，这两个属性都是只读的，不能通过设置它们的值来滚动文档</li>
</ul>
<p>对于元素来说，问题稍微复杂，每个 Element 对象都定义了三组属性：</p>
<ul>
<li><p>元素的 <code>offsetWidth</code> 和 <code>offsetHeight</code> 属性返回它们在屏幕上的 CSS 像素大小。这个大小包含元素边框和内边距，但不包含外边距。元素的 <code>offsetLeft</code> 和 <code>offsetTop</code> 属性返回元素的 x 和 y 坐标。对很多元素来说，这两个值都是文档坐标，但对定位元素的后代或者另一些元素（如表格单元）来说，这两个值是相对于祖先元素而非文档的坐标。而 <code>offsetParent</code> 属性保存着前述坐标值相对于哪个元素。这一组属性都是只读的。</p>
</li>
<li><p>元素的 <code>clientWidth</code> 和 <code>clientHeight</code> 属性与 <code>offsetWidth</code> 和 <code>offsetHeight</code> 属性类似，只是它们不包含元素边框，只包含内容区及内边距。<code>clientLeft</code> 和 <code>clientTop</code> 属性没有多大用处，它们是元素内边距外沿到边框外沿的水平和垂直距离</p>
</li>
<li><p>元素的 <code>scrollWidth</code> 和 <code>scrollHeight</code> 属性是元素内容区大小加上元素内边距，再加上溢出内容的大小。<code>scrollLeft</code> 和 <code>scrollTop</code> 是元素内容在元素视口中的滚动位移，而且这两个属性是可写属性，因此可以通过设置它们的值来滚动元素中的内容</p>
</li>
</ul>
<h2 id="Web-组件"><a href="#Web-组件" class="headerlink" title="Web 组件"></a>Web 组件</h2><p>HTML 是一种文档标记语言，为此也定义了丰富的标签。HTML已经变成Web应用描述用户界面的语言，但 <code>&lt;input&gt;</code> 和 <code>&lt;button&gt;</code> 等简单的 HTML 标签并不能满足现代 UI 设计的需要。今天的多数 Web 应用都不是用 <code>原始的 HTML</code> 写的。相反，很多 Web 开发者使用 React、Angular 等框架，这些框架支持创建可重用的用户界面组件。</p>
<p><strong>Web 组件是浏览器原生支持的替代这些框架的特性</strong>，主要涉及相对比较新的三个 Web 标准。这些 Web 标准允许 JavaScript 使用新标签扩展 HTML，扩展后的标签就是自成一体的、可重用的 UI 组件。</p>
<h3 id="使用-Web-组件"><a href="#使用-Web-组件" class="headerlink" title="使用 Web 组件"></a>使用 Web 组件</h3><p>Web 组件是在 JavaScript 中定义的，因此要在 HTML 中使用 Web 组件，需要包含定义该组件的 JavaScript 文件。Web 组件经常以 JavaScript 模块形式写成：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span> src=<span class="string">&quot;components/search-box.js&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>Web 组件要定义自己的 HTML 标签名，但有一个重要的限制就是标签名必须包含一个连字符（这意味着未来的 HTML 版本可以增加没有连字符的新标签，而这些标签不会跟任何人的 Web 组件冲突）​。要使用 Web 组件，只要像下面这样在 HTML 文件中使用其标签即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;search-box placeholder=<span class="string">&quot;Search...&quot;</span>&gt;&lt;/search-box&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>Web 组件可以像常规 HTML 标签一样具有属性</li>
<li>Web 组件不能使用自关闭标签定义，</li>
<li>与常规 HTML 元素类似，有的 Web 组件需要子组件，而有的 Web 组件不需要（也不显示）子组件</li>
<li>还有的 Web 组件可选地接收有标识的子组件，这些子组件会出现在命名的 <code>插槽</code>（slot）中</li>
</ul>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">search-box</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/search-icon.png&quot;</span> <span class="attr">slot</span>=<span class="string">&quot;left&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/cancel-icon.png&quot;</span> <span class="attr">slot</span>=<span class="string">&quot;right&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">search-box</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>还有一点需要注意，Web 组件经常以 JavaScript module 的形式引入，其自带 defer 属性，会在文档内容解析之后加载。因此浏览器会在运行 Web 组件定义代码之前，就要解析该 Web 组件所对应的自定义标签。浏览器中的 HTML 解析器很灵活，对自己不理解的输入非常宽容。当在 Web 组件还没有定义就遇到其标签时，浏览器会向 DOM 树中添加一个通用的 HTMLElement，即便它们不知道要对它做什么。之后，当自定义元素有定义之后，这个通用元素会被 <code>升级</code>​，从而具备预期的外观和行为。</p>
<p>如果 Web 组件包含子元素，那么在组件有定义之前它们可能会被不适当地显示出来。可以使用下面的 CSS 将 Web 组件隐藏到它们有定义为止：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">search-box<span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:defined</span>) &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  diplay: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与常规 HTML 元素一样，Web 组件可以在 JavaScript 中使用。一般来说，只有在定义这个组件的模块运行之后这样做才有意义。</p>
<p>知道了如何使用 Web 组件，接下来将介绍用于实现 Web 组件的三个浏览器特性。在这之前先介绍一些 <code>DocumentFragment</code>。DocumentFragment 也是一种 Node 类型，可以临时充当一组同辈节点的父节点，方便将这些同辈节点作为一个单元来使用：</p>
<ul>
<li>可以使用 <code>document.createDocumentFragment()</code> 来创建 DocumentFragment 节点</li>
<li>创建 DocumentFragment 节点后，就可以像使用 Element 一样，通过 append() 为它添加内容</li>
<li>DocumentFragment 与 Element 的区别在于它没有父节点，而且当你向文档中插入 DocumentFragment 节点时，DocumentFragment 本身并不会被插入，实际上插入的是它的子节点</li>
</ul>
<h3 id="HTML-模版"><a href="#HTML-模版" class="headerlink" title="HTML 模版"></a>HTML 模版</h3><p>通过 HTML 的 <code>&lt;template&gt;</code> 确实可以对网页中频繁使用的组件进行优化。<code>&lt;template&gt;</code> 标签及其子元素永远不会被浏览器渲染，只能在使用 JavaScript 的网页中使用。这个标签背后的思想是，当网页包含多个重复的基本 HTML 结构时（比如表格行或 Web 组件的内部实现），就可以使用 <code>&lt;template&gt;</code> 定义一次该结构，然后通过 JavaScript 按照需要任意重复使用该结构。</p>
<ul>
<li>在 JavaScript 中，<code>&lt;template&gt;</code> 标签对应的是一个 HTMLTemplateElement 对象</li>
<li>它只定义了一个 content 属性，而这个属性的值是包含 <code>&lt;template&gt;</code> 所有子节点的 DocumentFragment</li>
<li>也可以在 JavaScript 代码中创建一个模板，通过 <code>innerHTML</code> 创建其子节点，然后再按照需要克隆任意多个副本</li>
</ul>
<h3 id="自定义元素"><a href="#自定义元素" class="headerlink" title="自定义元素"></a>自定义元素</h3><p>实现 Web 的第二个浏览器特性是 <code>自定义元素</code>​，即可以把一个 HTML 标签与一个 JavaScript 类关联起来，然后文档中出现的这个标签就会在 DOM 树中转换为相应类的实例。</p>
<ul>
<li>创建自定义元素需要使用 <code>customElements.define()</code> 方法，它以标签名作为第一个参数（记住这个标签名必须包含一个连字符）​，以一个 <code>HTMLElement的子类</code> 作为其第二个参数</li>
<li>文档中具有该标签名的任何元素都会被 <code>升级</code> 为这个类的一个新实例</li>
<li>浏览器会自动调用自定义元素类的特定 <code>生命期方法</code>：<ul>
<li>当自定义元素被插入文档时，会调用 <code>connectedCallback()</code> 方法，可以通过该方法执行初始化</li>
<li>还有一个 <code>disconnectedCallback()</code> 方法，会在自定义元素从文档中被移除时调用，但用得不多</li>
</ul>
</li>
<li>如果自定义元素类定义了静态的 observedAttributes 属性，其值为一个属性名的数组。当在自定义元素的实例上设置了任意的命名属性，浏览器就会调用 <code>attributeChangedCallback()</code> 方法，这个回调可以根据属性值的变化采取必要的步骤以更新组件</li>
<li>自定义元素类也可以按照需要定义其他属性和方法。通常，它们都会定义设置方法和获取方法，让元素的属性可以暴露为 JavaScript 属性</li>
</ul>
<p>如下是一个示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">customElements.<span class="title function_">define</span>(<span class="string">&#x27;inline-circle&#x27;</span>, <span class="keyword">class</span> <span class="title class_">InlineCircle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;</span><br><span class="line">    <span class="title function_">connectedCallback</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;inline-block&#x27;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">borderRadius</span> = <span class="string">&#x27;50%&#x27;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">border</span> = <span class="string">&#x27;solid black 1px&#x27;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">&#x27;translateY(10%)&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">width</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&quot;0.8em&quot;</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&quot;0.8em&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">get</span> <span class="title function_">observedAttributes</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;diameter&#x27;</span>, <span class="string">&#x27;color&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">attributeChangedCallback</span>(<span class="params">name, oldValue, newValue</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (name === <span class="string">&#x27;diameter&#x27;</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">width</span> = newValue;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">height</span> = newValue;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name === <span class="string">&#x27;color&#x27;</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = newValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">diameter</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getAttribute</span>(<span class="string">&#x27;diameter&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">diameter</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;diameter&#x27;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">color</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getAttribute</span>(<span class="string">&#x27;color&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">color</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;color&#x27;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="影子-DOM"><a href="#影子-DOM" class="headerlink" title="影子 DOM"></a>影子 DOM</h3><p>上述自定义元素并没有恰当地封装，例如设置其 diameter 或 color 属性会导致其 style 属性被修改，而对于一个真正的 HTML 元素，这并不是我们希望看到的行为。要把一个自定义元素转换为真正的 Web 组件，还需要使用一个强大的封装机制：影子 DOM（shadow DOM）。</p>
<p>影子 DOM 允许把一个 <code>影子根节点</code>（shadow root）附加给一个自定义元素，而后者被称为 <code>影子宿主</code>（shadow host）。影子宿主元素与所有 HTML 元素一样，随时可以作为包含后代元素和文本节点的正常 DOM 树的根。<code>影子根节点</code>则是另一个更私密的后代元素树的根，这些元素从影子根节点上生长出来，可以把它们当成一个迷你文档。</p>
<p><code>影子 DOM</code>中的 <code>影子</code> 指的是作为影子根节点后代的元素 <code>藏在影子里</code>。也就是说，这个子树并不属于常规 DOM 树，不会出现在它们宿主元素的 children 数组中，而且对 querySelector() 等常规 DOM 遍历方法也不可见。相对而言，影子宿主的常规、普通 DOM 子树有时候也被称为 <code>阳光DOM</code>（light DOM）。</p>
<p>影子 DOM 的关键特性是它所提供的封装。影子根节点的后代对常规 DOM 树而言是隐藏且独立的，几乎就像它们是在一个独立的文档中一样。</p>
<ul>
<li><p>影子 DOM 中的元素对 querySelectorAll() 等常规 DOM 方法是不可见的。</p>
<ul>
<li>在创建影子根节点并将其附加于影子宿主时，可以指定其模式是 <code>开放</code>（open）还是 <code>关闭</code>（closed）</li>
<li>关闭的影子根节点将被完全封闭，不可访问</li>
<li>对于开发模式，影子宿主会有一个 shadowRoot 属性，如果需要，JavaScript 可以通过这个属性来访问影子根节点的元素</li>
</ul>
</li>
<li><p>在影子根节点之下定义的样式对该子树是私有的，永远不会影响外部的阳光 DOM 元素。类似地，应用给影子宿主元素的阳光 DOM 样式也不会影响影子根节点。在大多数情况下，阳光 DOM 的样式与影子 DOM 的样式是完全独立的（影子 DOM 中的元素会从阳光 DOM 继承字体大小和背景颜色等）。可以像这样限定 CSS 的范围或许是影子 DOM 最重要的特性</p>
</li>
<li><p>影子 DOM 中发生的某些事件（如 <code>load</code>​）会被封闭在影子 DOM 中。另外一些事件，像 focus、mouse 和键盘事件则会向上冒泡、穿透影子 DOM。当一个发源于影子 DOM 内的事件跨过了边界开始向阳光 DOM 传播时，其 target 属性会变成影子宿主元素，就好像事件直接起源于该元素一样</p>
</li>
</ul>
<p>作为影子宿主的 HTML 元素有两个后代子树。一个是 <code>children[​</code> ]数组，即宿主元素常规的阳光 DOM 后代；另一个则是影子根节点及其后代。它的工作原理如下：</p>
<ul>
<li>影子根节点的后代始终显示在影子宿主内</li>
<li>如果这些后代中包含一个 <code>&lt;slot&gt;</code> 元素，那么宿主元素的常规阳光 DOM 子元素会像它们本来就是该 <code>&lt;slot&gt;</code> 的子元素一样显示，替代该插槽中的任何影子 DOM 元素。</li>
<li>如果影子 DOM 不包含 <code>&lt;slot&gt;</code>，那么宿主的阳光 DOM 内容永远不会显示</li>
<li>如果影子 DOM 有一个 <code>&lt;slot&gt;</code>，但影子宿主没有阳光 DOM 子元素，那么该插槽的影子 DOM 内容作为默认内容显示</li>
<li>当阳光 DOM 内容显示在影子 DOM 插槽中时，我们说那些元素 <code>已分配</code>。此时要注意：那些元素实际上并未变成影子 DOM 的一部分。使用 querySelector() 依旧可以查询它们，它们仍然作为宿主元素的子元素或后代出现在阳光 DOM 中</li>
<li>如果影子 DOM 定义了多个 <code>&lt;slot&gt;</code>，且通过 name 属性为它们命名，那么影子宿主的阳光 DOM 后代可以通过<code>slot=&quot;slotname&quot;</code> 属性指定自己想出现在哪个插槽中</li>
</ul>
<p>要把一个阳光 DOM 元素转换为影子宿主，只要调用其 <code>attachShadow()</code> 方法，传入 <code>&#123;mode:&quot;open&quot;&#125;</code> 这个唯一的参数即可。这个方法返回一个影子根节点对象，同时也将该对象设置为这个宿主的 shadowRoot 属性的值。这个影子根节点对象是一个 DocumentFragment，可以使用 DOM 方法为它添加内容，也可以直接将其 innerHTML 属性设置为一个 HTML 字符串。</p>
<p>如果你的 Web 组件想知道影子 DOM（slot）中的阳光 DOM 内容什么时候变化，那它可以直接在该 <code>&lt;slot&gt;</code> 元素上注册一个 <code>slotchanged</code> 事件。</p>
<p>如下是自定义 Web 组件的一个示例，它实现了一个搜索框：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SearchBox</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">attachShadow</span>(&#123; <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span> &#125;);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">shadowRoot</span>.<span class="title function_">append</span>(<span class="title class_">SearchBox</span>.<span class="property">template</span>.<span class="property">content</span>.<span class="title function_">cloneNode</span>(<span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">input</span> = <span class="variable language_">this</span>.<span class="property">shadowRoot</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#input&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> leftSlot = <span class="variable language_">this</span>.<span class="property">shadowRoot</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;slot[name=&quot;left&quot;]&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> rightSlot = <span class="variable language_">this</span>.<span class="property">shadowRoot</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;slot[name=&quot;right&quot;]&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">input</span>.<span class="property">onfocus</span> = <span class="function">() =&gt;</span> &#123; <span class="variable language_">this</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;focused&#x27;</span>, <span class="string">&#x27;&#x27;</span>); &#125;;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">input</span>.<span class="property">onblur</span> = <span class="function">() =&gt;</span> &#123; <span class="variable language_">this</span>.<span class="title function_">removeAttribute</span>(<span class="string">&#x27;focused&#x27;</span>); &#125;;</span><br><span class="line"></span><br><span class="line">        leftSlot.<span class="property">onclick</span> = <span class="variable language_">this</span>.<span class="property">input</span>.<span class="property">onchange</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">            event.<span class="title function_">stopPropagation</span>();</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">disabled</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">dispatchEvent</span>(<span class="keyword">new</span> <span class="title class_">CustomEvent</span>(<span class="string">&#x27;search&#x27;</span>, &#123;</span><br><span class="line">                <span class="attr">detail</span>: <span class="variable language_">this</span>.<span class="property">input</span>.<span class="property">value</span></span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rightSlot.<span class="property">onclick</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">            event.<span class="title function_">stopPropagation</span>();</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">disabled</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">dispatchEvent</span>(<span class="keyword">new</span> <span class="title class_">CustomEvent</span>(<span class="string">&#x27;clear&#x27;</span>, &#123;<span class="attr">cancelable</span>: <span class="literal">true</span>&#125;));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!event.<span class="property">defaultPrevented</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">input</span>.<span class="property">value</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">attributeChangedCallback</span>(<span class="params">name, oldValue, newValue</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (name === <span class="string">&#x27;disabled&#x27;</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">input</span>.<span class="property">disabled</span> = newValue !== <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name === <span class="string">&quot;placeholder&quot;</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">input</span>.<span class="property">placeholder</span> = newValue;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name === <span class="string">&quot;size&quot;</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">input</span>.<span class="property">size</span> = newValue;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">input</span>.<span class="property">value</span> = newValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">placeholder</span>() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getAttribute</span>(<span class="string">&#x27;placeholder&#x27;</span>); &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">size</span>() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getAttribute</span>(<span class="string">&#x27;size&#x27;</span>); &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">value</span>() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getAttribute</span>(<span class="string">&#x27;value&#x27;</span>); &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">disabled</span>() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;disabled&#x27;</span>); &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">hidden</span>() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;hidden&#x27;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">placeholder</span>(<span class="params">value</span>) &#123; <span class="variable language_">this</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;placeholder&#x27;</span>, value); &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">size</span>(<span class="params">value</span>) &#123; <span class="variable language_">this</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;size&#x27;</span>, value); &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">value</span>) &#123; <span class="variable language_">this</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;value&#x27;</span>, value); &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">disabled</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        value ? <span class="variable language_">this</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;disabled&#x27;</span>, <span class="string">&#x27;&#x27;</span>) : <span class="variable language_">this</span>.<span class="title function_">removeAttribute</span>(<span class="string">&#x27;disabled&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">hidden</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        value ? <span class="variable language_">this</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;hidden&#x27;</span>, <span class="string">&#x27;&#x27;</span>) : <span class="variable language_">this</span>.<span class="title function_">removeAttribute</span>(<span class="string">&#x27;hidden&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SearchBox</span>.<span class="property">obsevedAttributes</span> = [<span class="string">&#x27;placeholder&#x27;</span>, <span class="string">&#x27;size&#x27;</span>, <span class="string">&#x27;value&#x27;</span>, <span class="string">&#x27;disabled&#x27;</span>];</span><br><span class="line"><span class="title class_">SearchBox</span>.<span class="property">template</span> = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;template&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">SearchBox</span>.<span class="property">template</span>.<span class="property">innerHTML</span> = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;style&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">:host &#123;</span></span><br><span class="line"><span class="string">    display: inline-block;</span></span><br><span class="line"><span class="string">    border: solid black 1px;</span></span><br><span class="line"><span class="string">    border-radius: 5px;</span></span><br><span class="line"><span class="string">    padding: 4px 6px;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">:host([hidden]) &#123;</span></span><br><span class="line"><span class="string">    display: none;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">:host([disabled]) &#123;</span></span><br><span class="line"><span class="string">    opacity: 0.5;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">:host([focused]) &#123;</span></span><br><span class="line"><span class="string">    box-show: 0 0 0 2px #6AE;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">input &#123;</span></span><br><span class="line"><span class="string">    border-width: 0;</span></span><br><span class="line"><span class="string">    outline: none;</span></span><br><span class="line"><span class="string">    font: inherit;</span></span><br><span class="line"><span class="string">    background: inherit;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">slot &#123;</span></span><br><span class="line"><span class="string">    cursor: default;</span></span><br><span class="line"><span class="string">    user-slect: none;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/style&gt;</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;slot name=&quot;left&quot;&gt;\u&#123;1f50d&#125;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    &lt;input type=&quot;text&quot; id=&quot;input&quot; /&gt;</span></span><br><span class="line"><span class="string">    &lt;slot name=&quot;right&quot;&gt;\u&#123;2573&#125;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line">customElements.<span class="title function_">define</span>(<span class="string">&#x27;search-box&#x27;</span>, <span class="title class_">SearchBox</span>);</span><br></pre></td></tr></table></figure>

<h2 id="可伸缩矢量图形"><a href="#可伸缩矢量图形" class="headerlink" title="可伸缩矢量图形"></a>可伸缩矢量图形</h2><p>SVG（Scalable Vector Graphics，可伸缩矢量图形）是一种图片格式。名字中的 <code>矢量</code> 代表着它与 GIF、JPEG、PNG 等指定像素值矩阵的光栅（raster）图片格式有着根本的不同。SVG 图片是对所期望绘制图形的精确的、分辨率无关的描述。SVG 图片是在文本文件中通过 XML 标记语言描述的。</p>
<p>在浏览器中有几种方式使用 SVG：</p>
<ul>
<li>可以在常规的 HTML <code>&lt;img&gt;</code> 标签中使用 <code>.svg</code> 图片文件</li>
<li>因为基于 XML 的 SVG 格式与 HTML 很类似，所以可以直接把 SVG 标签嵌入在 HTML 文档中</li>
<li>可以使用 <code>DOM API</code> 动态创建 SVG 元素，按需生成图片</li>
</ul>
<h3 id="在-HTML-中使用-SVG"><a href="#在-HTML-中使用-SVG" class="headerlink" title="在 HTML 中使用 SVG"></a>在 HTML 中使用 SVG</h3><p>SVG 图片当然可以使用 HTML 的 <code>&lt;img&gt;</code> 标签来显示，但也可以直接在 HTML 嵌入 SVG。而且在嵌入 SVG 后，甚至可以使用 CSS 样式表来指定字体、颜色和线宽：</p>
<ul>
<li>可以在 HTML 中直接内嵌 <code>&lt;svg&gt;</code> 标签</li>
<li><code>&lt;svg&gt;</code> 标签的后代并非标准的 HTML 标签，SVG 有很多其他标签，可以在需要时再去学习</li>
</ul>
<h3 id="编程操作-SVG"><a href="#编程操作-SVG" class="headerlink" title="编程操作 SVG"></a>编程操作 SVG</h3><p>直接在 HTML 文件中嵌入 SVG（而不是使用静态 <code>&lt;img&gt;</code> 标签）的一个原因，就是这样可以使用 <code>DOM API</code> 操作 SVG 图片。除了使用脚本简单地操作嵌入在 HTML 文档中的 SVG 图片，还可以通过 JavaScript 来创建SVG图片，这在可视化动态加载的数据时很有用。</p>
<p>尽管可以把 SVG 标签包含在 HTML 文档中，严格来讲它们仍然是 XML 标签，不是 HTML 标签。如果想通过 JavaScript DOM API 创建 SVG 元素，需要使用 <code>createElementNS</code> 方法，它的第一个参数是 XML 命名空间文字串。对 SVG 而言，命名空间是文字串 <code>http://www.w3.org/2000/svg</code>。</p>
<h2 id="lt-canvas-gt-与图形"><a href="#lt-canvas-gt-与图形" class="headerlink" title="&lt;canvas&gt; 与图形"></a><code>&lt;canvas&gt;</code> 与图形</h2><p>在 HTML 文档中，<code>&lt;canvas&gt;</code> 元素本身并不可见，它只是创建了一个绘图表面并向客户端 JavaScript 暴露了强大的绘图 API。<code>&lt;canvas&gt;</code> API 与 SVG 的主要区别在于使用画布（canvas）绘图要调用方法，而使用 SVG 创建图形则需要构建 XML 元素树。画布绘图 API 是基于 JavaScript 的，而且相对比较简洁（不像 SVG 语法那么复杂）。</p>
<p>大多数画布绘图 API 都没有定义在 <code>&lt;canvas&gt;</code> 元素上，而是定义在通过画布的 <code>getContext()</code> 方法获得的 <code>绘图上下文</code> 上：</p>
<ul>
<li>在调用 <code>getContext()</code> 时传入 <code>webgl</code> 也可以获取一个 3D 图形上下文，并使用 <code>WebGL API</code> 来绘制 3D 图形。<code>WebGL API</code> 是一套庞大、复杂、低级的 JavaScript API，开发者通过它可以访问 GPU、写自定义的着色器，以及执行其他非常强大的图形操作</li>
<li>调用 <code>getContext()</code> 时传入 <code>2d</code> 可以得到一个 <code>Canvas RenderingContext2D</code> 对象，使用它能够在画布上绘制二维图形</li>
</ul>
<p>如下是一个示例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a red square: <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;square&quot;</span> <span class="attr">width</span>=<span class="string">10</span> <span class="attr">height</span>=<span class="string">10</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a blue circle: <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;circle&quot;</span> <span class="attr">width</span>=<span class="string">10</span> <span class="attr">height</span>=<span class="string">10</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> canvas = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#square&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> context = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    context.<span class="property">fillStyle</span> = <span class="string">&#x27;red&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    context.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">10</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    canvas = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#circle&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    context = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    context.<span class="title function_">beginPath</span>();</span></span><br><span class="line"><span class="language-javascript">    context.<span class="title function_">arc</span>(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="number">2</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript">    context.<span class="property">fillStyle</span> = <span class="string">&#x27;#00f&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    context.<span class="title function_">fill</span>();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="路径与多边形"><a href="#路径与多边形" class="headerlink" title="路径与多边形"></a>路径与多边形</h3><p>要在画布上画线或者填充由这些线包围的区域，首先需要定义一个路径：</p>
<ul>
<li>路径是一个或多个子路径的序列</li>
<li>子路径则是两个或多个通过线段（或曲线段）连接起来的点的序列</li>
<li>开始新路径要调用 <code>beginPath()</code> 方法</li>
<li>开始定义子路径要调用 <code>moveTo()</code> 方法，在通过 <code>moveTo()</code> 建立起子路径的起点后，可以调用 <code>lineTo()</code> 将该点连接到一个新的点</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c.<span class="title function_">beginPath</span>();</span><br><span class="line">c.<span class="title function_">moveTo</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">c.<span class="title function_">lineTo</span>(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">c.<span class="title function_">lineTo</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure>

<p>定义路径并不会在画布上绘制任何东西：</p>
<ul>
<li>要绘制（或描画​）路径中的两条线段，必须调用 <code>stroke()</code> 方法</li>
<li>而要填充这些线段定义的区域，则要调用 <code>fill()</code> 方法</li>
<li><code>fill()</code> 方法在填充开放路径时，就好像有一条直线连接了子路径的终点与起点一样</li>
<li>调用 <code>closePath()</code> 可以把子路径的终点连接到起点，对路径进行闭合</li>
<li><code>stroke()</code> 和 <code>fill()</code> 这两个方法都会修改当前路径，在操作完一条路径后，如果想开始另一条路径，必须调用 beginPath()</li>
</ul>
<h3 id="画布大小与坐标"><a href="#画布大小与坐标" class="headerlink" title="画布大小与坐标"></a>画布大小与坐标</h3><p>在 HTML 中通过 <code>&lt;canvas&gt;</code> 的 <code>width</code> 和 <code>height</code> 属性，或者在 JavaScript 中通过画布对象的 width 和 height 属性可以指定画布的大小。画布坐标系的默认原点在画布左上角的 <code>(0,0)</code> 点。x 坐标向右增大，y 坐标向下增大。画布中的点可以使用浮点值来指定。</p>
<ul>
<li>要修改画布大小必须完全重置画布，设置画布的 width 或 height 属性，都会清除画布，擦掉当前路径，重置所有图形属性至其初始状态</li>
<li>在 HTML 中指定 <code>&lt;canvas&gt;</code> 的 width 和 height 属性会确定画布的实际像素数</li>
<li>为优化图片质量，不要在 HTML 中使用 width 和 height 属性设置画布的屏幕大小。而要使用 CSS 的样式属性 width 和 height 来设置画布在屏幕上的预期大小。然后在通过 JavaScript 开始绘制前，再将画布对象的 width 和 height 属性设置为 CSS 像素数乘以 window.devicePixelRatio</li>
</ul>
<h3 id="图形属性"><a href="#图形属性" class="headerlink" title="图形属性"></a>图形属性</h3><p>上下文对象上的一些属性（和方法）都会影响画布的图形状态：</p>
<ul>
<li>lineWidth 属性指定 <code>stroke()</code> 绘制的线条有多宽，默认值为 1</li>
<li>在绘制超过两像素宽的线条时，lineCap 和 lineJoin 属性会显著影响路径两端或者两条路径交点的样式</li>
<li><code>stroke()</code> 方法既可以画虚线、点线，也可以画实线。而画布的图形状态中也有一组数字可以用作 <code>虚线模式</code>​，虚线模式要通过 <code>setLineDash()</code> 和 <code>getLineDash()</code> 方法而不是一个属性来设置和获取</li>
<li>fillStyle 和 strokeStyle 属性指定如何填充和描绘路径。可以以实色、渐变色、图片进行填充</li>
<li>font 属性指定 <code>fillText()</code> 和 <code>strokeText()</code> 方法在绘制文本时使用的字体，这个属性的值应该是一个字符串，语法与 CSS 的 font 属性相同。textAlign 属性指定文本的水平对齐方式，textBaseline 属性指定文本相对于 Y 坐标如何垂直对齐</li>
<li>上下文对象有 4 个属性控制阴影的绘制：shadowColor 属性指定阴影颜色，shadowOffsetX 和 shadowOffsetY 属性指定阴影的 X 轴和 Y 轴偏移量，shadowBlur 属性指定阴影边缘的模糊程度</li>
<li>如果想用半透明色描绘或填充路径，可以使用类似 <code>rbga(...)</code> 这样支持半透明值的 CSS 颜色语法设置 <code>strokeStyle</code> 或 <code>fillStyle</code></li>
<li>通过设置 <code>globalCompositeOperation</code> 属性可以指定合成像素的方式</li>
</ul>
<p>每个 <code>&lt;canvas&gt;</code> 元素只有一个上下文对象，每次调用 <code>getContext()</code> 返回的都是同一个 <code>CanvasRenderingContext2D</code> 对象。<code>save()</code> 方法把当前的图形状态推到一个保存的状态栈中。<code>restore()</code> 方法从该栈中弹出状态，恢复最近一次保存的状态。</p>
<h3 id="画布绘制操作"><a href="#画布绘制操作" class="headerlink" title="画布绘制操作"></a>画布绘制操作</h3><p>之前介绍的 <code>beginPath()</code>、<code>moveTo()</code>、<code>lineTo()</code> 等方法都是基本的画布方法，可以用来定义、填充、绘制线条和多边形。除此之外，Canvas API 还提供其他绘制方法。</p>
<ul>
<li>CanvasRenderingContext2D 定义了 4 个绘制矩形的方法，分别是 <code>fillRect()</code>、<code>strokeRect()</code>、<code>clearRect()</code> 和 <code>rect()</code></li>
<li>CanvasRenderingContext2D 对象定义了一些方法，用于将一个新点添加到子路径，然后用一条曲线来连接当前点与新点，包括 <code>arc()</code>、<code>ellipse()</code>、<code>arcTo()</code>、<code>bezierCurveTo()</code> 和 <code>quadraticCurveTo()</code> 等</li>
<li>要在画布中绘制文本，一般都使用 fillText() 方法。对于大型文本的特效，可以使用 strokeText() 绘制个别字形的轮廓</li>
<li><code>drawImage()</code> 方法会将一张源图片（或源图片中某个矩形区域）的像素复制到画布上，并根据需要缩放和旋转图像的像素</li>
</ul>
<h3 id="坐标系变换"><a href="#坐标系变换" class="headerlink" title="坐标系变换"></a>坐标系变换</h3><p>除了默认坐标系，每个画布的图形状态中都有一个 <code>当前变换矩阵</code>​。这个矩阵定义了画布的当前坐标系。在多数画布操作中，当你指定一个点的坐标时，它表示的是当前坐标系中的一个点，而不是默认坐标系中的一个点。当前变换矩阵用于将你指定的坐标转换为默认坐标系中等价的坐标。</p>
<p>使用 <code>setTransform()</code> 方法可以直接设置画布的变换矩阵，但通常还是使用一系列平移、旋转和缩放操作来变换坐标系更简单。</p>
<ul>
<li><code>translate()</code> 方法简单地向左、右、上、下移动坐标系原点</li>
<li><code>rotate()</code> 方法按照指定的角度旋转坐标轴</li>
<li><code>scale()</code> 方法沿 x 轴或 y 轴拉伸或压缩距离</li>
</ul>
<p>通过调用 <code>transform()</code> 可以对当前坐标系应用任意变换，<code>setTransform()</code> 方法与 <code>transform()</code> 接收的参数一样，但它不变换当前坐标系，而是忽略当前坐标系，变换默认坐标系，并将结果作为新的当前坐标系。</p>
<h3 id="剪切"><a href="#剪切" class="headerlink" title="剪切"></a>剪切</h3><p>定义了路径之后，我们通常会调用 <code>stroke()</code> 或 <code>fill()</code>（或两者）​。但也可以调用 <code>clip()</code> 方法定义一个剪切区域。定义了剪切区域后，这个区域外部将不会被绘制。</p>
<h3 id="像素操作"><a href="#像素操作" class="headerlink" title="像素操作"></a>像素操作</h3><p>像素操作方法经常用于处理图片。<code>getImageData()</code> 方法返回一个 ImageData 对象，表示画布中某矩形区域中包含的原始像素。可以使用 <code>createImageData()</code> 创建空的 ImageData 对象。ImageData 对象中的像素是可写的，因此可以随意修改，然后再通过 <code>putImageData()</code> 把其中的像素复制到画布上。</p>
<h2 id="Audio-API"><a href="#Audio-API" class="headerlink" title="Audio API"></a>Audio API</h2><p>HTML的 <code>&lt;audio&gt;</code> 和 <code>&lt;video&gt;</code> 标签可以让我们在网页中轻松包含音频和视频。这两个元素有着重要的 API 和并不简单的用户界面：</p>
<ul>
<li>可以通过 <code>play()</code> 和 <code>pause()</code> 方法控制媒体播放</li>
<li>可以设置 volume 和 playbackRate 属性控制音量和播放速度</li>
<li>设置 currentTime 属性可以跳到媒体中特定的时间点</li>
</ul>
<h3 id="Audio-构造函数"><a href="#Audio-构造函数" class="headerlink" title="Audio 构造函数"></a>Audio 构造函数</h3><p>要在网页中包含音效，不一定要在HTML文档中包含 <code>&lt;audio&gt;</code> 标签。可以使用常规 DOM 方法 <code>document.createElement()</code> 或者直接使用 <code>Audio()</code> 构造函数动态创建 <code>&lt;audio&gt;</code> 元素。并且，要播放媒体也不一定要把创建的元素添加到文档中。只要调用它的 <code>play()</code> 方法即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> soundeffect = <span class="keyword">new</span> <span class="title class_">Audio</span>(<span class="string">&#x27;soundeffect.mp3&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  soundeffect.<span class="title function_">cloneNode</span>().<span class="title function_">play</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Web-Audio-API"><a href="#Web-Audio-API" class="headerlink" title="Web Audio API"></a>Web Audio API</h3><p>除了使用 Audio 元素播放录制的声音，浏览器也可以通过 <code>WebAudio API</code> 生成和播放合成音效。对于 WebAudio，要创建一组 AudioNode 对象，表示波形的来源、变换和目标，然后再将这些节点连接为一个网络以产生声音。</p>
<h2 id="位置、导航与历史"><a href="#位置、导航与历史" class="headerlink" title="位置、导航与历史"></a>位置、导航与历史</h2><p>Window 和 Document 对象的 location 属性引用的都是 Location 对象，该对象表示当前窗口显示文档的 URL，也提供了在窗口中加载新文档的 API。</p>
<p>Location 对象与 URL 对象非常相似，可以使用 protocol、hostname、port 和 path 访问当前文档 URL 的不同部分，href 属性以字符串形式返回整个 URL，hash 属性返回 URL 的 <code>片段标识符</code> 部分，search 属性返回 URL 中以问号开头的部分，通常是一些查询字符串。</p>
<p>浏览器也定义了 document.URL 属性，它是一个字符串，即当前文档的 URL。</p>
<h3 id="加载新文档"><a href="#加载新文档" class="headerlink" title="加载新文档"></a>加载新文档</h3><p>如果给 <code>window.location</code> 或 <code>document.location</code> 赋值一个字符串，则该字符串将被解释为一个 URL，且浏览器会加载它，从而用新文档替换当前文档：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">location</span> = <span class="string">&#x27;http://www.example.com&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>可以给 location 属性赋值相对 URL，浏览器会相对于当前 URL 解析它。简单的片段标识符也是一种特殊的 URL，但它不会导致浏览器加载新文档，只会把文档中 id 或 name 匹配该片段的元素滚动到浏览器窗口顶部。作为一个特例，片段标识符 <code>#top</code> 会让浏览器跳到文档顶部：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location = <span class="string">&quot;#top&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>Location 对象的个别属性是可写的，设置它们会改变 URL，也会导致浏览器加载新文档。给 Location 对象的 <code>assign()</code> 方法传入一个新字符串也可以加载新页面，效果等同于给 location 属性赋值。</p>
<p>Location 的 <code>replace()</code> 方法也接受一个字符串参数，字符串会被当作 URL 解析，并导致浏览器加载新页面，同时<code>replace()</code> 会在浏览器的历史记录中替换当前文档，即在浏览器历史记录中以新文档 URL 替代当前文档的 URL。</p>
<p>Location 对象也定义了 <code>reload()</code> 方法，调用该方法会让浏览器重新加载当前文档。</p>
<h3 id="浏览历史"><a href="#浏览历史" class="headerlink" title="浏览历史"></a>浏览历史</h3><p>Window 对象的 history 属性引用的是窗口的 History 对象。History 对象将窗口的浏览历史建模为文档和文档状态的列表。History 对象的 length 属性是浏览历史列表中元素的数量。但出于安全考虑，脚本不能访问存储的 URL。</p>
<p>History对象的 back() 和 forward() 方法就像浏览器的 <code>后退</code> 和 <code>前进</code> 按钮，可以让浏览器在浏览历史中后退或前进一步。另一个方法 <code>go()</code> 接收一个整数参数，可以在历史列表中前进（正整数）或后退（负整数）任意个页面。</p>
<p>如果窗口包含子窗口（如 <code>&lt;iframe&gt;</code> 元素）​，子窗口的浏览历史会按时间顺序与主窗口历史交替。</p>
<p>今天，Web 应用经常动态生成或加载内容，显示新应用状态而并不真正加载新文档。这样的应用必须自己管理历史记录，才能让用户直观地通过 <code>后退</code> 和 <code>前进</code> 按钮从应用的一个状态导航到另一个状态。</p>
<h3 id="使用-hashchange-事件管理历史"><a href="#使用-hashchange-事件管理历史" class="headerlink" title="使用 hashchange 事件管理历史"></a>使用 hashchange 事件管理历史</h3><p>第一种管理浏览历史的技术是使用 <code>location.hash</code> 和 <code>hashchange</code> 事件：</p>
<ul>
<li>location.hash 属性用于设置 URL 的片段标识符，通常用于指定要滚动到的文档区域的 ID。但 <code>location.hash</code> 不一定必须是元素 ID，也可以将它设置为任意字符串。只要不是某个元素碰巧有该字符串 ID，浏览器就不会在设置 hash 属性时滚动</li>
<li>设置 location.hash 属性会更新地址栏中显示的 URL，而且更重要的是，还会在浏览器历史列表中添加一条记录</li>
<li>只要文档的片段标识符改变，浏览器就会在 Window 对象上触发 <code>hashchange</code> 事件，显式设置 <code>location.hash</code> 也会触发 <code>hashchange</code> 事件</li>
</ul>
<p>因此，只要你可以为应用的每个可能的状态创建唯一的片段标识符，<code>“hashchange</code> 事件就能够在用户向后或向前导航浏览历史时给你发送通知：</p>
<ul>
<li>如果用户的交互会导致应用进入新状态，不要直接渲染新状态。而要先把新状态编码为一个字符串，并将 <code>location.hash</code> 设置为该字符串</li>
<li>在触发 <code>hashchange</code> 事件后，在事件处理程序将会显示该新状态</li>
<li>使用这种迂回技术可以保证新状态被插入浏览历史，因而 <code>后退</code> 和 <code>前进</code> 按钮继续有效</li>
</ul>
<h3 id="使用-pushState-管理历史"><a href="#使用-pushState-管理历史" class="headerlink" title="使用 pushState() 管理历史"></a>使用 pushState() 管理历史</h3><p>管理历史的第二种技术建立在 <code>history.pushState()</code> 方法和 <code>popstate 事件</code> 基础上的：</p>
<ul>
<li>当 Web 应用进入一个新状态时，它会调用 <code>history.pushState()</code>，向浏览器历史中添加一个表示该状态的对象</li>
<li>如果用户单击 <code>后退</code> 按钮，浏览器会触发携带该保存的状态对象的 <code>popstate</code> 事件，应用使用该对象重建其之前的状态</li>
<li>除了保存的状态对象，应用也可以为每个状态都保存一个 URL，这样可以方便用户将 URL 加入书签和分享应用内部状态的链接</li>
</ul>
<p>pushState() 的第一个参数是一个对象，包含恢复当前文档状态所需的全部状态信息，这个对象使用 HTML 的结构化克隆算法保存，第二个参数应该是与状态对应的标题字符串（绝大多数浏览器不支持，直接传空即可），第三个参数是一个可选的 URL，给每个状态都关联一个 URL 可以让用户收藏应用的内部状态。</p>
<p>除了 <code>pushState()</code> 方法，History 对象也定义了 <code>replaceState()</code>，它接收相同的参数，但会替换当前历史状态，而不是向浏览历史中添加新状态。当使用 <code>pushState()</code> 的应用首次加载时，一般最好调用 <code>replaceState()</code> 为应用的初始状态定义一个状态对象。</p>
<p>在用户使用 <code>后退</code> 或 <code>前进</code> 按钮导航到保存的历史状态时，浏览器会在 Window 对象上触发 <code>popstate</code> 事件。与之关联的事件对象有一个名为 state 的属性，其中包含当初你通过 <code>pushState()</code> 传入的状态对象的副本。</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>每次我们打开一个网页时，浏览器都会（使用HTTP或HTTPS协议）发送网络请求，请求 HTML 文档，也请求该文档依赖的图片、字体、脚本和样式表。除了根据用户操作发送网络请求，浏览器也暴露了相关的 JavaScript API。</p>
<h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><p>要发送简单的 HTTP 请求，使用 <code>fetch()</code> 只需三步：</p>
<ol>
<li>调用 <code>fetch()</code>，传入要获取内容的 URL</li>
<li>在 HTTP 响应开始到达时取得第 1 步异步返回的响应对象，然后调用这个响应对象的某个方法，读取响应体</li>
<li>取得第 2 步异步返回的响应体，按需要处理它</li>
</ol>
<p><code>fetch()</code> API 完全是基于期约的，因为涉及两个异步环节，所以使用 <code>fetch()</code> 时通常要写两个 <code>then()</code> 或两个 <code>await</code> 表达式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;api/users/current&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">currentUser</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">displayUserInfo</span>(currentUser);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">isServiceReady</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;api/service/status&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> body = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">  <span class="keyword">return</span> body === <span class="string">&quot;ready&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fetch()</code> API 取代了复杂且名字误导人的 <code>XMLHttpRequest</code> API（其实跟 XML 没什么关系）​。在一些遗留代码中也许还能看到 XHR（通常用这个简写）的身影，但在新代码中则完全没有必要使用它了。</p>
<ul>
<li>fetch() 返回的期约解决为一个 Response 对象。这个对象的 status 属性是 HTTP 状态码，另外，还存在一个更方便的 ok 属性：它在 status 为 200 或在 200 和 299 之间时是 true，在其他情况下是 false</li>
<li>当服务器开始发送响应时，fetch() 只要一收到 HTTP 状态码和响应头就会解决它的期约，但此时通常还没收到完整的响应体</li>
<li>Response 对象的 headers 属性是一个 Headers 对象。使用它的 has() 方法可以测试某个头部是否存在，使用它的 get() 方法可以取得某个头部的值，Headers 对象也是一个可迭代对象</li>
<li><code>fetch()</code> 只在自己根本联系不到服务器时才会拒绝自己返回的期约，因为这些情况对任何网络请求都可能发生，所以最好在任何 <code>fetch()</code> 调用后面都包含一个 <code>.catch()</code> 子句</li>
</ul>
<p>有时候，除了设置 URL 参数，还需要为 <code>fetch()</code> 请求设置一些头部。为此，可以使用两个参数版的 <code>fetch()</code>。与以前一样，第一个参数还是一个用于指定 URL 的字符串或 URL 对象。第二个参数用于提供额外选项，包括请求头部。另一种替代给 <code>fetch()</code> 传两个参数的方法是把同样的两个参数传给 <code>Request()</code> 构造函数，然后再将创建的 <code>Request</code> 对象传给 <code>fetch()</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> request = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="variable constant_">URL</span>, &#123;headers&#125;);</span><br><span class="line"><span class="title function_">fetch</span>(request).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> ...);</span><br></pre></td></tr></table></figure>

<p>除了 <code>json()</code> 和 <code>text()</code>，Response 对象还有以下几个方法来获取获取响应体：</p>
<ul>
<li><code>arrayBuffer()</code>：这个方法返回一个期约，解决为一个 ArrayBuffer。在响应包含二进制数据时可以使用这个方法</li>
<li><code>blob()</code>：这个方法返回一个期约，解决为一个 Blob 对象。Blob（Binary Large Object）在需要处理大量二进制数据的时候会用到。</li>
<li><code>formData()</code>：这个方法返回一个期约，解决为一个 FormData 对象。如果 Response 响应体是以 <code>multipart/form-data</code> 格式编码的，应该使用这个方法。这种编码格式常见于向服务器发送的 POST 请求中，在服务器响应中并不常见</li>
</ul>
<p>除了以某种形式返回完整响应体的异步响应方法，还可以流式访问响应体。在需要分块处理通过网络接收到的响应时可以采取这种方式：</p>
<ul>
<li>Response 对象的 body 属性是一个 <code>ReadableStream</code> 对象。</li>
<li>如果已经调用了 <code>text()</code> 或 <code>json()</code> 等读取、解析和返回响应体的方法，那么 <code>bodyUsed</code> 属性会变成 true，表示 body 流已经读完了</li>
<li>如果 bodyUsed 属性是 false，那就意味着该流尚未被读取。此时，可以在 <code>response.body</code> 上调用 <code>getReader()</code> 获取流读取器对象，然后通过这个读取器对象的 <code>read()</code> 方法异步从流中读取文本块</li>
<li>这个 read() 方法返回一个期约，解决为一个带有 done 和 value 属性的对象</li>
</ul>
<p>目前，在每个 <code>fetch()</code> 的例子中我们发送的都是 HTTP（或 HTTPS）GET 请求，如果想使用不同的请求方法（如 POST、PUT 或 DELETE）​，可以直接使用两个参数版的 fetch()，传入带 method 参数的选项对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url, &#123; <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">r</span> =&gt;</span> r.<span class="title function_">json</span>()).<span class="title function_">then</span>(handleResponse);</span><br></pre></td></tr></table></figure>

<ul>
<li>只要 method 方法不是 GET 或 HEAD（这两个方法不支持请求体）​，都可以在选项对象中设置 body 属性指定请求体</li>
<li>在指定请求体时，浏览器会自动添加合适的 <code>Content-Length</code> 请求头</li>
<li>对于 POST 请求，常见的做法是在请求体中传入一组名&#x2F;值参数，而不是将它们编码后作为查询参数附在 URL 后面。有两种方法可以实现：<ul>
<li>可以通过 <code>URLSearchParams</code> 指定参数的名和值，然后把这个 URLSearchParams 对象作为 body 属性的值。这样做，请求体将被设置为一个类似 URL 查询参数的字符串，而 <code>Content-Type</code> 头部也会自动被设置为 <code>application/x-www-form-urlencoded;charset=UTF-8</code></li>
<li>如果使用 FormData 对象指定参数的名和值，则 <code>Content-Type</code> 也将被设置为 <code>multipart/form-data; boundary=…</code></li>
</ul>
</li>
<li>从用户计算机向服务器上传文件是一个常见的任务，可以通过将 FormData 对象作为请求体来实现</li>
</ul>
<p>多数情况下，我们在 Web 应用中都是使用 fetch() 从自己的服务器请求数据。这种请求也被称为同源请求，因为传给 fetch() 的 URL 与 <code>包含发送请求脚本的文档</code> 是同源的（协议、主机名及端口都相同）​。<strong>出于安全考虑，浏览器通常不允许跨源网络请求（当然跨源请求图片和脚本是例外）​</strong>。不过，利用 CORS（Cross-Origin Resource Sharing，跨源资源共享）可以实现安全的跨源请求：</p>
<ul>
<li>在通过 <code>fetch(</code> )请求跨源 URL 时，浏览器会为请求添加一个 <code>Origin</code> 头部（且不允许通过headers属性覆盖它的值）以告知服务器这个请求来自不同源的文档</li>
<li>如果服务器对这个请求的响应中包含恰当的 <code>Access-Control-Allow-Origin</code> 头部，则请求可以继续</li>
<li>如果服务器没有明确允许请求，则 <code>fetch()</code> 返回的期约会被拒绝</li>
</ul>
<p>有时候我们可能想中断已经发出的 fetch() 请求，此时，fetch API 支持使用 <code>AbortController</code> 和 <code>AbortSignal</code> 类来中断请求。这两个类定义了通用的中断机制，也能在其他 API 中使用。</p>
<p>我们知道可以给 <code>fetch()</code>（或者 <code>Request()</code> 构造函数）传第二个参数，也就是选项对象，用于指定请求方法、请求头或请求体。这个选项对象还支持其他一些选项：</p>
<ul>
<li>cache：这个属性可以用来覆盖浏览器默认的缓存行为</li>
<li>redirect：这个属性控制浏览器如何处理服务器的重定向响应</li>
<li>referrer：这个属性是一个包含相对 URL 的字符串，用于指定 HTTP 的 Referer 头部</li>
</ul>
<h3 id="服务器发送事件"><a href="#服务器发送事件" class="headerlink" title="服务器发送事件"></a>服务器发送事件</h3><p>Web 所依赖的 HTTP 协议的一个核心特性是：客户端发起请求，服务器响应该请求。但是某些 Web 应用却需要在服务器发生事件时，接收来自服务器发送的通知。HTTP 天生并不具备这个特性，但随着技术的发展，客户端向服务器发送请求之后，两端都可以不关闭连接。此时一旦服务器有事情要通知客户端，就可以把数据写入这个连接并保持其打开。</p>
<p>由于这是一个有用的编程模式，客户端 Javascript 以 EventSource API 的形式对其给予支持。要创建与服务器间的这种长时间存在的请求连接，只要向 EventSource() 构造函数传入一个URL即可。当服务器将（适当格式化的）数据写入这个连接时，EventSource 对象会将它们转换为客户端能够监听到的事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ticker = <span class="keyword">new</span> <span class="title class_">EventSource</span>(<span class="string">&quot;stockprices.php&quot;</span>);</span><br><span class="line">ticker.<span class="title function_">addEventListener</span>(<span class="string">&quot;bid&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">displayNewBid</span>(event.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>与消息事件关联的事件对象有一个 data 属性，保存着服务器针对这次事件发送过来的字符串</li>
<li>与其他事件对象一样，这个事件对象也有一个 type 属性，指定了这个事件的名字。服务器确定生成的事件的类型，默认为 “message”</li>
</ul>
<p>这种 SSE（Server-Sent Event，服务器发送事件）协议很好理解：</p>
<ul>
<li>客户端（在它创建 EventSource 对象时）发起对服务器的连接，服务器保持连接打开</li>
<li>一旦有事件发生，服务器就向连接中写入几行文本，通过网络传送的消息格式大致如下：</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">event: bid</span><br><span class="line">data: GOOG</span><br><span class="line">data: 999</span><br></pre></td></tr></table></figure>

<ul>
<li>这个协议还允许为事件指定一个 ID ，以便客户端重新建立连接时告诉服务器它上一次接收到的事件 ID 是什么，而服务器可以重新发送它错过的事件</li>
</ul>
<p>SSE 的一个典型应用是类似在线聊天一样的多用户协作。聊天客户端可以使用 <code>fetch()</code> 把消息发送到聊天室，通过 EventSource 对象订阅聊天信息流。如下是一个示例：</p>
<p>客户端代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>SSE Chat<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100%; padding: 10px; border:solid black 2px&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> nick = <span class="title function_">prompt</span>(<span class="string">&quot;Enter your nickname&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;input&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        input.<span class="title function_">focus</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> chat = <span class="keyword">new</span> <span class="title class_">EventSource</span>(<span class="string">&quot;/chat&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        chat.<span class="title function_">addEventListener</span>(<span class="string">&quot;chat&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            div.<span class="title function_">append</span>(event.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">            input.<span class="title function_">before</span>(div);</span></span><br><span class="line"><span class="language-javascript">            input.<span class="title function_">scrollIntoView</span>();</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        input.<span class="title function_">addEventListener</span>(<span class="string">&quot;change&quot;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">fetch</span>(<span class="string">&quot;/chat&quot;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">body</span>: nick + <span class="string">&quot;: &quot;</span> + input.<span class="property">value</span>,</span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">            .<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="property">error</span>)</span></span><br><span class="line"><span class="language-javascript">            input.<span class="property">value</span> = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>而服务端代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clientHTML = fs.<span class="title function_">readFileSync</span>(<span class="string">&quot;chatClient.html&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clients = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server = <span class="keyword">new</span> http.<span class="title class_">Server</span>();</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8081</span>);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&quot;request&quot;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> pathname = url.<span class="title function_">parse</span>(request.<span class="property">url</span>).<span class="property">pathname</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pathname === <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">    response.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;<span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/html&quot;</span>&#125;).<span class="title function_">end</span>(clientHTML);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pathname !== <span class="string">&quot;/chat&quot;</span> ||</span><br><span class="line">    (request.<span class="property">method</span> !== <span class="string">&quot;GET&quot;</span> &amp;&amp; request.<span class="property">method</span> !== <span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">    response.<span class="title function_">writeHead</span>(<span class="number">404</span>).<span class="title function_">end</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.<span class="property">method</span> === <span class="string">&quot;GET&quot;</span>) &#123;</span><br><span class="line">    <span class="title function_">acceptNewClient</span>(request, response);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">broadcastNewMessage</span>(request, response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">acceptNewClient</span>(<span class="params">request, response</span>) &#123;</span><br><span class="line">  clients.<span class="title function_">push</span>(response);</span><br><span class="line"></span><br><span class="line">  request.<span class="property">connection</span>.<span class="title function_">on</span>(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    clients.<span class="title function_">splice</span>(clients.<span class="title function_">indexOf</span>(response), <span class="number">1</span>);</span><br><span class="line">    response.<span class="title function_">end</span>();</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  response.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/event-stream&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Connection&quot;</span>: <span class="string">&quot;keep-alive&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Cache-Control&quot;</span>: <span class="string">&quot;no-cache&quot;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  response.<span class="title function_">write</span>(<span class="string">&quot;event: chat\ndata: Connected\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">broadcastNewMessage</span>(<span class="params">request, response</span>) &#123;</span><br><span class="line">  request.<span class="title function_">setEncoding</span>(<span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> body = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> chunk <span class="keyword">of</span> request) &#123;</span><br><span class="line">    body += chunk;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  response.<span class="title function_">writeHead</span>(<span class="number">200</span>).<span class="title function_">end</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> message = <span class="string">&quot;data: &quot;</span> + body.<span class="title function_">replace</span>(<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;\ndata: &quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> event = <span class="string">`event: chat\n<span class="subst">$&#123;message&#125;</span>\n\n`</span>;</span><br><span class="line">  clients.<span class="title function_">forEach</span>(<span class="function"><span class="params">client</span> =&gt;</span> client.<span class="title function_">write</span>(event));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当客户端请求根 URL <code>/</code> 时，这个服务器会返回客户端代码，即对应的 HTML 文件</li>
<li>当客户端向 URL <code>/chat</code> 发送 GET 请求时，服务器会保存响应对象并保持连接打开</li>
<li>当客户端向 URL <code>/chat</code> 发送 POST 请求时，它会把请求体作为聊天消息并对每个保存的响应对象使用 <code>text/event-stream</code> 格式</li>
</ul>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket API 是一个复杂、强大的网络协议对外暴露的简单接口。WebSocket 允许 JavaScript 代码在浏览器中与服务器方便地交换文本和二进制消息：</p>
<ul>
<li>与服务器发送事件 <code>SSE</code> 类似，客户端必须建立连接，而连接一旦建立，服务器就可以异步向客户端发送消息</li>
<li>与 SSE 不同，WebSocket 支持二进制消息，而且消息可以双向发送，而不仅仅是从服务器向客户端发消息</li>
</ul>
<p>支撑 WebSocket 的网络协议是一种扩展 HTTP。在使用 WebSocket 协议连接服务时，要通过 URL 指定该服务，就像使用 Web 服务一样。WebSocket URL 以 <code>ws://</code> 而不是 <code>https://</code> 开头（浏览器通常会限制只能在安全的 <code>https://</code> 连接加载的页面中使用 WebSocket）：</p>
<ul>
<li>要建立 WebSocket 连接，浏览器首先要建立一个 HTTP 连接，并向服务器发送 <code>Upgrade: websocket</code> 请求头，请求把连接从 HTTP 协议切换为 WebSocket 协议</li>
<li>这意味着，要在客户端 JavaScript 中使用 WebSocket，服务器必须遵循 WebSocket 协议，按照该协议发送和接收数据</li>
</ul>
<p>如果想与支持 WebSocket 的服务器通信，需要创建一个 <code>WebSocket</code> 对象，并通过 <code>wss://URL</code> 来指定要连接的服务：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;wss://example.com/stockticker&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>这个套接口对象的 readyState 属性表明了当前的连接状态</li>
<li>当 WebSocket 的状态从 CONNECTING 转变为 OPEN 时，它会触发 <code>open</code> 事件。可以通过设置 WebSocket 对象的 onopen 属性或调用该对象的 addEventListener() 来监听这个事件</li>
<li>如果 WebSocket 连接发生了协议错误或其他错误，WebSocket 对象会触发 <code>error</code> 事件</li>
<li>在使用完 WebSocket 之后，可以调用 WebSocket 对象的 <code>close()</code> 方法关闭连接。当连接状态变成 <code>CLOSED</code> 时，WebSocket 对象会触发 <code>close</code> 事件</li>
</ul>
<p>要向位于 WebSocket 连接另一端的服务器发送消息，调用 WebSocket 对象的 <code>send()</code> 方法。要通过 WebSocket 从服务器接收消息，需要注册 <code>message</code> 事件处理程序，可以设置 WebSocket 对象的 onmessage 属性，也可以调用 <code>addEventListener()</code>。与 <code>message</code> 事件关联的事件对象是 <code>MessageEvent</code> 的实例，其 <code>data</code> 属性包含服务器的消息。</p>
<p>WebSocket 协议支持文本和二进制消息交换，但并未规定这些消息的结构或含义。使用 WebSocket 的应用必须在其提供的简单消息交换机制基础上自行协商通信协议。可以基于 <code>wss://URL</code> 来区分不同的协议格式。WebSocket 协议和 API 也提供了应用级消息协商功能：</p>
<ul>
<li>在调用 WebSocket() 构造函数时，<code>wss://URL</code> 是第一个参数，但也可以传一个字符串数组作为第二个参数，传入这个参数后，就相当于把客户端能够处理的应用协议提供给服务器，由服务器从中选择一个协议</li>
<li>连接建立以后，WebSocket 对象的 protocol 属性将保存服务器选择的子协议</li>
</ul>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>Web 应用可以使用浏览器 API 在用户计算机上本地存储数据。客户端存储的目的是让浏览器能够记住一些信息。客户端存储是按照来源隔离的，因此来自一个站点的页面不能读取来自另一个站点的页面存储的数据。但来自同一站点的两个页面可以共享存储的数据，并将其作为一种通信机制。</p>
<p>客户端存储分为如下几种形式：</p>
<ul>
<li>Web Storage：Web Storage API 包含 <code>localStorage</code> 和 <code>sessionStorage</code> 对象，本质上是映射字符串键和值的持久化对象。适合存储大量（不是巨量）的数据</li>
<li>cookie：cookie是一种古老的客户端存储机制，是专门为服务端脚本使用而设计的。浏览器也提供了 JavaScript API 可以在客户端操作 cookie。cookie 只适合保存少量数据。另外，保存在 cookie 中的数据也会随 HTTP 请求发送给服务器</li>
<li>IndexedDB：IndexedDB 是一种异步API，可以访问支持索引的对象数据库</li>
</ul>
<p>这些客户端数据存储技术都不涉及加密，因此任何形式的客户端存储技术都不能用来保存敏感信息。</p>
<h3 id="localStorage-和-sessionStorage"><a href="#localStorage-和-sessionStorage" class="headerlink" title="localStorage 和 sessionStorage"></a>localStorage 和 sessionStorage</h3><p>Window 对象的 localStorage 和 sessionStorage 属性引用的是 Storage 对象。Storage 对象与普通 JavaScript 对象非常类似，只不过：</p>
<ul>
<li>Storage 对象的属性值必须是字符串，如果想存取其他类型的数据，必须自己编码和解码</li>
<li>Storage 对象中存储的属性是持久化的。如果你设置了 localStorage 对象的一个属性，然后用户刷新了页面，你的程序仍然可以访问在该属性中保存的值</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="variable language_">localStorage</span>.<span class="property">username</span>;</span><br><span class="line"><span class="keyword">if</span> (!name) &#123;</span><br><span class="line">  name = <span class="title function_">prompt</span>(<span class="string">&quot;What&#x27;s your name?&quot;</span>);</span><br><span class="line">  <span class="variable language_">localStorage</span>.<span class="property">username</span> = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用 delete 操作符删除 localStorage 和 sessionStorage 的属性</li>
<li>可以使用 <code>for/in</code> 循环或 <code>Object.keys()</code> 枚举 Storage 对象的属性</li>
<li>可以使用 <code>clear()</code> 删除 Storage 对象的所有属性</li>
<li>Storage 对象也定义了 <code>getItem()</code>、<code>setItem()</code> 和 <code>deleteItem()</code> 方法，可以用来代替直接读写属性和 delete 操作符</li>
</ul>
<p><strong>localStorage 和 sessionStorage 的差异主要体现在生命期和作用域上</strong></p>
<ul>
<li>通过 <code>localStorage</code> 存储的数据是永久性的，除非 Web 应用或用户通过浏览器删除，否则数据会永远保存在用户设备上</li>
<li>localStorage 的作用域为文档来源。文档来源由协议、域名和端口共同定义，所有同源文档都共享相同的 localStorage 数据（与实际访问 localStorage 的脚本的来源无关）。同源文档可以相互读取对方的数据，可以重写对方的数据。但非同源文档的数据相互之间是完全隔离的，既读不到也不能重写</li>
<li>也需要注意，localStorage 的作用域也受浏览器实现的限制，两个不同的浏览器存储的数据无法互通</li>
<li>sessionStorage 数据的生命期与存储它的脚本所属的顶级窗口或浏览器标签页相同，窗口或标签页永远关闭后，通过 sessionStorage 存储的所有数据都会被删除（但是现代浏览器有能力再次打开最近关闭的标签页并恢复用户上次浏览的会话，因此之关联的sessionStorage的生命期有可能比看起来更长）</li>
<li>sessionStorage 的作用域与 localStorage 类似，都是文档来源。但是，sessionStorage 的作用域也在窗口间隔离。如果用户在两个浏览器标签页中打开了同一来源的文档，这两个标签页的 sessionStorage 数据也是隔离的</li>
</ul>
<p>存储在 localStorage 中的数据每次发生变化时，浏览器都会在该数据可见的其他 Window 对象（不包括导致该变化的窗口）上触发 <code>storage</code> 事件。要注册 <code>storage</code> 事件，可以使用 <code>window.onstorage</code> 事件属性，或者调用 <code>window.addEventListener()</code> 并传入 <code>storage</code>。</p>
<p>localStorage 和 <code>storage</code> 事件可以作为一种广播机制，即浏览器向所有当前浏览同一网站的窗口发送消息。</p>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>cookie 是浏览器为特定网页或网站保存的少量命名数据。cookie 是为服务端编程而设计的，cookie 数据会自动在浏览器与 Web 服务器之间传输，因此服务器端脚本可以读写存储在客户端的 cookie 值。</p>
<p>操作 cookie 的 API 很古老也很难用，因此没有涉及方法。查询、设置和删除 cookie，都是通过读写 Document 对象的 cookie 属性实现的，而且要使用特定格式的字符串。每个 cookie 的生命期和作用域可以通过 cookie 属性来单独指定。</p>
<p><code>document.cookie</code> 属性返回一个包含与当前文档有关的所有 cookie 的字符串。这个字符串是一个分号和空格分隔的名&#x2F;值对。为了使用 <code>document.cookie</code> 属性，通常必须调用 <code>split()</code> 方法把整个字符串拆分成单独的的 <code>名/值对</code>。从 cookie 属性中提取出某个 cookie 的值之后，必须根据 cookie 创建者的格式或编码来解释该值。</p>
<p>除了名字和值，每个 cookie 还有可选的属性，用于控制其生命期和作用域。</p>
<ul>
<li>cookie 默认的生命期很短，它们存储的值只在浏览器会话期间存在，用户退出浏览器后就会丢失。如果想让 cookie 的生命期超过单个浏览会话，必须告诉浏览器你希望保存它们多长时间，为此要指定 <code>cookie</code> 的 <code>max-age</code> 属性。如果指定了这样一个生命期，浏览器将把 cookie 存储在一个文件中，等时间到了再把它们删除</li>
<li>cookie 的可见性由文档来源决定，但也由文档路径决定，即 cookie 的作用域通过 path 和 domain 属性来配置。默认情况下，cookie 关联着创建它的网页，以及与该网页位于相同目录和子目录下的其他网页，这些网页都可以访问它</li>
<li>可以为 cookie 指定 path 属性，然后来自同一服务器的任何网页，只要其 URL 以你指定的路径前缀开头，就可以共享该 cookie</li>
<li>默认情况下，cookie 的作用域按照文档来源区分。不过大网站可能需要跨子域名共享 cookie，这时候就要用到 domain 属性了，但是不能将 cookie 的域设置为服务器父域名之外的其他域名</li>
<li>secure 属性是一个布尔值，用于指定如何通过网络传输 cookie 值。默认可以在普通的不安全的 HTTP 连接上传输。如果把 cookie 设置为安全的，那么就只能在浏览器与服务器通过 HTTPS 或其他安全协议连接时传输 cookie</li>
</ul>
<p>Cookie 主要用于为服务器端脚本存储少量数据，而且该数据在每次请求相关 URL 时都会发送给服务器。某些浏览器会限制每个 cookie 大小不超过 4kb。</p>
<p>要给当前文档关联一个短暂的 cookie，只要把 <code>document.cookie</code> 设置为 <code>name=value</code> 形式的字符串即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">`version=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(<span class="variable language_">document</span>.lastModified)&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>cookie值不能包含分号、逗号或空格。为此，可能需要使用核心 JavaScript 的全局函数 <code>encodeURIComponent()</code> 先对值进行编码，然后再把它保存到 cookie 中。</li>
<li>如果进行了编码，那么在将来读取 cookie 值时还必须使用对应的 <code>decodeURIComponent()</code> 函数来解码</li>
<li>可以在保存 cookie 属性的字符串中继续添加 <code>max-age</code>、<code>path</code> 和 <code>domain</code> 等属性。例如 <code>name=value; path=value; domain=value; secure</code></li>
<li>要删除 cookie，需要以相同的名字、路径和域名再设置一次，指定一个任意值（或空值）​，并将 max-age 属性指定为 0</li>
</ul>
<h3 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h3><p>IndexedDB 是一个对象数据库，不是关系型数据库，比支持 SQL 查询的数据库更简单，而且比 localStorage 提供的键&#x2F;值对存储机制更强大、高效和可靠：</p>
<ul>
<li>IndexedDB 数据库的作用域限定为包含文档的来源。换句话说，两个同源的网页可以互相访问对方的数据，但不同源的网页则不能相互访问</li>
<li>每个来源可以有任意数量的 IndexedDB 数据库。每个数据库的名字必须在当前来源下唯一</li>
<li>在 IndexedDB API 中，数据库就是一个命名的对象存储集合</li>
<li>对象存储中存储的是对象。对象会使用结构化克隆算法序列化为对象存储</li>
<li>每个对象必须有一个键，可以用于排序和从存储中检索，键必须唯一。JavaScript 字符串、数值和 Date 对象都是有效的键</li>
<li>IndexedDB 数据库可以自动为插入数据库中的每个对象生成一个唯一的键</li>
<li>通常插入对象存储中的对象都会有一个属性适合作为键。在这种情况下，可以在创建对象存储时为该属性指定一个 <code>键路径</code>，告诉数据库如何从对象中提取对象的键</li>
<li>可以在对象存储上定义任意数量的索引，每个索引为存储的对象定义了一个次键</li>
</ul>
<p>IndexedDB 提供了原子保证，即查询和更新数据库会按照事务进行分组，要么全部成功，要么全部失败，永远不会让数据库处于未定义、部分更新的状态。从概念上讲，IndexedDB API 非常简单：</p>
<ul>
<li>要查询或更新数据库，首先要打开对应的数据库（通过名字）​。然后，创建一个事务对象并使用该对象查找数据库中相应的对象存储（同样通过名字）​</li>
<li>通过调用该对象存储的 <code>get()</code> 方法查询对象，或通过调用 <code>put()</code> 方法存储新对象</li>
<li>如果想查询键在某个范围内的对象，需要创建一个 IDBRange 对象并指定范围的上、下边界，然后把它传给对象存储的 <code>getAll()</code> 或 <code>openCursor()</code> 方法</li>
<li>IndexedDB API是异步的，而且 IndexedDB 是在期约得到广泛支持之前定义的，因此这个 API 是基于事件而非基于期约的</li>
<li>在第一次打开一个数据库时，或者在增大一个已有数据库的版本号时，IndexedDB 会在调用 <code>indexedDB.open()</code> 返回的请求对象上触发 <code>upgradeneeded</code> 事件。这个 <code>upgradeneeded</code> 事件的处理程序要负责定义或更新这个新数据库的模式，这意味着创建对象存储和在这些对象存储上定义索引</li>
</ul>
<h2 id="工作线程与消息传递"><a href="#工作线程与消息传递" class="headerlink" title="工作线程与消息传递"></a>工作线程与消息传递</h2><p>单线程是 JavaScript 的一个基本特性，因此浏览器绝不会同时运行两个事件处理程序，也不会在一个事件处理程序运行的时候触发其他计时器，这样前端开发者就无需思考甚至理解并发编程了，但缺点是一个 JavaScript 函数不能运行太长时间，否则它们就会阻塞事件循环。事实上这也是 <code>fetch()</code> 被设计为异步函数的原因。</p>
<p>浏览器通过 Worker 类非常谨慎地放松了这种单线程的限制。这个类的实例代表与主线程和事件循环同时运行的线程：</p>
<ul>
<li>Worker 运行于独立的运行环境，有着完全独立的全局对象，不能访问 Window 或 Document 对象</li>
<li>Worker 与主线程只能通过异步消息机制通信</li>
</ul>
<p>这意味着并发修改 DOM 仍然是不可能的，但也意味我们可以写长时间运行的函数，而不会阻塞事件循环、卡死浏览器。工作线程适合执行计算密集型任务。创建新工作线程（worker）并不会像打开新浏览器窗口那么 <code>重量</code>，但也不是没有任何开销。复杂 Web 应用可能会创建几十个工作线程，但要创建几百或者几千个工作线程也是不切实际的。</p>
<p>与任何线程 API 一样，Worker API也有两部分。一部分是 Worker 对象，另一部分是 WorkerGlobalScope。前者是这个线程的外在部分，后者则是线程的内在部分。</p>
<h3 id="Worker-对象"><a href="#Worker-对象" class="headerlink" title="Worker 对象"></a>Worker 对象</h3><p>要创建新的工作线程，调用 <code>Worker()</code> 构造函数，传入一个 URL，这个 URL 用于指定线程要执行的 JavaScript 代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dataCruncher = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;utils/cruncher.js&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>创建 Worker 对象后，可以使用 <code>postMessage()</code> 方法向工作线程发送数据</li>
<li>传给 <code>postMessage()</code> 的值会使用结构化克隆算法被复制，得到的副本会通过消息事件发送给工作线程</li>
<li>通过监听 Worker 对象的 <code>message</code> 事件，可以从工作线程接收消息</li>
<li>Worker 对象也定义了标准的 <code>addEventListener()</code> 和 <code>removeEventListener()</code> 方法，可以用它们代替 onmessage</li>
</ul>
<h3 id="工作线程中的全局对象"><a href="#工作线程中的全局对象" class="headerlink" title="工作线程中的全局对象"></a>工作线程中的全局对象</h3><p>在通过 <code>Worker()</code> 构造函数创建新工作线程时，传入的 URL 指定的是一个 <code>JavaScript</code> 代码文件。其中的代码会在一个新的、干净的 JavaScript 执行环境中执行，与创建工作线程的脚本完全隔离。这个新执行环境中的全局对象是一个 <code>WorkerGlobalScope</code> 对象。</p>
<p><code>WorkerGlobalScope</code> 对象也有 <code>postMessage()</code> 方法和 <code>onmessage</code> 事件处理程序，只是方向与 <code>Worker</code> 对象上的恰好相反：</p>
<ul>
<li>在工作线程内部调用 postMessage() 会在外部生成消息事件，而在工作线程外部发送的消息会转换为事件并发送给内部的 onmessage 事件处理程序</li>
<li>WorkerGlobalScope 是工作线程的全局对象，<code>postMessage()</code> 和 <code>onmessage</code> 在工作线程的代码中看起来就像一个全局函数和一个全局变量</li>
<li>close() 函数可以让工作线程终止自己，效果与调用 Worker 对象的 terminate() 方法一样</li>
</ul>
<p>由于 <code>WorkerGlobalScope</code> 是工作线程的全局对象，因此它拥有核心 JavaScript 全局对象的所有属性，如 JSON 对象、isNaN() 函数、Date() 函数。而且，WorkerGlobalScope 也拥有下列客户端 Window 对象的属性：</p>
<ul>
<li>self 是对全局对象自身的引用</li>
<li>setTimeout()、clearTimeout()、setInterval()、clearInterval() 等定时器方法</li>
<li>location 属性描述传给 <code>Worker()</code> 构造函数的 URL，这个属性引用一个 Location 对象</li>
<li>navigator 属性引用的是一个类似 Window 的 Navigator 对象</li>
<li>常用的事件目标方法 <code>addEventListener()</code> 和 <code>removeEventListener()</code></li>
<li>WorkerGlobalScope 对象还包含重要的客户端 JavaScript API，比如 Console对象、fetch() 函数和 IndexedDB API 等等。WorkerGlobalScope 也包含 <code>Worker()</code> 构造函数，这意味着工作线程也可以创建自己的工作线程</li>
</ul>
<h3 id="在工作线程中导入代码"><a href="#在工作线程中导入代码" class="headerlink" title="在工作线程中导入代码"></a>在工作线程中导入代码</h3><p>浏览器支持 Worker 的时候 JavaScript 还不支持模块系统，因此工作线程有自己一套独特的系统用于导入外部代码：</p>
<ul>
<li><code>importScripts()</code> 接收一个或多个 URL 参数，每个 URL 引用一个 JavaScript 代码文件</li>
<li><code>importScripts()</code> 按照传入顺序一个接一个地同步加载并执行这些文件</li>
<li><code>importScripts()</code> 是同步函数，即它会在所有脚本都加载并执行完毕后返回</li>
<li>为了在工作线程中使用模块，必须给<code> Worker()</code> 构造函数传入第二个参数。这个参数必须是一个有 type 属性且值为 module 的对象。它表示应该将当前代码作为模块来解释，并允许使用 import 声明</li>
</ul>
<h3 id="工作线程执行模型"><a href="#工作线程执行模型" class="headerlink" title="工作线程执行模型"></a>工作线程执行模型</h3><p>工作线程自上而下地同步运行自己的代码（和所有导入的脚本及模块）​，之后就进入了异步阶段，准备对事件和定时器作出响应：</p>
<ul>
<li>如果注册了 <code>message</code> 事件处理程序，只要有收到消息事件的可能，则工作线程就不会退出</li>
<li>如果工作线程没有监听消息事件，它会运行直到没有其他待决的任务（如 <code>fetch()</code> 期约和定时器）​，且所有任务相关的回调都被调用，之后线程可以安全退出，而且是自动的</li>
<li>工作线程也可以调用全局的 <code>close()</code> 函数显式将自己终止</li>
</ul>
<p>如果工作线程中出现了异常，而且没有被 <code>catch</code> 子句捕获，则会在全局对象上触发 <code>error</code> 事件：</p>
<ul>
<li>如果这个事件有处理程序，而且处理程序调用了事件对象的 preventDefault()，则错误会停止传播</li>
<li>否则，​<code>error</code> 事件会在 Worker 对象上触发</li>
</ul>
<p>工作线程也可以注册一个事件处理程序，以便期约被拒绝又没有 <code>.catch()</code> 函数处理它时调用。可以在工作线程内定义一个 <code>self.onunhandledrejection</code> 函数，或者使用 <code>addEventListener()</code> 为全局事件 <code>unhandledrejection</code> 注册一个全局处理程序。</p>
<h3 id="postMessage-、MessagePort-和-MessageChannel"><a href="#postMessage-、MessagePort-和-MessageChannel" class="headerlink" title="postMessage()、MessagePort 和 MessageChannel"></a>postMessage()、MessagePort 和 MessageChannel</h3><p>Worker 对象的 postMessage() 方法和工作线程内部的全局 postMessage() 函数，都是通过调用在创建工作线程时一起创建的一对 MessagePort（消息端口）对象的 postMessage() 方法来实现通信的。客户端 JavaScript 无法直接访问这两个自动创建的 MessagePort 对象，但可以通过 <code>MessageChannel()</code> 构造函数创建一对新的关联端口：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> channel = <span class="keyword">new</span> <span class="title class_">MessageChannel</span>();</span><br><span class="line"><span class="keyword">let</span> myport = channel.<span class="property">port1</span>;</span><br><span class="line"><span class="keyword">let</span> yourport = channel.<span class="property">port2</span>;</span><br><span class="line">myport.<span class="title function_">postMessage</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">yourport.<span class="property">onmessage</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>);</span><br></pre></td></tr></table></figure>

<p>postMessage() 方法还接收可选的第二个参数，该参数是一个数组，数组的元素不是被复制到信道另一端，而是被转移到信道另一端。像这样可以转移而非复制的值包括 <code>MessagePort</code> 和 <code>ArrayBuffer</code>。如果 <code>postMessage()</code> 的第一个参数包含一个 <code>MessagePort</code>（嵌套在消息对象中某个地方）​，那么该 MessagePort 也必须出现在第二个参数中。这样一来，这个 MessagePort 将被转移到另一个线程，并在当前线程立即失效。</p>
<p>使用 MessageChannel 也可以实现两个工作线程间直接通信，从而避免通过主线程代为转发消息。</p>
<h3 id="通过-postMessage-跨源发送消息"><a href="#通过-postMessage-跨源发送消息" class="headerlink" title="通过 postMessage() 跨源发送消息"></a>通过 postMessage() 跨源发送消息</h3><p>在客户端 JavaScript 中，postMessage()方法还有另一个使用场景。这个场景涉及窗口而不是工作线程。如果文档中包含一个 <code>&lt;iframe&gt;</code> 元素，则该元素就像一个嵌入但独立的窗口。表示 <code>&lt;iframe&gt;</code> 的 Element对象有一个contentWindow 属性，也就是那个嵌套文档的 Window 对象。</p>
<ul>
<li>对于在这个嵌入窗格（iframe）中运行的脚本，<code>window.parent</code> 属性引用包含文档的 Window 对象</li>
<li>当两个窗口显示的文档具有相同来源时，两个窗口中的脚本都拥有访问另一个窗口中内容的权限</li>
<li>但是如果两个文档的来源不同，浏览器的同源策略将阻止两个窗口中的 JavaScript 相互访问对方的内容</li>
</ul>
<p>对于窗口，<code>postMessage()</code> 也为两个独立的来源提供了安全交换消息的受控机制。即便同源策略阻止脚本访问另一个窗口的内容，仍然可以调用另一个窗口的 <code>postMessage()</code>，这样会触发该窗口的 <code>message</code> 事件，从而让该窗口脚本中的事件处理程序接收到。</p>
<p>Window 对象上的 postMessage() 方法有一点不同，其第二个参数是一个字符串，表示一个源，用于指定你希望谁接收这条消息。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/%E5%89%8D%E7%AB%AF/" rel="tag"># 前端</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/01/23/javascript-guide-16/" rel="prev" title="JavaScript 权威指南 16：Node 服务端 JavaScript">
      <i class="fa fa-chevron-left"></i> JavaScript 权威指南 16：Node 服务端 JavaScript
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/01/21/javascript-guide-14/" rel="next" title="JavaScript 权威指南 14：元编程">
      JavaScript 权威指南 14：元编程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Web-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">Web 编程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTML-lt-script-gt-%E6%A0%87%E7%AD%BE%E4%B8%AD%E7%9A%84-JavaScript"><span class="nav-number">1.1.</span> <span class="nav-text">HTML &lt;script&gt; 标签中的 JavaScript</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.</span> <span class="nav-text">文档对象模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.3.</span> <span class="nav-text">浏览器中的全局对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%84%9A%E6%9C%AC%E5%85%B1%E4%BA%AB%E4%B8%80%E4%B8%AA%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">1.4.</span> <span class="nav-text">脚本共享一个命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="nav-number">1.5.</span> <span class="nav-text">JavaScript 程序的执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="nav-number">1.6.</span> <span class="nav-text">程序的输入与输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E9%94%99%E8%AF%AF"><span class="nav-number">1.7.</span> <span class="nav-text">程序错误</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6"><span class="nav-number">2.</span> <span class="nav-text">事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%88%AB"><span class="nav-number">2.1.</span> <span class="nav-text">事件类别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.2.</span> <span class="nav-text">注册事件处理程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.3.</span> <span class="nav-text">调用事件处理程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E4%BC%A0%E6%92%AD"><span class="nav-number">2.4.</span> <span class="nav-text">事件传播</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%8F%96%E6%B6%88"><span class="nav-number">2.5.</span> <span class="nav-text">事件取消</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BE%E5%8F%91%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="nav-number">2.6.</span> <span class="nav-text">派发自定义事件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C-DOM"><span class="nav-number">3.</span> <span class="nav-text">操作 DOM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9-Document-%E5%85%83%E7%B4%A0"><span class="nav-number">3.1.</span> <span class="nav-text">选择 Document 元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E6%A1%A3%E7%BB%93%E6%9E%84%E4%B8%8E%E9%81%8D%E5%8E%86"><span class="nav-number">3.2.</span> <span class="nav-text">文档结构与遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7"><span class="nav-number">3.3.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E5%86%85%E5%AE%B9"><span class="nav-number">3.4.</span> <span class="nav-text">元素内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E3%80%81%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="nav-number">3.5.</span> <span class="nav-text">创建、插入和删除节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95"><span class="nav-number">3.6.</span> <span class="nav-text">生成目录</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C-CSS"><span class="nav-number">4.</span> <span class="nav-text">操作 CSS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CSS-%E7%B1%BB"><span class="nav-number">4.1.</span> <span class="nav-text">CSS 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%8C%E5%86%85%E6%A0%B7%E5%BC%8F"><span class="nav-number">4.2.</span> <span class="nav-text">行内样式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%A0%B7%E5%BC%8F"><span class="nav-number">4.3.</span> <span class="nav-text">计算样式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%A0%B7%E5%BC%8F%E8%A1%A8"><span class="nav-number">4.4.</span> <span class="nav-text">操作样式表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSS-%E5%8A%A8%E7%94%BB%E4%B8%8E%E4%BA%8B%E4%BB%B6"><span class="nav-number">4.5.</span> <span class="nav-text">CSS 动画与事件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E6%A1%A3%E5%87%A0%E4%BD%95%E4%B8%8E%E6%BB%9A%E5%8A%A8"><span class="nav-number">5.</span> <span class="nav-text">文档几何与滚动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E6%A1%A3%E5%9D%90%E6%A0%87%E5%92%8C%E8%A7%86%E5%8F%A3%E5%9D%90%E6%A0%87"><span class="nav-number">5.1.</span> <span class="nav-text">文档坐标和视口坐标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E5%85%83%E7%B4%A0%E7%9A%84%E5%87%A0%E4%BD%95%E5%A4%A7%E5%B0%8F"><span class="nav-number">5.2.</span> <span class="nav-text">查询元素的几何大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AE%E5%AE%9A%E4%BD%8D%E4%BA%8E%E6%9F%90%E4%B8%80%E7%82%B9%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">5.3.</span> <span class="nav-text">确定位于某一点的元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BB%9A%E5%8A%A8"><span class="nav-number">5.4.</span> <span class="nav-text">滚动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%86%E5%8F%A3%E5%A4%A7%E5%B0%8F%E3%80%81%E5%86%85%E5%AE%B9%E5%A4%A7%E5%B0%8F%E5%92%8C%E6%BB%9A%E5%8A%A8%E4%BD%8D%E7%BD%AE"><span class="nav-number">5.5.</span> <span class="nav-text">视口大小、内容大小和滚动位置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Web-%E7%BB%84%E4%BB%B6"><span class="nav-number">6.</span> <span class="nav-text">Web 组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Web-%E7%BB%84%E4%BB%B6"><span class="nav-number">6.1.</span> <span class="nav-text">使用 Web 组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTML-%E6%A8%A1%E7%89%88"><span class="nav-number">6.2.</span> <span class="nav-text">HTML 模版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B4%A0"><span class="nav-number">6.3.</span> <span class="nav-text">自定义元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%B1%E5%AD%90-DOM"><span class="nav-number">6.4.</span> <span class="nav-text">影子 DOM</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E4%BC%B8%E7%BC%A9%E7%9F%A2%E9%87%8F%E5%9B%BE%E5%BD%A2"><span class="nav-number">7.</span> <span class="nav-text">可伸缩矢量图形</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8-HTML-%E4%B8%AD%E4%BD%BF%E7%94%A8-SVG"><span class="nav-number">7.1.</span> <span class="nav-text">在 HTML 中使用 SVG</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E6%93%8D%E4%BD%9C-SVG"><span class="nav-number">7.2.</span> <span class="nav-text">编程操作 SVG</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lt-canvas-gt-%E4%B8%8E%E5%9B%BE%E5%BD%A2"><span class="nav-number">8.</span> <span class="nav-text">&lt;canvas&gt; 与图形</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%A4%9A%E8%BE%B9%E5%BD%A2"><span class="nav-number">8.1.</span> <span class="nav-text">路径与多边形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%BB%E5%B8%83%E5%A4%A7%E5%B0%8F%E4%B8%8E%E5%9D%90%E6%A0%87"><span class="nav-number">8.2.</span> <span class="nav-text">画布大小与坐标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E5%BD%A2%E5%B1%9E%E6%80%A7"><span class="nav-number">8.3.</span> <span class="nav-text">图形属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%BB%E5%B8%83%E7%BB%98%E5%88%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">8.4.</span> <span class="nav-text">画布绘制操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9D%90%E6%A0%87%E7%B3%BB%E5%8F%98%E6%8D%A2"><span class="nav-number">8.5.</span> <span class="nav-text">坐标系变换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%AA%E5%88%87"><span class="nav-number">8.6.</span> <span class="nav-text">剪切</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%83%8F%E7%B4%A0%E6%93%8D%E4%BD%9C"><span class="nav-number">8.7.</span> <span class="nav-text">像素操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Audio-API"><span class="nav-number">9.</span> <span class="nav-text">Audio API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Audio-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">9.1.</span> <span class="nav-text">Audio 构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Web-Audio-API"><span class="nav-number">9.2.</span> <span class="nav-text">Web Audio API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E7%BD%AE%E3%80%81%E5%AF%BC%E8%88%AA%E4%B8%8E%E5%8E%86%E5%8F%B2"><span class="nav-number">10.</span> <span class="nav-text">位置、导航与历史</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E6%96%B0%E6%96%87%E6%A1%A3"><span class="nav-number">10.1.</span> <span class="nav-text">加载新文档</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%8E%86%E5%8F%B2"><span class="nav-number">10.2.</span> <span class="nav-text">浏览历史</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-hashchange-%E4%BA%8B%E4%BB%B6%E7%AE%A1%E7%90%86%E5%8E%86%E5%8F%B2"><span class="nav-number">10.3.</span> <span class="nav-text">使用 hashchange 事件管理历史</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-pushState-%E7%AE%A1%E7%90%86%E5%8E%86%E5%8F%B2"><span class="nav-number">10.4.</span> <span class="nav-text">使用 pushState() 管理历史</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C"><span class="nav-number">11.</span> <span class="nav-text">网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fetch"><span class="nav-number">11.1.</span> <span class="nav-text">fetch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E4%BA%8B%E4%BB%B6"><span class="nav-number">11.2.</span> <span class="nav-text">服务器发送事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WebSocket"><span class="nav-number">11.3.</span> <span class="nav-text">WebSocket</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8"><span class="nav-number">12.</span> <span class="nav-text">存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#localStorage-%E5%92%8C-sessionStorage"><span class="nav-number">12.1.</span> <span class="nav-text">localStorage 和 sessionStorage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cookie"><span class="nav-number">12.2.</span> <span class="nav-text">cookie</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IndexedDB"><span class="nav-number">12.3.</span> <span class="nav-text">IndexedDB</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="nav-number">13.</span> <span class="nav-text">工作线程与消息传递</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Worker-%E5%AF%B9%E8%B1%A1"><span class="nav-number">13.1.</span> <span class="nav-text">Worker 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1"><span class="nav-number">13.2.</span> <span class="nav-text">工作线程中的全局对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%AF%BC%E5%85%A5%E4%BB%A3%E7%A0%81"><span class="nav-number">13.3.</span> <span class="nav-text">在工作线程中导入代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B"><span class="nav-number">13.4.</span> <span class="nav-text">工作线程执行模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#postMessage-%E3%80%81MessagePort-%E5%92%8C-MessageChannel"><span class="nav-number">13.5.</span> <span class="nav-text">postMessage()、MessagePort 和 MessageChannel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-postMessage-%E8%B7%A8%E6%BA%90%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="nav-number">13.6.</span> <span class="nav-text">通过 postMessage() 跨源发送消息</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">195</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
