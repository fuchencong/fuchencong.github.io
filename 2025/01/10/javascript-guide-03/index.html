<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一门语言支持的类型集、变量的工作方式都是这门编程语言最基本的特征。这篇文章讲解 JavaScript 中的类型、值和变量。">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 权威指南 03：类型、值和变量">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2025/01/10/javascript-guide-03/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="一门语言支持的类型集、变量的工作方式都是这门编程语言最基本的特征。这篇文章讲解 JavaScript 中的类型、值和变量。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-01-10T06:20:26.000Z">
<meta property="article:modified_time" content="2025-02-19T06:35:07.688Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2025/01/10/javascript-guide-03/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JavaScript 权威指南 03：类型、值和变量 | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2025/01/10/javascript-guide-03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaScript 权威指南 03：类型、值和变量
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-10 14:20:26" itemprop="dateCreated datePublished" datetime="2025-01-10T14:20:26+08:00">2025-01-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>一门语言支持的类型集、变量的工作方式都是这门编程语言最基本的特征。这篇文章讲解 JavaScript 中的类型、值和变量。</p>
<span id="more"></span>

<h2 id="概述与定义"><a href="#概述与定义" class="headerlink" title="概述与定义"></a>概述与定义</h2><p>JavaScript 类型可以分为两类：原始类型和对象类型。JavaScript 的原始类型包括数值、字符串和布尔值​，特殊值 null 和 undefined 也是原始值，但它们不是数值、字符串或布尔值，这两个值通常被认为是各自特殊类型的唯一成员。ES6 新增了一种特殊类型 Symbol（符号）​，用于对语言进行扩展而不破坏向后兼容性。</p>
<p><strong>在 JavaScript中，任何不是数值、字符串、布尔值、符号、null 和 undefined 的值都是对象</strong>。对象是属性的集合，其中每个属性都有一个名字和一个值（原始值或其他对象）​。</p>
<p>普通 JavaScript 对象是一个命名值的无序集合。这门语言本身也定义一种特殊对象，称为数组。JavaScript 语言包括操作数组的特殊语法，而数组本身也具有区别于普通对象的行为。</p>
<p>除了基本的对象和数组之外，JavaScript 还定义了其他一些有用的对象类型，例如 Set、Map、Date 等。</p>
<p>JavaScript 与静态语言更大的差别在于，函数和类不仅仅是语言的语法，它们本身就是可以被 JavaScript 程序操作的值。<strong>与其他 JavaScript 非原始值一样，函数和类也是特殊的对象</strong>。</p>
<p>在内存管理方面，JavaScript 解释器会执行自动垃圾收集。这意味着 JavaScript 程序员通常不用关心对象或其他值的析构与释放。当一个值无法触达时，或者说当程序无法以任何方式引用这个值时，解释器就知道这个值已经用不到了，会自动释放它占用的内存。</p>
<p>JavaScript 支持面向对象的编程风格。粗略地说，这意味着不用定义全局函数去操作不同类型的值，而是由这些类型本身定义操作值的方法。</p>
<p><strong>JavaScript 的原始类型是不能修改的（immutable），而对象类型是可修改的（mutable）</strong>。可修改类型的值可以改变，而数值、布尔值、符号、null 和 undefined 是不可修改的，修改它们是无意义的。</p>
<p>JavaScript 可以自由地转换不同类型的值，JavaScript 这种自由的值转换会影响对相等的定义。</p>
<p>常量和变量可以让我们在程序中使用名字来引用值。常量使用 const 声明，变量使用 let（或在较老的 JavaScript 代码中使用 var）声明。JavaScript 常量和变量是无类型的（untyped），声明并不会限定要赋何种类型的值。</p>
<h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><p>JavaScript 的主要数值类型 Number 用于表示整数和近似实数。JavaScript 使用 IEEE-754 标准定义的 64 位浮点格式表示数值。JavaScript 的这种数值格式可以让我们准确表示 <code>-9007 199 254 740 992</code>（-2^53）到<code>9007 199 254 740 992</code>（2^53）之间的所有整数（含首尾值）​。如果你的整数值超出了这个范围，那可能会在末尾的数字上损失一些精度。另外需要要注意，JavaScript 中的某些操作（例如数组索引和位操作）是以 32 位整数计算的。</p>
<p>出现在 JavaScript 程序中的数值称为数值字面量。</p>
<h3 id="整数字面量"><a href="#整数字面量" class="headerlink" title="整数字面量"></a>整数字面量</h3><p>JavaScript 支持 10 进制、16 进制的整数字面量（以 0x 或 0X 开头，后跟一个十六进制数字字符串，大小写均可）。在 ES6 及之后的版本中，也可以通过二进制或八进制表示整数，分别使用前缀 <code>0b</code> 和 <code>0o</code>（或 <code>0B</code> 和 <code>0O</code> ）​：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># node</span><br><span class="line">&gt; <span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">&gt; <span class="number">0xa</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">&gt; <span class="number">0xA</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">&gt; <span class="number">0o12</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">&gt; <span class="number">0O12</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">&gt; <span class="number">0b1010</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">&gt; <span class="number">0B1010</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<h3 id="浮点字面量"><a href="#浮点字面量" class="headerlink" title="浮点字面量"></a>浮点字面量</h3><p>浮点字面量可以包含小数点，它们对实数使用传统语法。实数值由数值的整数部分、小数点和数值的小数部分组成。浮点字面量也可以使用指数记数法表示，即实数值后面可以跟字母e（或E）​，跟一个可选的加号或减号，再跟一个整数指数。这种记数法表示的是实数值乘以 10 的指数次幂。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">3.14</span></span><br><span class="line"><span class="number">3.14</span></span><br><span class="line">&gt; <span class="number">100.1</span></span><br><span class="line"><span class="number">100.1</span></span><br><span class="line">&gt; <span class="number">.3333</span></span><br><span class="line"><span class="number">0.3333</span></span><br><span class="line">&gt; <span class="number">6.02e10</span></span><br><span class="line"><span class="number">60200000000</span></span><br><span class="line">&gt; <span class="number">1.473823232E-32</span></span><br><span class="line"><span class="number">1.473823232e-32</span></span><br></pre></td></tr></table></figure>

<p>可以用下划线将数值字面量分隔为容易看清的数字段：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1_000_000_000</span></span><br><span class="line"><span class="number">1000000000</span></span><br><span class="line">&gt; <span class="number">0x89_AB_CD_EF</span></span><br><span class="line"><span class="number">2309737967</span></span><br><span class="line">&gt; <span class="number">0b0001_1101_0111</span></span><br><span class="line"><span class="number">471</span></span><br><span class="line">&gt; <span class="number">0.123_456_789</span></span><br><span class="line"><span class="number">0.123456789</span></span><br></pre></td></tr></table></figure>

<h3 id="JavaScript-中的算术"><a href="#JavaScript-中的算术" class="headerlink" title="JavaScript 中的算术"></a>JavaScript 中的算术</h3><p>JavaScript 程序使用语言提供的算术操作符来操作数值，包括 +、-、*、&#x2F;、%（取模）、**（幂运算，ES2016）。除了这些基本的算术运算符，JavaScript 还通过 Math 对象的属性提供了一组函数和常量，以支持更复杂的数学计算：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="number">.6</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt; <span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="number">.4</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line">&gt; <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line"><span class="number">1024</span></span><br><span class="line">&gt; <span class="title class_">Math</span>.<span class="property">PI</span></span><br><span class="line"><span class="number">3.141592653589793</span></span><br><span class="line">&gt; <span class="title class_">Math</span>.<span class="property">E</span></span><br><span class="line"><span class="number">2.718281828459045</span></span><br><span class="line">&gt; <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>JavaScript 中的算术在遇到上溢出、下溢出或被零除时不会发生错误。</p>
<ul>
<li>如果运算结果超过最大可表示数值（上溢出），结果是一个特殊的无穷值 Infinity</li>
<li>如果运算结果低于最小可表示数值（下溢出），结果是负无穷值 -Infinity</li>
<li>任何数加、减、乘、除无穷值结果还是无穷值（只是符号可能相反）</li>
<li>被零除只会简单地返回无穷或负无穷。不过有一个例外：0 除以 0是没有意义的值，这个操作的结果是一个特殊的 <code>非数值</code>（NaN，Not a Number）</li>
<li>无穷除无穷、负数平方根或者用无法转换为数值的非数值作为算术操作符的操作数，结果也都是NaN。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">0</span> - <span class="title class_">Infinity</span></span><br><span class="line">-<span class="title class_">Infinity</span></span><br><span class="line">&gt; <span class="number">1</span> + <span class="title class_">Infinity</span></span><br><span class="line"><span class="title class_">Infinity</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="title class_">Infinity</span></span><br><span class="line">&gt; -<span class="number">1</span> / <span class="number">0</span></span><br><span class="line">-<span class="title class_">Infinity</span></span><br><span class="line">&gt; <span class="number">0</span> / <span class="number">0</span></span><br><span class="line"><span class="title class_">NaN</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="title class_">Infinity</span> / -<span class="title class_">Infinity</span></span><br><span class="line"><span class="title class_">NaN</span></span><br><span class="line">&gt; <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(-<span class="number">1</span>)</span><br><span class="line"><span class="title class_">NaN</span></span><br><span class="line">&gt; <span class="number">1</span> / <span class="string">&quot;t&quot;</span></span><br><span class="line"><span class="title class_">NaN</span></span><br></pre></td></tr></table></figure>

<p>JavaScript 预定义了全局常量 Infinity 和 NaN 以对应正无穷和非数值。这些值也可以通过 Number 对象的属性获取。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="title class_">Number</span>.<span class="property">POSITIVE_INFINITY</span></span><br><span class="line"><span class="title class_">Infinity</span></span><br><span class="line">&gt; <span class="title class_">Number</span>.<span class="property">NEGATIVE_INFINITY</span></span><br><span class="line">-<span class="title class_">Infinity</span></span><br><span class="line">&gt; <span class="title class_">Number</span>.<span class="property">NaN</span></span><br><span class="line"><span class="title class_">NaN</span></span><br></pre></td></tr></table></figure>

<p>NaN 与任何值比较都不相等，也不等于自己。这意味着不同通过 <code>x === NaN</code> 来检查一个值是否是 NaN，而应该使用 <code>Number.isNaN(x)</code> 函数或者 <code>x != x</code> 来判断。这两个表达式当且仅当 x 与全局常量 NaN 具有相同值时才返回 true。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; x = <span class="title class_">NaN</span></span><br><span class="line"><span class="title class_">NaN</span></span><br><span class="line">&gt; x === <span class="number">1</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&gt; x === x</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&gt; x != x</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; <span class="title class_">Number</span>.<span class="built_in">isNaN</span>(x)</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>全局函数 isNaN 与 Number.isNaN 类似，它会在参数是 NaN 时，或者在参数是无法转换为数值的非数值时返回 true。也就是说全局函数 isNaN 会在判断之前对传入的值进行类型转换，而 Number.isNaN 则不会进行转换操作，如果传入的不是数值，<code>Number.isNaN</code> 会直接返回 false。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">isNaN</span>(<span class="title class_">NaN</span>)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; <span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; <span class="built_in">isNaN</span>(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&gt; <span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&gt; <span class="built_in">isNaN</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; <span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>负零值也有点不同寻常。它与正零值相等（即便使用JavaScript的严格相等比较）​，这意味着除了作为除数使用，几乎无法区分这两个值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">0</span> === -<span class="number">0</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="title class_">Infinity</span></span><br><span class="line">&gt; <span class="number">1</span> / -<span class="number">0</span></span><br><span class="line">-<span class="title class_">Infinity</span></span><br><span class="line">&gt; <span class="number">1</span> / <span class="number">0</span> == <span class="number">1</span> / -<span class="number">0</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="二级制浮点数与舍入错误"><a href="#二级制浮点数与舍入错误" class="headerlink" title="二级制浮点数与舍入错误"></a>二级制浮点数与舍入错误</h3><p>实数是无穷的，但 JavaScript 浮点格式只能够表示其中有限个数。这意味着在通过 JavaScript 操作实数时，数值表示的经常是实际数值的近似值。</p>
<p>JavaScript（以及所有现代编程语言）使用的 IEEE-754 浮点表示法是一种二进制表示法，这种表示法可以精确地表示如 <code>1/2</code>、<code>1/8</code> 和 <code>1/1024</code> 等分数。我们最常用的分数是十进制分数：1&#x2F;10、1&#x2F;100 等等。二进制浮点表示法无法精确表示哪怕 0.1 这么简单的数。</p>
<p>虽然 JavaScript 数值有足够大的精度，能够非常近似地表示 0.1，但无法精确地表示。这可能导致一些问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">0.3</span> - <span class="number">0.2</span></span><br><span class="line"><span class="number">0.09999999999999998</span></span><br><span class="line">&gt; <span class="number">0.2</span> - <span class="number">0.1</span></span><br><span class="line"><span class="number">0.1</span></span><br><span class="line">&gt; <span class="number">0.3</span> - <span class="number">0.2</span> === <span class="number">0.1</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&gt; <span class="number">0.2</span> - <span class="number">0.1</span> === <span class="number">0.1</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>这并不是 JavaScript 独有的问题，而是所有使用二进制浮点数的编程语言共同的问题</strong>。所以对于浮点数，切记不要尝试比较它们的相等性。如果浮点近似值对你的程序而言是个问题，可以考虑使用等量整数。</p>
<h3 id="通过-BigInt-表示任意精度整数"><a href="#通过-BigInt-表示任意精度整数" class="headerlink" title="通过 BigInt 表示任意精度整数"></a>通过 BigInt 表示任意精度整数</h3><p>ES2020 为 JavaScript 定义了一种新的数值类型 BigInt。BigInt 这种数值类型的值是整数。之所以增加这个类型，主要是为了表示 64 位整数，这对于兼容很多其他语言和 API 是必需的。</p>
<p>BigInt 字面量写作一串数字后跟小写字母 n。默认情况下，基数是10，但可以通过前缀 <code>0b</code>、<code>0o</code> 和 <code>0x</code> 来表示二进制、八进制和十六进制 BigInt。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1234n</span></span><br><span class="line"><span class="number">1234n</span></span><br><span class="line">&gt; <span class="number">0b11111n</span></span><br><span class="line"><span class="number">31n</span></span><br><span class="line">&gt; <span class="number">0o10n</span></span><br><span class="line"><span class="number">8n</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="number">0x8000_0000_0000_0000</span></span><br><span class="line"><span class="number">9223372036854776000</span></span><br><span class="line">&gt; <span class="number">2</span>**<span class="number">63</span></span><br><span class="line"><span class="number">9223372036854776000</span></span><br><span class="line">&gt; <span class="number">0x8000_0000_0000_0000n</span></span><br><span class="line"><span class="number">9223372036854775808n</span></span><br></pre></td></tr></table></figure>

<p>可以通过 BigInt() 函数把常规的 JavaScript 数值或字符串转换为 BigInt 值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="title class_">BigInt</span>(<span class="number">1234</span>)</span><br><span class="line"><span class="number">1234n</span></span><br><span class="line">&gt; <span class="title class_">BigInt</span>(<span class="string">&quot;10000000000000000000000000000000&quot;</span>)</span><br><span class="line"><span class="number">10000000000000000000000000000000n</span></span><br></pre></td></tr></table></figure>

<p>BigInt 的算术运算与常规数值的算术运算类似，但是除法会丢弃余数并会向下舍入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1000n</span> + <span class="number">2000n</span></span><br><span class="line"><span class="number">3000n</span></span><br><span class="line">&gt; <span class="number">10n</span> * <span class="number">20n</span></span><br><span class="line"><span class="number">200n</span></span><br><span class="line">&gt; <span class="number">20n</span> / <span class="number">2n</span></span><br><span class="line"><span class="number">10n</span></span><br><span class="line">&gt; <span class="number">20n</span> / <span class="number">3n</span></span><br><span class="line"><span class="number">6n</span></span><br><span class="line">&gt; <span class="number">20</span> / <span class="number">3</span></span><br><span class="line"><span class="number">6.666666666666667</span></span><br></pre></td></tr></table></figure>

<p>需要注意，<strong>不能混用 BigInt 操作数和常规数值操作数</strong>。因为 BigInt 和 JavaScript 常规数值（Number）两种类型都不比另一种更通用：</p>
<ul>
<li>BigInt 可以表示超大值，但只能表示整数</li>
<li>JavaScript 可以表示小数，但是却不能像 BigInt 一样表示任意精度的整数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1</span> + <span class="number">2n</span></span><br><span class="line"><span class="title class_">Uncaught</span> <span class="title class_">TypeError</span>: <span class="title class_">Cannot</span> mix <span class="title class_">BigInt</span> and other types, use explicit conversions</span><br></pre></td></tr></table></figure>

<p>相对来说，比较操作符允许混合操作数类。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1</span> &lt; <span class="number">2n</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; <span class="number">2</span> &gt; <span class="number">1n</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; <span class="number">2</span> == <span class="number">2n</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; <span class="number">2</span> === <span class="number">2n</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>位操作符通常可以用于BigInt操作数。但 Math 对象的任何函数都不接收 BigInt 操作数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1n</span> &lt;&lt; <span class="number">3</span></span><br><span class="line"><span class="title class_">Uncaught</span> <span class="title class_">TypeError</span>: <span class="title class_">Cannot</span> mix <span class="title class_">BigInt</span> and other types, use explicit conversions</span><br><span class="line">&gt; <span class="number">1n</span> &lt;&lt; <span class="number">3n</span></span><br><span class="line"><span class="number">8n</span></span><br><span class="line">&gt; <span class="title class_">Math</span>.<span class="title class_">Min</span>(<span class="number">1n</span>, <span class="number">2n</span>)</span><br><span class="line"><span class="title class_">Uncaught</span> <span class="title class_">TypeError</span>: <span class="title class_">Math</span>.<span class="property">Min</span> is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure>

<h3 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h3><p>JavaScript 为表示和操作与日期及时间相关的数据而定义了简单的 Date 类。JavaScript 的 Date是对象，但也有数值表示形式，即自 1970年1月1日 起至今的毫秒数，也叫时间戳：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line"><span class="number">1736601447264</span></span><br><span class="line"></span><br><span class="line">&gt; tt.<span class="title function_">getTime</span>()</span><br><span class="line"><span class="number">1736601575200</span></span><br><span class="line">&gt; tt.<span class="title function_">toISOString</span>()</span><br><span class="line"><span class="string">&#x27;2025-01-11T13:19:35.200Z&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><p>JavaScript 中表示文本的类型是 String，即字符串：</p>
<ul>
<li>字符串是 16 位值的不可修改的有序序列</li>
<li>字符串的 length 属性是它包含的 16 位值的个数</li>
<li>字符串（及数组）都是基于 0 的索引</li>
<li>JavaScript 没有表示单个字符元素的专门类型。要表示一个 16 位值，使用长度为 1 的字符串即可</li>
</ul>
<h3 id="字符、码点和-JavaScript-字符串"><a href="#字符、码点和-JavaScript-字符串" class="headerlink" title="字符、码点和 JavaScript 字符串"></a>字符、码点和 JavaScript 字符串</h3><p><strong>JavaScript 使用 Unicode 字符集的 UTF-16 编码</strong>，因此 JavaScript 字符串是无符号 16 位值的序列</p>
<ul>
<li>最常用的 Unicode 字符的码点是 16 位的，可以使用字符串中的一个元素来表示</li>
<li>码点超过 16 位的 Unicode 字符使用 UTF-16 规则编码为两个 16 位值的序列（称为 <code>surrogate pairt</code>，即为代理对）。<strong>这意味着一个长度为 2（2 个 16 位值）的 JavaScript 字符串可能表示的只是一个 Unicode 字符</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> euro = <span class="string">&quot;€&quot;</span></span><br><span class="line">&gt; euro.<span class="property">length</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt; euro[<span class="number">0</span>]</span><br><span class="line"><span class="string">&#x27;€&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">let</span> love = <span class="string">&quot;💙&quot;</span></span><br><span class="line">&gt; love.<span class="property">length</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt; love[<span class="number">0</span>]</span><br><span class="line"><span class="string">&#x27;\ud83d&#x27;</span></span><br><span class="line">&gt; love[<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;\udc99&#x27;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript 的字符串操作方法一般操作的是 16 位值，而不是字符。但在 ES6 中，字符串是可迭代的，如果对字符串使用 <code>for/of</code> 或 <code>...</code> 操作符，迭代的是字符而不是 16 位值。</p>
<h3 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h3><p>JavaScript 字符串字面量可以通过把字符序列放到 <code>单引号</code>、<code>双引号</code> 或 <code>反引号</code>（ES6）中来创建。双引号字符和反引号字符可以出现在由单引号定界的字符串中，同理，由双引号或反引号定界的字符串也可以包含另外两种引号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="string">&quot;&quot;</span></span><br><span class="line">&gt; <span class="string">&#x27;testing&#x27;</span></span><br><span class="line">&gt; <span class="string">&#x27;name=&quot;From&quot;&#x27;</span></span><br><span class="line">&gt; <span class="string">&quot;it&#x27;s me&quot;</span></span><br><span class="line">&gt; <span class="string">`She said &quot;it&#x27;s ok&quot;`</span></span><br></pre></td></tr></table></figure>

<p>JavaScript 最早的版本要求字符串字面量必须写在一行，此时会使用 <code>+</code> 来实现字符串拼接。ES5 开始可以通过每行末尾添加 <code>\</code> 将字符串字面量拆分成多行，这个反斜杠和后面的行终结符都不属于当前字符串字面量。如果需要在单引号、双引号字符串中添加换行符，则需要使用 <code>\n</code>。ES6 的反引号支持跨行字符串。</p>
<p>如果需要将 HTML 代码与 JavaScript 混合在一起，最好 JavaScript 和 HTML 分别使用不同的引号。</p>
<h3 id="字符串字面量中的转义序列"><a href="#字符串字面量中的转义序列" class="headerlink" title="字符串字面量中的转义序列"></a>字符串字面量中的转义序列</h3><p><strong>反斜杠 <code>\</code> 与后面的字符组合在一起，可以在字符串中表示一个无法直接表示的字符</strong>，因此被称为转义序列：</p>
<ul>
<li><code>\0</code>、<code>\n</code>、<code>\v</code>、 <code>\r</code>、 <code>\n</code>、<code>\&#39;</code>、<code>\&quot;</code> 都是转义字符，可以表示特定的字符</li>
<li><code>\xnn</code> 可以表示由 2 位十六进制数 nn 指定的 Unicode 字符</li>
<li><code>\unnnn</code> 可以表示由 4 位十六进制数 nnnn 指定的 Unicode 字符</li>
<li><code>\u&#123;n&#125;</code> 可以表示由码点 n 指定的 Unicode 字符，其中 n 是介于 0 到 10FFFF 之间的 1 到 6 个十六进制数字（ES6）</li>
</ul>
<p>如果字符 <code>\</code> 位于非有效转义序列的前面，则这个 <code>\</code> 会被忽略，因此 <code>\#</code> 等效于 <code>#</code>。</p>
<h3 id="使用字符串"><a href="#使用字符串" class="headerlink" title="使用字符串"></a>使用字符串</h3><ul>
<li>拼接字符串是 JavaScript 的一个内置特性。可以使用 <code>+</code> 操作符进行字符串拼接。</li>
<li>可以使用 <code>===</code> 和 <code>!==</code> 来比较字符串，只有当这两个字符串具有完全相同的16位值的序列时才相等。</li>
<li>字符串也可以使用 &lt;、&lt;&#x3D;、&gt; 和 &gt;&#x3D; 操作符来比较</li>
<li>使用 <code>s.length</code> 获取字符串的长度，<strong>即字符串包含的 16 位值的个数</strong></li>
<li>JavaScript 也提供了丰富的操作字符串的 API</li>
<li>JavaScript 的字符串都是不可修改的，所以修改字符串的 API 其实是创建一个新的字符串，它们并不会修改原始字符串</li>
<li>字符串也可以被当成数组，使用 <code>[]</code> 来访问字符串中的某个字符（十六位数值）</li>
</ul>
<h3 id="模版字面量"><a href="#模版字面量" class="headerlink" title="模版字面量"></a>模版字面量</h3><p>反引号字符串不仅仅是一种新的字符串字面量语法，它其实提供了模版字面量的功能。它可以包含任意的 JavaScript 表达式。反引号中字符串字面量最终值的计算，涉及对其中包含的所有表达式求值、将这些表达式的值转换为字符串，然后再把这些字符串与反引号中的字面量组合：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> name = <span class="string">&quot;Bill&quot;</span></span><br><span class="line">&gt; <span class="string">`Hello <span class="subst">$&#123; name &#125;</span>`</span></span><br><span class="line"><span class="string">&#x27;Hello Bill&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>位于 <code>$&#123;&#125;</code> 中的内容都会被当成 JavaScript 表达式来解释，而之外的内容则当成常规字符串字面量</li>
<li>模板字面量可以包含任意数量的表达式，可以包含任何常规字符串中可以出现的转义字符，也可以跨任意多行而无须特殊转义</li>
</ul>
<p>模版字面量还有一个特性：如果在开头的反引号前面有一个函数名（标签）​，那么模板字面量中的文本和表达式的值将作为参数传给这个函数。​<code>标签化模板字面量(tagged template literal)</code> 的值就是这个函数的返回值。注意，即使标签化模板字面量的标签部分是函数，在调用这个函数时也没有圆括号。在这种非常特别的情况下，反引号字符充当开头和末尾的圆括号。</p>
<p>ES6 提供过了一个内置的标签函数 <code>String.raw</code>，这个函数返回反引号中未经处理的文本，即不会处理任何反斜杠转义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="string">&quot;\n&quot;</span>.<span class="property">length</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt; <span class="title class_">String</span>.<span class="property">raw</span><span class="string">`\n`</span>.<span class="property">length</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>JavaScript 定义了一种被称为正则表达式（或 RegExp）的数据类型，用于描述和匹配文本中的字符串模式。RegExp 不是JavaScript中的基础类型，但具有类似数值和字符串的字面量语法。</p>
<ul>
<li>一对斜杠之间的文本构成正则表达式字面量。这对斜杠中的第二个后面也可以跟一个或多个字母，用于修改模式的含义</li>
<li>RegExp 对象定义了一些有用的方法，而字符串也有接收 RegExp 参数的方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="regexp">/^HTML/</span></span><br><span class="line">&gt; <span class="regexp">/[1-9][0-9]*/</span></span><br><span class="line">&gt; <span class="regexp">/\bjavascript\b/i</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> text =<span class="string">&quot;HTML, CSS, JavaScript&quot;</span></span><br><span class="line">&gt; <span class="keyword">let</span> pattern = <span class="regexp">/^HTML/</span></span><br><span class="line">&gt; pattern.<span class="title function_">test</span>(text)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; text.<span class="title function_">search</span>(pattern)</span><br><span class="line"><span class="number">0</span></span><br><span class="line">&gt; text.<span class="title function_">replace</span>(pattern, <span class="string">&quot;HTML5&quot;</span>)</span><br><span class="line"><span class="string">&#x27;HTML5, CSS, JavaScript&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><ul>
<li>布尔类型只有两个值：<code>true</code> 和 <code>false</code>，布尔值在 JavaScript 中常用于控制结构</li>
<li>JavaScript 的任何值都可以转换为布尔值。<ul>
<li><code>undefined</code>、<code>null</code>、<code>0</code>、<code>-0</code> <code>NaN</code> 和 <code>&quot;&quot;</code>（空字符串）都转换为 <code>false</code></li>
<li>其他值包括所有对象和数组都转换为 <code>true</code></li>
</ul>
</li>
<li>布尔值有一个 <code>toString()</code> 方法，可用于将自己转换为字符串 <code>true</code> 或 <code>false</code>。除此之外，布尔值再没有其他有用的方法了</li>
<li><code>&amp;&amp;</code> 布尔与运算：两个操作数都为真，结果才为真；任意一个操作数为假，结果为假</li>
<li><code>||</code> 布尔或运算：任意一个操作数为真，结果为真；两个操作数都为假，结果为假</li>
<li><code>!</code>  布尔非运算，对布尔值取反</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; (!!<span class="number">0</span>).<span class="title function_">toString</span>()</span><br><span class="line"><span class="string">&#x27;false&#x27;</span></span><br><span class="line">&gt; (!!<span class="string">&quot;0&quot;</span>).<span class="title function_">toString</span>()</span><br><span class="line"><span class="string">&#x27;true&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="null-与-undefined"><a href="#null-与-undefined" class="headerlink" title="null 与 undefined"></a>null 与 undefined</h2><p>null 是一个语言关键字，其为一个特殊值，用于表示某个值不存在。对 <code>null</code> 执行 <code>typeof</code> 会返回字符串 <code>&#39;object&#39;</code>，表明可以将 null 看成一种特殊对象。但在实践中，null 通常被当作它自己类型的唯一成员，可以用来表示数值、字符串以及对象“没有值”​。</p>
<p>JavaScript 中的 undefined 也表示值不存在，但 undefined 表示一种更深层次的不存在。对 undefined 应用 typeof 操作符会返回 <code>undefined</code>，表示这个值是该特殊类型的唯一成员。</p>
<ul>
<li>变量的值未初始化时就是 undefined</li>
<li>在查询不存在的对象属性或数组元素时也会得到 undefined</li>
<li>没有明确返回值的函数返回的值是 undefined</li>
<li>没有传值的函数参数的值也是 undefined</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">typeof</span> <span class="literal">null</span></span><br><span class="line"><span class="string">&#x27;object&#x27;</span></span><br><span class="line">&gt; <span class="keyword">typeof</span> <span class="literal">undefined</span></span><br><span class="line"><span class="string">&#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>可以用 undefined 表示一种系统级别、意料之外或类似错误的没有值，可以用 null 表示程序级别、正常或意料之中的没有值</strong>。</p>
<h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><p>符号（Symbol）是 ES6 新增的一种原始类型，用作非字符串的属性名。要理解符号，需要了解 JavaScript 的基础类型 Object 是一个属性的无序集合，其中每个属性都有一个名字和一个值。<strong>属性名通常是（在 ES6 之前一直必须是）字符串。但在 ES6 和之后的版本中，符号也可以作为属性名</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> strname = <span class="string">&quot;string name&quot;</span></span><br><span class="line">&gt; <span class="keyword">let</span> symname = <span class="title class_">Symbol</span>(<span class="string">&quot;propname&quot;</span>)</span><br><span class="line">&gt; <span class="keyword">typeof</span> strname</span><br><span class="line"><span class="string">&#x27;string&#x27;</span></span><br><span class="line">&gt; <span class="keyword">typeof</span> symname</span><br><span class="line"><span class="string">&#x27;symbol&#x27;</span></span><br><span class="line">&gt; o[strname] = <span class="number">1</span></span><br><span class="line">&gt; o[symname] = <span class="number">2</span></span><br><span class="line">&gt; o</span><br><span class="line">&#123; <span class="string">&#x27;string name&#x27;</span>: <span class="number">1</span>, [<span class="title class_">Symbol</span>(propname)]: <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure>

<p>Symbol 类型没有字面量语法，要获取一个 Symbol 值，需要调用 Symbol() 函数。<strong>这个函数永远不会返回相同的值，即使每次传入的参数都一样</strong>，这意味着可以将 <code>调用Symbol()取得的符号值</code> 安全地用于为对象添加新属性，而无须担心可能重写已有的同名属性。</p>
<p>实践中，符号通常用作一种语言扩展机制。有时候我们选择任何特定的字符串作为标准的新增属性名，都有可能破坏已有的代码。因此符号名应运而生。<code>Symbol.iterator</code> 是一个符号值，可用作一个方法名，让对象变得可迭代。</p>
<p><code>Symbol()</code> 函数可选地接收一个字符串参数，返回唯一的符号值。如果提供了字符串参数，那么调用返回符号值的 toString() 方法得到的结果中会包含该字符串</p>
<p>有时我们希望定义一些可以与其他代码共享的符号值。例如，我们定义了某种扩展，希望别人的代码也可以使用，就像前面提到的 <code>Symbol.iterator</code> 机制一样。JavaScript 定义了一个全局符号注册表。<code>Symbol.for()</code> 函数接收一个字符串参数，返回一个与该字符串关联的符号值。</p>
<ul>
<li>如果没有符号与该字符串关联，则会创建并返回一个新符号</li>
<li>否则，就会返回已有的符号</li>
</ul>
<p>因此 <code>Symbol.for()</code> 函数与 <code>Symbol()</code> 函数完全不同：</p>
<ul>
<li><code>Symbol()</code> 函数永远都不会返回相同值</li>
<li>而 <code>Symbol.for()</code> 在以相同的字符串调用时始终返回相同的值</li>
<li>通过 <code>Symbol.keyFor()</code> 函数可以查询全局符号注册表中某个符号的字符串键</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> s = <span class="title class_">Symbol</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">&gt; <span class="keyword">let</span> t = <span class="title class_">Symbol</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">&gt; s === t</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">&gt; <span class="keyword">let</span> t1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">&gt; s1 === t1</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s1)</span><br><span class="line"><span class="string">&#x27;test&#x27;</span></span><br><span class="line">&gt; <span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(t1)</span><br><span class="line"><span class="string">&#x27;test&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h2><p>全局对象的属性是全局性定义的标识符，可以在 JavaScript 程序的任何地方使用。JavaScript 解释器启动后（或每次浏览器加载新的页面时），都会创建一个新的全局对象并为其添加一组初始的属性，定义了：</p>
<ul>
<li>undefined、Infinity、NaN 等全局常量</li>
<li>isNaN()、parseInt() 等全局函数</li>
<li>Date()、String()、RegExp() 等全局构造函数</li>
<li>Math 和 JSON 等全局对象</li>
</ul>
<p><strong>全局对象的初始属性并不是保留字，但它们应该都被当成保留字</strong>。</p>
<p>在 Node 中，全局对象有一个名为 global 的属性，其值为全局对象本身，因此在 Node 程序中始终可以通过 global 来引用全局对象。</p>
<p>在浏览器中，Window 对象对浏览器窗口中的所有 JavaScript 代码而言，充当了全局对象的角色。这个全局的 Window 对象有一个自引用的 window 属性，可以引用全局对象。Window 对象定义了核心全局属性，也定义了其他一些特定于浏览器和客户端 JavaScript 的全局值。</p>
<p>ES2020 最终定义了 globalThis 作为在任何上下文中引用全局对象的标准方式。2020年初，所有现代浏览器和 Node 都实现了这个特性。</p>
<h2 id="不可修改的原始值与可修改的对象引用"><a href="#不可修改的原始值与可修改的对象引用" class="headerlink" title="不可修改的原始值与可修改的对象引用"></a>不可修改的原始值与可修改的对象引用</h2><p>JavaScript 中的原始类型的值（undeifned、null、boolean、number 和 string）是不可修改的。尤其是字符串，所有看起来返回一个修改后字符串的字符串方法，实际上返回的都是一个新字符串。原始值是按值比较的，即两个值只有在它们的值相同的时候才是相同的（当且仅当这两个字符串长度相同并且每个索引的字符也相同时，JavaScript 才认为它们相等）。</p>
<p>对象不同于原始值，对象是可修改的，即它们的值可以改变。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> o = &#123; x : <span class="number">1</span> &#125;</span><br><span class="line">&gt; o.<span class="property">x</span> = <span class="number">2</span></span><br><span class="line">&gt; o.<span class="property">y</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>对象不是按值比较的，两个不同的对象即使拥有完全相同的属性和值，它们也不相等</strong>。同样，两个不同的数组，即使每个元素都相同，它们也不相等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> o = &#123; x : <span class="number">1</span> &#125;</span><br><span class="line">&gt; o.<span class="property">x</span> = <span class="number">2</span></span><br><span class="line">&gt; o.<span class="property">y</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">let</span> oo = &#123; <span class="attr">x</span>: <span class="number">2</span>, <span class="attr">y</span>: <span class="number">3</span> &#125;</span><br><span class="line">&gt; o === oo</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&gt; [] === []</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>对象有时候被称作引用类型（reference type），以区别于 JavaScript 的原始类型。基于这一术语，对象值就是引用，对象是按引用比较的。换句话说，<strong>两个对象值当且仅当它们引用同一个底层对象时，才是相等的</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> a = []</span><br><span class="line">&gt; b = a</span><br><span class="line">&gt; b[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">&gt; a[<span class="number">0</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt; a === b</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>把对象（或数组）赋值给一个变量，<strong>其实是在赋值引用</strong>，并不会创建对象的新副本。如果想创建对象或数组的新副本，必须显式复制对象的属性或数组的元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt; <span class="keyword">let</span> b1 = <span class="title class_">Array</span>.<span class="title function_">from</span>(a1)</span><br><span class="line">&gt; b1</span><br><span class="line">[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ]</span><br><span class="line">&gt; a1 === b1</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>所以如果想要比较两个对象或数组的内容是否相等，必须比较它们的属性或者元素：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">equalArray</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a === b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (a.<span class="property">length</span> != b.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] != b[i]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">equalArray</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])) <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">equalArray</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [])) <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><strong>JavaScript 对待自己所需值的类型非常灵活</strong></p>
<ul>
<li>如果 JavaScript 需要布尔值，会将其他类型的值转换为 true 或者 false</li>
<li>如果 JavaScript 想要字符串，它就会把你提供的任何值都转换为字符串</li>
<li>如果 JavaScript 想要数值，它也会尝试把你给的值转换为一个数值，如果无法进行有意义的转换就转换为NaN​</li>
</ul>
<p>下表展示了 JavaScript 中类型之间的转换关系：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>转换为字符串</th>
<th>转换为数值</th>
<th>转换为布尔值</th>
</tr>
</thead>
<tbody><tr>
<td>undefiend</td>
<td>“undefined”</td>
<td>NaN</td>
<td>false</td>
</tr>
<tr>
<td>null</td>
<td>“null”</td>
<td>0</td>
<td>false</td>
</tr>
<tr>
<td>true</td>
<td>“true”</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>false</td>
<td>“false”</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>“”</td>
<td></td>
<td>0</td>
<td>false</td>
</tr>
<tr>
<td>“1.2”</td>
<td></td>
<td>1.2</td>
<td>true</td>
</tr>
<tr>
<td>“one”</td>
<td></td>
<td>NaN</td>
<td>true</td>
</tr>
<tr>
<td>0</td>
<td>“0”</td>
<td></td>
<td>false</td>
</tr>
<tr>
<td>-0</td>
<td>“0”</td>
<td></td>
<td>false</td>
</tr>
<tr>
<td>1</td>
<td>“1”</td>
<td></td>
<td>true</td>
</tr>
<tr>
<td>Infinity</td>
<td>“Infinity”</td>
<td></td>
<td>true</td>
</tr>
<tr>
<td>-Infinity</td>
<td>“-Infinity”</td>
<td></td>
<td>true</td>
</tr>
<tr>
<td>NaN</td>
<td>“NaN”</td>
<td></td>
<td>false</td>
</tr>
<tr>
<td>{}（任何对象）</td>
<td>后文介绍</td>
<td>后文介绍</td>
<td>true</td>
</tr>
<tr>
<td>[]（空数组）</td>
<td>“”</td>
<td>0</td>
<td>true</td>
</tr>
<tr>
<td>[9]（一个数值元素）</td>
<td>“9”</td>
<td>9</td>
<td>true</td>
</tr>
<tr>
<td>[‘a’]（任何其他数组）</td>
<td>使用 join 方法</td>
<td>NaN</td>
<td>true</td>
</tr>
<tr>
<td>Function{}</td>
<td>后文介绍</td>
<td>NaN</td>
<td>true</td>
</tr>
</tbody></table>
<h3 id="转换与相等"><a href="#转换与相等" class="headerlink" title="转换与相等"></a>转换与相等</h3><p>JavaScript有两个操作符用于测试两个值是否相等：</p>
<ul>
<li>一个是严格相等操作符 <code>===</code>，如果两个值不是同一种类型，那么这个操作符就不会判定它们相等</li>
<li>由于 JavaScript 在类型转换上很灵活，所以它也定义了 <code>==</code> 操作符，这个操作符判定相等的标准相当灵活</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="literal">null</span> === <span class="literal">undefined</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&gt; <span class="string">&quot;0&quot;</span> === <span class="number">0</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&gt; <span class="string">&quot;0&quot;</span> == <span class="number">0</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; <span class="number">0</span> == <span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; <span class="string">&quot;0&quot;</span> == <span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>一个值可以转换为另一个值并不意味着这两个值是相等的。<strong>JavaScript 操作符和语句期待不同类型的值，因此会执行以这些类型为目标类型的转换</strong>。例如，if 语句将 undefined 转换为 false，但 &#x3D;&#x3D; 操作符永远不会将其操作数转换为布尔值。</p>
<h3 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h3><p>执行显示类型转换的最简单方法就是使用 Boolean()、Number() 和 String() 函数。除 null 和 undefined 之外的所有值都有 toString() 方法，这个方法返回的结果通常与 String() 函数返回的结果相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="title class_">Number</span>(<span class="string">&quot;3&quot;</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt; <span class="title class_">String</span>(<span class="literal">false</span>)</span><br><span class="line"><span class="string">&#x27;false&#x27;</span></span><br><span class="line">&gt; <span class="title class_">Boolean</span>([])</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>另外，Boolean()、Number() 和 String() 函数也可以被当作构造函数通过 new 关键字来使用。如果你这样使用它们，那会得到一个与原始布尔值、数值和字符串值类似的 <code>包装</code> 对象。这种包装对象是早期 JavaScript 的历史遗存，已经没有必要再使用它们了。</p>
<p>某些JavaScript操作符会执行隐式类型转换，有时候可以利用这一点完成类型转换：</p>
<ul>
<li>如果 <code>+</code> 操作符有一个操作数是字符串，那它会把另一个操作数转换为字符串</li>
<li>一元操作符 <code>+</code> 会把自己的操作数转换为数值</li>
<li>而一元操作符 <code>!</code> 会把自己的操作数转换为布尔值，然后再取反</li>
</ul>
<p>所以经常看到这样的代码其实是执行类型转换：</p>
<ul>
<li><code>x + &quot;&quot;</code>    &#x2F;&#x2F; &#x3D;&gt; String(x)</li>
<li><code>+x</code>       &#x2F;&#x2F; &#x3D;&gt; Number(x)</li>
<li><code>x - 0</code>    &#x2F;&#x2F; &#x3D;&gt; Number(x)</li>
<li><code>!!x</code>      &#x2F;&#x2F; &#x3D;&gt; Boolean(x)</li>
</ul>
<p>Number类定义的一些类型转换方法，可以提供更多的精细控制能力：</p>
<ul>
<li>toString()方法接收一个可选的参数，用于指定一个基数或底数（不指定默认为 10）</li>
<li>toFixed()把数值转换为字符串时可以指定小数点后面的位数</li>
<li>toExponential() 使用指数记数法将数值转换为字符串，结果是小数点前保留 1 位，小数点后保留指定位数</li>
<li>toPrecision() 按照指定的有效数字个数将数值转换为字符串。如果有效数字个数不足以显示数值的整数部分，它会使用指数记数法</li>
<li>以上三种方法必要时都会舍去末尾的数字或者补零</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> n = <span class="number">17</span></span><br><span class="line">&gt; n.<span class="title function_">toString</span>(<span class="number">8</span>)</span><br><span class="line"><span class="string">&#x27;21&#x27;</span></span><br><span class="line">&gt; n.<span class="title function_">toString</span>(<span class="number">16</span>)</span><br><span class="line"><span class="string">&#x27;11&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">let</span> m = <span class="number">123456.789</span></span><br><span class="line">&gt; m.<span class="title function_">toFixed</span>(<span class="number">0</span>)</span><br><span class="line"><span class="string">&#x27;123457&#x27;</span></span><br><span class="line">&gt; m.<span class="title function_">toFixed</span>(<span class="number">2</span>)</span><br><span class="line"><span class="string">&#x27;123456.79&#x27;</span></span><br><span class="line">&gt; m.<span class="title function_">toFixed</span>(<span class="number">5</span>)</span><br><span class="line"><span class="string">&#x27;123456.78900&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt; m.<span class="title function_">toExponential</span>(<span class="number">1</span>)</span><br><span class="line"><span class="string">&#x27;1.2e+5&#x27;</span></span><br><span class="line">&gt; m.<span class="title function_">toExponential</span>(<span class="number">3</span>)</span><br><span class="line"><span class="string">&#x27;1.235e+5&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt; m.<span class="title function_">toPrecision</span>(<span class="number">4</span>)</span><br><span class="line"><span class="string">&#x27;1.235e+5&#x27;</span></span><br><span class="line">&gt; m.<span class="title function_">toPrecision</span>(<span class="number">7</span>)</span><br><span class="line"><span class="string">&#x27;123456.8&#x27;</span></span><br><span class="line">&gt; m.<span class="title function_">toPrecision</span>(<span class="number">10</span>)</span><br><span class="line"><span class="string">&#x27;123456.7890&#x27;</span></span><br></pre></td></tr></table></figure>

<p>字符串转换为数值时：</p>
<ul>
<li>如果把字符串传给 Number() 转换函数，它会尝试把字符串当成整数或浮点数字面量来解析。这个函数只能处理基数为 10 的整数，不允许首尾出现非空格的无关字符</li>
<li><code>parseInt()</code> 和 <code>parseFloat()</code> 函数则更灵活一些。<code>parseInt()</code> 只解析整数，而 <code>parseFloat()</code> 既解析整数也解析浮点数</li>
<li>如果字符串以 <code>0x</code> 或 <code>0X</code> 开头，<code>parseInt()</code> 会将其解析为十六进制数值</li>
<li>parseInt() 接收可选的第二个参数，用于指定要解析数值的底（基）数，合法的值是 2 到 36</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="title class_">Number</span>(<span class="string">&quot; 10&quot;</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line">&gt; <span class="title class_">Number</span>(<span class="string">&quot;x10&quot;</span>)</span><br><span class="line"><span class="title class_">NaN</span></span><br><span class="line">&gt; <span class="title class_">Number</span>(<span class="string">&quot;10x&quot;</span>)</span><br><span class="line"><span class="title class_">NaN</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">parseInt</span>(<span class="string">&quot;0o10&quot;</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line">&gt; <span class="built_in">parseInt</span>(<span class="string">&quot;0x10&quot;</span>)</span><br><span class="line"><span class="number">16</span></span><br><span class="line">&gt; <span class="built_in">parseInt</span>(<span class="string">&quot;Y10&quot;</span>)</span><br><span class="line"><span class="title class_">NaN</span></span><br><span class="line">&gt; <span class="built_in">parseInt</span>(<span class="string">&quot;10Y&quot;</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">parseInt</span>(<span class="string">&quot;11&quot;</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt; <span class="built_in">parseInt</span>(<span class="string">&quot;11&quot;</span>, <span class="number">16</span>)</span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure>

<h3 id="对象到原始值的转换"><a href="#对象到原始值的转换" class="headerlink" title="对象到原始值的转换"></a>对象到原始值的转换</h3><p>接下来介绍 JavaScript 将对象转换为原始值时要遵循的复杂规则，这些规则冗长、晦涩。JavaScript 对象到原始值转换的复杂性，主要原因在于某些对象类型有不止一种原始值的表示。JavaScript 规范定义了对象到原始值转换的 3 种基本算法。</p>
<ul>
<li>偏字符串：该算法返回原始值，而且只要可能就返回字符串</li>
<li>偏数值：该算法返回原始值，而且只要可能就返回数值</li>
<li>无偏好：该算法不倾向于任何原始值类型，而是由类定义自己的转换规则</li>
</ul>
<p><strong>JavaScript 内置类型除了 Date 类都实现了偏数值算法，Date 类实现了偏字符串算法。接下来我们先介绍哪些情况下会使用到这些算法</strong>：</p>
<p><strong>对象转换为布尔值</strong>：</p>
<ul>
<li>所有对象都转换为true</li>
<li>这个转换不需要使用前面介绍的对象到原始值的转换算法，而是直接适用于所有对象</li>
<li>包括空数组，甚至包括 new Boolean(false) 这样的包装对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> t = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>)</span><br><span class="line">&gt; !!t</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>对象转换为字符串</strong>：</p>
<ul>
<li>JavaScript 首先使用偏字符串算法将它转换为一个原始值，然后将得到的原始值再转换为字符串</li>
<li>当把对象传递给接受字符串参数的内置函数时、或者调用 <code>String()</code> 进行转换时、或者将对象插入到模版字面量中时，就会发生这种转换</li>
</ul>
<p><strong>对象转换为数值</strong>：</p>
<ul>
<li>JavaScript 首先使用偏数值算法将它转换为一个原始值，然后将得到的原始值再转换为数值</li>
<li>接收数值参数的内置 JavaScript 函数和方法都以这种方式将对象转换为数值，希望接受数值参数的操作符也是按照这种方式把对象转换为数值（以下操作符转换特例除外）：</li>
</ul>
<p>接下来再介绍一些操作符转换特例：</p>
<ul>
<li>JavaScript中的 + 操作符可以执行数值加法和字符串拼接：<ul>
<li>如果操作数是对象，那 JavaScript 会使用无偏好算法将对象转换为原始值</li>
<li>一旦两个操作数都是原始值，则会先检查它们的类型。如果有一个参数是字符串，则把另一个原始值也转换为字符串并拼接两个字符串</li>
<li>否则，把两个参数都转换为数值并把它们相加</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="string">&quot;1&quot;</span> + <span class="number">1</span></span><br><span class="line"><span class="string">&#x27;11&#x27;</span></span><br><span class="line">&gt; <span class="number">1</span> + <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="string">&#x27;11&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>==</code> 和 <code>!=</code> 操作符以允许类型转换的宽松方式执行相等和不相等测试</p>
<ul>
<li>如果一个操作数是对象，另一个操作数是原始值，则这两个操作符会使用无偏好算法将对象转换为原始值，然后再比较两个原始值</li>
</ul>
</li>
<li><p>关系操作符 &lt;、&lt;&#x3D;、&gt; 和 &gt;&#x3D; 用于比较操作数，它们既可以比较数值，也可以比较字符串</p>
<ul>
<li>如果操作数中有一个是对象，则会使用偏数值算法将对象转换为原始值。不过要注意，与对象到数值转换不同，这个偏数值算法返回的原始值不会再被转换为数值</li>
</ul>
</li>
</ul>
<p>所有对象都会继承 <code>toString()</code> 和 <code>toValue()</code> 这两个方法，它们在对象到原始值转换时会被用到。</p>
<ul>
<li><code>toString()</code> 方法返回对象的字符串表示，默认情况下，该方法不会返回有意义的值。很多类都定义了自己特有的 toString() 版本</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;.<span class="title function_">toString</span>()</span><br><span class="line"><span class="string">&#x27;[object Object]&#x27;</span></span><br><span class="line">&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">toString</span>()</span><br><span class="line"><span class="string">&#x27;1,2,3&#x27;</span></span><br><span class="line">&gt; <span class="regexp">/\d+/</span>.<span class="title function_">toString</span>()</span><br><span class="line"><span class="string">&#x27;/\\d+/&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>valueOf()</code> 方法并没有明确的任务定义，主要认为它可以将对象转换为代表对象的原始值（如果的确存在这样一个原始值）。<code>valueOf()</code> 方法默认返回对象本身</li>
</ul>
<p>现在我们可以大致介绍前面 3 个对象到原始值的转换算法的实现了：</p>
<ul>
<li><p>偏字符串算法：</p>
<ul>
<li>首先尝试 toString() 方法。如果这个方法有定义且返回原始值，则 JavaScript 使用该原始值（即使这个值不是字符串）​</li>
<li>如果 toString() 不存在，或者存在但返回对象，则 JavaScript 尝试 valueOf() 方法。如果这个方法存在且返回原始值，则 JavaScript 使用该值。</li>
<li>否则，转换失败，报 TypeError</li>
</ul>
</li>
<li><p>偏数值算法：</p>
<ul>
<li>与偏字符串算法类似，只不过是先尝试 valueOf() 方法，再尝试 toString() 方法</li>
</ul>
</li>
<li><p>无偏好算法：</p>
<ul>
<li>无偏好算法取决于被转换对象的类</li>
<li>如果是一个 Date 对象，则 JavaScript 使用偏字符串算法</li>
<li>如果是其他类型的对象，则 JavaScript 使用偏数值算法</li>
</ul>
</li>
</ul>
<p>了解这些转换规则，我们就能理解为什么单个数值元素的数组可以转换为数值了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="title class_">String</span>([<span class="number">1</span>])</span><br><span class="line"><span class="string">&#x27;1&#x27;</span></span><br><span class="line">&gt; <span class="title class_">String</span>([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="string">&#x27;1,2&#x27;</span></span><br><span class="line">&gt; <span class="title class_">Number</span>([<span class="number">1</span>])</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt; <span class="title class_">Number</span>([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="title class_">NaN</span></span><br></pre></td></tr></table></figure>

<h2 id="变量声明与赋值"><a href="#变量声明与赋值" class="headerlink" title="变量声明与赋值"></a>变量声明与赋值</h2><p>当把名字和值进行绑定时，我们通会说把值赋值给变量。变量意味着可以为其赋予新值，即变量所关联的值在程序运行期间可能会变化。如果把一个值永久地赋给一个名字，那么成该名字为常量而不是变量。</p>
<p>在 JavaScript 中使用变量或常量前，必须先声明它</p>
<ul>
<li>在 ES6 及之后的版本中，这是通过 let 和 const 关键字来完成的</li>
<li>在ES6之前，变量是通过 var 声明的</li>
</ul>
<h3 id="使用-let-和-const-声明"><a href="#使用-let-和-const-声明" class="headerlink" title="使用 let 和 const 声明"></a>使用 let 和 const 声明</h3><p>在现代 JavaScript（ES6及之后）中，变量是通过 let 关键字声明的，可以使用一条 let 语句声明多个变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i;</span><br><span class="line"><span class="keyword">let</span> sum;</span><br><span class="line"><span class="keyword">let</span> j, x;</span><br></pre></td></tr></table></figure>

<p>声明变量的同时（如果可能）也为其赋予一个初始值是个好的编程习惯。如果在 let 语句中不为变量指定初始值，变量也会被声明，<strong>但在被赋值之前它的值是undefined</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line">&gt; <span class="keyword">let</span> s = <span class="string">&quot;hello&quot;</span></span><br><span class="line">&gt; <span class="keyword">let</span> jh</span><br><span class="line">&gt; i</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt; s</span><br><span class="line"><span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&gt; jh</span><br><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure>

<p>要声明常量而非变量，则要使用 const 而非 let。</p>
<ul>
<li>const 与 let 类似，<strong>区别在于 const 必须在声明时初始化常量</strong></li>
<li>常量的值是不能改变的，尝试给常量重新赋值会抛出 TypeError</li>
<li>声明常量的一个常见（但并非普遍性）的约定是全部字母大写</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> C = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">const</span> y;</span><br><span class="line"><span class="keyword">const</span> y;</span><br><span class="line">      ^</span><br><span class="line"><span class="title class_">Uncaught</span> <span class="title class_">SyntaxError</span>: <span class="title class_">Missing</span> initializer <span class="keyword">in</span> <span class="keyword">const</span> declaration</span><br><span class="line">&gt; C = <span class="number">200</span></span><br><span class="line"><span class="title class_">Uncaught</span> <span class="title class_">TypeError</span>: <span class="title class_">Assignment</span> to constant variable.</span><br></pre></td></tr></table></figure>

<p>JavaScript 允许在循环语法中声明循环变量，这也是 let 另一个常见的使用场景：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = data.<span class="property">length</span>; i &lt; length; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然看起来有点怪，但也可以使用 const 声明 for&#x2F;in 和 for&#x2F;of 中的这些循环“变量”​，只要保证在循环体内不给它重新赋值即可。此时，const 声明的只是一次循环迭代期间的常量值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">of</span> data) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变量与常量作用域"><a href="#变量与常量作用域" class="headerlink" title="变量与常量作用域"></a>变量与常量作用域</h3><p>通过 let 和 const 声明的变量和常量具有块作用域。这意味着它们只在 let 和 const 语句所在的代码块中有定义。</p>
<ul>
<li>JavaScript 类和函数的函数体是代码块，if&#x2F;else 语句的语句体、while 和 for 循环的循环体都是代码块</li>
<li>粗略地讲，如果变量或常量声明在一对花括号中，那这对花括号就限定了该变量或常量有定义的代码区域</li>
<li>在声明变量或常量的 let 或 const 语句之前的代码行中引用这些变量或常量也是不合法的</li>
<li>作为for、for&#x2F;in 或 for&#x2F;of 循环的一部分声明的变量和常量，以循环体作为它们的作用域，即使它们实际上位于花括号外部</li>
<li>如果声明位于顶级，在任何代码块外部，则称其为全局变量或常量，具有全局作用域<ul>
<li>在 Node 和客户端 JavaScript 模块中​，全局变量的作用域是定义它们的文件</li>
<li>在传统客户端 JavaScript 中，全局变量的作用域是定义它们的 HTML 文档</li>
</ul>
</li>
</ul>
<h3 id="重复声明"><a href="#重复声明" class="headerlink" title="重复声明"></a>重复声明</h3><p>在同一个作用域中使用多个 let 或 const 声明同一个名字是语法错误。在嵌套作用域中声明同名变量是合法的（尽管实践中最好不要这么做）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  i = <span class="number">20</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// =&gt; 20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">30</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// =&gt; 30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Cannot access &#x27;i&#x27; before initialization</span></span><br><span class="line">  i = <span class="number">40</span>;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">50</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="声明与类型"><a href="#声明与类型" class="headerlink" title="声明与类型"></a>声明与类型</h3><p>JavaScript 的变量声明与值的类型无关。JavaScript 变量可以保存任何类型的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> i = <span class="number">10</span></span><br><span class="line">&gt; i = <span class="string">&quot;test&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-var-的变量声明"><a href="#使用-var-的变量声明" class="headerlink" title="使用 var 的变量声明"></a>使用 var 的变量声明</h3><p>在 ES6 之前的 JavaScript 中，声明变量的唯一方式是使用 var 关键字，无法声明常量。var 的语法与 let 的语法相同：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> x = <span class="number">20</span></span><br><span class="line">&gt; <span class="keyword">var</span> xx</span><br><span class="line">&gt; x</span><br><span class="line"><span class="number">20</span></span><br><span class="line">&gt; xx</span><br><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure>

<p>虽然 var 和 let 有相同的语法，但它们也有重要的区别。</p>
<ul>
<li>使用 var 声明的变量不具有块作用域。这种变量的作用域仅限于包含函数的函数体，无论它们在函数中嵌套的层次有多深</li>
<li>如果在函数体外部使用 var，则会声明一个全局变量，通过 var 声明的全局变量与通过 let 声明的全局变量有一个重要区别<ul>
<li>通过 var 声明的全局变量被实现为全局对象的属性，且这个属性不能使用 delete 操作符删除</li>
<li>通过 let 和 const 声明的全局变量和常量不是全局对象的属性</li>
</ul>
</li>
<li>与通过 let 声明的变量不同，使用 var 在相同作用域内多次声明同名变量是合法的（var 变量都是具有函数作用域），而且这种重新声明也很常见</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// =&gt; 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>var 声明的一个最不同寻常的特性是作用域提升（hoisting）。在使用 var 声明变量时，该声明会被提高（或提升）到包含函数的顶部，但变量的初始化仍然在代码所在位置完成，只有变量的定义转移到了函数顶部。<ul>
<li>因此对使用 var 声明的变量，可以在包含函数内部的任何地方使用而不会报错</li>
<li>如果初始化代码尚未运行，则变量的值可能是 undefined，但在初始化之前是可以使用变量而不报错的</li>
<li>这会成为一个 bug 来源，也是 let 要纠正的一个最重要的错误特性。如果使用 let 声明了一个变量，但试图在 let 语句运行前使用该变量则会导致错误，而不是得到 undefined 值</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test3</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// =&gt; undefined</span></span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// =&gt; 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，关于使用未声明的变量，也有注意事项。</p>
<ul>
<li>在严格模式下​，如果试图使用未声明的变量，那代码运行时会触发引用错误</li>
<li>在严格模式外部，如果将一个值赋给尚未使用 let、const 或 var 声明的名字，则会创建一个新全局变量。且无论这个赋值语句在函数或代码块中被嵌套了多少次，都会创建一个全局变量。这很容易导致 bug，因此总是推荐使用严格模式</li>
<li>但是以这种意外方式创建的全局变量类似于使用 var 声明的全局变量，都是定义全局对象的属性。但是这些属性可以通过的 delete 删除</li>
</ul>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>ES6 实现了一种复合声明与赋值语法，叫作解构赋值（destructuring assignment）。</p>
<ul>
<li>等号右手端的值是数组或对象（<code>​结构化</code> 的值）​</li>
<li>左边通过模拟数组或对象字面量语法指定一个或多个变量</li>
<li>解构赋值会从右侧的值中提取出一个或多个值，并保存到左侧列出的变量中</li>
<li>解构赋值可能最常用于在 const、let 或 var 声明语句中初始化变量，但也可以在常规赋值表达式中使用。解构也可以在定义函数参数时使用</li>
<li>解构赋值让使用返回数组的函数变得异常便捷</li>
<li>也可以在这个 for 循环上下文中使用变量解构赋值</li>
<li>解构赋值左侧变量的个数不一定与右侧数组中元素的个数相同。左侧多余的变量会被设置为 undefined，而右侧多余的值会被忽略。左侧的变量列表可以包含额外的逗号，以跳过右侧的某些值</li>
<li>在解构赋值时，如果你想把所有未使用或剩余的值收集到一个变量中，可以在左侧最后一个变量名前面加上 <code>...</code></li>
<li>解构赋值可用于嵌套数组。此时，赋值的左侧看起来也应该像一个嵌套的数组字面量</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">&gt; x</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt; y</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt; [x, y] = [y, x]</span><br><span class="line">&gt; x</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt; y</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt; [,x,,,y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">&gt; x</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt; y</span><br><span class="line"><span class="number">5</span></span><br><span class="line">&gt; [x, ...y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">&gt; x</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt; y</span><br><span class="line">[ <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">let</span> [a, [b, c], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">name</span>:<span class="string">&quot;Mike&quot;</span>, <span class="attr">age</span>:<span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(o)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组解构的一个强大特性是它并不要求必须是数组！实际上，赋值的右侧可以是任何可迭代对象​，任何可以在 for&#x2F;of 循环中使用的对象也可以被解构：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> [x, ...y] = <span class="string">&quot;hello&quot;</span></span><br><span class="line">&gt; x</span><br><span class="line"><span class="string">&#x27;h&#x27;</span></span><br><span class="line">&gt; y</span><br><span class="line">[ <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span> ]</span><br></pre></td></tr></table></figure>

<p>解构赋值在右侧是对象值的情况下也可以执行。此时，赋值的左侧看起来就像一个对象字面量，<strong>即一个包含在花括号内的逗号分隔的变量名列表</strong>。</p>
<ul>
<li>赋值右侧对象中那些没有提到名字的属性都被忽略了。如果赋值的左侧包含一个不是右侧对象属性的变量名，该变量将被赋值 undefined。</li>
<li>左侧中变量的名称不一定要与结构对象的属性名称一致（当然这样做更好，保持简单、易于理解）。对象解构赋值左侧的每个标识符都可以是一个冒号分隔的标识符对，其中第一个标识符是要解构其值的属性名，第二个标识符是要把值赋给它的变量名</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> color = &#123;<span class="attr">r</span>: <span class="number">0</span>, <span class="attr">g</span>: <span class="number">100</span>, <span class="attr">b</span>:<span class="number">255</span>&#125;;</span><br><span class="line">&gt; <span class="keyword">let</span> &#123;r, g, b&#125; = color</span><br><span class="line">&gt; r</span><br><span class="line"><span class="number">0</span></span><br><span class="line">&gt; g</span><br><span class="line"><span class="number">100</span></span><br><span class="line">&gt; b</span><br><span class="line"><span class="number">255</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">let</span> &#123;name, age, country&#125; = &#123;<span class="attr">name</span>:<span class="string">&quot;mike&quot;</span>, <span class="attr">age</span>:<span class="number">20</span>, <span class="attr">heigth</span>:<span class="number">180</span>&#125;</span><br><span class="line">&gt; name</span><br><span class="line"><span class="string">&#x27;mike&#x27;</span></span><br><span class="line">&gt; age</span><br><span class="line"><span class="number">20</span></span><br><span class="line">&gt; country</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">let</span> &#123;<span class="attr">name</span>:n, <span class="attr">age</span>:a&#125; = &#123;<span class="attr">name</span>:<span class="string">&quot;jack&quot;</span>, <span class="attr">age</span>:<span class="number">21</span>&#125;</span><br><span class="line">&gt; n</span><br><span class="line"><span class="string">&#x27;jack&#x27;</span></span><br><span class="line">&gt; a</span><br><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure>

<p>在使用嵌套对象、对象的数组，或数组的对象时，解构赋值甚至会变得更复杂，但都是合法的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> [&#123;<span class="attr">x</span>: x1, <span class="attr">y</span>:y1&#125;, &#123;<span class="attr">x</span>:x2, <span class="attr">y</span>:y2&#125;] = [&#123;<span class="attr">x</span>:<span class="number">10</span>, <span class="attr">y</span>:<span class="number">20</span>&#125;, &#123;<span class="attr">x</span>:<span class="number">30</span>, <span class="attr">y</span>:<span class="number">40</span>&#125;]</span><br><span class="line">&gt; x1</span><br><span class="line"><span class="number">10</span></span><br><span class="line">&gt; y1</span><br><span class="line"><span class="number">20</span></span><br><span class="line">&gt; x2</span><br><span class="line"><span class="number">30</span></span><br><span class="line">&gt; y2</span><br><span class="line"><span class="number">40</span></span><br></pre></td></tr></table></figure>

<p>当然复杂的结构语法可能会导致代码难于理解，有时候还不如使用传统代码，这样更易于理解。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/%E5%89%8D%E7%AB%AF/" rel="tag"># 前端</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/01/11/javascript-guide-04/" rel="prev" title="JavaScript 权威指南 04：表达式与操作符">
      <i class="fa fa-chevron-left"></i> JavaScript 权威指南 04：表达式与操作符
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/01/09/javascript-guide-02/" rel="next" title="JavaScript 权威指南 02：词法结构">
      JavaScript 权威指南 02：词法结构 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%AE%9A%E4%B9%89"><span class="nav-number">1.</span> <span class="nav-text">概述与定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%80%BC"><span class="nav-number">2.</span> <span class="nav-text">数值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-number">2.1.</span> <span class="nav-text">整数字面量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-number">2.2.</span> <span class="nav-text">浮点字面量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript-%E4%B8%AD%E7%9A%84%E7%AE%97%E6%9C%AF"><span class="nav-number">2.3.</span> <span class="nav-text">JavaScript 中的算术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E7%BA%A7%E5%88%B6%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8E%E8%88%8D%E5%85%A5%E9%94%99%E8%AF%AF"><span class="nav-number">2.4.</span> <span class="nav-text">二级制浮点数与舍入错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-BigInt-%E8%A1%A8%E7%A4%BA%E4%BB%BB%E6%84%8F%E7%B2%BE%E5%BA%A6%E6%95%B4%E6%95%B0"><span class="nav-number">2.5.</span> <span class="nav-text">通过 BigInt 表示任意精度整数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4"><span class="nav-number">2.6.</span> <span class="nav-text">日期和时间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E6%9C%AC"><span class="nav-number">3.</span> <span class="nav-text">文本</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E3%80%81%E7%A0%81%E7%82%B9%E5%92%8C-JavaScript-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">3.1.</span> <span class="nav-text">字符、码点和 JavaScript 字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-number">3.2.</span> <span class="nav-text">字符串字面量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F%E4%B8%AD%E7%9A%84%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97"><span class="nav-number">3.3.</span> <span class="nav-text">字符串字面量中的转义序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">3.4.</span> <span class="nav-text">使用字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E7%89%88%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-number">3.5.</span> <span class="nav-text">模版字面量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">3.6.</span> <span class="nav-text">模式匹配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E5%80%BC"><span class="nav-number">4.</span> <span class="nav-text">布尔值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null-%E4%B8%8E-undefined"><span class="nav-number">5.</span> <span class="nav-text">null 与 undefined</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7"><span class="nav-number">6.</span> <span class="nav-text">符号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1"><span class="nav-number">7.</span> <span class="nav-text">全局对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E4%BF%AE%E6%94%B9%E7%9A%84%E5%8E%9F%E5%A7%8B%E5%80%BC%E4%B8%8E%E5%8F%AF%E4%BF%AE%E6%94%B9%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8"><span class="nav-number">8.</span> <span class="nav-text">不可修改的原始值与可修改的对象引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">9.</span> <span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E4%B8%8E%E7%9B%B8%E7%AD%89"><span class="nav-number">9.1.</span> <span class="nav-text">转换与相等</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="nav-number">9.2.</span> <span class="nav-text">显式转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%B0%E5%8E%9F%E5%A7%8B%E5%80%BC%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">9.3.</span> <span class="nav-text">对象到原始值的转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%8E%E8%B5%8B%E5%80%BC"><span class="nav-number">10.</span> <span class="nav-text">变量声明与赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-let-%E5%92%8C-const-%E5%A3%B0%E6%98%8E"><span class="nav-number">10.1.</span> <span class="nav-text">使用 let 和 const 声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">10.2.</span> <span class="nav-text">变量与常量作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D%E5%A3%B0%E6%98%8E"><span class="nav-number">10.3.</span> <span class="nav-text">重复声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%8E%E7%B1%BB%E5%9E%8B"><span class="nav-number">10.4.</span> <span class="nav-text">声明与类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-var-%E7%9A%84%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="nav-number">10.5.</span> <span class="nav-text">使用 var 的变量声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="nav-number">10.6.</span> <span class="nav-text">解构赋值</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">190</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
