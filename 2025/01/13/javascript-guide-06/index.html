<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="对象是 JavaScript 最基本的数据类型，详细了解对象的工作机制非常重要。这篇文章将学习 JavaScript 的对象。">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 权威指南 06：对象">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2025/01/13/javascript-guide-06/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="对象是 JavaScript 最基本的数据类型，详细了解对象的工作机制非常重要。这篇文章将学习 JavaScript 的对象。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-01-13T06:03:45.000Z">
<meta property="article:modified_time" content="2025-03-13T12:42:32.134Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2025/01/13/javascript-guide-06/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JavaScript 权威指南 06：对象 | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2025/01/13/javascript-guide-06/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaScript 权威指南 06：对象
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-13 14:03:45" itemprop="dateCreated datePublished" datetime="2025-01-13T14:03:45+08:00">2025-01-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>对象是 JavaScript 最基本的数据类型，详细了解对象的工作机制非常重要。这篇文章将学习 JavaScript 的对象。</p>
<span id="more"></span>
<h2 id="对象简介"><a class="markdownIt-Anchor" href="#对象简介"></a> 对象简介</h2>
<p>对象是一种复合值，它汇聚多个值（原始值或其他对象）并允许我们按名字存储和获取这些值。对象是一个属性的无序集合，每个属性都有名字和值：</p>
<ul>
<li>属性名通常是字符串，也可以是符号</li>
<li>除了维持自己的属性之外，JavaScript 对象也可以从其他对象继承属性，这个其他对象称为其 <code>原型</code></li>
<li>JavaScript 对象是动态的，即可以动态添加和删除属性</li>
<li>对象是可修改的，是按引用操作而不是按值操作的</li>
</ul>
<p>在 JavaScript 中，任何不是字符串、数值、符号、布尔值、null、undefined 的值都是对象。即使字符串、数值和布尔值不是对象，它们的行为也类似不可修改的对象。</p>
<p>有时候区分直接定义在对象上的属性和那些从原型对象上继承的属性很重要。JavaScript 使用术语 <code>自有属性</code> 指代非继承属性。</p>
<p>属性有一个名字和一个值。除了名字和值之外，每个属性还有 3 个属性特性（property attribute）：</p>
<ul>
<li>writable（可写）特性指定是否可以设置属性的值</li>
<li>enumerable（可枚举）特性指定是否可以在 <code>for/in</code> 循环中返回属性的名字</li>
<li>configurable（可配置）特性指定是否可以删除属性，以及是否可修改其特性</li>
</ul>
<p>很多 JavaScript 内置对象拥有只读、不可枚举或不可配置的属性。不过，默认情况下，我们所创建对象的所有属性都是可写、可枚举和可配置的。</p>
<h2 id="创建对象"><a class="markdownIt-Anchor" href="#创建对象"></a> 创建对象</h2>
<p>对象可以通过对象字面量、new 关键字和 Object.create() 函数来创建。</p>
<h3 id="对象字面量"><a class="markdownIt-Anchor" href="#对象字面量"></a> 对象字面量</h3>
<p>创建对象最简单的方式是在 JavaScript 代码中直接包含对象字面量。对象字面量的最简单形式是包含在一对花括号中的一组逗号分隔的 <code>名:值</code> 对。</p>
<ul>
<li>属性名是 JavaScript 标识符或字符串字面量（允许空字符串）​，还可以是 Symbol</li>
<li>属性值是任何 JavaScript 表达式，它的值会变成属性值</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> empty = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> point = &#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>:<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> p2 = &#123;<span class="attr">x</span>:point.<span class="property">x</span>, <span class="attr">y</span>:point.<span class="property">y</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line">  <span class="string">&quot;main title&quot;</span>: <span class="string">&quot;JavaScript&quot;</span>,</span><br><span class="line">  <span class="string">&quot;sub-title&quot;</span>: <span class="string">&quot;The Definitive Guide&quot;</span>,</span><br><span class="line">  <span class="attr">author</span>: &#123;</span><br><span class="line">    <span class="attr">firstname</span>: <span class="string">&quot;David&quot;</span>,</span><br><span class="line">    <span class="attr">surname</span>: <span class="string">&quot;Flanagan&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象字面量最后一个属性后面的逗号是合法的，有些编程风格指南鼓励添加这些逗号，以便将来在对象字面量末尾再增加新属性时不会导致语法错误。</p>
<p>对象字面量是一个表达式，每次求值都会创建并初始化一个新的、不一样的对象。字面量每次被求值的时候，它的每个属性的值也会被求值。</p>
<h3 id="使用-new-创建对象"><a class="markdownIt-Anchor" href="#使用-new-创建对象"></a> 使用 new 创建对象</h3>
<p>new 操作符用于创建和初始化一个新对象。new 关键字后面必须跟一个函数调用。以这种方式使用的函数被称为构造函数（constructor），目的是初始化新创建的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">&gt; <span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Array</span>()</span><br><span class="line">&gt; <span class="keyword">let</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">&gt; <span class="keyword">let</span> r = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br></pre></td></tr></table></figure>
<p>除了内置的构造函数，我们经常需要定义自己的构造函数来初始化新创建的对象</p>
<h3 id="原型"><a class="markdownIt-Anchor" href="#原型"></a> 原型</h3>
<p>几乎每个 JavaScript 对象都有另一个与之关联的对象。这另一个对象被称为原型（prototype），JavaScript 对象从这个原型继承属性。</p>
<ul>
<li>通过对象字面量创建的所有对象都有相同的原型对象，在 JavaScript 代码中可以通过 <code>Object.prototype</code> 引用这个原型对象</li>
<li>使用 new 关键字和构造函数调用创建的对象，使用构造函数 prototype 属性的值作为它们的原型。
<ul>
<li>使用 <code>new Object()</code> 创建的对象继承自 <code>Object.prototype</code>，与通过 {} 创建的对象一样</li>
<li>通过 <code>new Array()</code> 创建的对象以 <code>Array.prototype</code> 为原型</li>
<li>通过 <code>new Date()</code> 创建的对象以 <code>Date.prototype</code> 为原型</li>
</ul>
</li>
</ul>
<p><strong>几乎所有对象都有原型，但只有少数对象有 prototype 属性。正是这些有 prototype 属性的对象为所有其他对象定义了原型</strong>。</p>
<p><strong><code>Object.prototype</code> 是为数不多的没有原型的对象，因为它不继承任何属性</strong>。其他原型对象都是常规对象，都有自己的原型。</p>
<ul>
<li>多数内置构造函数（和多数用户定义的构造函数）的原型都继承自 <code>Object.prototype</code></li>
<li>例如 <code>Date.prototype</code> 从 <code>Object.prototype</code> 继承属性，因此通过 <code>new Date()</code> 创建的日期对象从<code>Date.prototype</code> 和 <code>Object.prototype</code> 继承属性。<strong>这种原型对象链接起来的序列被称为原型链</strong></li>
</ul>
<h3 id="objcetcreate"><a class="markdownIt-Anchor" href="#objcetcreate"></a> Objcet.create()</h3>
<p><code>Object.create()</code> 用于创建一个新对象，使用其第一个参数作为新对象的原型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> o = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;) <span class="comment">// o 继承属性 x 和 y</span></span><br><span class="line">&gt; o.<span class="property">x</span> + o.<span class="property">y</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>传入 null 可以创建一个没有原型的新对象。不过，这样创建的新对象不会继承任何东西，连 <code>toString()</code> 这种基本方法都没有。</p>
<p>如果想创建一个普通的空对象（类似{}或new Object()返回的对象）​，传入 <code>Object.prototype</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> o2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br></pre></td></tr></table></figure>
<p>能够以任意原型创建新对象是一种非常强大的技术，<code>Object.create()</code> 的一个用途是防止对象被某个第三方库函数意外（但非恶意）修改。这种情况下，不要直接把对象传给库函数，而要传入一个继承自它的对象。如果函数读取这个对象的属性，可以读到继承的值。而如果它设置这个对象的属性，则修改不会影响原始对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">x</span>: <span class="string">&quot;don&#x27;t change this value&quot;</span>&#125;;</span><br><span class="line">library.<span class="keyword">function</span>(<span class="params"><span class="built_in">Object</span>.create(o)</span>);</span><br></pre></td></tr></table></figure>
<h2 id="查询和设置属性"><a class="markdownIt-Anchor" href="#查询和设置属性"></a> 查询和设置属性</h2>
<p>要获取或设置属性的值，可以使用 <code>.</code> 或 <code>[]</code> 操作符：</p>
<ul>
<li>操作符左边应该是一个表达式，其值为一个对象</li>
<li>如果使用点操作符，右边必须是一个命名属性的简单标识符</li>
<li>如果使用方括号，方括号中的值必须是一个表达式，其结果为包含目的属性名的字符串（或者可以转换为字符串或符号的值）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; book.<span class="property">author</span></span><br><span class="line">&gt; book[<span class="string">&quot;main title&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>JavaScript 对象是关联数组，<code>book.author</code> 和 <code>book[&quot;author&quot;]</code> 是一样的。JavaScript 是松散类型语言。JavaScript 程序可以为任意对象创建任意数量的属性：</p>
<ul>
<li>在使用 <code>.</code> 操作符访问对象的属性时，属性名是通过标识符来表示的。标识符必须直接书写在 JavaScript 程序中（这也就要求我们提前知道这些属性名称），它们不是一种数据类型，因此不能被程序操作。</li>
<li>在通过方括号 <code>[​]</code> 这种数组表示法访问对象属性时，属性名是通过字符串来表示的。因此可以在程序运行期间动态修改属性名</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> addr = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    addr += customer[<span class="string">`address<span class="subst">$&#123;i&#125;</span>`</span>] + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这个例子展示了使用数组表示法通过字符串表达式访问对象属性的灵活性</strong>。字符串是一种数据类型，可以在运行是修改，而标识符是静态的，必须硬编码到程序中。</p>
<p>JavaScript 对象经常作为关联数组使用。ES6 及其之后版本，使用 Map 类通常比使用普通对象更好。</p>
<h3 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h3>
<p>JavaScript对象有一组 <code>自有属性</code>​，同时也从它们的原型对象继承一组属性。假设要从对象 o 中查询属性 x：</p>
<ul>
<li>如果 o 没有叫这个名字的自有属性，则会从 o 的原型对象查询属性 x</li>
<li>如果原型对象也没有叫这个名字的自有属性，但它有自己的原型，则会继续查询这个原型的原型</li>
<li>这个过程一直持续，直至找到属性x或者查询到一个原型为null的对象。</li>
</ul>
<p>假设你为对象 o 的 x 属性赋值：</p>
<ul>
<li>如果 o 有一个名为 x 的自有（非继承）属性，这次赋值就会修改已有 x 属性的值</li>
<li>否则赋值会在对象 o 上创建一个名为 x 的新属性。如果 o 之前继承了属性 x，那么现在这个继承的属性会被新创建的同名属性隐藏</li>
</ul>
<p>属性赋值查询原型链只为确定是否允许赋值：</p>
<ul>
<li>如果 o 继承了一个名为 x 的只读属性，则不允许赋值</li>
<li>如果允许赋值，则只会在原始对象上创建或设置属性，而不会修改原型链中的对象</li>
</ul>
<p><strong>查询属性时会用到原型链，而设置属性时不影响原型链是一个重要的 JavaScript 特性</strong>，利用这一点，可以选择性地覆盖继承的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> o1 = &#123;<span class="attr">r</span>: <span class="number">1</span>&#125;</span><br><span class="line">&gt; <span class="keyword">let</span> o2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(o1)</span><br><span class="line">&gt; o2.<span class="property">x</span> = <span class="number">1</span>, o2.<span class="property">y</span> = <span class="number">2</span></span><br><span class="line">&gt; o2.<span class="property">r</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">&gt; o1.<span class="property">r</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt; o2.<span class="property">r</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>属性赋值要么失败要么在原始对象上创建或设置属性的规则有一个例外。如果 o 继承了属性 x，而该属性是一个通过设置方法定义的访问器属性，那么就会调用该设置方法而不会在 o 上创建新属性 x。<strong>要注意，此时会在对象 o 上而不是在定义该属性的原型对象上调用设置方法</strong>。因此如果这个设置方法定义了别的属性，那也会在 o 上定义同样的属性，但仍然不会修改原型链。</p>
<h3 id="属性访问错误"><a class="markdownIt-Anchor" href="#属性访问错误"></a> 属性访问错误</h3>
<p>属性访问表达式并不总是会返回或设置值：</p>
<ul>
<li>查询不存在的属性不是错误。如果在 o 的自有属性和继承属性中都没找到属性 x，则属性访问表达式 o.x 的求值结果为 undefined</li>
<li>然而，查询不存在对象的属性则是错误。因为 null 和 undefined 值没有属性，查询这两个值的属性是错误（TypeError，属性访问表达式会失败）。使用 <code>?.</code> 条件式属性访问可以避免该错误：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> surname = book?.<span class="property">author</span>?.<span class="property">surname</span>;</span><br></pre></td></tr></table></figure>
<p>尝试在 null 或 undefined 上设置属性也会导致 TypeError。而且，尝试在其他值上设置属性也不总是会成功，<strong>因为有些属性是只读的，不能设置，而有些对象不允许添加新属性</strong>。在严格模式下​，只要尝试设置属性失败就会抛出 TypeError。在非严格模式下，这些失败通常是静默失败。</p>
<p>尝试在对象 o 上设置属性 p 在以下情况下会失败：</p>
<ul>
<li>o 有一个只读自有属性 p：不可能设置只读属性</li>
<li>o 有一个只读继承属性 p：不可能用同名自有属性隐藏只读继承属性</li>
<li>o 没有自有属性 p，o 没有继承 <code>通过设置方法定义的属性 p</code>，o 的 extensible 特性为 false：
<ul>
<li>如果没有要调用的设置方法，那么 p 必须要添加到 o 上。但如果 o 不可扩展（extensible为false）​，则不能在它上面定义新属性</li>
</ul>
</li>
</ul>
<h2 id="删除属性"><a class="markdownIt-Anchor" href="#删除属性"></a> 删除属性</h2>
<p>delete 操作符用于从对象中移除属性。它唯一的操作数应该是一个属性访问表达式。注意，delete 并不操作属性的值，而是操作属性本身。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> book.<span class="property">author</span>;</span><br><span class="line"><span class="keyword">delete</span> book[<span class="string">&quot;main title&quot;</span>];</span><br></pre></td></tr></table></figure>
<p>delete 操作符只删除自有属性，不删除继承属性。要删除继承属性，必须从定义属性的原型对象上删除。这样做会影响继承该原型的所有对象。</p>
<ul>
<li>如果 delete 操作成功或没有影响（如删除不存在的属性）​，则 delete 表达式求值为true</li>
<li>对非属性访问表达式（无意义地）使用 delete，同样也会求值为 true</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">delete</span> o2.<span class="property">x</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; o2</span><br><span class="line">&#123; <span class="attr">y</span>: <span class="number">2</span> &#125;</span><br><span class="line">&gt; <span class="keyword">delete</span> o2.<span class="property">r</span> <span class="comment">// 删除继承属性，什么也不做</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; o2.<span class="property">r</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>delete 不会删除 configurable 特性为 false 的属性（通过变量声明或函数声明创建的全局对象属性、某些内置对象属性都是不可配置的）。在严格模式下，尝试删除不可配置的属性会导致 TypeError。在非严格模式下，delete 直接求值为 false。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125; <span class="comment">// 声明一个全局函数</span></span><br><span class="line">&gt; <span class="keyword">delete</span> globalThis.<span class="property">f</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>在非严格模式下删除全局对象可配置的属性时，可以省略对全局对象的引用，只在 delete 操作符后面加上属性名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; globalThis.<span class="property">x</span> = <span class="number">1</span> <span class="comment">// 创建可配置的全局属性</span></span><br><span class="line">&gt; x</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt; globalThis.<span class="property">x</span> = <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt; x</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt; <span class="keyword">delete</span> x</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; x</span><br><span class="line"><span class="title class_">Uncaught</span> <span class="title class_">ReferenceError</span>: x is not defined</span><br></pre></td></tr></table></figure>
<p>在严格模式下，如果操作数是一个像 x 这样的非限定标识符，delete 会抛出 SyntaxError，即必须写出完整的属性访问表达式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> x; <span class="comment">// 严格模式下抛出 SyntaxError</span></span><br><span class="line"><span class="keyword">delete</span> globalThis.<span class="property">x</span>; <span class="comment">// 严格模式下正常工作</span></span><br></pre></td></tr></table></figure>
<h2 id="测试属性"><a class="markdownIt-Anchor" href="#测试属性"></a> 测试属性</h2>
<p>JavaScript 对象可以被想象成一组属性，实际开发中经常需要测试这组属性的成员关系。为了检查对象是否有一个给定名字的属性，可以使用 in 操作符，或者 <code>hasOwnProperty()</code>、<code>propertyIsEnumerable()</code> 方法，或者直接查询相应属性。</p>
<ul>
<li>in 操作符要求左边是一个属性名，右边是一个对象。如果对象有包含相应名字的自有属性或继承属性，将返回 true</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> o = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;</span><br><span class="line">&gt; <span class="string">&quot;x&quot;</span> <span class="keyword">in</span> o</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; <span class="string">&quot;y&quot;</span> <span class="keyword">in</span> o</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&gt; <span class="string">&quot;toString&quot;</span> <span class="keyword">in</span> o</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>对象的 hasOwnProperty() 方法用于测试对象是否有给定名字的属性。对继承的属性，它返回 false</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; o.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;x&quot;</span>)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; o.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;y&quot;</span>)</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&gt; o.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;toString&quot;</span>)</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&gt; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;toString&quot;</span>)</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>propertyIsEnumerable()</code> 方法细化了 <code>hasOwnProperty()</code> 测试。<strong>如果传入的命名属性是自有属性且这个属性的 enumerable 特性为 true，这个方法会返回 true</strong>。某些内置属性是不可枚举的。使用常规 JavaScript 代码创建的属性都是可枚举的</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; o.<span class="title function_">propertyIsEnumerable</span>(<span class="string">&quot;x&quot;</span>)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; o.<span class="title function_">propertyIsEnumerable</span>(<span class="string">&quot;y&quot;</span>)</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&gt; o.<span class="title function_">propertyIsEnumerable</span>(<span class="string">&quot;toString&quot;</span>)</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&gt; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">propertyIsEnumerable</span>(<span class="string">&quot;toString&quot;</span>)</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>除了使用 in 操作符，通常简单的属性查询配合 <code>!==</code> 确保其不是未定义的就可以了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; o.<span class="property">x</span> !== <span class="literal">undefined</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; o.<span class="property">y</span> != <span class="literal">undefined</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&gt; o.<span class="property">toString</span> != <span class="literal">undefined</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>但是 in 可以区分不存在的属性和存在但被设置为undefined的属性，这是 <code>!==</code> 无法做到的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> o2 = &#123;<span class="attr">x</span>: <span class="literal">undefined</span>&#125;</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt; <span class="string">&quot;x&quot;</span> <span class="keyword">in</span> o2</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; o2.<span class="property">x</span> !== <span class="literal">undefined</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&gt; <span class="keyword">delete</span> o2.<span class="property">x</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; <span class="string">&quot;x&quot;</span> <span class="keyword">in</span> o2</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="枚举属性"><a class="markdownIt-Anchor" href="#枚举属性"></a> 枚举属性</h2>
<p>为了遍历或获取对象的所有属性，有如下方法：</p>
<ul>
<li><code>for/in</code> 循环对指定对象的每个可枚举（自有或继承）属性都会运行一次循环体，将属性的名字赋给循环变量。对象继承的内置方法是不可枚举的，但你的代码添加给对象的属性默认是可枚举的
<ul>
<li>为防止通过 for/in 枚举继承的属性，可以在循环体内添加一个显式测试 <code>hasOwnProperty()</code></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> o = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>, <span class="attr">z</span>:<span class="number">3</span>&#125;</span><br><span class="line">&gt; <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">in</span> o) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(p); &#125;</span><br><span class="line">x</span><br><span class="line">y</span><br><span class="line">z</span><br></pre></td></tr></table></figure>
<ul>
<li>除了使用 <code>for/in</code> 循环，有时候可以先获取对象所有属性名的数组，然后再通过 <code>for/of</code> 循环遍历该数组
<ul>
<li>Object.keys() 返回对象可枚举自有属性名的数组。不包含不可枚举属性、继承属性或名字是符号的属性</li>
<li>Object.getOwnPropertyNames() 与 Object.keys() 类似，但会额外返回不可枚举的自有属性名，只要它们的名字是字符串</li>
<li>Object.getOwnPropertySymbols() 返回名字是符号的自有属性，无论是否可枚举</li>
<li>Reflect.ownKeys() 返回所有属性名，包括可枚举和不可枚举属性，以及字符串属性和符号属性</li>
</ul>
</li>
</ul>
<p>ES6 正式定义了枚举对象自有属性的顺序，<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code> <code>Obejct.getOwnPropertySymbols()</code>、<code>Reflect.ownKeys()</code> 等方法都按照如下顺序列出属性：</p>
<ul>
<li>先列出名字为非负整数的字符串属性，按照数值顺序从最小到最大。这条规则意味着数组和类数组对象的属性会按照顺序被枚举</li>
<li>在列出类数组索引的所有属性之后，再列出所有剩下的字符串名字（包括看起来像负数或浮点数的名字）的属性。这些属性按照它们添加到对象的先后顺序列出</li>
<li>最后，名字为符号对象的属性按照它们添加到对象的先后顺序列出</li>
</ul>
<p><code>for/in</code> 循环的枚举顺序并不像上述枚举函数那么严格，但实现通常会按照上面描述的顺序枚举自有属性，然后再沿原型链上溯，以同样的顺序枚举每个原型对象的属性。不过要注意，如果已经有同名属性被枚举过了，甚至如果有一个同名属性是不可枚举的，那这个属性就不会枚举了。</p>
<h2 id="扩展对象"><a class="markdownIt-Anchor" href="#扩展对象"></a> 扩展对象</h2>
<p>在 JavaScript 程序中，把一个对象的属性复制到另一个对象上是很常见的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> target = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;</span><br><span class="line">&gt; <span class="keyword">let</span> source = &#123;<span class="attr">x</span>:<span class="number">2</span>, <span class="attr">y</span>:<span class="number">3</span>&#125;</span><br><span class="line">&gt; <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(source)) &#123; target[key] = source[key]; &#125;</span><br><span class="line">&gt; target</span><br><span class="line">&#123; <span class="attr">x</span>: <span class="number">2</span>, <span class="attr">y</span>: <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure>
<p>ES6 定义了 <code>Object.assign()</code> 方法，它接收两个或多个对象作为其参数：</p>
<ul>
<li>它会修改并返回第一个参数，第一个参数是目标对象</li>
<li>之后的参数都是来源对象</li>
<li>对于每个来源对象，它会把该对象的可枚举自有属性（包括名字为符号的属性）复制到目标对象</li>
<li>它按照参数列表顺序逐个处理来源对象，第一个来源对象的属性会覆盖目标对象的同名属性，而第二个来源对象（如果有）的属性会覆盖第一个来源对象的同名属性，依次类推</li>
<li>该函数以普通的属性 get 和 set 方法来复制属性。因此如果源对象存在 getter 方法、或者目标对象存在 setter 方法，这些方法会在复制期间被调用，但这些方法本身不会被复制</li>
</ul>
<p>如下是 <code>Object.assign()</code> 的一个典型使用方法：先把默认值复制到新对象中，然后再使用 o 的属性覆盖那些默认值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, <span class="keyword">default</span>, o)</span><br></pre></td></tr></table></figure>
<p>使用扩展操作符 … 也可以表达这种对象复制和覆盖操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o = &#123;...<span class="keyword">default</span>, ...o&#125;;</span><br></pre></td></tr></table></figure>
<p>为了避免额外的对象创建和复制，也可以自己实现一个 <code>merge</code> 函数，只复制那些不存在的属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">target, ...sources</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> sources) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(s)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(k <span class="keyword">in</span> target)) &#123;</span><br><span class="line">        target[k] = s[k];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; &#123; x: 2, y: 3 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">x</span>:<span class="number">2</span>, <span class="attr">y</span>: <span class="number">3</span>&#125;));</span><br><span class="line"><span class="comment">// =&gt; &#123; x: 1, y: 3 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">merge</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">x</span>:<span class="number">2</span>, <span class="attr">y</span>: <span class="number">3</span>&#125;));</span><br></pre></td></tr></table></figure>
<h2 id="序列化对象"><a class="markdownIt-Anchor" href="#序列化对象"></a> 序列化对象</h2>
<p>对象序列化（serialization）是把对象的状态转换为字符串的过程，之后可以从中恢复对象的状态。函数 <code>JSON.stringify()</code> 和 <code>JSON.parse()</code> 用于序列化和恢复 JavaScript 对象。这两个函数使用 JSON 数据交换格式。JSON 表示 JavaScript Object Notation（JavaScript对象表示法）​，其语法与 JavaScript 对象和数组字面量非常类似</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> o = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>:&#123;<span class="attr">z</span>:[<span class="literal">false</span>, <span class="literal">null</span>, <span class="string">&quot;&quot;</span>]&#125;&#125;</span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(o)</span><br><span class="line">&gt; str</span><br><span class="line"><span class="string">&#x27;&#123;&quot;x&quot;:1,&quot;y&quot;:&#123;&quot;z&quot;:[false,null,&quot;&quot;]&#125;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">let</span> p = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(str)</span><br><span class="line">&gt; p</span><br><span class="line">&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: &#123; <span class="attr">z</span>: [ <span class="literal">false</span>, <span class="literal">null</span>, <span class="string">&#x27;&#x27;</span> ] &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>JSON 语法是 JavaScript 语法的子集，不能表示所有 JavaScript 的值</p>
<ul>
<li>可以序列化和恢复的值包括对象、数组、字符串、有限数值、true、false 和 null</li>
<li><code>NaN</code>、<code>Infinity</code> 和 <code>-Infinity</code> 会被序列化为 null</li>
<li>日期对象会被序列化为 ISO 格式的日期字符串​，但 JSON.parse() 会保持其字符串形式，不会恢复原始的日期对象</li>
<li>函数、RegExp 和 Error 对象以及 undefined 值不能被序列化或恢复</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> o2 = &#123;<span class="attr">x</span>: <span class="title class_">NaN</span>&#125;</span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(o2)</span><br><span class="line">&gt; str</span><br><span class="line"><span class="string">&#x27;&#123;&quot;x&quot;:null&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">let</span> p2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(str)</span><br><span class="line">&gt; p2</span><br><span class="line">&#123; <span class="attr">x</span>: <span class="literal">null</span> &#125;</span><br></pre></td></tr></table></figure>
<p><code>JSON.stringify()</code> 只序列化对象的可枚举自有属性。如果属性值无法序列化，则该属性会从输出的字符串中删除。JSON.stringify() 和 JSON.parse() 都接收可选的第二个参数，用于自定义序列化及恢复操作。</p>
<h2 id="对象方法"><a class="markdownIt-Anchor" href="#对象方法"></a> 对象方法</h2>
<p>所有 JavaScript 对象（除了那些显式创建为没有原型的）都从 Object.prototype 继承属性，这些继承的属性主要是方法，这里介绍 <code>Object.prototype</code> 上的几个通用方法：</p>
<h3 id="tostring-方法"><a class="markdownIt-Anchor" href="#tostring-方法"></a> toString 方法</h3>
<p>toString() 方法不接收参数，返回表示调用它的对象的值的字符串。每当需要把一个对象转换为字符串时， JavaScript 就会调用该对象的这个方法。</p>
<p>默认的 toString() 方法实现并不会提供太多信息：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> o = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;</span><br><span class="line">&gt; o.<span class="title function_">toString</span>()</span><br><span class="line"><span class="string">&#x27;[object Object]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>由于这个默认方法不会显示太有用的信息，很多类都会重新定义自己的 toString() 方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> o = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>, <span class="attr">toString</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">`(x:<span class="subst">$&#123;<span class="variable language_">this</span>.x&#125;</span>, y:<span class="subst">$&#123;<span class="variable language_">this</span>.y&#125;</span>)`</span>&#125;&#125;</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt; o.<span class="title function_">toString</span>()</span><br><span class="line"><span class="string">&#x27;(x:1, y:2)&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="tolocalestring-方法"><a class="markdownIt-Anchor" href="#tolocalestring-方法"></a> toLocaleString 方法</h3>
<p>除了基本的 <code>toString()</code> 方法之外，对象也都有一个 <code>toLocaleString()</code> 方法。这个方法的用途是返回对象的本地化字符串表示。Object 定义的默认 toLocaleString() 方法本身没有实现任何本地化，而是简单地调用 toString() 并返回该值。</p>
<p>Date 类就实现了自己的 <code>toLocaleString()</code> 方法，该方法返回一个本地化日期字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt; d.<span class="title function_">toString</span>()</span><br><span class="line"><span class="string">&#x27;Sun Jan 19 2025 16:24:36 GMT+0800 (China Standard Time)&#x27;</span></span><br><span class="line">&gt; d.<span class="title function_">toLocaleString</span>()</span><br><span class="line"><span class="string">&#x27;1/19/2025, 4:24:36 PM&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="valueof-方法"><a class="markdownIt-Anchor" href="#valueof-方法"></a> valueOf 方法</h3>
<p>valueOf() 方法与 toString() 方法很相似，但会在 JavaScript 需要把对象转换为某些非字符串原始值（通常是数值）时被调用。默认的 valueOf() 方法并没有做什么，因此一些内置类定义了自己的 valueOf() 方法。Date类 定义的 valueOf() 方法可以将日期转换为数值，这样就让日期对象可以通过 &lt; 和 &gt; 操作符来进行比较。</p>
<h3 id="tojson-方法"><a class="markdownIt-Anchor" href="#tojson-方法"></a> toJSON 方法</h3>
<p><code>Object.prototype</code> 实际上并未定义 <code>toJSON()</code> 方法，但 <code>JSON.stringify()</code> 方法会从要序列化的对象上寻找 <code>toJSON()</code> 方法。如果要序列化的对象上存在这个方法，就会调用它，然后序列化该方法的返回值，而不是原始对象。</p>
<h2 id="对象字面量扩展语法"><a class="markdownIt-Anchor" href="#对象字面量扩展语法"></a> 对象字面量扩展语法</h2>
<p>最近的 JavaScript 版本从几个方面扩展了对象字面量语法。下面将讲解这些扩展。</p>
<h3 id="简写属性"><a class="markdownIt-Anchor" href="#简写属性"></a> 简写属性</h3>
<p>假设变量 x 和 y 中保存着值，而你想创建一个具有属性 x 和 y 且值分别为相应变量值的对象。在 ES6 及其之后版本，可以删除简化基本的对象字面量语法，删除标识符名称及其冒号：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line">&gt; <span class="keyword">let</span> o1 = &#123;<span class="attr">x</span>:x, <span class="attr">y</span>:y&#125;</span><br><span class="line">&gt; <span class="keyword">let</span> o2 = &#123;x, y&#125;</span><br><span class="line">&gt; o1</span><br><span class="line">&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;</span><br><span class="line">&gt; o2</span><br><span class="line">&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="计算的属性名"><a class="markdownIt-Anchor" href="#计算的属性名"></a> 计算的属性名</h3>
<p>有时候，我们需要创建一个具有特定属性的对象，但该属性的名字不是编译时可以直接写在源代码中的常量。相反，你需要的这个属性名保存在一个变量里，或者是调用的某个函数的返回值。不能对这种属性使用基本对象字面量。<strong>为此，必须先创建一个对象，然后再为它添加想要的属性</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PROPERTY_NAME</span> = <span class="string">&quot;p1&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">computePropertyName</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&quot;p&quot;</span> + <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = &#123;&#125;;</span><br><span class="line">o[<span class="variable constant_">PROPERTY_NAME</span>] = <span class="number">1</span>;</span><br><span class="line">o[<span class="title function_">computePropertyName</span>()] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>使用 ES6 称为计算属性的特性可以更简单地创建类似对象，只需要直接将方括号放到对象字面量中即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PROPERTY_NAME</span> = <span class="string">&quot;p1&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">computePropertyName</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&quot;p&quot;</span> + <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = &#123;</span><br><span class="line">  [<span class="variable constant_">PROPERTY_NAME</span>]: <span class="number">1</span>,</span><br><span class="line">  [<span class="title function_">computePropertyName</span>()]: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了这个语法，就可以在方括号中加入任意 JavaScript 表达式。对这个表达式求值得到的结果（必要时转换为字符串）会用作属性的名字。</p>
<h3 id="符号作为属性名"><a class="markdownIt-Anchor" href="#符号作为属性名"></a> 符号作为属性名</h3>
<p>计算属性语法也让另一个非常重要的对象字面量特性成为可能。在 ES6 及之后，属性名可以是字符串或符号。如果把符号赋值给一个变量或常量，那么可以使用计算属性语法将该符号作为属性名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> extension = <span class="title class_">Symbol</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">&gt; <span class="keyword">let</span> o = &#123; [extension]: <span class="number">1</span> &#125;</span><br><span class="line">&gt; o</span><br><span class="line">&#123; [<span class="title class_">Symbol</span>(test)]: <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>
<p>符号是不透明值。除了用作属性名之外，不能用它们做任何事情。不过，每个符号都与其他符号不同，这意味着符号非常适合用于创建唯一属性名。创建新符号需要调用 Symbol() 工厂函数（<strong>符号是原始值，不是对象</strong>，因此 Symbol() 不是构造函数，不能使用 new 调用）​。</p>
<p>Symbol() 返回的值不等于任何其他符号或其他值。可以给 Symbol() 传一个字符串，在把符号转换为字符串时会用到这个字符串。但这个字符串的作用仅限于辅助调试，使用相同字符串参数创建的两个符号依旧是不同的符号。</p>
<p>使用符号不是为了安全，而是为 JavaScript 对象定义安全的扩展机制。因为你可以放心地使用符号作为属性名，而不用担心冲突问题。</p>
<h3 id="扩展操作符"><a class="markdownIt-Anchor" href="#扩展操作符"></a> 扩展操作符</h3>
<p>在 ES2018 及之后，可以在对象字面量中使用扩展操作符 <code>...</code> 把已有对象的属性复制到新对象中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> o1 = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;</span><br><span class="line">&gt; <span class="keyword">let</span> o2 = &#123;<span class="attr">a</span>:<span class="number">3</span>, <span class="attr">d</span>:<span class="number">4</span>&#125;</span><br><span class="line">&gt; <span class="keyword">let</span> o12 = &#123;...o1, ...o2&#125;</span><br><span class="line">&gt; o12</span><br><span class="line">&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">d</span>: <span class="number">4</span> &#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>...</code> 语法经常被称为扩展操作符，但却不是真正意义上的 JavaScript 操作符。实际上，它是仅在对象字面量中有效的一种特殊语法（在其他 JavaScript 上下文中，三个点有其他用途）。</p>
<ul>
<li>如果扩展对象和被扩展对象有一个同名属性，那么这个属性的值由后面的属性值决定</li>
<li>扩展操作符只能复制对象的自有属性，不复制任何继承属性：</li>
<li>要额外注意扩展操作符可能带来的性能问题：如果对象有 n 个属性，把这个属性扩展到另一个对象可能是一种 <code>O(n)</code> 操作</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> o3 = &#123;...o1, ...o2, <span class="attr">a</span>:<span class="number">100</span>&#125;</span><br><span class="line">&gt; o3</span><br><span class="line">&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">100</span>, <span class="attr">d</span>: <span class="number">4</span> &#125;</span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">let</span> p = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;)</span><br><span class="line">&gt; p</span><br><span class="line">&#123;&#125;</span><br><span class="line">&gt; p.<span class="property">x</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt; <span class="keyword">let</span> q = &#123;...p&#125;</span><br><span class="line">&gt; q</span><br><span class="line">&#123;&#125;</span><br><span class="line">&gt; q.<span class="property">x</span></span><br><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="简写方法"><a class="markdownIt-Anchor" href="#简写方法"></a> 简写方法</h3>
<p>在把函数定义为对象属性时，我们称该函数为方法。在 ES6 以前，需要像定义对象的其他属性一样，通过函数定义表达式在对象字面量中定义一个方法。但在 ES6 中，对象字面量语法经过扩展，允许一种省略 function 关键字和冒号的简写方法，结果代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> square = &#123;</span><br><span class="line">  <span class="attr">area</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">side</span> * <span class="variable language_">this</span>.<span class="property">side</span>; &#125;,</span><br><span class="line">  <span class="comment">// shorthand method</span></span><br><span class="line">  <span class="title function_">area2</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">side</span> * <span class="variable language_">this</span>.<span class="property">side</span> &#125;,</span><br><span class="line">  <span class="attr">side</span>: <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(square.<span class="title function_">area</span>(), square.<span class="title function_">area2</span>());</span><br></pre></td></tr></table></figure>
<p>这种简写语法让人一看便知 <code>area2</code> 是方法。</p>
<p>在使用这种简写语法来写方法时，属性名可以是对象字面量允许的任何形式。除了像上面的 <code>area2</code> 一样的常规 JavaScript 标识符之外，也可以使用字符串字面量和计算的属性名，包括符号属性名：</p>
<h3 id="属性的获取方法getter和设置方法setter"><a class="markdownIt-Anchor" href="#属性的获取方法getter和设置方法setter"></a> 属性的获取方法（getter）和设置方法（setter）</h3>
<p>目前我们讨论的所有对象属性都是数据属性，即有一个名字和一个普通的值。除了数据属性之外，JavaScript 还支持为对象定义 <code>访问器属性</code>（accessor property）。这种属性不是一个值，而是一个或两个访问器方法：一个获取方法（getter）和一个设置方法（setter）。</p>
<ul>
<li>当程序查询一个访问器属性的值时，JavaScript 会调用获取方法（不传参数）​。这个方法的返回值就是属性访问表达式的值</li>
<li>当程序设置一个访问器属性的值时，JavaScript会调用设置方法，传入赋值语句右边的值。这个方法负责 <code>设置</code> 属性的值。设置方法的返回值会被忽略</li>
</ul>
<p>如果一个属性既有获取方法也有设置方法，则该属性是一个可读写属性；如果只有一个获取方法，那它就是只读属性；如果只有一个设置方法，那它就是只写属性，读取这种属性始终得到 <code>undefined</code>。</p>
<p>访问器属性可以通过对象字面量的一个扩展语法来定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  <span class="attr">dataProp</span>: <span class="number">10</span>,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">accessProp</span>() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">dataProp</span>; &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">accessProp</span>(<span class="params">value</span>) &#123; <span class="variable language_">this</span>.<span class="property">dataProp</span> = value; &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>访问器属性是通过一个或两个方法来定义的，方法名就是属性名</li>
<li>除了前缀是 get 和 set 之外，这两个方法看起来就像用 ES6 简写语法定义的普通方法一样（在 ES6 中，也可以使用计算的属性名来定义获取方法和设置方法。只要把 get 和 set 后面的属性名替换为用方括号包含的表达式即可）​</li>
<li>与数据属性一样，访问器属性也是可以继承的</li>
</ul>
<p>使用访问器属性的典型场景包括写入属性时进行合理性检查，以及每次读取属性时返回不同的值。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/%E5%89%8D%E7%AB%AF/" rel="tag"># 前端</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/01/14/javascript-guide-07/" rel="prev" title="JavaScript 权威指南 07：数组">
      <i class="fa fa-chevron-left"></i> JavaScript 权威指南 07：数组
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2025/01/12/javascript-guide-05/" rel="next" title="JavaScript 权威指南 05：语句">
      JavaScript 权威指南 05：语句 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text"> 对象简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.</span> <span class="nav-text"> 创建对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-number">2.1.</span> <span class="nav-text"> 对象字面量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-new-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.2.</span> <span class="nav-text"> 使用 new 创建对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B"><span class="nav-number">2.3.</span> <span class="nav-text"> 原型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#objcetcreate"><span class="nav-number">2.4.</span> <span class="nav-text"> Objcet.create()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7"><span class="nav-number">3.</span> <span class="nav-text"> 查询和设置属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">3.1.</span> <span class="nav-text"> 继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E9%94%99%E8%AF%AF"><span class="nav-number">3.2.</span> <span class="nav-text"> 属性访问错误</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%B1%9E%E6%80%A7"><span class="nav-number">4.</span> <span class="nav-text"> 删除属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E5%B1%9E%E6%80%A7"><span class="nav-number">5.</span> <span class="nav-text"> 测试属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E5%B1%9E%E6%80%A7"><span class="nav-number">6.</span> <span class="nav-text"> 枚举属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1"><span class="nav-number">7.</span> <span class="nav-text"> 扩展对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="nav-number">8.</span> <span class="nav-text"> 序列化对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="nav-number">9.</span> <span class="nav-text"> 对象方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tostring-%E6%96%B9%E6%B3%95"><span class="nav-number">9.1.</span> <span class="nav-text"> toString 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tolocalestring-%E6%96%B9%E6%B3%95"><span class="nav-number">9.2.</span> <span class="nav-text"> toLocaleString 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#valueof-%E6%96%B9%E6%B3%95"><span class="nav-number">9.3.</span> <span class="nav-text"> valueOf 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tojson-%E6%96%B9%E6%B3%95"><span class="nav-number">9.4.</span> <span class="nav-text"> toJSON 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95"><span class="nav-number">10.</span> <span class="nav-text"> 对象字面量扩展语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%86%99%E5%B1%9E%E6%80%A7"><span class="nav-number">10.1.</span> <span class="nav-text"> 简写属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%8D"><span class="nav-number">10.2.</span> <span class="nav-text"> 计算的属性名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E4%BD%9C%E4%B8%BA%E5%B1%9E%E6%80%A7%E5%90%8D"><span class="nav-number">10.3.</span> <span class="nav-text"> 符号作为属性名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">10.4.</span> <span class="nav-text"> 扩展操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%86%99%E6%96%B9%E6%B3%95"><span class="nav-number">10.5.</span> <span class="nav-text"> 简写方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95getter%E5%92%8C%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95setter"><span class="nav-number">10.6.</span> <span class="nav-text"> 属性的获取方法（getter）和设置方法（setter）</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">198</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">


  

</body>
</html>
