<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Go 标准库的 io 包定义了 Go 语言基本的 I&#x2F;O 模型，它提供了各种与 I&#x2F;O 相关的接口类型，同时也提供了一些工具类型和函数，以提供一些扩展功能。">
<meta property="og:type" content="article">
<meta property="og:title" content="go 库学习之 io">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2024/11/03/go-library-io/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="Go 标准库的 io 包定义了 Go 语言基本的 I&#x2F;O 模型，它提供了各种与 I&#x2F;O 相关的接口类型，同时也提供了一些工具类型和函数，以提供一些扩展功能。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-11-03T14:05:52.000Z">
<meta property="article:modified_time" content="2024-11-04T02:19:46.575Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2024/11/03/go-library-io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>go 库学习之 io | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2024/11/03/go-library-io/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          go 库学习之 io
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-03 22:05:52" itemprop="dateCreated datePublished" datetime="2024-11-03T22:05:52+08:00">2024-11-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Go 标准库的 io 包定义了 Go 语言基本的 I/O 模型，它提供了各种与 I/O 相关的接口类型，同时也提供了一些工具类型和函数，以提供一些扩展功能。</p>
<span id="more"></span>
<h2 id="核心接口类型"><a class="markdownIt-Anchor" href="#核心接口类型"></a> 核心接口类型</h2>
<p>Go io 包的一个核心功能就是提供对各种 I/O 功能的抽象。io 包通过定义各种接口类型来实现对可读、可写等对象的抽象，这样 I/O 相关的代码逻辑只需要与这些接口类型进行交互，而不用关心具体的 I/O 对象，这些具体的 I/O 对象可以是磁盘文件、网络连接、或者是内存中的一块 Buffer。</p>
<p>另外这种抽象也方便 Go 实现包裹函数模式，可以基于某个 I/O 对象创建一个新的 I/O 对象，新 I/O 对象在原有 I/O 对象的基础上添加了某些新的特性，例如在文件 I/O 对象上提供缓冲特性。</p>
<p>下面就列出 io 包定义的核心接口类型。</p>
<h3 id="reader-接口"><a class="markdownIt-Anchor" href="#reader-接口"></a> Reader 接口</h3>
<p><code>Reader</code> 接口类型用于表示一个 <code>可读对象</code>，即可以从 <code>Reader</code> 所表示的数据源中读取数据。Reader 接口类型定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">	Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Read 方法从数据源中读取最多 <code>len(p)</code> 字节的数据到字节切片 <code>p</code> 中。它返回所读取到的字节长度（0 &lt;= n &lt;= len(p) 以及遇到的错误。</p>
<ul>
<li>如果当前存在可读数据（即使不是 len(p) 长度），Read 操作也会立即读取并返回，而不是等待更多数据</li>
<li>当 Read 成功读取了 n 字节（n &gt; 0）后，遇到了错误或者遇到 EOF（end-of-file，EOF），本次调用应该返回成功读取到的字节数。至于 err 返回值，可以在本次调用返回 non-nil 错误，也可以在下一次调用返回错误（以及 n == 0）</li>
<li>调用者在考虑 error 返回值之前，应该始终先处理 <code>n &gt; 0</code> 的情况</li>
<li>如果 <code>len(p) == 0</code>，Read 函数应该总是返回 n == 0。如果某些错误情况已经发生（例如 EOF），它也可以返回 non-nil error</li>
<li>不鼓励 <code>实现</code> 返回 <code>0，nil error</code>（除非 len(p) == 0）。调用者应该把 <code>0, nil</code> 返回值当作什么都没发生，而不代表 EOF</li>
</ul>
<h3 id="writer-接口"><a class="markdownIt-Anchor" href="#writer-接口"></a> Writer 接口</h3>
<p><code>Writer</code> 接口类型用于表示一个 <code>可写对象</code>，即可以将数据写入到 <code>Writer</code> 所表示的数据目的地中。Writer 接口类型定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Write 方将 p 字节切片中的 <code>len(p)</code> 长的字节数据写入到 Writer 所表示的数据目的地中。它返回所写入的字节长度（0 &lt;= n &lt;= len(p) 以及遇到的错误（导致写入提前停止）：</p>
<ul>
<li>如果返回值 n &lt; len(p)，必须返回一个 non-nil 错误</li>
<li>Write 操作不能修改 p 中的数据，即使临时性修改也不行</li>
</ul>
<h3 id="closer-接口"><a class="markdownIt-Anchor" href="#closer-接口"></a> Closer 接口</h3>
<p><code>Closer</code> 接口类型用于表示一个 <code>可关闭</code> 的 I/O 对象，它的定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Close() <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="seeker-接口"><a class="markdownIt-Anchor" href="#seeker-接口"></a> Seeker 接口</h3>
<p><code>Seeker</code> 接口类型用于表示一个 <code>可寻址</code> 的 I/O 对象，即可以设置该 I/O 对象下次读写的位置。它的定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Seeker <span class="keyword">interface</span> &#123;</span><br><span class="line">	Seek(offset <span class="type">int64</span>, whence <span class="type">int</span>) (<span class="type">int64</span>, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>whence 参数表示 offset 参数的参考点，它可以是如下值：</p>
<ul>
<li>SeekStart：相对起始位置</li>
<li>SeekCurrent：相对当前位置</li>
<li>SeekEnd：相对结束位置</li>
</ul>
<h3 id="readerfrom-接口"><a class="markdownIt-Anchor" href="#readerfrom-接口"></a> ReaderFrom 接口</h3>
<p><code>ReaderFrom</code> 接口定义了 <code>ReadFrom</code> 方法，表示可以从某个 Reader 中读取数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReaderFrom <span class="keyword">interface</span> &#123;</span><br><span class="line">	ReadFrom(r Reader) (n <span class="type">int64</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReadFrom 方法会一直从 r 中读取数据，直到 r 返回 EOF 或者其他错误。此时 ReadFrom 方法返回读取到的字节数，以及遇到的错误。<strong>如果是因为 EOF 错误而不再读取，ReadFrom 不会返回该错误</strong>。</p>
<h3 id="writerto-接口"><a class="markdownIt-Anchor" href="#writerto-接口"></a> WriterTo 接口</h3>
<p><code>WriterTo</code> 接口定义了 <code>WriteTo</code> 方法，表示可以将数据写入到某个 Writer 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WriterTo <span class="keyword">interface</span> &#123;</span><br><span class="line">	WriteTo(w Writer) (n <span class="type">int64</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WriteTo 方法会一直将数据写入到 w 中，直到没有更多数据可以写入或者遇到错误。此时 WriteTo 方法返回写入的字节数以及遇到的错误。</p>
<h3 id="readerat-接口"><a class="markdownIt-Anchor" href="#readerat-接口"></a> ReaderAt 接口</h3>
<p><code>ReaderAt</code> 接口定义了 <code>ReadAt</code> 方法，实现了该接口的 I/O 对象支持从其指定位置读取数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReaderAt <span class="keyword">interface</span> &#123;</span><br><span class="line">	ReadAt(p []<span class="type">byte</span>, off <span class="type">int64</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReadAt 方法返回成功读取的字节数（0 &lt;= n &lt;= len(p)），以及遇到的错误。当 ReadAt 返回 n &lt; len(p) 时，ReadAt 方法必须返回一个 non-nil 错误来解释为什么无法进一步读取数据。这方面 ReadAt 比 Read 更严格。另外，如果当前可读的数据不足 <code>len(p)</code>，ReadAt 会一直阻塞直到所要求长度的数据被读取成功或者遇到错误。ReadAt 的这个行为也和 Read 不同。</p>
<h3 id="writerat-接口"><a class="markdownIt-Anchor" href="#writerat-接口"></a> WriterAt 接口</h3>
<p><code>WriterAt</code> 接口定义了 <code>WriteAt</code> 方法，实现了该接口的 I/O 对象支持在指定位置写入数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WriterAt <span class="keyword">interface</span> &#123;</span><br><span class="line">	WriteAt(p []<span class="type">byte</span>, off <span class="type">int64</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WriteAt 方法返回成功写入的字节数（0 &lt;= n &lt;= len(p)）以及遇到的错误（导致写入提前停止）。如果 n &lt; len(p) 时，WriteAt 方法必须返回一个 non-nil 错误来解释为什么无法继续写入数据。</p>
<h3 id="readwriter-接口及其他组合接口类型"><a class="markdownIt-Anchor" href="#readwriter-接口及其他组合接口类型"></a> ReadWriter 接口及其他组合接口类型</h3>
<p><code>ReadWriter</code> 接口类型表示一个 <code>可读、可写</code> 的 I/O 对象。它其实就是 <code>Reader</code> 和 <code>Writer</code> 接口的组合，它的定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>io 包还定义了一些组合接口类型，都比较简单，列举如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Closer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">	Writer</span><br><span class="line">	Closer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadWriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Writer</span><br><span class="line">	Closer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadSeeker <span class="keyword">interface</span> &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Seeker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadSeeker <span class="keyword">interface</span> &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Seeker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadSeekCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Seeker</span><br><span class="line">	Closer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WriteSeeker <span class="keyword">interface</span> &#123;</span><br><span class="line">	Writer</span><br><span class="line">	Seeker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadWriteSeeker <span class="keyword">interface</span> &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Writer</span><br><span class="line">	Seeker</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="每次一字节-io-操作"><a class="markdownIt-Anchor" href="#每次一字节-io-操作"></a> 每次一字节 I/O 操作</h3>
<p>io 包定义了如下接口类型，以支持每次一字节的 I/O 操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ByteReader <span class="keyword">interface</span> &#123;</span><br><span class="line">	ReadByte() (<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ByteScanner <span class="keyword">interface</span> &#123;</span><br><span class="line">	ByteReader</span><br><span class="line">	UnreadByte() <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ByteWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">	WriteByte(c <span class="type">byte</span>) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="每次一-rune-io-操作"><a class="markdownIt-Anchor" href="#每次一-rune-io-操作"></a> 每次一 rune I/O 操作</h3>
<p>io 包定义了如下接口类型，以支持每次一 rune 的 I/O 操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RuneReader <span class="keyword">interface</span> &#123;</span><br><span class="line">	ReadRune() (r <span class="type">rune</span>, size <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RuneScanner <span class="keyword">interface</span> &#123;</span><br><span class="line">	RuneReader</span><br><span class="line">	UnreadRune() <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他接口类型"><a class="markdownIt-Anchor" href="#其他接口类型"></a> 其他接口类型</h3>
<p><code>StringWriter</code> 接口类型定义了 <code>WriteString</code> 方法，用于将字符串写入到目的地中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">	WriteString(s <span class="type">string</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="工具函数"><a class="markdownIt-Anchor" href="#工具函数"></a> 工具函数</h2>
<p>io 包基于这些接口类型，定义了一些基础的工具函数，以提供一些通用的 io 功能。这些 io 工具函数都以接口类型作为参数，使得这些函数可以作用于各种 io 实现。</p>
<p><code>ReadAtLeast</code> 函数从 reader 中至少读取 n 字节数据，它返回所读取的字节数，以及错误信息。</p>
<ul>
<li>只有当读取的字节数小于所要求的 min 字节时，才会返回 non-nil 错误。这也意味着如果返回了 n，则肯定不会有错误</li>
<li>如果没读取任何字节，就遇到了 EOF 错误，此时 ReadAtLeast 才返回 EOF 错误</li>
<li>如果读取了部分数据，才遇到 EOF 错误，此时 ReadAtLeast 返回 ErrUnexpectedEOF</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAtLeast</span><span class="params">(r Reader, buf []<span class="type">byte</span>, min <span class="type">int</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p><code>ReadFull</code> 从 Reader 中读取数据，直至 buf 缓冲区满或者遇到错误。它返回所读取的字节数，以及错误信息。由于它只是对 <code>ReadAtLeast</code> 的封装，所以返回逻辑与 <code>ReadAtLeast</code> 一致。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFull</span><span class="params">(r Reader, buf []<span class="type">byte</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> ReadAtLeast(r, buf, <span class="built_in">len</span>(buf))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Copy</code> 函数从 src 中读取数据，写入到 dst 中，直到遇到 EOF（此时认为拷贝成功）或者出现错误。它返回所拷贝的字节数以及对应的错误信息。拷贝成功 err 总是返回 nil，而不是 EOF。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span><span class="params">(dst Writer, src Reader)</span></span> (written <span class="type">int64</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> copyBuffer(dst, src, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CopyBuffer</code> 函数和 <code>Copy</code> 类似，只不过它使用用户指定缓冲区 buf 来保存中间数据，而不是临时申请 buf。</p>
<ul>
<li>如果指定的 buf 为 nil，则还是会临时申请 buf</li>
<li>如果指定的 buf 为 0 长度，则直接 panic</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyBuffer</span><span class="params">(dst Writer, src Reader, buf []<span class="type">byte</span>)</span></span> (written <span class="type">int64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p><code>Copy</code> 和 <code>CopyBuffer</code> 函数内部都是基于 <code>copyBuffer</code> 函数实现的：</p>
<ul>
<li>首先判断 src 是否实现了 <code>WriterTo</code> 接口。如果实现了，直接调用其 WriteTo 方法即可</li>
<li>再判断 dst 是否实现了 <code>ReaderFrom</code> 接口。如果实现了，直接调用其 ReadFrom 方法即可</li>
<li>最后才尝试 <code>读取-写入</code> 操作</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyBuffer</span><span class="params">(dst Writer, src Reader, buf []<span class="type">byte</span>)</span></span> (written <span class="type">int64</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 如果 src 实现了 WriterTo 接口，直接调用 WriteTo 即可</span></span><br><span class="line">	<span class="comment">// If the reader has a WriteTo method, use it to do the copy.</span></span><br><span class="line">	<span class="comment">// Avoids an allocation and a copy.</span></span><br><span class="line">	<span class="keyword">if</span> wt, ok := src.(WriterTo); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> wt.WriteTo(dst)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果 dst 实现了 ReaderFrom 接口，直接调用 ReadFrom 即可</span></span><br><span class="line">	<span class="comment">// Similarly, if the writer has a ReadFrom method, use it to do the copy.</span></span><br><span class="line">	<span class="keyword">if</span> rf, ok := dst.(ReaderFrom); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> rf.ReadFrom(src)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 申请 buffer</span></span><br><span class="line">	<span class="keyword">if</span> buf == <span class="literal">nil</span> &#123;</span><br><span class="line">		size := <span class="number">32</span> * <span class="number">1024</span></span><br><span class="line">		<span class="comment">// 如果 src 是一个 LimitedReader，那么每次最多只能读取 l.N  大小</span></span><br><span class="line">		<span class="keyword">if</span> l, ok := src.(*LimitedReader); ok &amp;&amp; <span class="type">int64</span>(size) &gt; l.N &#123;</span><br><span class="line">			<span class="keyword">if</span> l.N &lt; <span class="number">1</span> &#123;</span><br><span class="line">				size = <span class="number">1</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				size = <span class="type">int</span>(l.N)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		buf = <span class="built_in">make</span>([]<span class="type">byte</span>, size)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 读取数据到 buf 中</span></span><br><span class="line">		nr, er := src.Read(buf)</span><br><span class="line">		<span class="comment">// 先判断 nr 是否大于 0，处理已经读取的数据</span></span><br><span class="line">		<span class="keyword">if</span> nr &gt; <span class="number">0</span> &#123;</span><br><span class="line">			nw, ew := dst.Write(buf[<span class="number">0</span>:nr])</span><br><span class="line">			<span class="keyword">if</span> nw &lt; <span class="number">0</span> || nr &lt; nw &#123;</span><br><span class="line">				nw = <span class="number">0</span></span><br><span class="line">				<span class="keyword">if</span> ew == <span class="literal">nil</span> &#123;</span><br><span class="line">					ew = errInvalidWrite</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			written += <span class="type">int64</span>(nw)</span><br><span class="line">			<span class="comment">// 写入发生错误，直接终止</span></span><br><span class="line">			<span class="keyword">if</span> ew != <span class="literal">nil</span> &#123;</span><br><span class="line">				err = ew</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 读取的数据和写入数据长度不一致，也终止</span></span><br><span class="line">			<span class="keyword">if</span> nr != nw &#123;</span><br><span class="line">				err = ErrShortWrite</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 再处理读取的 err</span></span><br><span class="line">		<span class="keyword">if</span> er != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 读取时非 EOF 才认为是错误</span></span><br><span class="line">			<span class="keyword">if</span> er != EOF &#123;</span><br><span class="line">				err = er</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> written, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CopyN</code> 从 src 拷贝 N 个字节到 dst 中，它返回实际拷贝的字节数以及错误信息</p>
<ul>
<li>如果返回的 written 为 n，则 err 总是 nil</li>
<li>如果是因为 Reader 返回 EOF 而导致拷贝提前终止，则 err 为 nil</li>
<li>否则 err 为实际的错误信息</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyN</span><span class="params">(dst Writer, src Reader, n <span class="type">int64</span>)</span></span> (written <span class="type">int64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p><code>ReadAll</code> 函数从 Reader 中读取数据，直到遇到 EOF 或者发生错误，之后返回读取到的数据以及错误信息。如果是因为遇到 EOF 而终止读取，ReadAll 应该返回 nil 错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAll</span><span class="params">(r Reader)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<h2 id="工具-io-类型"><a class="markdownIt-Anchor" href="#工具-io-类型"></a> 工具 I/O 类型</h2>
<p>io 包还提供了一些工具类型，也是为了给库的使用者提供一些通用的 io 功能。</p>
<h3 id="limitedreader"><a class="markdownIt-Anchor" href="#limitedreader"></a> LimitedReader</h3>
<p><code>LimitedReader</code> 可以限制从底层 Reader 中读取数据的长度。它的定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LimitedReader <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 底层 Reader</span></span><br><span class="line">	R Reader <span class="comment">// underlying reader</span></span><br><span class="line">    <span class="comment">// 当前还剩余的可读字节数</span></span><br><span class="line">	N <span class="type">int64</span>  <span class="comment">// max bytes remaining</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LimitedReader</code> 实现的 Read 方法会根据 <code>LimitedReader.N</code> 判断是否可以继续读取。如果 <code>N &lt;= 0</code>，Read 直接返回 <code>0, EOF</code>，否则返回读取的字节数（读取时会限制本次能够读取的最大长度），以及对应的错误信息。</p>
<h3 id="teereader"><a class="markdownIt-Anchor" href="#teereader"></a> TeeReader</h3>
<p>TeeReader 接收一个 Reader 和 Writer 作为参数，并返回一个新的 teeReader。当从该 teeReader 中读取数据时，它会负责从底层的 r 中读取数据，并将读取到的数据写入到 w 中，然后才返回读取到的数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TeeReader</span><span class="params">(r Reader, w Writer)</span></span> Reader &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;teeReader&#123;r, w&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// teeReader 内部类型</span></span><br><span class="line"><span class="keyword">type</span> teeReader <span class="keyword">struct</span> &#123;</span><br><span class="line">	r Reader</span><br><span class="line">	w Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sectionreader"><a class="markdownIt-Anchor" href="#sectionreader"></a> SectionReader</h3>
<p><code>SectionReader</code> 可以从底层 ReaderAt 的指定 offset 处开始读取指定数量的数据，它的定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SectionReader <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 底层的 Reader</span></span><br><span class="line">	r ReaderAt <span class="comment">// constant after creation</span></span><br><span class="line">	<span class="comment">// 创建时设置的初始偏移</span></span><br><span class="line">	base <span class="type">int64</span> <span class="comment">// constant after creation</span></span><br><span class="line">	<span class="comment">// 当前的读取偏移</span></span><br><span class="line">	off   <span class="type">int64</span></span><br><span class="line">	<span class="comment">// 结束位置，到达该位置后就不能再读取</span></span><br><span class="line">	limit <span class="type">int64</span> <span class="comment">// constant after creation</span></span><br><span class="line">	<span class="comment">// 需要读取的字节数</span></span><br><span class="line">	n     <span class="type">int64</span> <span class="comment">// constant after creation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SectionReader</code> 中的 <code>base</code> 和 <code>limit</code> 字段就限制了其从底层 Reader 中读取的数据范围。通过 <code>NewSectionReader</code> 来创建一个 <code>SectionReader</code> 对象。其实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSectionReader</span><span class="params">(r ReaderAt, off <span class="type">int64</span>, n <span class="type">int64</span>)</span></span> *SectionReader &#123;</span><br><span class="line">	<span class="keyword">var</span> remaining <span class="type">int64</span></span><br><span class="line">	<span class="keyword">const</span> maxint64 = <span class="number">1</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> off &lt;= maxint64-n &#123;</span><br><span class="line">		<span class="comment">// 没有溢出，设置正确的结束位置</span></span><br><span class="line">		remaining = n + off</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果溢出，直接设置结束位置为 maxint64</span></span><br><span class="line">		remaining = maxint64</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;SectionReader&#123;r, off, off, remaining, n&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SectionReader</code> 实现了 <code>Reader</code>、<code>ReaderAt</code>、<code>Seeker</code> 接口。</p>
<h3 id="offsetwriter"><a class="markdownIt-Anchor" href="#offsetwriter"></a> OffsetWriter</h3>
<p><code>OffsetWriter</code> 可以从底层的 WriterAt 的指定 offset 处开始写入数据。它的定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OffsetWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 底层的 WriterAt</span></span><br><span class="line">	w    WriterAt</span><br><span class="line">	<span class="comment">// 创建时设置的初始偏移</span></span><br><span class="line">	base <span class="type">int64</span> <span class="comment">// the original offset</span></span><br><span class="line">	<span class="comment">// 当前的写入偏移</span></span><br><span class="line">	off  <span class="type">int64</span> <span class="comment">// the current offset</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NewOffsetWriter</code> 函数用于创建一个 OffsetWriter 对象：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOffsetWriter</span><span class="params">(w WriterAt, off <span class="type">int64</span>)</span></span> *OffsetWriter &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;OffsetWriter&#123;w, off, off&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次通过 <code>OffsetWriter.Write</code> 写入数据时，它会从底层 WriterAt <code>OffsetWriter.off</code> 处开始写入，写入完成后更新 <code>OffsetWriter.off</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *OffsetWriter)</span></span> Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	n, err = o.w.WriteAt(p, o.off)</span><br><span class="line">	o.off += <span class="type">int64</span>(n)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 <code>OffsetWriter.WriteAt</code> 写入数据时，它会基于 <code>OffsetWriter.base</code> 实时计算本次写入的偏移，写入完成后也不会对 <code>OffsetWriter.off</code> 进行更改：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *OffsetWriter)</span></span> WriteAt(p []<span class="type">byte</span>, off <span class="type">int64</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> off &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, errOffset</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Off 需要基于 o.base 实时计算</span></span><br><span class="line">	off += o.base</span><br><span class="line">	<span class="comment">// 写入完成后，也不会对 o.off 进行更改</span></span><br><span class="line">	<span class="keyword">return</span> o.w.WriteAt(p, off)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>OffsetWriter</code> 也实现了 <code>Seeker</code> 接口，用来更新 <code>OffsetWriter.off</code>。</p>
<h3 id="multireader"><a class="markdownIt-Anchor" href="#multireader"></a> MultiReader</h3>
<p><code>MultiReader</code> 函数会创建一个 <code>multiReader</code> 的 Reader 对象，它可以实现从多个 Reader 中读取数据，逻辑上就相当于将多个 Reader 中的数据串联起来。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MultiReader</span><span class="params">(readers ...Reader)</span></span> Reader &#123;</span><br><span class="line">	r := <span class="built_in">make</span>([]Reader, <span class="built_in">len</span>(readers))</span><br><span class="line">	<span class="built_in">copy</span>(r, readers)</span><br><span class="line">	<span class="keyword">return</span> &amp;multiReader&#123;r&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>multiReader</code> 实现了 Read 方法，会尝试按顺序从底层的 readers 中读取数据，如果某个 reader 读取完成，则从下一个 reader 读取。</p>
<h3 id="multiwriter"><a class="markdownIt-Anchor" href="#multiwriter"></a> MultiWriter</h3>
<p><code>MultiWriter</code> 函数会创建一个 <code>multiWriter</code> 的 Writer 对象，它可以实现将一份数据同时写入多个 Writer。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MultiWriter</span><span class="params">(writers ...Writer)</span></span> Writer &#123;</span><br><span class="line">	allWriters := <span class="built_in">make</span>([]Writer, <span class="number">0</span>, <span class="built_in">len</span>(writers))</span><br><span class="line">	<span class="keyword">for</span> _, w := <span class="keyword">range</span> writers &#123;</span><br><span class="line">		<span class="comment">// 如果当前 writer 自己就是 multiWriter</span></span><br><span class="line">		<span class="keyword">if</span> mw, ok := w.(*multiWriter); ok &#123;</span><br><span class="line">			<span class="comment">// 将其所有元素添加进来</span></span><br><span class="line">			allWriters = <span class="built_in">append</span>(allWriters, mw.writers...)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			allWriters = <span class="built_in">append</span>(allWriters, w)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;multiWriter&#123;allWriters&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pipe"><a class="markdownIt-Anchor" href="#pipe"></a> Pipe</h3>
<p>Pipe 用于创建一个同步的内存型管道，通过它可以将读（需要一个 io.Reader）、写（需要一个 io.Writer）两端连接起来。通过 Pipe 函数创建一个管道，并返回该管道的读写两端：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pipe</span><span class="params">()</span></span> (*PipeReader, *PipeWriter)</span><br></pre></td></tr></table></figure>
<p>创建的管道是同步型的，这意味着 <code>PipeWriter</code> 写入数据会被阻塞，直到有消费者从 <code>PipeReader</code> 中读取数据。写入的数据是直接拷贝到读端，中间不会使用内部 buffer。Pipe 是并发安全的。</p>
<h3 id="其他工具"><a class="markdownIt-Anchor" href="#其他工具"></a> 其他工具</h3>
<ul>
<li><code>io</code> 包还提供了一个 <code>Discard</code> Writer 对象，往 <code>Discard</code> 中写入数据不会做任何实际操作。</li>
<li><code>NopCloser</code> 用于包装一个 Reader 对象，并返回一个 <code>ReadCloser</code> 对象，新的 <code>ReadCloser</code> 对象的 <code>Close</code> 方法不做任何实际操作</li>
</ul>
<h2 id="iofs"><a class="markdownIt-Anchor" href="#iofs"></a> io/fs</h2>
<p><code>io/fs</code> 包定义了与文件系统相关的接口类型，用于实现对文件系统的抽象。其中 <code>FS</code> 接口类型用于表示一个层次化文件系统的最小实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FS <span class="keyword">interface</span> &#123;</span><br><span class="line">    Open(name <span class="type">string</span>) (File, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>File</code> 接口类型则用于表示一个文件的最小实现，这里的 <code>文件</code> 可以是常规文件、目录文件、符号链接等等：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> File <span class="keyword">interface</span> &#123;</span><br><span class="line">	Stat() (FileInfo, <span class="type">error</span>)</span><br><span class="line">	Read([]<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">	Close() <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DirEntry</code> 接口类型用于表示一个 <code>目录项</code>，即目录里的某个子项（或者称为子文件）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DirEntry <span class="keyword">interface</span> &#123;</span><br><span class="line">	Name() <span class="type">string</span></span><br><span class="line">	IsDir() <span class="type">bool</span></span><br><span class="line">	Type() FileMode</span><br><span class="line">	Info() (FileInfo, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ReadDirFile</code> 用于表示一个 <code>目录文件</code>，可以通过它的 <code>ReadDir</code> 方法获取该目录文件下的所有 <code>目录项</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadDirFile <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// ReadDirFile 也是一个 File</span></span><br><span class="line">	File</span><br><span class="line"></span><br><span class="line">    <span class="comment">// n 用于设置读取最多 n 个目录项，如果 n &lt;= 0，则读取所有目录项</span></span><br><span class="line">	ReadDir(n <span class="type">int</span>) ([]DirEntry, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FileInfo</code> 接口类型用于表示 <code>Stat</code> 函数返回的文件信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FileInfo <span class="keyword">interface</span> &#123;</span><br><span class="line">	Name() <span class="type">string</span>       <span class="comment">// base name of the file</span></span><br><span class="line">	Size() <span class="type">int64</span>        <span class="comment">// length in bytes for regular files; system-dependent for others</span></span><br><span class="line">	Mode() FileMode     <span class="comment">// file mode bits</span></span><br><span class="line">	ModTime() time.Time <span class="comment">// modification time</span></span><br><span class="line">	IsDir() <span class="type">bool</span>        <span class="comment">// abbreviation for Mode().IsDir()</span></span><br><span class="line">	Sys() any           <span class="comment">// underlying data source (can return nil)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FS</code> 接口类型只是表示文件系统的最小接口类型，<code>io/fs</code> 基于 <code>FS</code> 接口类型还定义了一系列接口类型，用于表示支持不同功能的文件系统。这些接口类型包裹：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GlobFS 是一个提供了 Glob 方法的文件系统</span></span><br><span class="line"><span class="keyword">type</span> GlobFS <span class="keyword">interface</span> &#123;</span><br><span class="line">	FS</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以对文件进行模式匹配（即支持我们所说的文件通配符），返回匹配 pattern 的文件名称列表</span></span><br><span class="line">	Glob(pattern <span class="type">string</span>) ([]<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReadDirFS 是一个提供 ReadDir 方法的文件系统</span></span><br><span class="line"><span class="keyword">type</span> ReadDirFS <span class="keyword">interface</span> &#123;</span><br><span class="line">	FS</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 name 目录，返回一系列的目录项</span></span><br><span class="line">	ReadDir(name <span class="type">string</span>) ([]DirEntry, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReadFileFS 是一个提供了 ReadFile 方法的文件系统</span></span><br><span class="line"><span class="keyword">type</span> ReadFileFS <span class="keyword">interface</span> &#123;</span><br><span class="line">	FS</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 name 文件，返回文件内容。成功读取应该总是返回 nil 错误，而不是 io.EOF</span></span><br><span class="line">	ReadFile(name <span class="type">string</span>) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StatFS 表示一个提供 Stat 方法的文件系统</span></span><br><span class="line"><span class="keyword">type</span> StatFS <span class="keyword">interface</span> &#123;</span><br><span class="line">	FS</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 name 文件的 FileInfo</span></span><br><span class="line">	Stat(name <span class="type">string</span>) (FileInfo, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SubFS 是一个提供 Sub 方法的文件系统</span></span><br><span class="line"><span class="keyword">type</span> SubFS <span class="keyword">interface</span> &#123;</span><br><span class="line">	FS</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sub 方法返回一个根目录在 dir 的 Sub 文件系统</span></span><br><span class="line">	Sub(dir <span class="type">string</span>) (FS, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于这些接口类型，<code>io/fs</code> 包也提供了一系列工具函数，用于实现文件系统的基本操作。这些函数包括：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Glob</span><span class="params">(fsys FS, pattern <span class="type">string</span>)</span></span> (matches []<span class="type">string</span>, err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadDir</span><span class="params">(fsys FS, name <span class="type">string</span>)</span></span> ([]DirEntry, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(fsys FS, name <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stat</span><span class="params">(fsys FS, name <span class="type">string</span>)</span></span> (FileInfo, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sub</span><span class="params">(fsys FS, dir <span class="type">string</span>)</span></span> (FS, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WalkDir</span><span class="params">(fsys FS, root <span class="type">string</span>, fn WalkDirFunc)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>
<p>我们可以看其中 <code>Stat</code> 函数的实现，其他函数的实现思路都是类似的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stat 函数返回指定 name 的文件信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stat</span><span class="params">(fsys FS, name <span class="type">string</span>)</span></span> (FileInfo, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 如果 FS 实现了 StatFS，直接调用其自己的方法实现</span></span><br><span class="line">	<span class="keyword">if</span> fsys, ok := fsys.(StatFS); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> fsys.Stat(name)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 提供一个通用实现</span></span><br><span class="line">	<span class="comment">// 调用 file 自己的 Stat 方法，</span></span><br><span class="line">	file, err := fsys.Open(name)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	<span class="keyword">return</span> file.Stat()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2>
<p>本篇文章学习了 Go 标准库的 <code>io</code> 包和 <code>io/fs</code> 包，学习了 Go 对其 I/O 模型的基本抽象，这也是后续进一步学习 Go 标准库其他包所需的基础知识。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/Go/" rel="tag"># Go</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2024/11/10/go-library-bufio/" rel="prev" title="go 库学习之 bufio">
      <i class="fa fa-chevron-left"></i> go 库学习之 bufio
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2024/10/27/go-library-netip/" rel="next" title="go 库学习之 netip">
      go 库学习之 netip <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text"> 核心接口类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#reader-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.1.</span> <span class="nav-text"> Reader 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#writer-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.2.</span> <span class="nav-text"> Writer 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#closer-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.3.</span> <span class="nav-text"> Closer 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#seeker-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.4.</span> <span class="nav-text"> Seeker 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#readerfrom-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.5.</span> <span class="nav-text"> ReaderFrom 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#writerto-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.6.</span> <span class="nav-text"> WriterTo 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#readerat-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.7.</span> <span class="nav-text"> ReaderAt 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#writerat-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.8.</span> <span class="nav-text"> WriterAt 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#readwriter-%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E4%BB%96%E7%BB%84%E5%90%88%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.9.</span> <span class="nav-text"> ReadWriter 接口及其他组合接口类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%8F%E6%AC%A1%E4%B8%80%E5%AD%97%E8%8A%82-io-%E6%93%8D%E4%BD%9C"><span class="nav-number">1.10.</span> <span class="nav-text"> 每次一字节 I&#x2F;O 操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%8F%E6%AC%A1%E4%B8%80-rune-io-%E6%93%8D%E4%BD%9C"><span class="nav-number">1.11.</span> <span class="nav-text"> 每次一 rune I&#x2F;O 操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.12.</span> <span class="nav-text"> 其他接口类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0"><span class="nav-number">2.</span> <span class="nav-text"> 工具函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E5%85%B7-io-%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text"> 工具 I&#x2F;O 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#limitedreader"><span class="nav-number">3.1.</span> <span class="nav-text"> LimitedReader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#teereader"><span class="nav-number">3.2.</span> <span class="nav-text"> TeeReader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sectionreader"><span class="nav-number">3.3.</span> <span class="nav-text"> SectionReader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#offsetwriter"><span class="nav-number">3.4.</span> <span class="nav-text"> OffsetWriter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#multireader"><span class="nav-number">3.5.</span> <span class="nav-text"> MultiReader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#multiwriter"><span class="nav-number">3.6.</span> <span class="nav-text"> MultiWriter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pipe"><span class="nav-number">3.7.</span> <span class="nav-text"> Pipe</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7"><span class="nav-number">3.8.</span> <span class="nav-text"> 其他工具</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iofs"><span class="nav-number">4.</span> <span class="nav-text"> io&#x2F;fs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text"> 小结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">224</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">


  

</body>
</html>
