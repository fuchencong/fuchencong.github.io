<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Go 采用的是基于 错误值比较 的错误处理机制，即通过检查返回的 error 值来判断函数&#x2F;方法是否执行成功，如果执行失败，也是通过该 error 值来携带具体的错误信息。相比于其他编程语言的 异常 错误处理机制，这种 值比较 机制更加简单，它要求在程序控制流程中显式关注和处理每个错误，这样的代码往往可读性更好，也符合 Go 追求简答的设计哲学。 标准库的 errors 包为 Go 的错">
<meta property="og:type" content="article">
<meta property="og:title" content="go 库学习之 errors">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2024/10/18/go-library-errors/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="Go 采用的是基于 错误值比较 的错误处理机制，即通过检查返回的 error 值来判断函数&#x2F;方法是否执行成功，如果执行失败，也是通过该 error 值来携带具体的错误信息。相比于其他编程语言的 异常 错误处理机制，这种 值比较 机制更加简单，它要求在程序控制流程中显式关注和处理每个错误，这样的代码往往可读性更好，也符合 Go 追求简答的设计哲学。 标准库的 errors 包为 Go 的错">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-10-18T03:56:56.000Z">
<meta property="article:modified_time" content="2024-10-27T13:33:01.157Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2024/10/18/go-library-errors/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>go 库学习之 errors | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2024/10/18/go-library-errors/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          go 库学习之 errors
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-18 11:56:56" itemprop="dateCreated datePublished" datetime="2024-10-18T11:56:56+08:00">2024-10-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Go 采用的是基于 <code>错误值比较</code> 的错误处理机制，即通过检查返回的 error 值来判断函数&#x2F;方法是否执行成功，如果执行失败，也是通过该 error 值来携带具体的错误信息。相比于其他编程语言的 <code>异常</code> 错误处理机制，这种 <code>值比较</code> 机制更加简单，它要求在程序控制流程中显式关注和处理每个错误，这样的代码往往可读性更好，也符合 Go 追求简答的设计哲学。</p>
<p>标准库的 errors 包为 Go 的错误处理机制提供了基础支持，这篇文章将学习 errors 包的基本用法和原理。</p>
<span id="more"></span>

<h2 id="error-接口"><a href="#error-接口" class="headerlink" title="error 接口"></a>error 接口</h2><p>这种基于 <code>值比较</code> 的错误处理方式使得我们可以使用任意类型来表示错误信息，例如可以像 C 语言惯例那样使用 int 类型来表示错误：0 表示成功，非 0 表示错误，不同的错误值（通常称为错误码）表示不同错误类型。<strong>C 语言这种使用整型值来表示错误的方式虽然简单，但它毕竟不是语言标准，无法让不同代码遵守同一套约定</strong>。而且整型值能够携带的错误信息也很少。</p>
<p>为了能够在所有 Go 代码之间统一地表示错误，Go 语言定义了 error 接口类型，它的定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">	Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们的 Go 代码需要接收、处理、返回错误值时，可以统一使用 <code>error</code> 接口类型来表示错误。另一方面，我们可以根据自己的需要定义具体的错误类型，只要这些数据类型实现了 <code>error</code> 接口，那么这些类型的值都可以用于表示 <code>错误</code>。这样既保证了错误处理在不同 Go 代码之间的一致性，又赋予了 <code>具体实现</code> 灵活定义错误类型的自由。</p>
<p>这其实也是 <code>面向接口</code> 编程思想的体现。</p>
<h2 id="errors-New-函数"><a href="#errors-New-函数" class="headerlink" title="errors.New 函数"></a><code>errors.New</code> 函数</h2><p>errors 包内部定义了 <code>errorString</code> 类型，用于实现 error 接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">	s <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *errorString 实现了 Error 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>errorString</code> 类型是个非导出类型，通过 <code>errors.New</code> 函数创建一个该类型的实例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>errorString</code> 的实现非常简单：</p>
<ul>
<li>当调用 <code>errors.New(string)</code> 创建 <code>errorString</code> 实例时，它保存下传入的错误字符串</li>
<li>当通过 <code>Error()</code> 方法获取错误信息时，直接返回所保存的错误字符串</li>
</ul>
<p>但是需要注意到，<code>errors.New</code> 函数每次都是返回一个新的 <code>errorString</code> 实例，因此当对错误值进行比较式，两个实例即使保存的错误字符串相同，它们也是不相同的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;errors&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrNotExist = errors.New(<span class="string">&quot;not exist&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> errors.New(<span class="string">&quot;not exist&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> e := f(); e == ErrNotExist &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;exist error&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// not exist error</span></span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;not exist error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了解决上述问题，一般的做法是提前通过 <code>errros.New()</code> 定义好各种错误，每次总是使用这些已经定义好错误实例值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;errors&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrNotExist = errors.New(<span class="string">&quot;not exist&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ErrNotExist</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> e := f(); e == ErrNotExist &#123;</span><br><span class="line">		<span class="comment">// exist error</span></span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;exist error&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;not exist error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="errors-Join-函数"><a href="#errors-Join-函数" class="headerlink" title="errors.Join 函数"></a><code>errors.Join</code> 函数</h2><p><code>errors.Join()</code> 函数可以将多个错误实例包装（wrap）成一个，参数中的 nil 会被忽略，如果所有错误实例值都是 nil，则 Join 函数也返回 nil。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(errs ...<span class="type">error</span>)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>

<p><code>Join</code> 函数返回的错误实例类型是非导出类型 <code>joinError</code> 类型，它是以切片的形式保存所有的错误实例，该类型定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> joinError <span class="keyword">struct</span> &#123;</span><br><span class="line">	errs []<span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Join</code> 函数的核心实现就是将参数中的所有非 nil 的 error 保存到 <code>joinError</code> 的 <code>err</code> 切片中，并返回 <code>joinError</code> 类型的实例。</p>
<p><code>joinError</code> 类型实现了 <code>Error</code> 接口，其 <code>Error()</code> 方法就是调用 <code>err</code> 切片中每个对象的 <code>Error()</code> 方法，并以 <code>\n</code> 作为分隔符连接各个错误字符串，并返回连接后的结果。</p>
<h2 id="错误包裹链"><a href="#错误包裹链" class="headerlink" title="错误包裹链"></a>错误包裹链</h2><p>当通过 <code>Join()</code> 将一组错误包装成一个错误后，我们如何判断应该如何进行错误的 <code>值比较</code> 呢？例如假设通过 Join 函数将 <code>A</code> 和 <code>B</code> 包装成一个错误 <code>AB</code>，我们预期 <code>AB</code> 错误应该也属于 <code>A</code> 错误。这就涉及 Go 对错误链的支持了。</p>
<p>当代码调用层次比较深时，每一层可能都会构造自己的错误信息，同时我们又不希望丢失原有的错误上下文信息，这时就需要通过 <code>错误包裹链</code> 机制来提供 <code>错误的包裹</code> 功能了。错误包裹机制可以接受一个或一组错误，将其包裹成一个新的错误，并且可以从该新错误中提取原有错误信息。<code>Join</code> 函数、<code>fmt.Errorf</code> 的 <code>%w</code> 都提供错误包裹能力。</p>
<p>go 的 <code>erros</code> 包提供了 <code>Is</code> 和 <code>As</code> 函数来从 <code>包裹错误</code> 中检视、提取原始错误。这两个函数依赖的核心机制就是如下接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span>&#123; Unwrap() <span class="type">error</span> &#125;</span><br><span class="line"><span class="keyword">interface</span>&#123; Unwrap() []<span class="type">error</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="errors-Is-函数"><a href="#errors-Is-函数" class="headerlink" title="errors.Is 函数"></a><code>errors.Is</code> 函数</h3><p><code>errors.Is</code> 函数用于判断 <code>err</code> 错误是否和指定的 <code>target</code> 错误匹配，该函数会沿着 <code>err</code> 的包裹链，逐步 <code>Unwrap()</code>，判断其返回值是否和 <code>target</code> 相等。下面展示了 <code>errors.Is</code> 函数的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Is</span><span class="params">(err, target <span class="type">error</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// 如果某一个值是 nil，直接判断即可</span></span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> || target == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err == target</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断 target 是否是可比较类型，例如 slice 就不是可比较类型</span></span><br><span class="line">	isComparable := reflectlite.TypeOf(target).Comparable()</span><br><span class="line">	<span class="keyword">return</span> is(err, target, isComparable)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// is 函数用于判断 err 错误是否和指定的 target 错误匹配</span></span><br><span class="line"><span class="comment">// targetComparable 表示 target 自己是否是可比较的数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">is</span><span class="params">(err, target <span class="type">error</span>, targetComparable <span class="type">bool</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 如果 target 是可比较类型，可以直接比较</span></span><br><span class="line">		<span class="keyword">if</span> targetComparable &amp;&amp; err == target &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果 err 自己实现了 Is() 方法，则首先尝试调用其自己实现的 x.Is 方法进行判断</span></span><br><span class="line">		<span class="keyword">if</span> x, ok := err.(<span class="keyword">interface</span>&#123; Is(<span class="type">error</span>) <span class="type">bool</span> &#125;); ok &amp;&amp; x.Is(target) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> x := err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="comment">// 如果 err 实现了 Unwrap() error  方法</span></span><br><span class="line">		<span class="keyword">case</span> <span class="keyword">interface</span>&#123; Unwrap() <span class="type">error</span> &#125;:</span><br><span class="line">			<span class="comment">// 使用 Unwrap() 返回后的值继续比较</span></span><br><span class="line">			err = x.Unwrap()</span><br><span class="line">			<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">// 如果 err 实现了 Unwrap() []error 方法</span></span><br><span class="line">		<span class="keyword">case</span> <span class="keyword">interface</span>&#123; Unwrap() []<span class="type">error</span> &#125;:</span><br><span class="line">			<span class="comment">// 则遍历 Unwrap() 返回的每个 err，进行深度遍历检查</span></span><br><span class="line">			<span class="keyword">for</span> _, err := <span class="keyword">range</span> x.Unwrap() &#123;</span><br><span class="line">				<span class="comment">// 对每个 err 继续调用 is 进行检查</span></span><br><span class="line">				<span class="keyword">if</span> is(err, target, targetComparable) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		<span class="comment">// 如果没有实现上述两个方法，则返回 false</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>errors.Is</code> 函数的核心逻辑是：</p>
<ul>
<li>如果 err 自己实现了 <code>Is</code> 方法，首先调用其自己的 Is 方法进行判断</li>
<li>否则判断 err 是否实现了 <code>Unwrap() error</code> 方法或 <code>Unwrap() []error</code> 方法。如果实现了这两个接口，则会调用 <code>Unwrap</code> 方法并对其返回的 err 进行判断</li>
<li>以上过程会不断递归进行，直至得到判断结果。如果无法继续判断下去，则返回 false</li>
</ul>
<h3 id="errors-As-函数"><a href="#errors-As-函数" class="headerlink" title="errors.As 函数"></a><code>errors.As</code> 函数</h3><p><code>errors.As</code> 函数 As 函数用于判断 err 错误是否可以当成 target 错误类型，如果是可以的话，会在 target 中保存该错误值并返回 true，否则返回 false。直接。即 <code>errors.Is()</code> 函数用于是错误值的比较，而 <code>errors.As()</code> 则是错误类型的比较。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">As</span><span class="params">(err <span class="type">error</span>, target any)</span></span> <span class="type">bool</span></span><br></pre></td></tr></table></figure>

<p>As 函数的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> As(err <span class="type">error</span>, target any) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> target == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;errors: target cannot be nil&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 通过反射获取 target 的类型</span></span><br><span class="line">	val := reflectlite.ValueOf(target)</span><br><span class="line">	typ := val.Type()</span><br><span class="line">	<span class="comment">// target 的类型必须是指针类型 或者是值为 nill 的指针类型</span></span><br><span class="line">	<span class="keyword">if</span> typ.Kind() != reflectlite.Ptr || val.IsNil() &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;errors: target must be a non-nil pointer&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取指针所指向值的数据类型</span></span><br><span class="line">	targetType := typ.Elem()</span><br><span class="line">	<span class="comment">// targetType 类型必须是接口类型，且该接口类型必须实现了 Error 接口</span></span><br><span class="line">	<span class="keyword">if</span> targetType.Kind() != reflectlite.Interface &amp;&amp; !targetType.Implements(errorType) &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;errors: *target must be interface or implement error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> as(err, target, val, targetType)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">as</span><span class="params">(err <span class="type">error</span>, target any, targetVal reflectlite.Value, targetType reflectlite.Type)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 判断 err 类型的值是否可以赋值给 targetType</span></span><br><span class="line">		<span class="keyword">if</span> reflectlite.TypeOf(err).AssignableTo(targetType) &#123;</span><br><span class="line">			<span class="comment">// 如果可以，则完成值的设置</span></span><br><span class="line">			targetVal.Elem().Set(reflectlite.ValueOf(err))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果 err 自己实现了 As 方法，则调用 err 自己的 As 方法</span></span><br><span class="line">		<span class="keyword">if</span> x, ok := err.(<span class="keyword">interface</span>&#123; As(any) <span class="type">bool</span> &#125;); ok &amp;&amp; x.As(target) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> x := err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="comment">// 如果 err 实现了 Unwrap() error  方法</span></span><br><span class="line">		<span class="keyword">case</span> <span class="keyword">interface</span>&#123; Unwrap() <span class="type">error</span> &#125;:</span><br><span class="line">			<span class="comment">// 使用 Unwrap 后的值进行判断</span></span><br><span class="line">			err = x.Unwrap()</span><br><span class="line">			<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">// 如果 err 实现了 Unwrap() []error  方法</span></span><br><span class="line">		<span class="keyword">case</span> <span class="keyword">interface</span>&#123; Unwrap() []<span class="type">error</span> &#125;:</span><br><span class="line">			<span class="comment">// 则遍历 Unwrap() 返回的每个 err，进行深度遍历检查</span></span><br><span class="line">			<span class="keyword">for</span> _, err := <span class="keyword">range</span> x.Unwrap() &#123;</span><br><span class="line">				<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 对每个 err 继续调用 as 进行检查</span></span><br><span class="line">				<span class="keyword">if</span> as(err, target, targetVal, targetType) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		<span class="comment">// 如果没有实现上述两个方法，则返回 false</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error 接口类型</span></span><br><span class="line"><span class="keyword">var</span> errorType = reflectlite.TypeOf((*<span class="type">error</span>)(<span class="literal">nil</span>)).Elem()</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>errors.As</code> 函数的逻辑类似于 <code>errors.Is</code> 函数：</p>
<ul>
<li>通过反射中的 <code>reflectlite.Type.AssignableTo</code> 方法判断 err 值是否可以赋值给 targetType</li>
<li>如果 err 自己实现了 <code>As</code> 方法，首先调用其自己的 As 方法进行判断</li>
<li>否则判断 err 是否实现了 <code>Unwrap() error</code> 方法或 <code>Unwrap() []error</code> 方法。如果实现了这两个接口，则会调用 <code>Unwrap</code> 方法并对其返回的 err 进行判断</li>
<li>以上过程会不断递归进行，直至得到判断结果。如果无法继续判断下去，则返回 false</li>
</ul>
<p>这里需要注意下 <code>errors.As</code> 函数的 <code>target</code> 必须是个非 nil 指针，且指针所指向类型必须是个接口类型或者实现了 <code>Error()</code> 方法的数据类型。</p>
<h3 id="errors-Unwrap-函数"><a href="#errors-Unwrap-函数" class="headerlink" title="errors.Unwrap 函数"></a><code>errors.Unwrap</code> 函数</h3><p>除了以上两个函数，<code>errors</code> 包还提供了 <code>Unwrap</code> 函数，可以直接尝试获取 err 所包裹的下一层错误。其实现非常简单：如果 <code>err</code> 实现了 <code>Unwrap() error</code> 方法，则直接调用该方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unwrap</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 如果实现了 Unwrap 方法，那么还会调用其 Unwrap 方法</span></span><br><span class="line">	u, ok := err.(<span class="keyword">interface</span> &#123;</span><br><span class="line">		Unwrap() <span class="type">error</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// 没有实现 Unwrap 方法，直接返回 nil</span></span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> u.Unwrap()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别注意，<code>Unwrap</code> 方法只判断了 <code>err</code> 是否实现了 <code>Unwrap() error</code> 方法，其并不会尝试调用 <code>Unwrap() []error</code> 方法。</p>
<h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><p>首先如下展示了 Join 函数的一个基本使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	errA := errors.New(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">	errB := errors.New(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A\nB</span></span><br><span class="line">	errAB := errors.Join(errA, errB)</span><br><span class="line">	fmt.Println(errAB.Error())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// true</span></span><br><span class="line">	fmt.Println(errors.Is(errAB, errA))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 Join 函数也能够支持 <code>错误包裹链</code>，这正是因为其实现了 <code>Unwrap() []error</code> 方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *joinError)</span></span> Unwrap() []<span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.errs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看一个自定义类型实现 <code>错误包裹链</code> 的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> wrappedError <span class="keyword">struct</span> &#123;</span><br><span class="line">	err <span class="type">error</span></span><br><span class="line">	msg <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> customizedError <span class="keyword">struct</span> &#123;</span><br><span class="line">	msg <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *customizedError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *wrappedError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> w.msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *wrappedError)</span></span> Unwrap() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> w.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err1 := errors.New(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	err2 := errors.New(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	cErr1 := &amp;customizedError&#123;<span class="string">&quot;customized error 1&quot;</span>&#125;</span><br><span class="line">	cErr2 := &amp;customizedError&#123;<span class="string">&quot;customized error 2&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	wrap1 := &amp;wrappedError&#123;</span><br><span class="line">		msg: <span class="string">&quot;wrap1&quot;</span>,</span><br><span class="line">		err: err1,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wrapc := &amp;wrappedError&#123;</span><br><span class="line">		msg: <span class="string">&quot;wrap customized&quot;</span>,</span><br><span class="line">		err: cErr1,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// true</span></span><br><span class="line">	fmt.Println(errors.Is(wrap1, err1))</span><br><span class="line">	<span class="comment">// false</span></span><br><span class="line">	fmt.Println(errors.Is(wrap1, err2))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> errors.As(wrap1, &amp;err2) &#123;</span><br><span class="line">		<span class="comment">// // wrap1</span></span><br><span class="line">		fmt.Println(err2.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// true</span></span><br><span class="line">	fmt.Println(errors.Is(wrapc, cErr1))</span><br><span class="line">	<span class="comment">// false</span></span><br><span class="line">	fmt.Println(errors.Is(wrapc, cErr2))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// customized error 2</span></span><br><span class="line">	fmt.Println(cErr2.Error())</span><br><span class="line">	<span class="keyword">if</span> errors.As(wrapc, &amp;cErr2) &#123;</span><br><span class="line">		<span class="comment">// customized error 1</span></span><br><span class="line">		fmt.Println(cErr2.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个例子中，需要特别注意的是 <code>errors.New()</code> 函数的返回的是 error 接口类型，因此当调用 <code>errors.As(wrap1, &amp;err2)</code> 时，其实是判断 <code>wrap1</code> 是否可以赋值给 <code>error</code> 接口类型，因此 <code>err2</code> 最后其实保存的是值其实是 <code>wrap1</code> 本身。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇文章学习了 go 库 erros 包所提供的基础设施，包括 <code>errors.New</code> 函数、<code>errors.Join</code> 函数等。同时 errors 包通过 <code>Unwrap</code> 接口实现了对 <code>错误包裹链</code> 的支持，我们可以通过 <code>errors.Unwrap</code>、<code>errors.Is</code>、<code>errors.As</code> 函数来对错误链中的错误进行提取和检视。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/Go/" rel="tag"># Go</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2024/10/27/go-library-netip/" rel="prev" title="go 库学习之 netip">
      <i class="fa fa-chevron-left"></i> go 库学习之 netip
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2024/10/13/go-library-bytes/" rel="next" title="go 库学习之 bytes">
      go 库学习之 bytes <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#error-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.</span> <span class="nav-text">error 接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#errors-New-%E5%87%BD%E6%95%B0"><span class="nav-number">2.</span> <span class="nav-text">errors.New 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#errors-Join-%E5%87%BD%E6%95%B0"><span class="nav-number">3.</span> <span class="nav-text">errors.Join 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%8C%85%E8%A3%B9%E9%93%BE"><span class="nav-number">4.</span> <span class="nav-text">错误包裹链</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#errors-Is-%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.</span> <span class="nav-text">errors.Is 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#errors-As-%E5%87%BD%E6%95%B0"><span class="nav-number">4.2.</span> <span class="nav-text">errors.As 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#errors-Unwrap-%E5%87%BD%E6%95%B0"><span class="nav-number">4.3.</span> <span class="nav-text">errors.Unwrap 函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B"><span class="nav-number">5.</span> <span class="nav-text">简单示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">小结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">175</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
