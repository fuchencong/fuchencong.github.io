<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="这篇文章学习使用 Go 语言做软件项目过程中很可能会遇到的一些工程问题的解决方法，包括使用 go module 进行 Go 包依赖管理、Go 应用容器镜像、Go 相关工具使用等。">
<meta property="og:type" content="article">
<meta property="og:title" content="《Go 语言精进之路》读书笔记（10）：工具链与工程实践">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2024/10/06/improve-go-10/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="这篇文章学习使用 Go 语言做软件项目过程中很可能会遇到的一些工程问题的解决方法，包括使用 go module 进行 Go 包依赖管理、Go 应用容器镜像、Go 相关工具使用等。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-10-06T02:41:55.000Z">
<meta property="article:modified_time" content="2024-10-16T02:46:31.704Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2024/10/06/improve-go-10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>《Go 语言精进之路》读书笔记（10）：工具链与工程实践 | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2024/10/06/improve-go-10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《Go 语言精进之路》读书笔记（10）：工具链与工程实践
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-06 10:41:55" itemprop="dateCreated datePublished" datetime="2024-10-06T10:41:55+08:00">2024-10-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这篇文章学习使用 Go 语言做软件项目过程中很可能会遇到的一些工程问题的解决方法，包括使用 <code>go module</code> 进行 Go 包依赖管理、Go 应用容器镜像、Go 相关工具使用等。</p>
<span id="more"></span>

<h2 id="使用-Go-module-管理包依赖"><a href="#使用-Go-module-管理包依赖" class="headerlink" title="使用 Go module 管理包依赖"></a>使用 <code>Go module</code> 管理包依赖</h2><p>使用 <code>go module</code> 管理包依赖已经成为 Go 项目包依赖管理的唯一标准，并成为高质量 Go 代码的必要条件。</p>
<h3 id="Go-语言包管理演进回顾"><a href="#Go-语言包管理演进回顾" class="headerlink" title="Go 语言包管理演进回顾"></a>Go 语言包管理演进回顾</h3><p>为了更好理解 go module 包依赖管理机制，首先需要了解 Go 语言包管理的演进历史。</p>
<p>Go 在构建设计方面深受 Google 内部开发实践的影响。Google 内部采用基于主干的开发模型：</p>
<ul>
<li>所有开发人员基于主干（trunk&#x2F;mainline）开发，将代码提交到主干或从主干获取最新的代码（同步到本地仓库）​</li>
<li>版本发布时，建立发布分支（Release branch）​，发布分支实质上就是某一个时刻主干代码的快照</li>
<li>必须同步到发布分支上的补丁代码和改进代码通常先在主干上提交（commit）​，再挑拣（cherry-pick）到发布分支上</li>
</ul>
<p>基于这个模型，google 内部各个 project&#x2F;repositories 的 master 分支上的代码都被认为是稳定的。<code>go get</code> 早期的行为模式与该模型类似：<code>go get</code> 仅支持获取主分支上的 latest 代码，没有指定 version、branch 或 revision 的能力。</p>
<p><code>go get</code> 本质上是 git、hg 等版本管理工具的高级包装。对于使用 git 的 Go 包来说，go get 的实质就是将这些包克隆到本地的特定目录下（例如在 gopath 模式下为 <code>$GOPATH/src/github.com/user/repo</code>），同时 <code>go get</code> 可以自动解析包的依赖，自动下载相关依赖包并调用本地 Go 工具链完成的包的本地构建。</p>
<p>这种机制有如下缺点：</p>
<ul>
<li>不能保证可重现的构建（不同 gopher 在不同时间获取和编译包得到的结果可能是不同的）</li>
<li>如果依赖包引入了不兼容代码，你的程序&#x2F;包无法通过编译</li>
<li>如果依赖包引入了编译问题，这种错误也会传导到你的包中，导致你的包无法通过编译</li>
</ul>
<p>Gopher 希望自己项目所依赖的第三方包都能受自己控制，不是随意变化，于是 godep、gb、glide 等一批第三方包管理工具出现。</p>
<p>Go 核心团队自己也一直在关注 Go 的包依赖问题，并在 1.5 版本中引入了 vendor 机制。vendor 标准化了项目依赖的第三方库的存放位置，Go 编译器能够原生优先感知和使用 vendor 目录下缓存的第三方包版本。</p>
<p>虽然有了 vendor 的支持，vendor 内的第三方依赖包代码的管理也依旧是不规范的：要么是手动、要么借助 godep 这样的第三方包管理工具（依赖包的分析、记录和获取等）。</p>
<p>2018 年 5 月，Russ Cox 将 <code>go module</code> 机制合入 Go 项目项目主干，它的诞生意味着另一个尝试用来解决 Go 包管理的 dep 项目结束。</p>
<h3 id="Go-module：Go-包管理的生产标准"><a href="#Go-module：Go-包管理的生产标准" class="headerlink" title="Go module：Go 包管理的生产标准"></a>Go module：Go 包管理的生产标准</h3><p>在 <code>GO111MODULE=&quot;off&quot;</code> 的情况下，项目的构建采用传统的 GOPATH 模式。在该模式下，我们需要通过 <code>go get</code> 将包下载到本地（它也会自动下载该包的所有依赖包）<code>$GOPATH</code> 目录下，GO 编译器会从 <code>$GOPATH</code>（及 vendor 目录下）搜索目标程序依赖包。这种模式称为 <code>gopath mode</code>。</p>
<p>在引入了 vendor 机制以及诸多包管理工具后，Go 核心团队一致在尝试 <code>去 GOPATH</code>。从 Go 1.18 开始，GOPATH 会有一个默认值，Linux 下是 <code>$HOME/go</code>。虽然不用设置 GOPATH，但是 GOPATH 在 Go 工具链中依然很重要。</p>
<p>Go module 引入了一种新的依赖管理模式：module-aware 模式。在该模式下，通常一个仓库的顶层目录下会放置一个 <code>go.mod</code> 文件，每个 go.mod 文件唯一定义一个 module。<strong>一个 module 就是由一组相关的包组成的一个独立的版本单元</strong>。存放 go.mod 文件的目录被称为 module 根目录。module root 目录及其子目录下的所有 Go 包均属于该 module（除了那些自身包含 go.mod 文件的子目录）。<strong>虽然 Go 支持在一个仓库中定义多个 module，但是 Go 惯用法是一个仓库只定义一个 module</strong>。</p>
<p>在 module-aware 模式下，Go 编译器将不会在 <code>GOPATH</code> 及 <code>vendor</code> 下搜索目标程序依赖的第三方 Go 包。在该模式下，Go 编译器会将下载的依赖包缓存在 <code>$GOPATH/pkg/mod</code> 目录下。</p>
<p>在 Go1.11 版本中，go module 通过 <code>GO111MODULE</code> 变量来控制是否开启。该变量有 3 个值：auto、on 和 off。默认值为 auto。GO111MODULE 的值会直接影响 Go 编译器的包依赖管理工作模式的选择：是 gopath 模式还是module-aware 模式。</p>
<ul>
<li>如果为 off，则始终使用 gopath 模式，即 Go 编译器在 $GOPATH 及 vendor 下搜索目标程序的依赖包</li>
<li>如果为 on，则始终使用 module-aware 模式，即总是在 go module 的缓存目录（默认是 $GOPATH&#x2F;pkg&#x2F;mod）下搜索对应版本的依赖包</li>
<li>如果为 auto，此时取决于要构建的源代码所在位置以及是否包含 go.mod 文件。如果要构建的源代码不在以 <code>GOPATH/src</code> 为根目录的子树中且包含 go.mod 文件（两个条件同时满足），那么会使用 <code>module-aware</code> 模式，否则使用 <code>gopath</code> 模式</li>
</ul>
<p>在 Go1.13 中，虽然 <code>GO111MODULE</code> 的值还是 auto，但是只要目录下有 go.mod 文件，那么 Go 编译器就会使用 module-aware 模式来管理包依赖。</p>
<p>在 Go1.14, go module 机制趋于稳定，<code>GO111MODULE</code> 的值对包依赖管理工作模式的选择及行为模式变动如下：</p>
<ul>
<li>在 <code>module-aware</code> 模式下，如果 go.mod 中 <code>go version</code> 是 Go 1.14 及以上，且当前仓库顶层目录下有 vendor 目录，那么 Go 工具链将默认使用 vendor（-mod&#x3D;vendor）中的包，而不是 <code>module cache</code> 中的（$GOPATH&#x2F;pkg&#x2F;mod下）​。同时，Go 工具会校验 vendor&#x2F;modules.txt 与 go.mod 文件以确保它们保持同步。如果显示传入 <code>-mod=mod</code>，那么也可以强制使用 module cache 中的包进行构建</li>
<li>在 <code>module-aware</code> 模式下，如果无法找到 <code>go.mod</code>，那么你必须显式传入要处理的 Go 源文件列表，否则 Go 工具链将需要你明确建立 go.mod。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># go build</span></span><br><span class="line">go: go.mod file not found <span class="keyword">in</span> current directory or any parent directory; see <span class="string">&#x27;go help modules&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># go build main.go</span></span><br><span class="line"><span class="comment"># ls</span></span><br><span class="line">main  main.go</span><br></pre></td></tr></table></figure>

<p>在 Go 1.16 中，Go <code>module-aware</code> 模式成为默认模式，即 <code>GO111MODULE</code> 的值默认为 on。</p>
<p><code>go.mod</code> 文件一旦被创建，它的内容就会被 Go 工具链全面掌控。Go 工具链的各类命令执行时都会维护 go.mod 文件。</p>
<ul>
<li>可以通过 <code>go list -m</code> 来查看构建当前 module 所需的所有相关包信息的列表。其中 <code>Main: true</code> 的那个 module 为 <code>main module</code>。<code>main module</code> 即 <code>go build</code> 命令执行时所在当前目录所归属的那个 module。go 命令会在当前目录、当前目录的父目录、父目录的父目录等下面寻找 go.mod 文件，所找到的第一个 <code>go.mod</code> 文件对应的 module 即为 main module</li>
<li>使用 <code>go mod -require</code> 可以显示更新 go.mod 文件中的 require 段的信息（支持 query 表达式）。如果没有显式指定版本，Go 编译器总是使用依赖包的最新版本信息（如果依赖包没有版本，Go 会为其会产生伪版本号）</li>
<li>每个依赖管理方案都必须解决选择依赖项版本的问题。Go 则采用了最小版本选择（Minimal Version Selection, MVS）算法</li>
<li>按照语义化版本规范，当代码出现与之前版本不兼容性变化时，需要升级版本中的 major 版本号。go module 允许在包导入路径中带有 major 版本号，甚至可以在一个项目中同时依赖同一个包的不同版本</li>
<li>go module 机制依然兼容 vendor 机制。go module 支持通过如下命令将某个 module 的所有依赖复制一份到 module 的根路径下。这样即使在 <code>module-aware</code> 模式下，依然可以只用 vendor 下的包来构建。而且生成的 vendor 目录还可以兼容 Go1.11 之前的 Go 编译器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># go mod -vendor</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># go build -mod=vendor</span></span><br></pre></td></tr></table></figure>

<ul>
<li>执行 <code>go build</code> 之后，当前构建的模块目录下多了一个 <code>go.sum</code> 文件，该文件记录了每个依赖库的版本和对应内容的校验和。go 命令会使用这些校验和与缓存在本地的依赖包副本元信息进行对比校验。可以通过 <code>go mod verify</code> 命令来检查当前依赖包是否被修改过</li>
<li>在将代码提交&#x2F;推回存储库之前，运行 <code>go mod tidy</code> 以确保 module 文件（go.mod）是最新且准确的，<strong>该命令可以确保项目具有所需内容准确且完整的快照</strong></li>
<li>由于 go.mod 和 go.sum 都是由 Go 工具链维护和管理的，不建议手动修改 go.mod 中 require 中的包版本号。我们可以通过 <code>go get</code> 命令来修改依赖关系（该命令会自动计算并更新其间接依赖的包的版本）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># go list -m -versions golang.org/x/text</span></span><br><span class="line">golang.org/x/text v0.1.0 v0.2.0 v0.3.0 v0.3.1 v0.3.2 v0.3.3 v0.3.4 v0.3.5 v0.3.6 v0.3.7 v0.3.8 v0.4.0 v0.5.0 v0.6.0 v0.7.0 v0.8.0 v0.9.0 v0.10.0 v0.11.0 v0.12.0 v0.13.0 v0.14.0 v0.15.0 v0.16.0 v0.17.0 v0.18.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># go get golang.org/x/text@v0.3.2</span></span><br><span class="line">go: downloading golang.org/x/text v0.3.2</span><br><span class="line">go: added golang.org/x/text v0.3.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat go.mod</span></span><br><span class="line">module <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">go 1.23.1</span><br><span class="line"></span><br><span class="line">require golang.org/x/text v0.3.2 // indirect</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat go.sum</span></span><br><span class="line">golang.org/x/text v0.3.2 h1:tW2bmiBqwgJj/UpqtC8EpXEZVYOwU0yG4iWbprSVAcs=</span><br><span class="line">golang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=</span><br><span class="line">golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=</span><br></pre></td></tr></table></figure>

<ul>
<li>在 module-aware 模式下，使用 <code>go get -u</code> 将当前 module 的所有依赖的包版本都升级到最新的兼容版本。如果仅升级 patch 号，而不升级 minor 号，可以使用 <code>go get -u=patch</code></li>
</ul>
<h3 id="Go-module-代理"><a href="#Go-module-代理" class="headerlink" title="Go module 代理"></a>Go module 代理</h3><p>可以通过设置 GOPROXY 环境变量让 Go 命令从代理服务器下载 module。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOPROXY=<span class="string">&#x27;https://goproxy.cn&#x27;</span></span><br></pre></td></tr></table></figure>

<p>Go1.13 开始，<code>https://proxy.golang.org</code> 被设置为 <code>GOPROXY</code> 环境变量的默认值之一，这也是 Go 提供的官方代理服务。而且该变量支持设置多个值（多个代理之间采用逗号隔开），Go 工具链会按照顺序从列表中的代理服务获取依赖包数据。</p>
<p>Go 1.13 提供了 GOSUMDB 环境变量来配置 Go 校验和数据库的服务地址（和公钥）​，其默认值为 <code>sum.golang.org</code>，这也是 Go 官方提供的校验和数据库服务（也可以使用 <code>sum.golang.google.cn</code>）​。</p>
<p>如果依赖的是企业内部代码服务器或公共代码托管站点上的私有 module，那么就不能使用公共 module 代理服务来获取数据。Go 1.13 提供了 <code>GOPRIVATE</code> 环境变量用于指示哪些仓库下的 module 是私有的，不需要通过 GOPROXY 下载，也不需要通过 GOSUMDB 验证其校验和。但是也需要注意，<code>GONOPROXY</code> 和 <code>GONOSUMDB</code> 可以覆盖 GOPRIVATE 变量中的设置。</p>
<h3 id="升级-module-的主版本号"><a href="#升级-module-的主版本号" class="headerlink" title="升级 module 的主版本号"></a>升级 module 的主版本号</h3><p>Go import包兼容性的总原则是：如果新旧版本的包使用相同的导入路径，那么新包与旧包是兼容的。也就是说，如果新旧两个包不兼容，那么应该采用不同的导入路径。因此主版本是导入路径的一部分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/bigwhite/foo/bar&quot;</span></span><br><span class="line">    barV2 <span class="string">&quot;github.com/bigwhite/foo/v2/bar&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在该方案中，对于包作者而言，升级主版本号需要：</p>
<ul>
<li>在 go.mod 中升级 module 的根路径，增加 vN</li>
<li>建立 <code>vN.x.x</code> 形式的标签（可选，如果不打标签，Go 会在消费者的 go.mod 中使用伪版本号，比如 （<code>bitbucket.org/bigwhite/modules-major-branch/v2 v2.0.0-20190603050009-28a5b8da279e</code>）</li>
<li>如果包内部有相互的包引用，那么在升级主版本号的时候，这些包的导入路径也要增加 vN，否则就会出现在高版本号的代码中引用低版本号包代码的情况，这也是包作者极容易忽略的事情</li>
</ul>
<p>对于包的消费者而言，升级依赖包的主版本号，只需要在导入包时在导入路径中增加 vN 即可，当然代码中也要针对不兼容的部分进行修改，然后 go 工具就会自动下载相关包了。</p>
<p>Go module 还提供了一种用起来不那么自然的方案，那就是利用子目录分割不同主版本。这里直接用 vN 作为子目录名字，在代码仓库中将不同版本 module 放置在不同的子目录中，这样即便不建分支、不打标签，Go编译器通过子目录名也能找到对应的版本。这种方式使得代码的分支管理更为复杂，一般很少使用。</p>
<h2 id="构建最小-Go-程序容器镜像"><a href="#构建最小-Go-程序容器镜像" class="headerlink" title="构建最小 Go 程序容器镜像"></a>构建最小 Go 程序容器镜像</h2><p>Go 语言已经成为云原生时代的头部语言，在本条中我们就来看看如何一步步地构建出最小 Go 程序容器镜像。</p>
<h3 id="镜像：继承中的创新"><a href="#镜像：继承中的创新" class="headerlink" title="镜像：继承中的创新"></a>镜像：继承中的创新</h3><p>2008 年，LXC（Linux Container）功能被合并到 Linux 内核中。LXC 是一种内核级虚拟化技术，主要基于 Namespace 和 Cgroups 技术，实现共享一个操作系统内核前提下的进程资源隔离，为进程提供独立的虚拟执行环境，这样的一个虚拟执行环境就是一个容器。</p>
<p>Docker 也是基于 Namespace 和 Cgroups 技术实现的，其创新之处在于其基于 Union File System 技术定义了一套容器打包规范，真正将容器中的应用及其运行的所有依赖都封装到一种特定格式的文件中，这种文件就称为 <code>镜像</code>。Docker 为开发者提供了开发者体验良好的工具集，包括用于构建镜像的 Dockerfile 以及一种用于编写 Dockerfile 的领域特定语言。</p>
<p>镜像是容器的序列化标准，它为容器的存储、重用和传输打下了基础。</p>
<h3 id="builder-模式的崛起"><a href="#builder-模式的崛起" class="headerlink" title="builder 模式的崛起"></a>builder 模式的崛起</h3><p>Dockerfile 由若干条命令组成，每条命令的执行结果都会单独形成一个层。在最终镜像中只要包含能够让应用正常运行的运行环境即可。为了解决应用的构建问题，至少有两种方法：</p>
<ul>
<li>在本地构建并复制到镜像中</li>
<li>借助构建者镜像（builder image）构建</li>
</ul>
<p>本地构建有很多局限性，例如本地环境无法复用、无法融入 CI&#x2F;CD 流水线等。而借助 builder image 进行构建成为 Docker 社区的最佳实践。在该模式下，整个目标镜像的构建被分为两个阶段：</p>
<ul>
<li>第一阶段，构建负责编译源码的构建者镜像</li>
<li>第二阶段，将第一阶段的输出作为输入，构建出最终的目标镜像</li>
</ul>
<p>在第一阶段中，可以使用 Docker 官方推出的各种主流编程语言的官方基础镜像，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:<span class="number">1.23</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line">WORKDIR /<span class="keyword">go</span>/src</span><br><span class="line"></span><br><span class="line">COPY ./main.<span class="keyword">go</span> .</span><br><span class="line"></span><br><span class="line">RUN <span class="keyword">go</span> build -o main ./main.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<p>接下来通过一些命令将两个阶段进行连接，这些命令将上阶段的构建输出取出并作为下一阶段构建的输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker build -t go-docker -f Dockerfile .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># docker create --name build-go-docker go-docker</span></span><br><span class="line"><span class="comment"># docker cp build-go-docker:/go/src/main ./main</span></span><br><span class="line"><span class="comment"># docker rm -f build-go-docker</span></span><br><span class="line"><span class="comment"># docker rmi go-docker</span></span><br></pre></td></tr></table></figure>

<p>接下来就是目标镜像的 Dockerfile：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">From ubuntu:20.04</span><br><span class="line"></span><br><span class="line">COPY ./main /root/main</span><br><span class="line">RUN <span class="built_in">chmod</span> +x /root/main</span><br><span class="line"></span><br><span class="line">WORKDIR /root</span><br><span class="line">ENTRYPOINT [<span class="string">&quot;/root/main&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>这样构建的目标镜像就不需要 go 的编译环境，只包含应用程序的运行环境即可。</p>
<h3 id="追求最小镜像"><a href="#追求最小镜像" class="headerlink" title="追求最小镜像"></a>追求最小镜像</h3><p>我们还可以对目标镜像继续优化，仅保留能支撑我们应用运行所必要的库、命令，其余的一律不纳入目标镜像。我们可以选择一些更小的镜像作为 base image，例如：</p>
<ul>
<li>busybox：它的默认 C 运行时库是 uClibc，而通常使用的 libc 实现都是 glibc</li>
<li>alpine：它使用比 glibc 更小、更安全的 musl libc 库。而且其支持自己的包管理体系 apk</li>
</ul>
<p>一般开发者喜欢使用 alpine 作为基础镜像。但是由于其也不是使用 glibc 作为 C 运行时库，这会使得基于 glibc 上编译出来的应用程序不兼容。对于 Go 程序来说，可以静态编译程序（也会失去一些 libc 提供的原生能力），或者可以采用基于 alpine 的 builder image。</p>
<h3 id="对多阶段构建的支持"><a href="#对多阶段构建的支持" class="headerlink" title="对多阶段构建的支持"></a>对多阶段构建的支持</h3><p>Docker 引擎本身也支持多阶段构建（multi-stage build），如下是一个多阶段构建的实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:alpine as builder</span><br><span class="line"></span><br><span class="line">WORKDIR /go/src</span><br><span class="line"></span><br><span class="line">COPY ./main.go .</span><br><span class="line"></span><br><span class="line">RUN go build -o main ./main.go</span><br><span class="line"></span><br><span class="line">FROM alpine:latest</span><br><span class="line"></span><br><span class="line">WORKDIR /root</span><br><span class="line">COPY --from=builder /go/src/main .</span><br><span class="line">RUN <span class="built_in">chmod</span> +x /root/main</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [<span class="string">&quot;/root/main&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># docker build -f Dockerfile -t multi-<span class="keyword">go</span>-docker .</span><br><span class="line"># docker run multi-<span class="keyword">go</span>-docker</span><br><span class="line">hello docker</span><br></pre></td></tr></table></figure>

<h2 id="自定义-Go-包的导入路径"><a href="#自定义-Go-包的导入路径" class="headerlink" title="自定义 Go 包的导入路径"></a>自定义 Go 包的导入路径</h2><p>我们使用最多的 Go 包 go get 导入路径主要是基于一些代码托管站点域名，例如 github.com。还有一些包的导入路径很特殊，例如 <code>golang.org/x/net</code>，这些包使用了自定义的包导入路径，这种自定义包导入路径的方式有很多好处：</p>
<ul>
<li>可以作为 Go 包的权威导入路径：Go 包的用户只需要使用包的权威导入路径，无论 Go 包的实际托管点在哪、Go 包迁移到哪个托管站点，对 Go 包的用户都不会带来实质性影响</li>
<li>便于组织和个人对 Go 包的管理：可以将分散托管在不同代码站点上的 Go 包统一聚合到组织的官方域名下</li>
<li>go 包导入路径可以更短、更简洁</li>
</ul>
<h3 id="govanityurls"><a href="#govanityurls" class="headerlink" title="govanityurls"></a>govanityurls</h3><p>govanityurls 工具可以帮助 gopher 快速实现自定义 Go 包的 <code>go get</code> 导入路径。它其实类似于导航服务器，<code>go get</code> 向自定义包地址发起请求时，实则是将请求发送给了 govanityurls 服务，之后 govanityurls 将请求中包所在仓库的真实地址返回给 <code>go get</code>，<code>go get</code> 再从真实的仓库地址获取数据。</p>
<h3 id="使用-govanityurls"><a href="#使用-govanityurls" class="headerlink" title="使用 govanityurls"></a>使用 govanityurls</h3><p>要使用 govanityurls，需要遵循如下步骤：</p>
<ul>
<li>安装 govanityurls 工具</li>
<li>配置 govanityurls 的配置文件 vanity.yaml，该文件中配置了 host 下的自定义包路径以及其真实的仓库地址</li>
<li>配置反向代理：使用一个反向代理软件（例如 Nginx）将访问自定义包导入路径的请求转发给 govanityurls 服务的主机地址</li>
<li>启动 govanityurls 服务</li>
</ul>
<h2 id="熟练掌握-Go-常用工具"><a href="#熟练掌握-Go-常用工具" class="headerlink" title="熟练掌握 Go 常用工具"></a>熟练掌握 Go 常用工具</h2><p>接下来将全面介绍 Go 包开发周期中的常用工具，涵盖主要原生工具以及使用较广的第三方工具。</p>
<h3 id="获取与安装"><a href="#获取与安装" class="headerlink" title="获取与安装"></a>获取与安装</h3><p>Go 原生提供了获取和安装 Go 包的工具 <code>go get</code> 和 <code>go install</code>。</p>
<h4 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a>go get</h4><p><code>go get</code> 用于获取 Go 包及其依赖包。</p>
<ul>
<li><p><code>go get -d</code> 可以获取 Go 项目的源码，它仅将源码下载到本地，不会对目标包进行编译和安装</p>
<ul>
<li>在 <code>module-aware</code> 模式下，<code>go get -d</code> 命令会将源码包及其依赖下载到 <code>$GOPATH/pkg/mod</code> 下</li>
<li>在 <code>gopath</code> 模式下，则将源码包及其依赖下载到 <code>$GOPATH/src</code> 下</li>
<li>虽然都会下载依赖包，但是 <code>module-aware</code> 模式还会分析依赖包的版本。</li>
</ul>
</li>
<li><p>标准的 <code>go get</code> 会下载项目及其依赖包的源码，并对下载的源码进行编译和安装。</p>
<ul>
<li>在 gopath 模式下，如果目标源码最终被编译成一个可执行的二进制文件，则被安装到 <code>$GOBIN</code> 或者 <code>$GOPATH/bin</code> 目录下。如果是目标源码是库，则编译后的库目标文件以 <code>.a</code> 形式被安装到 <code>$GOPATH/pkg/$GOOS_$GOARCH</code></li>
<li>在 module-aware 模式下，编译出的二进制目标文件也会被安装到 <code>$GOBIN</code> 或者 <code>$GOPATH/bin</code>；如果目标源码是库，则只编译并将编译结果缓存下来，不会安装</li>
</ul>
</li>
<li><p><code>go get -u</code> 可以更新目标包及其依赖包的版本。</p>
<ul>
<li>在 gopath 模式下，该命令获取最新版本的源码到本地后会再次编译安装</li>
<li>在 module-aware 模式下，该命令则会根据目标 module 的 go.mod 中依赖 module 版本获取满足要求的、依赖 module 的 minor 版本或 patch 版本更新</li>
</ul>
</li>
<li><p><code>go get -t</code> 可以获取测试代码依赖的包</p>
</li>
</ul>
<h4 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h4><p><code>go install</code> 可以将本地构建出的可执行文件安装到 <code>$GOBIN</code>（默认值为 <code>$GOPATH/bin</code>）、将包目标文件 <code>.a</code> 安装到 <code>$GOPATH/pkg/$GOOS_$GOARCH</code> 下。</p>
<p><code>go install</code> 命令在 gopath 模式和 module-aware 模式下的行为也略有差异。</p>
<ul>
<li>gopath 模式：<ul>
<li>引入 go module 之前（即 Go1.11 之前）：将可执行文件安装到 $GOBIN，将依赖包安装到 <code>$GOPATH/pkg/$GOOS_$GOARCH</code></li>
<li>引入 go module 之后：仅将可执行文件安装到 <code>$GOBIN</code>，将依赖包编译后放入 <code>$GOCACHE</code> 下</li>
</ul>
</li>
<li>module-aware 模式：仅将可执行文件安装到 <code>$GOBIN</code> 下，将依赖包编译后放入 <code>$GOCACHE</code> 下</li>
</ul>
<h4 id="新的变化"><a href="#新的变化" class="headerlink" title="新的变化"></a>新的变化</h4><p>其实从 Go1.17 开始，使用 <code>go get</code> 来安装可执行文件已经被废弃了，取而代之的是 <code>go install</code>。在 Go1.18 中，<code>go get</code> 也不再用于构建软件包，它只是用来增加、更新或移除 <code>go.mod</code> 中的依赖项。具体可以参考 <a target="_blank" rel="noopener" href="https://go.dev/doc/go-get-install-deprecation">Deprecation of ‘go get’ for installing executables</a>。</p>
<h3 id="包或者-module-的检视"><a href="#包或者-module-的检视" class="headerlink" title="包或者 module 的检视"></a>包或者 module 的检视</h3><p>Go 提供了一个原生工具 <code>go list</code>，用于列出关于包&#x2F;module 的各类信息。该命令默认列出当前路径下的包的导入路径</p>
<ul>
<li>如果是 module-aware 模式，它会在当前路径下寻找 go.mod 文件。如果当前路径下没有 <code>go.mod</code> 文件，则报错</li>
<li>在 gopath 模式下，如果当前路径没有包，<code>go list</code> 会报错。如果后面直接接包的导入路径，<code>go list</code> 会在 <code>$GOPATH/src</code> 下寻找该包，如果存在，则输出包的导入路径</li>
<li>如果要列出当前路径及其子路径（递归）下的所有包，可以用 <code>go list &#123;当前路径&#125;/...</code>。也可以使用 <code>包导入路径 + ...</code> 的方式，表示列出该路径下所有子路径下的包导入路径</li>
</ul>
<p>Go 原生保留了几个代表特定包或包集合的路径关键字：main、all、cmd 和 std。这些保留的路径关键字不要用于 Go 包的构建中：</p>
<ul>
<li>main：表示独立可执行程序的顶层包</li>
<li>all：在 gopath 模式下，可以展开为标准库和 GOPATH 路径下的所有包；在 module-aware 模式下，可以展开为主 module（当前路径下的 module）下的所有包及其所有依赖包</li>
<li>std：代表标准库所有包的集合</li>
<li>cmd：代表 Go 语言自身项目仓库下 src&#x2F;cmd 下的所有包及 internal 包</li>
</ul>
<p>如下是 <code>go list</code> 的其他用法：</p>
<ul>
<li>默认 <code>go list</code> 输出的都是包的导入路径信息，如果要列出 module 信息，可以使用 <code>go list -m</code></li>
<li><code>go list -f</code> 可以定制其输出内容的格式</li>
<li><code>go list -json</code> 可以以 JSON 格式输出包的全部信息</li>
<li><code>go list -m -u</code> 可以列出 module 及其依赖 module 是否有新的版本可以升级</li>
</ul>
<h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>Go 原生的 <code>go build</code> 命令可以用于 Go 源码的构建。大多数情况下，只需要标准 <code>go build</code> 即可满足构建需求。如下介绍 <code>go build</code> 的一些常见用法：</p>
<ul>
<li><code>-x -v</code>：可以让构建过程一目了然。其中 -v 用于输出当前正在编译的包，而 -x 则用于输出 go build 执行的每一个命令</li>
<li><code>-a</code>：该选项让 <code>go build</code> 忽略掉所有缓存机制，忽略掉已经安装到 <code>$GOPATH/pkg</code> 下的依赖包库文件，并从目标包&#x2F;module 依赖的标准包的每个 Go 源文件开始重新构建</li>
<li><code>-race</code>：可以在构建的结果中加入竞态检测的代码</li>
<li><code>go build</code> 可以经由 <code>-gcflags</code> 向 compile 工具传递所需的命令行标志选项集合。具体的使用方法如下所示。如果没有指定 <code>标志应用的包范围</code>，则指定的编译选项仅应用于当前包；如果显式指定了包范围，则编译选项不仅会应用到当前包的编译上，还会应用于包范围指定的包上</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -gcflags[=标志应用的包范围]=<span class="string">&#x27;空格分隔的标志选项列表&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用 <code>go tool compile -help</code> 列出编译器所支持的选项集合。例如通常使用 <code>-N -l</code> 两个选项关闭对代码的优化和内联，这样方便调试</li>
<li><code>go build</code> 支持经由 <code>-ldflags</code> 为链接器传递链接选项的集合。可以通过 <code>go tool link -help</code> 列出链接器支持的所有链接选项。例如，通过 -X 选项设置包中 string 类型变量的值（经常用于设置程序的版本信息）、-s 选项不生成符号表、-w 不生成 DWARF 调试信息</li>
<li><code>go build</code> 支持通过 <code>-tags</code> 指定构建的约束条件，以决定哪些源文件被包含在包内进行构建。tags 的值是一组逗号分隔的值。例如：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go build -tags=<span class="string">&quot;tag1,tag2...&quot;</span> ...</span><br></pre></td></tr></table></figure>

<ul>
<li>此时 Go 源文件中也会包含 <code>build tag</code>。<code>build tag</code> 通常放在 Go 源文件的顶部区域，以一行注释或者连续的多行注释形式存在。<code>build tag</code> 与前后的包注释或包声明语句的中间要有一行空行。<code>build tag</code> 行也是注释行，它以 <code>+build</code> 作为起始标记，与前面的注释符号 <code>//</code> 中间有一个空格，之后则是约束标记字符串。<strong>当一个 Go 源文件带有 build tag 时，只有该组 tag 被求值为 true 时，该源文件才会被包含入对应包的构建中</strong>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build aix darwin dragonfly freebsd js,wasm linux netbsd openbsd solaris</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> os</span><br></pre></td></tr></table></figure>

<ul>
<li>Go 源文件中的 <code>build tag</code> 按照如下规则进行布尔表达式求值：<ul>
<li><code>// +build tag1 tag2</code>：tag1 OR tag2</li>
<li><code>// +build tag1,tag2</code>：tag1 AND tag2</li>
<li><code>// +build !tag1</code>：NOT tag1</li>
</ul>
</li>
</ul>
<h3 id="运行与诊断"><a href="#运行与诊断" class="headerlink" title="运行与诊断"></a>运行与诊断</h3><p>由于 Go 生成的程序对环境的依赖很少，甚至不需要任何依赖（比如采用静态链接），在如今的云原生微服务时代，这让 Go 程序在部署和运行方面有着很大的优势。Go 原生提供了一些环境变量，这些环境变量可以影响 Go 程序运行时的行为，并输出 Go 运行时的一些信息以辅助在线诊断 Go 程序的问题。</p>
<ul>
<li>GOMAXPROCS：可用于设置 Go 程序启动后的逻辑处理器 P 的数量。从 Go1.5 开始，该值默认为 CPU 核数。</li>
<li>GOGC：它是一个整数值，表示一个百分比，用于控制垃圾回收的时机。它的分子是上一次 GC 结束后到当前时刻新分配的堆内存大小（设为 M）​，分母则是上一次 GC 结束后堆内存上的活动对象内存数据的大小（设为 N）​</li>
<li>GODEBUG：提供强大的运行时诊断能力。例如通过 <code>gctrace=1</code> 可以在 GC 启动时输出 GC 相关信息</li>
</ul>
<h3 id="格式化与静态代码检查"><a href="#格式化与静态代码检查" class="headerlink" title="格式化与静态代码检查"></a>格式化与静态代码检查</h3><ul>
<li>在提交代码前，可以使用 <code>gofmt</code> 对代码进行格式化。<code>goimports</code> 在 <code>gofmt</code> 功能的基础上可以自动更新源文件中的 <code>import</code> 区域</li>
<li>静态代码检查工具可以按照设定好的规则对代码进行扫描，才语义层面尝试发现潜在问题。<code>go vet</code> 是官方 Go 工具链提供的静态代码检查工具。也有一些第三方 lint 工具，例如 <code>golangci-lint</code></li>
</ul>
<h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>接下来介绍一些可以实施 Go 代码重构的工具。</p>
<ul>
<li><code>gofmt -r</code> 支持对当前路径及其子路径下的 Go 包源文件进行纯字符串模式的替换</li>
<li><code>gorename</code> 工具可以进行语法层面安全的标识符替换</li>
<li><code>gomvpkg</code> 是专门用来实现包移动&#x2F;改名并同步更新项目中所有导入该包的源文件中的包导入路径和包引用名的工具</li>
</ul>
<h3 id="查看文档"><a href="#查看文档" class="headerlink" title="查看文档"></a>查看文档</h3><p>Go 已经将项目文档加入到 Go 发行版中，开发人员在本地安装 Go 的同时也拥有了一份完整的 Go 项目文档。而且 Go 还将文档查看工具集成到其工具链当中（go doc），使之成为 Go 工具链不可分割的一部分。</p>
<ul>
<li>通过 <code>go doc &lt;pkg&gt;</code> 可以查看标准库某个包的文档</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># go doc http</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过 <code>go doc [&lt;pkg&gt;.][&lt;sym&gt;.]&lt;methodOrField&gt;</code> 可以查看某个函数&#x2F;方法&#x2F;类型&#x2F;字段的文档</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># go doc http.Request.Form</span></span><br><span class="line">package http // import <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Request struct &#123;</span><br><span class="line">    // Form contains the parsed form data, including both the URL field<span class="string">&#x27;s query</span></span><br><span class="line"><span class="string">    // parameters and the PATCH, POST, or PUT form data. This field is only available</span></span><br><span class="line"><span class="string">    // after ParseForm is called. The HTTP client ignores Form and uses Body instead.</span></span><br><span class="line"><span class="string">    Form url.Values</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // ... other fields elided ...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>直接输入 <code>go doc</code> 可以查看当前路径下的包的文档，可以查看某个导出元素、某个子路径下的包的文档</li>
<li><code>go doc -src</code> 可以查看某个元素的源代码</li>
</ul>
<p>从 Go1.13 开始，godoc 被挪到 Go 扩展工具链中。可以通过如下命令安装 <code>godoc</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install golang.org/x/tools/cmd/godoc@latest</span><br></pre></td></tr></table></figure>

<p>godoc 实际上是一个 Web 服务，它会在本地建立起一个 Web 形式的 Go 文档中心，执行如下命令就会启动该文档中心：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">godoc -http=0.0.0.0:6060</span><br></pre></td></tr></table></figure>

<p>另外，Go 团队提供了一个博客内容服务程序，可以本地安装该 blog 内容服务程序。另外，Go 团队还提供了一种 present 文件，它是使用自定义的轻量级标记语言编写的文件，可以通过特点的站点渲染该文件，或者本地安装 present 工具，就可以在浏览器中查看 present 文件。</p>
<h3 id="代码导航与洞察"><a href="#代码导航与洞察" class="headerlink" title="代码导航与洞察"></a>代码导航与洞察</h3><p>2019 年，Go 官方启动了 Go 语言服务器的实现项目 gopls。语言服务器协议（LSP）是由微软创建的，目的是让语言服务器和开发工具之间的通信协议标准化。这样单个语言服务器就可以在多个开发工具中重复使用，从而避免以往必须为每个开发工具都单独开发代码补全、代码跳转等功能。</p>
<p>VsCode、Vim 等主流 IDE&#x2F;编辑器都已经支持 gopls。</p>
<h2 id="使用-go-generate-驱动代码生成"><a href="#使用-go-generate-驱动代码生成" class="headerlink" title="使用 go generate 驱动代码生成"></a>使用 <code>go generate</code> 驱动代码生成</h2><p>这里单独介绍如何使用 <code>go generate</code> 工具驱动代码生成。</p>
<h3 id="go-generate：Go-原生的代码生成驱动器"><a href="#go-generate：Go-原生的代码生成驱动器" class="headerlink" title="go generate：Go 原生的代码生成驱动器"></a>go generate：Go 原生的代码生成驱动器</h3><p>有时候目标的构建需要依赖一些额外的前置动作，我们可以借助外部构建管理工具（例如 make）实现这个需求。Go 核心团队在 Go1.4 版本的 Go 工具链中增加了这种在构建之前驱动执行前置动作的能力，即 <code>go generate</code> 命令。</p>
<p>通过预先放置在代码中的、可以被 <code>go generate</code> 命令识别的指示符（directive），当我们执行 <code>go generate</code> 命令时，这些指示符命令就会被 <code>go generate</code> 识别并执行，从而完成前置动作的执行。</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//go:generate protoc -I ./IDL msg.proto --gofast_out=./msg</span><br></pre></td></tr></table></figure>

<h3 id="go-generate-的工作原理"><a href="#go-generate-的工作原理" class="headerlink" title="go generate 的工作原理"></a>go generate 的工作原理</h3><p><code>go generate</code> 命令需要在 <code>go build</code> 这类命令之前单独执行以生成后续命令需要的 Go 源文件等。<code>go generate</code> 命令将 Go 源文件当做普通文本文件并识别出可以与如下字符串模式匹配的内容。注意，注释符号 <code>//</code> 后面没有空格。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//go:generate <span class="built_in">command</span> arg...</span><br></pre></td></tr></table></figure>

<p>注意，go generate 指示符可以放在 Go 源文件中的任意位置，并且一个 Go 源文件中可以有多个 <code>go generate</code> 指示符，<code>go generate</code> 命令会按其出现的顺序逐个识别和执行。可以将 Go 源文件作为参数传递给 <code>go generate</code> 命令，也可以使用包作为 <code>go generate</code> 参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:generate echo &quot;start&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:generate echo &quot;middle&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:generate echo &quot;end&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># go generate</span></span><br><span class="line">start</span><br><span class="line">middle</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><code>go generate</code> 还可以通过 <code>-run</code> 使用正则式去匹配各源文件中 <code>go generate</code> 指示符中的命令，并仅执行匹配成功的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$go</span> generate -x -v -run <span class="string">&quot;protoc&quot;</span> ./...</span><br></pre></td></tr></table></figure>

<h3 id="go-generate-的应用场景"><a href="#go-generate-的应用场景" class="headerlink" title="go generate 的应用场景"></a><code>go generate</code> 的应用场景</h3><p><code>go generate</code> 目前主要用在目标构建之前驱动代码生成动作的执行，例如基于 protobuf 定义文件生成 Go 源文件就是 <code>go generate</code> 一个极为典型的应用。</p>
<p>还有比较广泛的应用包括利用 stringer 工具自动生成枚举类型的 String 方法以及利用 go-bindata 工具将数据文件&#x2F;静态文件嵌入 Go 源码中。当然从 Go1.16 开始，Go 内置了静态文件嵌入功能，我们可以直接在 Go 源码中通过 <code>go:embed</code> 指示符将静态资源文件嵌入。</p>
<p>go generate 工具通常是由 Go 包的作者使用和执行的，其生成的 Go 源码一般会提交到代码仓库中，<strong>这个过程对生成的包的使用者来说是透明的</strong>。</p>
<h2 id="牢记-Go-常见的陷阱"><a href="#牢记-Go-常见的陷阱" class="headerlink" title="牢记 Go 常见的陷阱"></a>牢记 Go 常见的陷阱</h2><p>牢记 Go 语言中的一些场景 <code>陷阱</code>，有助于 Gopher 在工程实践中少走弯路。当然这里的 <code>陷阱</code> 并不是真正的语言缺陷，而是一些因为对 Go 语言规范、运行时、标准库以及工具链等了解不够全面、深入和透彻而容易犯的错误，或者是因为语言间的使用差异而导致的误用问题。</p>
<h3 id="语法规范类"><a href="#语法规范类" class="headerlink" title="语法规范类"></a>语法规范类</h3><ul>
<li>短变量声明不总是会声明一个新的变量：在同一个代码块中，使用多短变量声明语句重新声明已经声明过的变量时，短变量声明语句</li>
<li>短变量声明会导致难于发现的变量遮蔽：由于不在同一个代码块中，短变量声明可能会会创建一个新的同名变量，造成对外层代码块中同名变量的遮蔽</li>
<li>不是所有以 nil 作为零值的类型都是零值可用的：切片、map、接口类型和指针类型的零值都是 nil，但是不是所有这些类型都是零值可用的<ul>
<li>对于切片类型，在 append 操作时是零值可用的</li>
<li>对于指针类型，可以调用没有对自身进行指针解引用的方法</li>
<li>对于接口类型，为接口类型赋予显式类型转换后的 nil（并非真正的零值），可以通过该接口调用 <code>没有解引用</code> 操作的方法</li>
</ul>
</li>
<li>值为 nil 的接口类型变量并不总是等于 nil：接口类型在运行时的表示分为两部分，一部分是类型信息，一部分是值信息。只有当接口类型变量的这两部分的值都为 nil 时，该变量才与 nil 相等。</li>
<li><code>for range</code> 针对切片、数组或字符串进行迭代操作时，迭代变量由两个，第一个是元素在迭代集合中的序号值，第二个值才是元素值</li>
<li>针对 string 类型进行 for range 迭代时，每次返回的是一个码点，而不是一个字节。如果想要逐字节迭代，可以通过 <code>[]byte(s)</code> 将字符串类型转换为字节切片再进行迭代。Go 编译器会对这个转换进行优化，它不会为 <code>[]byte</code> 进行额外的内存分配，而是直接使用 string 的底层数据</li>
<li>对 map 类型内元素的迭代顺序是随机的，如果想要有序迭代 map 内的元素，需要额外数据结构的支持，例如使用切片来有序保证 map 内元素的 key 值</li>
<li>在 <code>for range</code> 迭代中，我们需要注意到，我们是在 <code>复制品</code> 上进行迭代。而且迭代变量也是重用的</li>
<li>基于已有切片创建新的切片与原切片共享底层存储，这样如果原切片占用较大的内存，新切片的存在又使原切片内存无法得到释放，这样会占用过多内存。可以通过内建函数 <code>copy</code> 为新切片建立独立的存储空间以避免与原切片共享底层存储，从而避免空间浪费</li>
<li>除了占用的内存过多，新切片与旧切片共享底层存储也可能导致隐匿数据的暴露、切片数据被篡改。因为切片的容量特性，对新分配的切片进行扩张式 reslicing 操作有可能导致隐匿数据被暴露。依然可以通过为新切片分配独立的存储空间的方法来解决这个缺陷</li>
<li>新切片与原切片底层存储可能 <code>分家</code>，这是因为 Go 的切片支持自动扩。一旦发生 <code>分家</code>，后续对新切片的任何操作都不会影响到原切片</li>
<li>string 类型的长度并不等于该字符串的字符个数，而是等于 string 类型底层数组中的字节数量。string 类型的下标操作也是以字节为单位</li>
<li>string 类型是不可变的，无法改变其中的数据内容</li>
<li>string 类型的零值是 “”，而不是 nil</li>
<li>在 Go 中，switch 的执行流并不会从匹配到的 case 语句开始一直向下执行，而是执行完 case 语句块代码后跳出 switch 语句，除非你显式使用 <code>fallthrough</code> 强制向下一个case语句执行</li>
<li>在没有外部结构支撑的情况下，Go 原生并不支持获取某个 goroutine 的退出状态。而利用 channel 等数据结构，可以轻松获取 goroutine 的退出状态</li>
<li>程序的退出与否全看 main goroutine 是否退出。一旦 main goroutine 退出，这时即便有其他 goroutine 仍然在运行，程序进程也会退出，其他 goroutine 也就终止了。通常我们可以使用 sync.WaitGroup 来协调多个 goroutine</li>
<li>任何一个 goroutine 出现 panic，如果没有及时捕获，那么整个程序都将退出。为了避免这个问题，可以采用防御性代码，即在每个 goroutine 的启动函数中加上对 panic 的捕获逻辑。当然有时候让程序及时退出也可能是更好的处理方案</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">safeRun</span><span class="params">(g <span class="keyword">func</span>()</span></span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;caught a panic:&quot;</span>, e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    g()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>channel 有可能处于两种特殊状态，即零值 channel（nil channel）和已关闭的 channel（closed channel）。</p>
<ul>
<li>对 nil channel，发送和接收操作都会被阻塞</li>
<li>对于 closed channel，接收操作将返回 channel 中元素类型的零值，发送操作将引发 panic</li>
</ul>
</li>
<li><p>使用值类型 receiver 的方法无法改变类型实例的状态。因为方法本质上是一个以 receiver 为第一个参数的函数，而 Go 都是通过 <code>值复制</code> 的形式进行参数传递，因此函数内部对值类型的 receiver 进行修改，无法改变外部实参的状态</p>
</li>
<li><p>值类型实例可以调用采用指针类型 receiver 的方法，指针类型实例也可以调用采用值类型 receiver 的方法。<strong>注意这个语法糖的范围仅限于类型实例调用方法这个范畴。当我们将类型实例赋值给某个接口时，只有真正实现了该接口类型的类型实例才能赋值成功</strong></p>
</li>
<li><p>在 Go 中，如果 for 循环与 switch 或 select 联合使用时，可能会调用 break 的陷阱中。在 Go 中，不接标签的 break 语句会跳出最内层的 switch、select 或 for 代码块。如果要跳出最外层的循环，需要为循环定义一个标签，并让 break 跳到这个标签</p>
</li>
</ul>
<h3 id="标准库类"><a href="#标准库类" class="headerlink" title="标准库类"></a>标准库类</h3><p>接下来介绍一些标准库使用时经常会犯的一些错误：</p>
<ul>
<li>time 包中采用 <code>参考时间</code> 来实现日期时间的格式化</li>
<li>json 包在将结构体类型编码为 JSON  文本时，是通过为结构体字段添加 tag 的方式来指示其在 JSON 文本中的名字。而且 json 包默认仅对结构体中的导出字段（字段名首字母大写）进行编码，非导出字段并不会被编码。解码时也遵循该规则。除了 json 包，标准库 encoding 目录下的各类编解码包都遵循相同的规则</li>
<li>nil 切片是指尚未初始化的切片，Go 运行时尚未为其分配存储空间，而空切片则是已经初始化了的切片，Go 运行时为其分配了存储空间，但该切片的长度为 0。json 包在为这两种切片编码时会区别对待，空切片编码为 <code>[]</code>，nil 切片则编码为 <code>null</code></li>
<li>由于字节切片可以存储任意的字节序列，可能包含控制符、<code>\0</code> 以及不合法的 Unicode 字符等无法显示或导致乱码的内容。json 包在编码字节序列时，有可能将其编码为 base64 编码的文本。如果能确保切片中存储的是合法 Unicode 字符的 utf-8 编码字节，又不想将其编码为 base64 输出，那么可以将其转换为 string 类型后在用 json 包进行处理</li>
<li>当 JSON 文本中的整型数值被解码为 <code>interface&#123;&#125;</code> 类型时，其底层真实类型为 float64。因为很多时候 JSON 文本中字段不确定，因此常用 <code>map[string]interface&#123;&#125;</code> 类型来接收 json 包解码后的数据，这样 JSON 字段值就会被存储在一个 <code>interface&#123;&#125;</code> 变量中，之后则通过类型断言来获取其中存储的整型值，而此时 <code>interface&#123;&#125;</code> 的底层类型是 <code>float64</code>，而不是 int。json 包也提供了 Number 类型来存储 JSON 文本中的各类数值类型，并可以转换为整型、浮点型、字符串等</li>
<li>在使用 http 包实现 http 客户端时，需要及时关闭 <code>resp.Body</code>，因为 http 包的实现逻辑是只有应答的 Body 中的内容被全部读取完毕且调用了 <code>Body.Close()</code>，默认的 HTTP 客户端才会重用带有 keep-alive 标志的 HTTP 连接。如果是服务端，http 包会自动处理 <code>Request.Body</code></li>
<li>对于 Go 标准库 HTTP 客户端，想要及时关闭 HTTP 连接有两种方法：<ul>
<li>第一种是将 http.Request 中的字段 Close 设置为 true</li>
<li>第二种是通过创建一个 http.Client 新实例来实现（不使用 DefaultClient），并将心创建的 Client 实例的 Transport 字段中的 DisableKeepAlives 设置为 true，这样就设置了与服务端不保持长连接</li>
</ul>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/Go/" rel="tag"># Go</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2024/10/07/go-library-context/" rel="prev" title="go 库学习之 context">
      <i class="fa fa-chevron-left"></i> go 库学习之 context
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2024/10/05/improve-go-09/" rel="next" title="《Go 语言精进之路》读书笔记（09）：标准库、反射与 cgo">
      《Go 语言精进之路》读书笔记（09）：标准库、反射与 cgo <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Go-module-%E7%AE%A1%E7%90%86%E5%8C%85%E4%BE%9D%E8%B5%96"><span class="nav-number">1.</span> <span class="nav-text">使用 Go module 管理包依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Go-%E8%AF%AD%E8%A8%80%E5%8C%85%E7%AE%A1%E7%90%86%E6%BC%94%E8%BF%9B%E5%9B%9E%E9%A1%BE"><span class="nav-number">1.1.</span> <span class="nav-text">Go 语言包管理演进回顾</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go-module%EF%BC%9AGo-%E5%8C%85%E7%AE%A1%E7%90%86%E7%9A%84%E7%94%9F%E4%BA%A7%E6%A0%87%E5%87%86"><span class="nav-number">1.2.</span> <span class="nav-text">Go module：Go 包管理的生产标准</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go-module-%E4%BB%A3%E7%90%86"><span class="nav-number">1.3.</span> <span class="nav-text">Go module 代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%87%E7%BA%A7-module-%E7%9A%84%E4%B8%BB%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="nav-number">1.4.</span> <span class="nav-text">升级 module 的主版本号</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E6%9C%80%E5%B0%8F-Go-%E7%A8%8B%E5%BA%8F%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F"><span class="nav-number">2.</span> <span class="nav-text">构建最小 Go 程序容器镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%9C%E5%83%8F%EF%BC%9A%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E5%88%9B%E6%96%B0"><span class="nav-number">2.1.</span> <span class="nav-text">镜像：继承中的创新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#builder-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%B4%9B%E8%B5%B7"><span class="nav-number">2.2.</span> <span class="nav-text">builder 模式的崛起</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%BD%E6%B1%82%E6%9C%80%E5%B0%8F%E9%95%9C%E5%83%8F"><span class="nav-number">2.3.</span> <span class="nav-text">追求最小镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA%E7%9A%84%E6%94%AF%E6%8C%81"><span class="nav-number">2.4.</span> <span class="nav-text">对多阶段构建的支持</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-Go-%E5%8C%85%E7%9A%84%E5%AF%BC%E5%85%A5%E8%B7%AF%E5%BE%84"><span class="nav-number">3.</span> <span class="nav-text">自定义 Go 包的导入路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#govanityurls"><span class="nav-number">3.1.</span> <span class="nav-text">govanityurls</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-govanityurls"><span class="nav-number">3.2.</span> <span class="nav-text">使用 govanityurls</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%86%9F%E7%BB%83%E6%8E%8C%E6%8F%A1-Go-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="nav-number">4.</span> <span class="nav-text">熟练掌握 Go 常用工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E4%B8%8E%E5%AE%89%E8%A3%85"><span class="nav-number">4.1.</span> <span class="nav-text">获取与安装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#go-get"><span class="nav-number">4.1.1.</span> <span class="nav-text">go get</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#go-install"><span class="nav-number">4.1.2.</span> <span class="nav-text">go install</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E7%9A%84%E5%8F%98%E5%8C%96"><span class="nav-number">4.1.3.</span> <span class="nav-text">新的变化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E6%88%96%E8%80%85-module-%E7%9A%84%E6%A3%80%E8%A7%86"><span class="nav-number">4.2.</span> <span class="nav-text">包或者 module 的检视</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA"><span class="nav-number">4.3.</span> <span class="nav-text">构建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E4%B8%8E%E8%AF%8A%E6%96%AD"><span class="nav-number">4.4.</span> <span class="nav-text">运行与诊断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8E%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5"><span class="nav-number">4.5.</span> <span class="nav-text">格式化与静态代码检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%9E%84"><span class="nav-number">4.6.</span> <span class="nav-text">重构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E6%A1%A3"><span class="nav-number">4.7.</span> <span class="nav-text">查看文档</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AF%BC%E8%88%AA%E4%B8%8E%E6%B4%9E%E5%AF%9F"><span class="nav-number">4.8.</span> <span class="nav-text">代码导航与洞察</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-go-generate-%E9%A9%B1%E5%8A%A8%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="nav-number">5.</span> <span class="nav-text">使用 go generate 驱动代码生成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#go-generate%EF%BC%9AGo-%E5%8E%9F%E7%94%9F%E7%9A%84%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E9%A9%B1%E5%8A%A8%E5%99%A8"><span class="nav-number">5.1.</span> <span class="nav-text">go generate：Go 原生的代码生成驱动器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#go-generate-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">5.2.</span> <span class="nav-text">go generate 的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#go-generate-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">5.3.</span> <span class="nav-text">go generate 的应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%A2%E8%AE%B0-Go-%E5%B8%B8%E8%A7%81%E7%9A%84%E9%99%B7%E9%98%B1"><span class="nav-number">6.</span> <span class="nav-text">牢记 Go 常见的陷阱</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83%E7%B1%BB"><span class="nav-number">6.1.</span> <span class="nav-text">语法规范类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB"><span class="nav-number">6.2.</span> <span class="nav-text">标准库类</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">184</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
