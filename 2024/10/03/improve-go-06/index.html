<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Go 以其轻量级的并发编程思想而闻名，这篇文章将详细介绍 Go 基本执行单元：goroutine 的调度原理、Go 并发模型以及常见并发模式、Go 支持并发的原生类型–channel 的惯用使用模式等内容。">
<meta property="og:type" content="article">
<meta property="og:title" content="《Go 语言精进之路》读书笔记（06）：并发编程">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2024/10/03/improve-go-06/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="Go 以其轻量级的并发编程思想而闻名，这篇文章将详细介绍 Go 基本执行单元：goroutine 的调度原理、Go 并发模型以及常见并发模式、Go 支持并发的原生类型–channel 的惯用使用模式等内容。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-10-03T02:18:48.000Z">
<meta property="article:modified_time" content="2024-10-11T02:26:14.101Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2024/10/03/improve-go-06/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>《Go 语言精进之路》读书笔记（06）：并发编程 | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2024/10/03/improve-go-06/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《Go 语言精进之路》读书笔记（06）：并发编程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-03 10:18:48" itemprop="dateCreated datePublished" datetime="2024-10-03T10:18:48+08:00">2024-10-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Go 以其轻量级的并发编程思想而闻名，这篇文章将详细介绍 Go 基本执行单元：goroutine 的调度原理、Go 并发模型以及常见并发模式、Go 支持并发的原生类型–channel 的惯用使用模式等内容。</p>
<span id="more"></span>

<h2 id="优先考虑并发设计"><a href="#优先考虑并发设计" class="headerlink" title="优先考虑并发设计"></a>优先考虑并发设计</h2><p>并发不是并行，并发（Concurrency）关乎结构，并行（Parallelism）关乎执行。Go 原生支持并发。</p>
<h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p>并行方案就是在处理器核数充足的情况下，启动多个单线程应用的实例，这样每个实例运行在一个核上，尽可能地利用多核计算资源。并发就是重新做应用结构设计，即将应用分解成多个基本执行单元中执行的、可能有一定关联关系的代码片段。</p>
<p>基于多线程模型的应用设计就是一种典型的并发程序设计，这种以操作系统线程作为承载分解后的代码片段的执行单元，由操作系统执行调度。因为操作系统线程的创建、销毁以及线程间上下文切换的代价都比较大。而且线程的接口多以标准库形式提供，线程间通信原语也不足，用户层接口较为晦涩。</p>
<p>Go 的设计哲学之一就是 <code>原生并发，轻量高效</code>。Go 没有使用操作系统线程作为承载分解后的代码片段（模块）的基本执行单元，而是实现了 goroutine 这一有 Go 运行时负责调度的用户层轻量级线程为并发程序设计提供原生支持。它具有如下特点：</p>
<ul>
<li>资源占用小，每个 goroutine 的初始栈大小仅为 2KB</li>
<li>由 Go 运行时而不是操作系统调度，goroutine 上下文切换代价较小</li>
<li>语言原生支持：goroutine 由 go 关键字接函数或者方法创建，函数或方法返回即表示 goroutine 退出</li>
<li>语言内置 channel 作为 goroutine 间通信的原语，为并发设计提供强大支持</li>
</ul>
<p>在应用的结构设计阶段，Go 的惯例是优先考虑并发设计，这样应用可以更好、更自然地适应规模化。</p>
<h3 id="Go-并发设计实例"><a href="#Go-并发设计实例" class="headerlink" title="Go 并发设计实例"></a>Go 并发设计实例</h3><p>串行程序设计的弊端是：所有任务是串行顺序执行的，当计算资源在处理某个任务，其他任务就无法执行，即使此时计算资源充足。<strong>并发关乎结构，并行关乎执行</strong>，并发和并行是两个阶段的事情，并发在程序的设计和实现阶段，并行在程序的执行阶段。</p>
<p>Go 鼓励在程序设计时优先按照并发设计思路组织程序结构，进行独立计算的分解。只有并发设计才能让应用自然适应计算资源的规模化，并显出更大的威力。</p>
<h2 id="了解-goroutine-调度原理"><a href="#了解-goroutine-调度原理" class="headerlink" title="了解 goroutine 调度原理"></a>了解 goroutine 调度原理</h2><p>goroutine 是由 Go 运行时管理的用户层轻量级线程，无论是 Go 自身运行时代码还是用户层 Go 代码都是在 goroutine 中运行。Go 的运行时负责 goroutine 的调度。</p>
<h3 id="goroutine-调度器"><a href="#goroutine-调度器" class="headerlink" title="goroutine 调度器"></a>goroutine 调度器</h3><p>将 goroutine 按照一定算法放到 CPU 上执行的程序就称为 goroutine 调度器。一个 Go 程序对于操作系统来说只是一个用户层程序，操作系统眼中只有线程，goroutine 的调度应该要靠 Go 自己完成。</p>
<p>Go 1.0 版本使用了一个简单的 goroutine 调度器，称为 G-M 模型。在这个调度器中，每个 goroutine 对应运行时中的一个抽象结构 G（goroutine），而被视作物理 CPU 的操作系统线程则被抽象为另一个结构 M（machine）。G-M 模型实现起来比较简单且能正常工作，但是限制了 Go 并发程序的伸缩性。</p>
<p>之后，Dmitry Vyukov 实现了 G-P-M 调度模型和 work stealing 算法，这一模型一直沿用至今。该模型在 G-M 模型中间增加了一个 P（逻辑处理器），使得 goroutine 调度器具有很好的伸缩性。Dmitry Vyukov 还负责实现了 Go 抢占式调度器设计。除非极端的无限循环或者死循环，否则只要 G 调用函数，Go 运行时就有了抢占 G 的机会。</p>
<p>Go 提供了调度器当前状态的查看方法：使用 Go 运行时环境变量 GODEBUG。</p>
<p>Go 从 1.5 版本开始，将 P 的默认数量从 1 改为 CPU 核（逻辑核）的数量。<code>runtime.GOMAXPROCS(n)</code> 函数可以修改 P 的数量为指定值 n。</p>
<h2 id="掌握-Go-并发模型和常见并发模式"><a href="#掌握-Go-并发模型和常见并发模式" class="headerlink" title="掌握 Go 并发模型和常见并发模式"></a>掌握 Go 并发模型和常见并发模式</h2><p><strong>不要通过共享内存来通信，而应该通过通信来共享内存。</strong></p>
<h3 id="Go-并发模型"><a href="#Go-并发模型" class="headerlink" title="Go 并发模型"></a>Go 并发模型</h3><p>传统语言的并发逻辑多是基于操作系统的线程，其并发执行单元之间的通信则是利用操作系统提供的线程或进程间通信的原语，例如共享内存、信号、管道、消息队列、套接字等。这种传统的基于共享内存的并发模型很难用，而且易错，尤其在大型或复杂的程序中。</p>
<p>Go 的并发模型借鉴了计算机科学家 Tony Hoare 提出的 CSP（Communicating Sequential Process，通信顺序进程）模型。在该模型中，输入&#x2F;输出应该是基本的编程原语，数据处理逻辑（CSP 中的 P）仅需要调用输入原语获取数据，顺序处理数据，并将结果数据通过输出原语即可。因此一个符合 CSP 模型的并发程序应该是一组通过输入&#x2F;输出原语连接起来的 P 集合。从这个角度看，CSP 理论不仅是一个并发参考模型，也是一种并发程序的程序组织方法。</p>
<p>为了实现 CSP 模型中的输入&#x2F;输出原语，Go 引入了 goroutine（P）之间的通信原语 channel。goroutine 可以从 channel 获取输入数据，再将处理后额结果数据通过 channel 输出。</p>
<p>虽然 CSP 模型已经成为 Go 语言支持的主流并发模型，但 Go 也支持传统的基于共享内存的并发模型，并提供基本的低级同步原语（主要是 sync 包中的互斥锁、条件变量、读写锁、原子操作等）。Go 始终推荐以 CSP 模型风格构建并发程序，对于局部情况，比如性能敏感的区域或需要保护的结构体数据，可以使用更为高效的低级同步原语（例如 sync.Mutex）。</p>
<h3 id="Go-常见的并发模式"><a href="#Go-常见的并发模式" class="headerlink" title="Go 常见的并发模式"></a>Go 常见的并发模式</h3><p>Go 针对 CSP 模型提供了 3 种并发原语：</p>
<ul>
<li>goroutine：对应 CSP 模型中的 P，封装了数据处理逻辑，是 Go 运行时调度的基本执行单元</li>
<li>channel：对于 CSP 模型中的输入&#x2F;输出原语，用于 goroutine 之间的通信和同步</li>
<li>select：用于应对多路输入&#x2F;输出，可以让 goroutine 同时协调处理多个 channel 操作</li>
</ul>
<p>Go 使用 <code>go 关键字 + 函数/方法创建 goroutine</code>，在稍微复杂的并发程序中，需要考虑通过 CSP 模型输入&#x2F;输出原语承载体 channel 在 goroutine 之间建立连接，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spawn</span><span class="params">(f <span class="keyword">func</span>()</span></span>) <span class="keyword">chan</span> T &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> T)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        f()</span><br><span class="line">        ...</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := spawn(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>channel 也是 Go 语言一等公民：channel 可以像变量一样被初始化、传递和赋值。</p>
<p>goroutine 的执行函数返回，即意味着 goroutine 退出。但有一些常驻后台的服务程序可能会对 goroutine 有着优雅退出的要求，这里介绍几种 goroutine 的退出模式，这里借鉴了线程模型中的术语：</p>
<p>分离模式：对于分离的 goroutine，创建它的 goroutine 不需要关心它的退出。这类 goroutine 在启动后即与其创建者彻底分离，其生命周期与其执行的主函数相关，函数返回即 goroutine 退出。</p>
<p>join 模式：goroutine 的创建者需要等待新的 goroutine 结束，如下是一个示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        interval, ok := args[<span class="number">0</span>].(<span class="type">int</span>)</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        time.Sleep(time.Second * time.Duration(interval))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spawn</span><span class="params">(fn <span class="keyword">func</span>(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span>, args ...<span class="keyword">interface</span>&#123;&#125;) <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">        c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                fn(args...)</span><br><span class="line">                c &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done := spawn(work, <span class="number">3</span>)</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;spawn a worker goroutine&quot;</span>)</span><br><span class="line">        _ = &lt;-done</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;worker done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果新的 goroutine 不仅要等待 goroutine 的退出，还要获取其结束状态，同样可以通过自定义类型的 channel 来实现，例如将上面示例 channel 的类型从 <code>chan struct&#123;&#125;</code> 改为 <code>chan error</code></p>
</li>
<li><p>有时 goroutine 的创建者可能会创建不止一个 goroutine，并且需要等待全部 goroutine 退出，可以通过 Go 语言提供的 <code>sync.WaitGroup</code> 实现等待多个 goroutine 退出的模式。每创建一个 goroutine，都会调用 <code>wg.Add(1)</code>，而新创建的 goroutine 执行完毕退出前都会调用 <code>wg.Done()</code>。当所有 goroutine 都退出后，<code>wg.Wait()</code> 函数则会返回</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;sync&quot;</span></span><br><span class="line">        <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        interval, ok := args[<span class="number">0</span>].(<span class="type">int</span>)</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        time.Sleep(time.Second * time.Duration(interval))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spawnGroup</span><span class="params">(n <span class="type">int</span>, fn <span class="keyword">func</span>(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span>, args ...<span class="keyword">interface</span>&#123;&#125;) <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">        c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">        <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">                wg.Add(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">                        name := fmt.Sprintf(<span class="string">&quot;worker-%d&quot;</span>, i)</span><br><span class="line">                        fn(args...)</span><br><span class="line">                        <span class="built_in">println</span>(name, <span class="string">&quot;done&quot;</span>)</span><br><span class="line">                        wg.Done()</span><br><span class="line">                &#125;(i)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                wg.Wait()</span><br><span class="line">                c &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done := spawnGroup(<span class="number">5</span>, worker, <span class="number">3</span>)</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;spawn a group of workers&quot;</span>)</span><br><span class="line">        _ = &lt;-done</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;group workers done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>支持超时机制的等待：可以通过定时器设置超时等待时间，例如：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done := spawnGroup(<span class="number">5</span>, worker, <span class="number">30</span>)</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;spawn a group of workers&quot;</span>)</span><br><span class="line"></span><br><span class="line">        timer := time.NewTimer(time.Second * <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">defer</span> timer.Stop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">                <span class="built_in">println</span>(<span class="string">&quot;wait group workers exit timeout!&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> &lt;-done:</span><br><span class="line">                <span class="built_in">println</span>(<span class="string">&quot;group workers done&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>notify-and-wait 模式：很多时候 goroutine 的创建者需要主动通知那些新的 goroutine 退出，尤其是当 main goroutine 作为创建者时。我们可以通过 &#96;notify-and-wait 模式来满足这一场景要求</p>
<ul>
<li>如下代码展示了通知并等待一个 goroutine 退出，此时 spawn 返回的 channel 的作用发生了变化，从原先的只是用于新 goroutine 发送退出信号给创建者，变成了一个双向的数据通道：即承载了创建者发送给新 goroutine 的退出信号，也承载新 goroutine 返回给创建者的退出状态</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        time.Sleep(time.Second * time.Duration(j))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spawn</span><span class="params">(fn <span class="keyword">func</span>(<span class="type">int</span>)</span></span>) <span class="keyword">chan</span> <span class="type">string</span> &#123;</span><br><span class="line">        quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">var</span> job <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">                <span class="keyword">for</span> &#123;</span><br><span class="line">                        <span class="keyword">select</span> &#123;</span><br><span class="line">                        <span class="keyword">case</span> j := &lt;-job:</span><br><span class="line">                                fn(j)</span><br><span class="line">                        <span class="keyword">case</span> &lt;-quit:</span><br><span class="line">                                quit &lt;- <span class="string">&quot;ok&quot;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> quit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        quit := spawn(worker)</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;spawn a worker goroutine&quot;</span>)</span><br><span class="line"></span><br><span class="line">        time.Sleep(<span class="number">5</span>)</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;notify the worker to exit&quot;</span>)</span><br><span class="line">        quit &lt;- <span class="string">&quot;exit&quot;</span></span><br><span class="line"></span><br><span class="line">        timer := time.NewTimer(time.Second * <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">defer</span> timer.Stop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> status := &lt;-quit:</span><br><span class="line">                <span class="built_in">println</span>(<span class="string">&quot;worker done:&quot;</span>, status)</span><br><span class="line">        <span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">                <span class="built_in">println</span>(<span class="string">&quot;wait worker exit timeout&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通知并等待多个多个 goroutine 退出：Go 语言的 channel 有一个特性是，当使用 close 函数关闭 channel 时，所有阻塞到该 channel 上的 goroutine 都会得到通知：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;sync&quot;</span></span><br><span class="line">        <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        time.Sleep(time.Second * time.Duration(j))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spawnGroup</span><span class="params">(n <span class="type">int</span>, fn <span class="keyword">func</span>(<span class="type">int</span>)</span></span>) <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">        quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">        job := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">        <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">                wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                name := fmt.Sprintf(<span class="string">&quot;worker-%d&quot;</span>, i)</span><br><span class="line">                <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">                        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">                        <span class="keyword">for</span> &#123;</span><br><span class="line">                                <span class="keyword">select</span> &#123;</span><br><span class="line">                                <span class="keyword">case</span> j, ok := &lt;-job:</span><br><span class="line">                                        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                                                <span class="built_in">println</span>(name, <span class="string">&quot; done&quot;</span>)</span><br><span class="line">                                                <span class="keyword">return</span></span><br><span class="line">                                        &#125;</span><br><span class="line">                                        fn(j)</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;(i)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                &lt;-quit</span><br><span class="line">                <span class="built_in">close</span>(job)</span><br><span class="line">                wg.Wait()</span><br><span class="line">                quit &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> quit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        quit := spawnGroup(<span class="number">5</span>, worker)</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;spawn a group of workers&quot;</span>)</span><br><span class="line"></span><br><span class="line">        time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;notify the worker group to exit&quot;</span>)</span><br><span class="line">        quit &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">        timer := time.NewTimer(time.Second)</span><br><span class="line">        <span class="keyword">defer</span> timer.Stop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">                <span class="built_in">println</span>(<span class="string">&quot;wait group workers exit timeout!&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> &lt;-quit:</span><br><span class="line">                <span class="built_in">println</span>(<span class="string">&quot;group workers done&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这段代码的关键是当创建者关闭 job channel 时，所有 worker goroutine 都是得到通知，此时通过 <code>comma ok</code> 模式获取 ok 值为 false，即表明该 channel 已经关闭</strong>。</p>
<p>Go 中的 channel 原语使得构建管道并发模式变得容易且自然。如下展示了一个示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newNumGenerator</span><span class="params">(start, count <span class="type">int</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">        c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">for</span> i := start; i &lt; start+count; i++ &#123;</span><br><span class="line">                        c &lt;- i</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">close</span>(c)</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filterOdd</span><span class="params">(i <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(i <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> i * i, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spawn</span><span class="params">(f <span class="keyword">func</span>(<span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">bool</span>), in &lt;-<span class="keyword">chan</span> <span class="type">int</span>) &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">        out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">                        r, ok := f(v)</span><br><span class="line">                        <span class="keyword">if</span> ok &#123;</span><br><span class="line">                                out &lt;- r</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">close</span>(out)</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        in := newNumGenerator(<span class="number">1</span>, <span class="number">20</span>)</span><br><span class="line">        out := spawn(square, spawn(filterOdd, in))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> v := <span class="keyword">range</span> out &#123;</span><br><span class="line">                <span class="built_in">println</span>(v)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来再来了解两种基于管道模式的扩展模式：</p>
<ul>
<li>扇出模式：多个功能相同的 goroutine 从同一个 channel 读取数据并处理，直到该 channel 关闭。这种情况称为扇出。使用扇出模式可以在一组 goroutine 中均衡分配工作量，从而更均衡地利用 CPU 资源</li>
<li>扇入模式：在某个处理环节，处理程序面对不止一个输入 channel，把所有输入 channel 的数据汇聚到统一的输入 channel，然后处理程序再从这个 channel 中读取数据并处理，直到该 channel 因所有输入 channel 关闭而关闭，这种情况就称为 <code>扇入</code></li>
</ul>
<p>如下是扇出&#x2F;扇入模式的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;sync&quot;</span></span><br><span class="line">        <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newNumGenerator</span><span class="params">(start, count <span class="type">int</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">        c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">for</span> i := start; i &lt; start+count; i++ &#123;</span><br><span class="line">                        c &lt;- i</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">close</span>(c)</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filterOdd</span><span class="params">(i <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(i <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> i * i, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spawnGroup</span><span class="params">(name <span class="type">string</span>, num <span class="type">int</span>, f <span class="keyword">func</span>(<span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">bool</span>), in &lt;-<span class="keyword">chan</span> <span class="type">int</span>) &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">        groupOut := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">        <span class="keyword">var</span> outSlice []<span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">                out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">                <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">                        name := fmt.Sprintf(<span class="string">&quot;%s-%d&quot;</span>, name, i)</span><br><span class="line">                        fmt.Printf(<span class="string">&quot;%s begin to work...\n&quot;</span>, name)</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">                                r, ok := f(v)</span><br><span class="line">                                <span class="keyword">if</span> ok &#123;</span><br><span class="line">                                        out &lt;- r</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="built_in">close</span>(out)</span><br><span class="line">                        fmt.Printf(<span class="string">&quot;%s work done\n&quot;</span>, name)</span><br><span class="line">                &#125;(i)</span><br><span class="line"></span><br><span class="line">                outSlice = <span class="built_in">append</span>(outSlice, out)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">                <span class="keyword">for</span> _, out := <span class="keyword">range</span> outSlice &#123;</span><br><span class="line">                        wg.Add(<span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(out &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">                                <span class="keyword">for</span> v := <span class="keyword">range</span> out &#123;</span><br><span class="line">                                        groupOut &lt;- v</span><br><span class="line">                                &#125;</span><br><span class="line">                                wg.Done()</span><br><span class="line">                        &#125;(out)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                wg.Wait()</span><br><span class="line">                <span class="built_in">close</span>(groupOut)</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> groupOut</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        in := newNumGenerator(<span class="number">1</span>, <span class="number">20</span>)</span><br><span class="line">        out := spawnGroup(<span class="string">&quot;square&quot;</span>, <span class="number">2</span>, square, spawnGroup(<span class="string">&quot;filterOdd&quot;</span>, <span class="number">3</span>, filterOdd, in))</span><br><span class="line"></span><br><span class="line">        time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> v := <span class="keyword">range</span> out &#123;</span><br><span class="line">                <span class="built_in">println</span>(v)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要实现超时取消模式，可以通过定时器实现，并通过 select 原语监视该定时器事件和响应 channel 上的事件。如果要在超时之后，取消已经创建的 goroutine（on-flight goroutine），我们可以使用 Go 的 context 包来实现取消模式。</p>
<h2 id="了解-channel-的妙用"><a href="#了解-channel-的妙用" class="headerlink" title="了解 channel 的妙用"></a>了解 channel 的妙用</h2><p>channel 在 Go 的 CSP 模型中，既可以实现 goroutine 间的通信，又可以实现 goroutine 间的同步。channel 在 Go 中是 <code>一等公民</code>，如下是 channel 的使用原语：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">c &lt;- x</span><br><span class="line">&lt;- c</span><br><span class="line">x = &lt;- c</span><br><span class="line">x, ok = &lt;- c</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;...&#125;</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line"></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stream</span><span class="params">(ctx context.Context, out <span class="keyword">chan</span>&lt;- Value)</span></span>  <span class="type">error</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spawn</span><span class="params">(...)</span></span> &lt;-<span class="keyword">chan</span> T</span><br></pre></td></tr></table></figure>

<p>当要同时对多个 channel 进行操作时，可以使用 <code>select</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> x := &lt;- c1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> y, ok := &lt;- c2:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> c3 &lt;- z:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="无缓冲-channel"><a href="#无缓冲-channel" class="headerlink" title="无缓冲 channel"></a>无缓冲 channel</h3><p>无缓冲 channel 兼具通信和同步特性，在并发程序中应用广泛。当使用不带有 capacity 参数的内置 make 函数创建一个可用的无缓冲 channel：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c := make(chan T)</span><br></pre></td></tr></table></figure>

<p>由于无缓冲的 channel 在运行时中实现不带有缓冲区，因此对无缓冲 channel 的接收和发送操作是同步的。<strong>即对于同一个无缓冲 channel，只有在对其进行接收操作的 goroutine 和对其进行发送操作的 goroutine 都存在，通信才能进行，否则单方面的操作会让对应的 goroutine 阻塞</strong>。</p>
<p>对于无缓冲 channel：</p>
<ul>
<li>发送动作一定发生在 <code>接收动作完成</code> 之前</li>
<li>接收动作一定发生在 <code>发送动作完成</code> 之前</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">        a = <span class="string">&quot;hello&quot;</span></span><br><span class="line">        &lt;-c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">go</span> f()</span><br><span class="line">        c &lt;- <span class="number">5</span></span><br><span class="line">        <span class="built_in">println</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以无缓冲 channel 可以实现以下目的：</p>
<ul>
<li>在两个 goroutine 之间一对一地传递通知信号</li>
<li>用来实现一对多的信号通知机制，这样的信号通知机制常被用于协调多个 goroutine 一起工作。如下代码中，关闭一个无缓冲的 channel 会让所有阻塞在该 channel 上的接收操作返回，从而实现一种一对多的广播机制。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;sync&quot;</span></span><br><span class="line">        <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> signal <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;worker %d: is working...\n&quot;</span>, i)</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;worker %d: done...\n&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spawnGroup</span><span class="params">(f <span class="keyword">func</span>(<span class="type">int</span>)</span></span>, num <span class="type">int</span>, groupSignal &lt;-<span class="keyword">chan</span> signal) &lt;-<span class="keyword">chan</span> signal &#123;</span><br><span class="line">        c := <span class="built_in">make</span>(<span class="keyword">chan</span> signal)</span><br><span class="line">        <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">                wg.Add(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">                        &lt;-groupSignal</span><br><span class="line">                        fmt.Printf(<span class="string">&quot;worker %d: start to work...\n&quot;</span>, i)</span><br><span class="line">                        f(i)</span><br><span class="line">                        wg.Done()</span><br><span class="line">                &#125;(i)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                wg.Wait()</span><br><span class="line">                c &lt;- signal(<span class="keyword">struct</span>&#123;&#125;&#123;&#125;)</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;start a group of workers...&quot;</span>)</span><br><span class="line">        groupSignal := <span class="built_in">make</span>(<span class="keyword">chan</span> signal)</span><br><span class="line">        done := spawnGroup(worker, <span class="number">3</span>, groupSignal)</span><br><span class="line">        fmt.Println(<span class="string">&quot;the group of workers start to work...&quot;</span>)</span><br><span class="line">        <span class="built_in">close</span>(groupSignal)</span><br><span class="line">        &lt;-done</span><br><span class="line">        fmt.Println(<span class="string">&quot;the group of workers work done!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无缓冲 channel 具有同步特性，这让它在某些场合下可以替代锁，从而使得程序更加清晰</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> counter <span class="keyword">struct</span> &#123;</span><br><span class="line">        c <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">        i <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cter counter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitCounter</span><span class="params">()</span></span> &#123;</span><br><span class="line">        cter = counter&#123;</span><br><span class="line">                c: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>),</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">for</span> &#123;</span><br><span class="line">                        cter.i++</span><br><span class="line">                        cter.c &lt;- cter.i</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;counter init ok&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Increase</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;-cter.c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">        InitCounter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">                <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">                        v := Increase()</span><br><span class="line">                        fmt.Println(<span class="string">&quot;current value %d&quot;</span>, v)</span><br><span class="line">                &#125;(i)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="带缓冲-channel"><a href="#带缓冲-channel" class="headerlink" title="带缓冲 channel"></a>带缓冲 channel</h3><p>带缓冲 channel 可以通过带有 capacity 参数的内置 make 函数创建：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> T, capacity)</span><br></pre></td></tr></table></figure>

<p>由于带缓冲 channel 在运行时的实现带有缓冲区，因此对带缓冲区 channel 的发送操作在缓冲区未满、接收操作在缓冲区非空的情况下是异步的（发送或接收无须阻塞等待）。在缓冲区满时发送操作才会阻塞；在缓冲区空时接收操作才会阻塞。</p>
<p><strong>可自行设置容量、异步收发的带缓冲 channel 更适合用作消息队列，并且带缓冲 channel 在数据收发性能上明显好于无缓冲 channel</strong>。</p>
<p>Go 并发设计的一个惯用法是将带缓冲的 channel 用作计数信号量（counting semaphore）：</p>
<ul>
<li>channel 中当前数据的个数可以表示当前处于活动状态的 goroutine 数量</li>
<li>channel 的容量则代表允许同时处于活动状态的 goroutine 最大数量</li>
<li>向 channel 中发送数据表示获取一个信号量槽位</li>
<li>从 channel 中读取一个数据表示释放一个信号量槽位</li>
</ul>
<p>如下是一个示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;sync&quot;</span></span><br><span class="line">        <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> active = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">var</span> jobs = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">                        jobs &lt;- (i + <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">close</span>(jobs)</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">        <span class="keyword">for</span> j := <span class="keyword">range</span> jobs &#123;</span><br><span class="line">                wg.Add(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">                        active &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">                        <span class="built_in">println</span>(<span class="string">&quot;handle job&quot;</span>, j)</span><br><span class="line">                        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">                        &lt;-active</span><br><span class="line">                        wg.Done()</span><br><span class="line">                &#125;(j)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>len 是 Go 语言原生内置的函数，它可以接受数组、切片、map、字符串或 channel 类型的参数，并返回对应类型的长度。如果参数是 channel 类型：</p>
<ul>
<li>对于无缓冲 channel，len 总返回 0</li>
<li>当 s 为缓冲 channel，len 总是返回当前 channel 中尚未被读取的元素个数</li>
</ul>
<p>如果需要将判断 channel 长度逻辑与读取写入逻辑放在一起，那么必须将它们实现成一个事务，这类事务可以通过 select 实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tryRecv</span><span class="params">(c &lt;- <span class="keyword">chan</span> <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> i := &lt;- c:</span><br><span class="line">        <span class="keyword">return</span> i, <span class="literal">true</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trySend</span><span class="params">(c <span class="keyword">chan</span> &lt;- <span class="type">int</span>, i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> c &lt;- i:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于用到了 select 原语的 default 分支，当 channel 为空时，tryRecv 不会被阻塞，当 channel 满时，trySend 不会阻塞。</p>
<p>对于 <code>多发送单接收</code> 场景，可以在接收者中通过 <code>len(channel) &gt; 0</code> 来判断 channel 中是否有数据接收。对于 <code>多接收单发送</code> 场景，可以在发送者中通过 <code>len(channel) &lt; cap(channel)</code> 来判断 channel 中是否可以继续发送。</p>
<h3 id="nil-channel-的妙用"><a href="#nil-channel-的妙用" class="headerlink" title="nil channel 的妙用"></a>nil channel 的妙用</h3><p><strong>对于没有初始化的 channel（nil channel）进行读写操作将会发生阻塞</strong>。有时候利用这个 nil channel 这个特性，可以达到事半功倍的效果。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">        c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">                c1 &lt;- <span class="number">1</span></span><br><span class="line">                <span class="built_in">close</span>(c1)</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                time.Sleep(<span class="number">8</span> * time.Second)</span><br><span class="line">                c2 &lt;- <span class="number">2</span></span><br><span class="line">                <span class="built_in">close</span>(c2)</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> x, ok := &lt;-c1:</span><br><span class="line">                        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                                c1 = <span class="literal">nil</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="built_in">println</span>(x)</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> x, ok := &lt;-c2:</span><br><span class="line">                        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                                c2 = <span class="literal">nil</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="built_in">println</span>(x)</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> c1 == <span class="literal">nil</span> &amp;&amp; c2 == <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的关键是在判断出 c1 或 c2 被关闭后，显式地将 c1、c2 设置为 nil。否则的话，从一个已经关闭的 channel 中接收数据将永远不会被阻塞，此时就会导致 select 继续选中这个已经关闭的 channel 分支执行（此时返回该 channel 元素类型的零值）。</p>
<h3 id="与select-结合使用的一些惯用法"><a href="#与select-结合使用的一些惯用法" class="headerlink" title="与select 结合使用的一些惯用法"></a>与select 结合使用的一些惯用法</h3><p>channel 与 select 结合使用能够形成强大的表达能力。这里再简单总结下：</p>
<ul>
<li>select 语句的 default 分支的语义是在其他分支均因通信未就绪而无法被选择的时候执行，<strong>这就为 default 分支赋予了一种 <code>避免阻塞</code> 的特性</strong>。</li>
<li>带超时机制的 select 是 Go 语言中一种常见的 select 和 channel 的组合用法，通过超时事件，既可以避免长期陷入某种操作的等待中，也可以做一些异常处理工作。例如：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- c:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> &lt;- time.After(<span class="number">30</span> * time.Second)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在使用 <code>timer.Timer</code> 时，要特别注意 timer 使用后的释放，即要及时调用 timer 的 Stop 方法从最小堆中删除尚未到达过期时间的 timer 对象</p>
</li>
<li><p>结合 time 包的 Ticker，可以实现带有心跳机制的 select。同样，在使用完 ticker 之后，要记得调用其 Stop 方法停止 ticker 的运作。例如：</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">()</span></span> &#123;</span><br><span class="line">    heartbeat := time.NewTicker(<span class="number">30</span> * time.Second)</span><br><span class="line">    <span class="keyword">defer</span> heartbeat.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;- c:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> &lt;- heartbeat.C:</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="了解-sync-包的正确用法"><a href="#了解-sync-包的正确用法" class="headerlink" title="了解 sync 包的正确用法"></a>了解 sync 包的正确用法</h2><p>Go 在提供 CSP 并发模型原语的同时，还通过标准库的 sync 包提供了针对传统基于共享内存并发模型的基本同步原语，包括互斥锁（sync.Mutex）、读写锁（sync.RWMutex）和条件变量（sync.Cond）等。</p>
<h3 id="使用-sync-包还是-channel"><a href="#使用-sync-包还是-channel" class="headerlink" title="使用 sync 包还是 channel"></a>使用 sync 包还是 channel</h3><p>虽然建议大家优先使用 CSP 并发模型进行并发程序设计，但是以下场景我们依然需要 sync 包提供的低级同步原语：</p>
<ul>
<li>需要高性能的临界区同步机制场景：channel 属于高级同步原语，其实现是构建在低级同步原语之上。因此 channel 自身的性能与低级同步原语相比要低一些。因此在需要高性能的临界区同步机制的情况下，sync 包提供的低级同步原语更为适合</li>
<li>不想转移结构体对象所有权，但又要保证结构体内部状态数据的同步访问的场景：基于 channel 的并发设计的一个特点是，在 goroutine 间通过 channel 转移数据对象的所有权。只有拥有数据对象所有权（从 channel 接收到该数据）的 goroutine 才可以对该数据对象进行状态变更</li>
</ul>
<h3 id="使用-sync-包的注意事项"><a href="#使用-sync-包的注意事项" class="headerlink" title="使用 sync 包的注意事项"></a>使用 sync 包的注意事项</h3><p><strong>包括 Mutex 等 sync 包中定义的结构类型在首次使用后不应该对其进行复制操作</strong>。在使用 sync 包中的类型时，推荐通过闭包方式或者传递类型实例（或者包裹该类型的类型实例）的地址或指针的方式进行。</p>
<h3 id="互斥锁还是读写锁"><a href="#互斥锁还是读写锁" class="headerlink" title="互斥锁还是读写锁"></a>互斥锁还是读写锁</h3><p>sync 包提供了两种用于临界区同步的原语：</p>
<ul>
<li>互斥锁（Mutex）：临界区同步原语的首选，在并发量较小的情况下，互斥锁性能更好</li>
<li>读写锁（RWMutex）：适合在应用在具有一定并发量且读多写少的场合中。读写锁的读锁性能并不会随着并发量的增大而变化，但写锁在并发量大的情况下性能比互斥锁、读写锁的读锁都差</li>
</ul>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>sync.Cond 是传统的条件变量在 Go 语言中的实现，一个条件变量可以理解为一个容器，这个容器中存放着一个或一组等待着某个条件成立的 goroutine。当条件成立时，这些处于等待状态的 goroutine 将得到通知并被唤醒以继续后续的工作。条件变量是同步原语的一种，如果没有条件变量，开发人员可能需要在 goroutine 中通过连续轮询的方式检查是否满足条件，连续轮询非常消耗资源。</p>
<p>如下是一个示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;sync&quot;</span></span><br><span class="line">        <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> signal <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ready <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;worker %d: is working...\n&quot;</span>, i)</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;worker %d: done\n&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spawnGroup</span><span class="params">(f <span class="keyword">func</span>(i <span class="type">int</span>)</span></span>, num <span class="type">int</span>, groupSignal *sync.Cond) <span class="keyword">chan</span> signal &#123;</span><br><span class="line">        c := <span class="built_in">make</span>(<span class="keyword">chan</span> signal)</span><br><span class="line">        <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">                wg.Add(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">                        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">                        groupSignal.L.Lock()</span><br><span class="line">                        <span class="keyword">for</span> !ready &#123;</span><br><span class="line">                                groupSignal.Wait()</span><br><span class="line">                        &#125;</span><br><span class="line">                        groupSignal.L.Unlock()</span><br><span class="line"></span><br><span class="line">                        f(i)</span><br><span class="line">                &#125;(i)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                wg.Wait()</span><br><span class="line">                c &lt;- signal(<span class="keyword">struct</span>&#123;&#125;&#123;&#125;)</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;start a group of workers&quot;</span>)</span><br><span class="line">        groupSignal := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">        c := spawnGroup(worker, <span class="number">5</span>, groupSignal)</span><br><span class="line"></span><br><span class="line">        time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;the group of workers start to work...&quot;</span>)</span><br><span class="line"></span><br><span class="line">        groupSignal.L.Lock()</span><br><span class="line">        ready = <span class="literal">true</span></span><br><span class="line">        groupSignal.Broadcast()</span><br><span class="line">        groupSignal.L.Unlock()</span><br><span class="line"></span><br><span class="line">        &lt;-c</span><br><span class="line">        fmt.Printf(<span class="string">&quot;the group of workers done\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>sync.Cond 实例的初始化需要一个满足了实现了 sync.Locker 接口类型实例，通常直接使用 <code>sync.Mutex</code></li>
<li>各个等待条件成立的 gorotine 在加锁后判断条件是否成立，如果不成立，则调用 sync.Cond 的 Wait 方法进行等待状态。Wait 方法在 goroutine 挂起前会进行 Unlock 操作</li>
<li>main groutine 将 ready 设置为 true 后并调用 sync.Cond 的 Broadcast 方法后，各个阻塞的 goroutine 将被唤醒并从 Wait 方法中返回。<strong>Wait 方法会再次加锁让 goroutine 进入临界区，并再次判断条件数据</strong></li>
</ul>
<h3 id="使用-sync-Once-实现单例模式"><a href="#使用-sync-Once-实现单例模式" class="headerlink" title="使用 sync.Once 实现单例模式"></a>使用 sync.Once 实现单例模式</h3><p>之前我们介绍过 init 函数，它在程序运行期间只被执行一次且满足 goroutine 安全。sync 包提供了另外一种更为灵活的机制，可以保证任意一个函数在程序运行期间只被执行一次，即 sync.Once。</p>
<p>sync.Once 的 <code>仅执行一次</code> 语义被一些包用于初始化和资源清理的过程中，以避免重复执行初始化或资源关闭操作。<code>sync.Once</code> 的语义十分适合实现单例模式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;sync&quot;</span></span><br><span class="line">        <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"><span class="keyword">var</span> instance *Foo</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span></span> *Foo &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="built_in">println</span>(<span class="string">&quot;caught a panic&quot;</span>, e)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;get instance&quot;</span>)</span><br><span class="line">        once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                instance = &amp;Foo&#123;&#125;</span><br><span class="line">                time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">                <span class="built_in">panic</span>(<span class="string">&quot;panic in once.Do function&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">                wg.Add(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                        inst := GetInstance()</span><br><span class="line">                        fmt.Printf(<span class="string">&quot;the return addr of instance %p\n&quot;</span>, inst)</span><br><span class="line">                        wg.Done()</span><br><span class="line">                &#125;()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./main</span></span><br><span class="line">get instance</span><br><span class="line">get instance</span><br><span class="line">get instance</span><br><span class="line">get instance</span><br><span class="line">get instance</span><br><span class="line">caught a panic (0x483c80,0x4b4720)</span><br><span class="line">the <span class="built_in">return</span> addr of instance 0x0</span><br><span class="line">the <span class="built_in">return</span> addr of instance 0x54f3e0</span><br><span class="line">the <span class="built_in">return</span> addr of instance 0x54f3e0</span><br><span class="line">the <span class="built_in">return</span> addr of instance 0x54f3e0</span><br><span class="line">the <span class="built_in">return</span> addr of instance 0x54f3e0</span><br></pre></td></tr></table></figure>

<ul>
<li><code>once.Do(f)</code> 会等待 f 执行完毕后才返回，这期间其他执行 once.Do 函数的 goroutine 将会阻塞等待</li>
<li>Do 函数返回后，后续的 goroutine 再执行 Do 函数将不再执行 f 并立即返回</li>
<li>即便函数 f 中出现 panic，sync.Once 原语也认为 once.Do 执行完毕，后续对 <code>once.Do</code> 的调用将不再执行 f</li>
</ul>
<h3 id="使用-sync-Pool-减轻垃圾回收的压力"><a href="#使用-sync-Pool-减轻垃圾回收的压力" class="headerlink" title="使用 sync.Pool 减轻垃圾回收的压力"></a>使用 sync.Pool 减轻垃圾回收的压力</h3><p>sync.Pool 时是一个 <code>数据对象</code> 缓存池，它具有如下特点：</p>
<ul>
<li>放入该缓存池中的数据对象的生命是暂时的，随时都可能被垃圾回收</li>
<li>缓存池中的数据对象是可以重复利用的，这样可以在一定程度上降低数据对象重新分配的频率，减轻 GC 的压力</li>
<li>sync.Pool 为每个 P（goroutine 调度模型中的 P）单独建立一个 local 缓存池，进一步降低高并发下对锁的争夺</li>
</ul>
<p>sync.Pool 的一个典型应用就是建立像 bytes.Buffer 这种类型的临时缓存对象池：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bufPool = sync.Pool &#123;</span><br><span class="line">        New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实践中，为了避免大内存的 Buffer 对象被用于小数据而造成内存没有及时释放，Go 标准库采用两种方式来缓解这一问题：</p>
<ul>
<li>限制要放回缓存池中的数据对象的大小</li>
<li>建立多级缓存池：这样就可以根据要处理的数据大小从最适合的缓存池中获取 Buffer 对象，并在完成数据处理后将对象归还到对应的池中</li>
</ul>
<h2 id="使用-atomic-包实现伸缩性更好的并发读取"><a href="#使用-atomic-包实现伸缩性更好的并发读取" class="headerlink" title="使用 atomic 包实现伸缩性更好的并发读取"></a>使用 atomic 包实现伸缩性更好的并发读取</h2><h3 id="atomic-包与原子操作"><a href="#atomic-包与原子操作" class="headerlink" title="atomic 包与原子操作"></a>atomic 包与原子操作</h3><p>atomic 包是 Go 语言提供的原子操作（原语）的相关接口。原子操作的指令是不可中断的，它好比一个事务，要么不执行，一旦执行就一次性全部执行完毕，不可分割。因此，原子操作可用于共享数据的并发同步。</p>
<p>原子操作由底层硬件直接提供支持，是一种硬件实现的指令级事务。因此 atomic 包中提供的原语更接近硬件底层，也更为低级，它常用来实现更为高级的并发同步技术。</p>
<h3 id="对共享整型变量的无锁读写"><a href="#对共享整型变量的无锁读写" class="headerlink" title="对共享整型变量的无锁读写"></a>对共享整型变量的无锁读写</h3><p>atomic 包提供了两大类原子接口：</p>
<ul>
<li>针对整型变量</li>
<li>针对自定义类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n1 <span class="type">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addSyncByAtomic</span><span class="params">(delta <span class="type">int64</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> atomic.AddInt64(&amp;n1, delta)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readSyncByAtomic</span><span class="params">()</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> atomic.LoadInt64(&amp;n1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对共享自定义类型变量的无锁读写"><a href="#对共享自定义类型变量的无锁读写" class="headerlink" title="对共享自定义类型变量的无锁读写"></a>对共享自定义类型变量的无锁读写</h3><p>atomic 通过 Value 类型的装箱操作实现了对任意自定义类型的原子操作，从而实现对共享自定义类型变量的无锁读写的支持。</p>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> config atomic.Value</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">        data <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setConfig</span><span class="params">(c Config)</span></span> &#123;</span><br><span class="line">        config.Store(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getConfig</span><span class="params">()</span></span> Config &#123;</span><br><span class="line">        <span class="keyword">return</span> config.Load().(Config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随着并发量的提升，使用 atomic 实现的共享变量的并发读写性能表现更为稳定，尤其是原子读操作。这让 atomic 包与 sync 包中的原语比起来具有更好的伸缩性和更好的性能。但是 atomic 原子操作可用来同步的范围有较大的限制，仅仅是一个整型变量或者自定义类型变量。如果需要对一个复杂的临界区数据进行同步，那么首选依旧是 sync 包中的原语。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/Go/" rel="tag"># Go</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2024/10/03/improve-go-07/" rel="prev" title="《Go 语言精进之路》读书笔记（07）：错误处理">
      <i class="fa fa-chevron-left"></i> 《Go 语言精进之路》读书笔记（07）：错误处理
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2024/10/02/improve-go-05/" rel="next" title="《Go 语言精进之路》读书笔记（05）：接口">
      《Go 语言精进之路》读书笔记（05）：接口 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.</span> <span class="nav-text">优先考虑并发设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="nav-number">1.1.</span> <span class="nav-text">并发与并行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go-%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.2.</span> <span class="nav-text">Go 并发设计实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3-goroutine-%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">了解 goroutine 调度原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#goroutine-%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="nav-number">2.1.</span> <span class="nav-text">goroutine 调度器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%8C%E6%8F%A1-Go-%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B8%B8%E8%A7%81%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">掌握 Go 并发模型和常见并发模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Go-%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.1.</span> <span class="nav-text">Go 并发模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.2.</span> <span class="nav-text">Go 常见的并发模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3-channel-%E7%9A%84%E5%A6%99%E7%94%A8"><span class="nav-number">4.</span> <span class="nav-text">了解 channel 的妙用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E7%BC%93%E5%86%B2-channel"><span class="nav-number">4.1.</span> <span class="nav-text">无缓冲 channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E7%BC%93%E5%86%B2-channel"><span class="nav-number">4.2.</span> <span class="nav-text">带缓冲 channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nil-channel-%E7%9A%84%E5%A6%99%E7%94%A8"><span class="nav-number">4.3.</span> <span class="nav-text">nil channel 的妙用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8Eselect-%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%AF%E7%94%A8%E6%B3%95"><span class="nav-number">4.4.</span> <span class="nav-text">与select 结合使用的一些惯用法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3-sync-%E5%8C%85%E7%9A%84%E6%AD%A3%E7%A1%AE%E7%94%A8%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">了解 sync 包的正确用法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-sync-%E5%8C%85%E8%BF%98%E6%98%AF-channel"><span class="nav-number">5.1.</span> <span class="nav-text">使用 sync 包还是 channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-sync-%E5%8C%85%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">5.2.</span> <span class="nav-text">使用 sync 包的注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E8%BF%98%E6%98%AF%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">5.3.</span> <span class="nav-text">互斥锁还是读写锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">5.4.</span> <span class="nav-text">条件变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-sync-Once-%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.5.</span> <span class="nav-text">使用 sync.Once 实现单例模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-sync-Pool-%E5%87%8F%E8%BD%BB%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%8E%8B%E5%8A%9B"><span class="nav-number">5.6.</span> <span class="nav-text">使用 sync.Pool 减轻垃圾回收的压力</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-atomic-%E5%8C%85%E5%AE%9E%E7%8E%B0%E4%BC%B8%E7%BC%A9%E6%80%A7%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%B9%B6%E5%8F%91%E8%AF%BB%E5%8F%96"><span class="nav-number">6.</span> <span class="nav-text">使用 atomic 包实现伸缩性更好的并发读取</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#atomic-%E5%8C%85%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">6.1.</span> <span class="nav-text">atomic 包与原子操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E5%85%B1%E4%BA%AB%E6%95%B4%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E6%97%A0%E9%94%81%E8%AF%BB%E5%86%99"><span class="nav-number">6.2.</span> <span class="nav-text">对共享整型变量的无锁读写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E5%85%B1%E4%BA%AB%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E6%97%A0%E9%94%81%E8%AF%BB%E5%86%99"><span class="nav-number">6.3.</span> <span class="nav-text">对共享自定义类型变量的无锁读写</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">156</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
