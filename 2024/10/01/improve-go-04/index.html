<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="函数和方法是 Go 程序逻辑的基本承载单元，这篇文章将聚焦于函数与方法的设计与实现。">
<meta property="og:type" content="article">
<meta property="og:title" content="《Go 语言精进之路》读书笔记（04）：函数与方法">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2024/10/01/improve-go-04/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="函数和方法是 Go 程序逻辑的基本承载单元，这篇文章将聚焦于函数与方法的设计与实现。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-10-01T06:14:35.000Z">
<meta property="article:modified_time" content="2024-10-09T06:17:41.331Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2024/10/01/improve-go-04/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>《Go 语言精进之路》读书笔记（04）：函数与方法 | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2024/10/01/improve-go-04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《Go 语言精进之路》读书笔记（04）：函数与方法
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-01 14:14:35" itemprop="dateCreated datePublished" datetime="2024-10-01T14:14:35+08:00">2024-10-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>函数和方法是 Go 程序逻辑的基本承载单元，这篇文章将聚焦于函数与方法的设计与实现。</p>
<span id="more"></span>

<h2 id="在-init-函数中检查包级别变量的初始状态"><a href="#在-init-函数中检查包级别变量的初始状态" class="headerlink" title="在 init 函数中检查包级别变量的初始状态"></a>在 init 函数中检查包级别变量的初始状态</h2><p>包是 Go 程序逻辑封装的基本单元，每个包都可以立即为一个 <code>自治的</code>、封装良好的、对外部暴露有限接口的基本单元。一个 Go 程序就是由一组包组成的。</p>
<p>Go 包中包含了常量、包级别变量、函数、类型和类型方法、接口等，我们要保证包内部这些元素在被使用之前处于合理有效的状态，尤其是包级别变量。在 Go 中一般通过 init 函数来完成这一工作。</p>
<h3 id="认识-init-函数"><a href="#认识-init-函数" class="headerlink" title="认识 init 函数"></a>认识 init 函数</h3><p>Go 中有两个特殊函数，一个是 main 包中的 main 函数，它是所有 Go 可执行程序的入口函数；另一个就是包的 init 函数。init 函数是一个无参数、无返回值的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个包定义了 init 函数，Go 运行时会负责在该包初始化时调用它的 init 函数。<strong>在 Go 程序中不能显式调用 init，否则会在编译期间报错。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;init invoked&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;main invoked&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./main</span></span><br><span class="line">init invoked</span><br><span class="line">main invoked</span><br></pre></td></tr></table></figure>

<ul>
<li>一个 Go 包可以拥有多个 init 函数，每个组成 Go 包的 Go 源文件可以定义多个 init 函数</li>
<li>在初始化 Go 包时，Go 运行时会按照一定的次序逐一调用该包的 init 函数。</li>
<li>Go 运行时不会并发调用 init 函数，总是串行执行一个个 init 函数</li>
<li>每个 init 函数在整个 Go 程序生命周期内仅会被执行一次</li>
</ul>
<p>因此，init 函数非常适合做一些包级数据的初始化及初始状态的检查工作。一般来说，先被传递给 Go 编译器的源文件中的 init 函数先被执行，同一个源文件中的多个 init 函数按照声明顺序依次执行。<strong>但是 Go 的惯例告诉我们：不要依赖 init 函数的执行次序</strong>。</p>
<h3 id="程序初始化顺序"><a href="#程序初始化顺序" class="headerlink" title="程序初始化顺序"></a>程序初始化顺序</h3><p>Go 程序由一组包组合而成，程序的初始化就是这些包的初始化。下图展示了 Go 程序的初始化顺序：</p>



<ul>
<li>Go 运行时按照包导入的顺序，先去初始化 main 包的第一个依赖包 pkg1</li>
<li>Go 运行时按照 <code>深度优先</code> 的原则，查找到 <code>pkg1 -&gt; pkg2 -&gt; pkg3</code>，由于 pkg3 没有依赖包，因此在 <code>pkg3</code> 中按照 <code>常量-变量-init</code> 函数的顺序进行初始化</li>
<li><code>pkg3</code> 初始化完毕后，Go 运行时回到 pkg2 并对 pkg2 初始化，之后再回到 pkg1 并对 pkg1 进行初始化</li>
<li>之后 Go 运行按照类似的规则继续对 main 包中的第二个依赖包 pkg4 进行初始化</li>
<li>当 main 包所有依赖包都初始化完毕后，会开始 main 包自身的初始化，Go 运行时会按照 <code>常量-变量-init</code> 函数顺序完成 main 包的初始化</li>
</ul>
<p>完成以上初始化工作后，才正式进入程序入口函数 main 函数。下面这个程序展示了包内初始化工作是按照 <code>常量-变量-init</code> 函数顺序完成的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    _ = constInitCheck()</span><br><span class="line">    v1 = variableInit(<span class="string">&quot;v1&quot;</span>)</span><br><span class="line">    v2 = variableInit(<span class="string">&quot;v2&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    c1 = <span class="string">&quot;c1&quot;</span></span><br><span class="line">    c2 = <span class="string">&quot;c2&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constInitCheck</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c1 != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;main: const c1 check&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> c2 != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;main: const c2 check&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">variableInit</span><span class="params">(name <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;main: variable %s init\n&quot;</span>, name)</span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;main: init&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./main</span></span><br><span class="line">main: const c1 check</span><br><span class="line">main: const c2 check</span><br><span class="line">main: variable v1 init</span><br><span class="line">main: variable v2 init</span><br><span class="line">main: init</span><br></pre></td></tr></table></figure>

<h3 id="使用-init-函数检查包级别变量的初始状态"><a href="#使用-init-函数检查包级别变量的初始状态" class="headerlink" title="使用 init 函数检查包级别变量的初始状态"></a>使用 init 函数检查包级别变量的初始状态</h3><p>init 函数就好比 Go 包真正投入使用之前唯一的 <code>质检员</code>，负责对包内部以及暴露到外部的包级数据（主要是包级变量）的初始状态进行检查。<code>init()</code> 使用场景主要：</p>
<ul>
<li>重置包级别变量值</li>
<li>对包级别变量进行初始化，保证其后续使用</li>
<li>在 init 函数进行注册：在 init 函数中注册自己的实现模式降低了 Go 包对外的直接暴露，尤其是包级别变量的暴露，避免了外部通过包级别变量对包状态的修改。有时候我们仅仅以空别名的方式导入某个包，就是为了让 Go 运行时运行该包的 init 函数，从而完成相关的注册工作</li>
</ul>
<p>init 函数是一个无参数、无返回值的函数。如果 init 函数中遇到错误，则说明该包其实处于一个不可用的状态，因此这种情况下快速失败是最佳选择。一般选择直接调用 panic 或者 log.Fatal 等函数记录异常日志，然后让程序快速退出。</p>
<h2 id="让自己习惯于函数是一等公民"><a href="#让自己习惯于函数是一等公民" class="headerlink" title="让自己习惯于函数是一等公民"></a>让自己习惯于函数是一等公民</h2><p>在 Go 中，函数是唯一一种基于特定输入、实现特定任务并可反馈任务执行结果的代码块（方法本质上是函数的一个变种）。本质上，我们可以说 Go 程序就是一组函数的集合。</p>
<p>Go 的函数具有以下特点：</p>
<ul>
<li>以 func 关键字开头</li>
<li>支持多返回值</li>
<li>支持具名返回值</li>
<li>支持递归调用</li>
<li>支持同类型的可变参数</li>
<li>支持 defer，实现函数优雅返回</li>
</ul>
<p>而且 Go 中的函数是一等公民。</p>
<h3 id="什么是一等公民"><a href="#什么是一等公民" class="headerlink" title="什么是一等公民"></a>什么是一等公民</h3><p>如果一门编程语言对某种语法元素的创建和使用限制，可以像对待值一样对待这种语法元素，那么就称这种语法元素是这门编程语言的 <code>一等公民</code>。这意味着拥有 <code>一等公民</code> 待遇的语法元素可以存储在变量中，可以作为参数传递给函数，可以在函数内部创建并作为返回值从函数返回。</p>
<p>在 Go 中，我们可以正常创建函数、在函数内部创建函数、使用函数来创建自定义类型、将定义好的函数存储到变量中、将函数作为参数传入函数中、作为返回值从函数返回，函数也可以放入数组、切片或 map 结构中，可以像其他变量一样赋值给 <code>interface&#123;&#125;</code>，甚至可以建立元素为函数的 channel。</p>
<p>因此在 Go 中，作为 <code>一等公民</code> 的 Go 函数拥有很大的灵活性。</p>
<h3 id="函数作为-一等公民-的特殊作用"><a href="#函数作为-一等公民-的特殊作用" class="headerlink" title="函数作为 一等公民 的特殊作用"></a>函数作为 <code>一等公民</code> 的特殊作用</h3><p>函数是一等公民，<strong>意味着函数也可以被显式类型转换</strong>，并且这样的类型转换在特定的领域具有奇妙的作用。如下是一个典型例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greeting</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;Welcome, gohper\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8090&quot;</span>, http.HandlerFunc(greeting))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码值得深入分析，可以看到 <code>ListenAndServer</code> 的第二个参数其实一个 <code>Handler</code> 接口类型，该接口类型只有一个方法 <code>ServeHTTP()</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="type">string</span>, handler Handler)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然我们的 <code>greeting()</code> 的函数原型和 <code>ServerHTTP()</code> 原型一致，但是我们不能直接将 greeting 作为参数值传入，<strong>因为 <code>greeting()</code> 函数类型并没有实现接口 Handler 的方法，无法将其赋值给 Handler 接口类型</strong>。</p>
<p>为了解决这个问题，我们将 <code>http.HandlerFunc(greeting)</code> 作为参数传递给 <code>ListenAndServe()</code>，而 <code>HandlerFunc</code> 的定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP calls f(w, r).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span></span> ServeHTTP(w ResponseWriter, r *Request) &#123;</span><br><span class="line">    f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HandlerFunc 其实就是一个基于函数定义的新类型，它的底层类型就 <code>func(ResponseWriter, *Request)</code>。而 <code>HandlerFunc</code> 类型实现了 <code>ServeHTTP()</code> 方法，也就是说 <code>HandlerFunc</code> 实现了 Handler 接口。</p>
<p>所以 <code>http.HandlerFunc(greeting)</code> 其实是将函数 greeting 显式转型为 <code>HandlerFunc</code> 类型，而后者实现了 Handler 接口，这样转型后的值就满足了 <code>ListenAndServe()</code> 的第二个参数类型要求。<strong>而这个转型是可以通过编译器检查的，因为 HandlerFunc 底层类型与 greeting 的函数原型是一致的</strong>。</p>
<p>如下是一个更简单的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Adder <span class="keyword">interface</span> &#123;</span><br><span class="line">    Add(<span class="type">int</span>, <span class="type">int</span>) <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AdderFunc <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f AdderFunc)</span></span> Add(x, y <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> f(x, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i Adder = AdderFunc(add)</span><br><span class="line">    <span class="built_in">println</span>(i.Add(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go 其实对函数式编程也提供一定程度的支持，有时候应用函数式编程风格可以编写出更优雅、更简洁、更易维护的代码。</p>
<p>函数式编程的一种典型应用是 <code>函数柯里化</code>，这是指把接受多个参数的函数变换成接受一个单一参数（原函数的第一个参数）的函数，并返回接受余下参数和返回结果的新函数的技术。如下是一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">times</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x * y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partialTimes</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x * y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    timesTwo := partialTimes(<span class="number">2</span>)</span><br><span class="line">    timesThree := partialTimes(<span class="number">3</span>)</span><br><span class="line">    timesFour := partialTimes(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(timesTwo(<span class="number">5</span>))</span><br><span class="line">    fmt.Println(timesThree(<span class="number">5</span>))</span><br><span class="line">    fmt.Println(timesFour(<span class="number">5</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也用到了 Go 函数支持的另一个特性 <code>闭包</code>。闭包是在函数内部定义的匿名函数，并且允许匿名函数访问定义它的外部函数的作用域。本质上，闭包是将函数内部和函数外部连接起来的桥梁。</p>
<p>函数式编程里的另一个典型应用是函子（functor）。函子本身是一个容器类型，以 Go 语言为例，这个容器可以是切片、map 甚至 channel。该容器类型需要实现一个方法，该方法接受一个函数类型参数，并在容器上的每个元素上应用那个函数，得到一个新函子，原函子容器内部的元素值不受影响。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IntSliceFunctor <span class="keyword">interface</span> &#123;</span><br><span class="line">    Fmap(fn <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span>) IntSliceFunctor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> intSliceFunctorImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">    ints []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(isf intSliceFunctorImpl)</span></span> Fmap(fn <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span>) IntSliceFunctor &#123;</span><br><span class="line">    newInts := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(isf.ints))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, elt := <span class="keyword">range</span> isf.ints &#123;</span><br><span class="line">        retInt := fn(elt)</span><br><span class="line">        newInts[i] = retInt</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> intSliceFunctorImpl&#123;ints: newInts&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewIntSliceFunctor</span><span class="params">(slice []<span class="type">int</span>)</span></span> IntSliceFunctor &#123;</span><br><span class="line">    <span class="keyword">return</span> intSliceFunctorImpl&#123;ints: slice&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    intSlice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    f := NewIntSliceFunctor(intSlice)</span><br><span class="line"></span><br><span class="line">    mapperFunc1 := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    mapped1 := f.Fmap(mapperFunc1)</span><br><span class="line"></span><br><span class="line">    mapperFunc2 := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i * <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    mapped2 := mapped1.Fmap(mapperFunc2)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%+v\n %+v\n&quot;</span>, mapped1, mapped2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函子非常适合用于对容器元素进行批量同构处理，而且代码比每次都对容器中的元素进行循环处理要优雅、简洁许多。</p>
<p>再看一个函数式编程风格，即 <code>延续传递式</code>（Continuation-passing Style，CPS）。在该风格中，函数式不允许有返回值的。一个函数 A 应该将其想返回的值显式传递给一个 continuation 函数（一般接受一个参数），而 continuation 函数自身是函数 A 的一个参数。如下是一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Max</span><span class="params">(n <span class="type">int</span>, m <span class="type">int</span>, f <span class="keyword">func</span>(y <span class="type">int</span>)</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> n &gt; m &#123;</span><br><span class="line">        f(n)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        f(m)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Max(<span class="number">5</span>, <span class="number">6</span>, <span class="function"><span class="keyword">func</span><span class="params">(y <span class="type">int</span>)</span></span> &#123;fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, y)&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这种编程风格其实理解起来更为困难。所以我们不能为了函数式而进行函数式编程。</p>
<h2 id="使用-defer-让函数更简洁、更健壮"><a href="#使用-defer-让函数更简洁、更健壮" class="headerlink" title="使用 defer 让函数更简洁、更健壮"></a>使用 defer 让函数更简洁、更健壮</h2><p>有时候我们会在函数中申请一些资源并在函数退出前释放或关闭这些资源。<strong>函数的实现需要确保这些资源在函数退出时被及时正确地释放，无论函数的执行流程是按预期顺利进行还是出现错误提前退出</strong>。但即便如此，如果函数实现中的某段代码逻辑抛出 panic，传统的错误处理机制依然没有办法捕获它并尝试从 panic 中恢复。</p>
<p>解决上面这些问题正是 Go 语言引入 defer 的初衷。</p>
<h3 id="defer-的运作机制"><a href="#defer-的运作机制" class="headerlink" title="defer 的运作机制"></a>defer 的运作机制</h3><p>defer 的运作离不开函数，这意味着：</p>
<ul>
<li>在 Go 中，只有函数和方法内部才能使用 defer</li>
<li>defer 关键字后面只能接受函数或者方法，这些函数被称为 deferred 函数。defer 将它们注册到其所在 goroutine 用于存放 deferred 函数的栈数据结构中，<strong>这些 deferred 函数将在执行 defer 的函数退出前按照后进先出（LIFO）的顺序调度执行</strong></li>
</ul>
<p>无论是执行到函数体尾部，还是在某个错误处理分支显式调用 return 返回，抑或是出现 panic，<strong>已经存储到 deferred 函数栈中的函数都会被调度执行</strong>。因此 deferred 函数是一个在任何情况下都可以为函数进行收尾工作的好场合。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeToFile</span><span class="params">(fname <span class="type">string</span>, data []<span class="type">byte</span>, mu *sync.Mutex)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">    f, err := os.OpenFile(fname, os.O_RDWR, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">    _, err = f.Seek(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _, err = f.Write(data)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f.Sync()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里资源释放函数的 defer 注册动作紧临着资源申请成功的动作。<strong>这样成对出现的惯例极大降低了遗漏资源释放的可能性</strong>。这样再也不用小心翼翼地在每个错误处理分支中检查是否遗漏了某个资源的释放动作。</p>
<h3 id="defer-的常见用法"><a href="#defer-的常见用法" class="headerlink" title="defer 的常见用法"></a>defer 的常见用法</h3><p>除了释放资源这个最基本的用法之外，defer 的运作机制决定了它还可以在其他一些场合发挥作用。</p>
<p>defer 的第二个重要用途就是拦截 panic，并按需要对 panic 进行处理。可以尝试从 panic 中恢复（这也是 Go 中唯一从 panic 中恢复的手段），也可以触发一个新的 panic。</p>
<p>下面的代码演示了如何拦截 panic 并恢复程序的执行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;raise a panic&quot;</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;recovered from a panic&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    bar()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    foo()</span><br><span class="line">    fmt.Println(<span class="string">&quot;main exit normally&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而如下代码则为触发一个新的 panic：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/bytes/buffer.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeSlice</span><span class="params">(n <span class="type">int</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    <span class="comment">// If the make fails, give a known error.</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">recover</span>() != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(ErrTooLarge) <span class="comment">// 触发一个新panic</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make</span>([]<span class="type">byte</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>deferred 函数在出现 panic 的情况下依旧能够调度执行</strong>，所以如下两个函数在程序触发 panic 时是不一样的。当 <code>bizoperation</code> 出现 panic 时，函数 g 无法释放 mutex，而函数 f 则可以正确释放。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">    bizoperation()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    bizoperation()</span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然 deferred 函数可以拦截大部分 panic，但是无法拦截并恢复一些运行时之外的致命问题，例如通过 C 代码引发的 panic，deferred 函数就无能为力。</p>
<p>defer 还可以用于修改函数的具名返回值，例如用于修改 error 错误值。如下是一个更简单的例子。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(a, b <span class="type">int</span>)</span></span> (x, y <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        x = x * <span class="number">5</span></span><br><span class="line">        y = y * <span class="number">10</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    x = a + <span class="number">5</span></span><br><span class="line">    y = b + <span class="number">6</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x, y := foo(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">println</span>(x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./main</span></span><br><span class="line">30 80</span><br></pre></td></tr></table></figure>

<p>defer 函数被注册即调度执行的时间点使得它十分适合用来输出一些调试信息。一个典型的例子是在出入函数时打印 trace 日志，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;entering: &quot;</span>, s)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">un</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;leaveing: &quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> un(trace(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;in a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> un(trace(<span class="string">&quot;b&quot;</span>))</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;in b&quot;</span>)</span><br><span class="line">    a()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./main</span></span><br><span class="line">entering:  b</span><br><span class="line"><span class="keyword">in</span> b</span><br><span class="line">entering:  a</span><br><span class="line"><span class="keyword">in</span> a</span><br><span class="line">leaveing:  a</span><br><span class="line">leaveing:  b</span><br></pre></td></tr></table></figure>

<p>defer 还有一种比较小众的用法，用于还原变量的旧值。如下是一个来自标准库的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/syscall/fs_nacl.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    oldFsinit := fsinit</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fsinit = oldFsinit &#125;()</span><br><span class="line">    fsinit = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    Mkdir(<span class="string">&quot;/dev&quot;</span>, <span class="number">0555</span>)</span><br><span class="line">    Mkdir(<span class="string">&quot;/tmp&quot;</span>, <span class="number">0777</span>)</span><br><span class="line">    mkdev(<span class="string">&quot;/dev/null&quot;</span>, <span class="number">0666</span>, openNull)</span><br><span class="line">    mkdev(<span class="string">&quot;/dev/random&quot;</span>, <span class="number">0444</span>, openRandom)</span><br><span class="line">    mkdev(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="number">0444</span>, openRandom)</span><br><span class="line">    mkdev(<span class="string">&quot;/dev/zero&quot;</span>, <span class="number">0666</span>, openZero)</span><br><span class="line">    chdirEnv()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关于-defer-的几个关键问题"><a href="#关于-defer-的几个关键问题" class="headerlink" title="关于 defer 的几个关键问题"></a>关于 defer 的几个关键问题</h3><p>对于自定义的函数或方法，defer 可以无条件的支持，但是对于有返回值的自定义函数或方法，返回值会在 deferred 函数被调度执行的时候被自动丢弃。对于有返回值的内置函数，如果将其作为 defer 函数，则编译器会给出错误提示。此时可以将它们包装到一个匿名函数中，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _ = <span class="built_in">append</span>(sl, <span class="number">11</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>使用 defer 时，<strong>需要牢记，defer 关键字后面的表达式是将 deferred 函数注册到 deferred 函数栈的时候进行求值的</strong>。如下是一个典型例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;foo1&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">println</span>(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;foo2&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(n)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo3</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;foo3&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(i)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    foo1()</span><br><span class="line">    foo2()</span><br><span class="line">    foo3()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./main</span></span><br><span class="line">foo1</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">foo2</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">foo3</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>这里最需要注意的是 foo3，因为压入 deferred 函数栈的函数是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>而每个 deferred 函数被调度执行的时候，匿名函数以闭包的方式访问外部函数变量 i，而此时 i 的值是 4，因此最后都是输出 4。</p>
<p>下面还是一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sl := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(a []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(a)</span><br><span class="line">    &#125;(sl)</span><br><span class="line"></span><br><span class="line">    sl = []<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;</span><br><span class="line">    _ = sl</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sl := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(p *[]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(*p)</span><br><span class="line">    &#125;(&amp;sl)</span><br><span class="line"></span><br><span class="line">    sl = []<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;</span><br><span class="line">    _ = sl</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    foo1()</span><br><span class="line">    foo2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./main</span></span><br><span class="line">[1 2 3]</span><br><span class="line">[3 2 1]</span><br></pre></td></tr></table></figure>


<p>虽然 defer 让资源释放的过程变得优雅的多，也不容易出错，<strong>但是在性能敏感的程序中，defer 带来的性能开销也是 Gopher 必须要知晓和权衡的</strong>。Go 1.14 开始，defer 性能提升巨大，已经和不用 defer 的性能相差很小了。</p>
<h2 id="理解方法的本质以选择正确的-receiver-类型"><a href="#理解方法的本质以选择正确的-receiver-类型" class="headerlink" title="理解方法的本质以选择正确的 receiver 类型"></a>理解方法的本质以选择正确的 receiver 类型</h2><p>和函数相比，Go 语言的方法在声明形式上仅仅多了一个参数，Go 称之为 receiver 参数。<strong>receiver 参数是方法与类型之间的纽带</strong>。Go 方法的声明形式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver T/*T)</span></span> MethodName(params) (results)</span><br></pre></td></tr></table></figure>

<p>在上述方法声明中的 T 称为 receiver 的基类型。通过 receiver，上述方法被绑定到类型 T 上。或者说，上述方法是类型 T 的一个方法。可以通过类型 T 或者 *T 的实例调用该方法。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t T</span><br><span class="line">t.MethodName(params)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pt *T = &amp;t</span><br><span class="line">pt.MethodName(params)</span><br></pre></td></tr></table></figure>

<p>Go 方法具有如下特点：</p>
<ul>
<li>方法名的首字母是否大写决定了该方法是不是导出方法</li>
<li>方法定义要与类型定义放在同一个包内，因此不能为原生类型（例如 int、float、map 等）添加方法，只能为自定义类型添加方法，也不能横跨 Go 包为其他包内的自定义类型定义方法</li>
<li>每个方法只能有一个 receiver 参数。不支持多 receiver 参数列表或者变长 receiver 参数。一个方法只能绑定一个基类型</li>
<li>receiver 参数的基类型本身不能是指针类型或者接口类型。例如如下都是错误的</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt *<span class="type">int</span></span><br><span class="line"><span class="comment">// compiler: invalid receiver type MyInt (pointer or interface type)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r MyInt)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyReader io.Reader</span><br><span class="line"><span class="comment">// compiler: invalid receiver type MyReader (pointer or interface type)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r MyReader)</span></span> Read(p []<span class="type">byte</span>) (<span class="type">int</span> <span class="type">error</span>) &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法的本质"><a href="#方法的本质" class="headerlink" title="方法的本质"></a>方法的本质</h3><p>Go 语言没有类，方法与类型之间通过 receiver 联系在一起。可以为任何非内置原生类型定义方法。对于 Go 来说，会将 receiver 作为第一个参数传入方法的参数列表，因此如下方法其实和如下函数是等价的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> Get() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> Set(a <span class="type">int</span>) &#123;</span><br><span class="line">    t.a = a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span><span class="params">(t T)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Set</span><span class="params">(t *T, a <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    t.a = a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这种转换后的函数就是方法的原型</strong>，只不过在 Go 中，这种等价是由 Go 编译器在编译和生成代码时自动完成的。Go 语言规范中提供了一个新的概念，可以让我们更充分理解上面的等价转换。</p>
<p>Go 方法的使用方式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t T</span><br><span class="line">t.Get()</span><br><span class="line">t.Set(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>也可以按照如下方式等价替换上述调用方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t T</span><br><span class="line">T.Get(t)</span><br><span class="line">(*T).Set(&amp;t, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><strong>这种直接以类型名 T 调用的方法的表达式称为方法表达式</strong>。**类型 T 只能调用 T 的方法集合中的方法，同理，类型 <em>T 只能调用 <em>T 方法集合中的方法</em></em></p>
<p>这种通过方法表达式对方法进行调用与我们之前所做的方法到函数的等价转换如出一辙。<strong>这就是 Go 方法的本质：一个以方法所绑定类型实例为第一个参数的普通函数</strong>。Go 方法自身的类型就是一个普通函数，我们甚至可以将其作为右值赋值给函数类型的变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t T</span><br><span class="line">f1 := (*T).Set</span><br><span class="line">f2 := T.Get</span><br><span class="line">f1(&amp;t, <span class="number">3</span>)</span><br><span class="line">fmt.Println(f2(t))</span><br></pre></td></tr></table></figure>

<h3 id="选择正确的-receiver-类型"><a href="#选择正确的-receiver-类型" class="headerlink" title="选择正确的 receiver 类型"></a>选择正确的 receiver 类型</h3><p>因为方法和函数的如下等价变换关系：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> M1() &lt;=&gt; M1(t T)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> M2() &lt;=&gt; M2(t *T)</span><br></pre></td></tr></table></figure>

<p>当以 T 作为 receiver 参数类型时，由于其等价于 <code>M1(t T)</code>，Go 函数的参数采用的是值复制传递。当选择以 <code>*T</code> 作为 receiver 参数类型时，由于其等价于 <code>M2(t *T)</code>，因此传递给 M2 函数的 t 是 T 类型实例的地址。</p>
<p>如下示例演示了选择不同 receiver 类型对原类型实例的影响：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> M1() &#123;</span><br><span class="line">    t.a = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> M2() &#123;</span><br><span class="line">    t.a = <span class="number">11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> t T</span><br><span class="line">    <span class="built_in">println</span>(t.a)</span><br><span class="line">    t.M1()</span><br><span class="line">    <span class="built_in">println</span>(t.a)</span><br><span class="line">    t.M2()</span><br><span class="line">    <span class="built_in">println</span>(t.a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./main</span></span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">11</span><br></pre></td></tr></table></figure>

<p>**无论是 T 类型实例还是 *T 类型实例，都既可以调用 receiver 为 T 类型的方法，也可以调用 receiver 为 *T 类型的方法**。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> M1() &#123;</span><br><span class="line">    t.a = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> M2() &#123;</span><br><span class="line">    t.a = <span class="number">11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> t T</span><br><span class="line">    t.M1()</span><br><span class="line">    <span class="built_in">println</span>(t.a)</span><br><span class="line">    t.M2()</span><br><span class="line">    <span class="built_in">println</span>(t.a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pt = &amp;T&#123;&#125;</span><br><span class="line">    pt.M1()</span><br><span class="line">    <span class="built_in">println</span>(pt.a)</span><br><span class="line">    pt.M2()</span><br><span class="line">    <span class="built_in">println</span>(pt.a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./main</span></span><br><span class="line">0</span><br><span class="line">11</span><br><span class="line">0</span><br><span class="line">11</span><br></pre></td></tr></table></figure>

<p>可以看到 T 类型实例调用 receiver 为 <em>T 的 M2 方法是 ok 的，同样，</em>T 类型实例 pt 调用 receiver 类型为 T 的 M1 方法也是可以的。<strong>实际上，这都是 Go 的语法糖，Go 编译器在编译和生成代码时为我们自动做了转换</strong>。</p>
<p>因此，可以得出 receiver 类型选用的初步结论：</p>
<ul>
<li>如果要对类型实例进行修改，那么为 receiver 选择 *T 类型（只与方法 receiver 类型有关，与调用实例的类型无关）</li>
<li>如果没有对类型实例进行修改的需求，那么 receiver 选择 T 类型或者 *T 类型均可，但考虑到 Go 方法调用时，receiver 是以值复制形式传入方法中，如果类型 size 较大，以值形式传入会导致较大的损耗，这是选择 *T 作为 receiver 类型更好</li>
</ul>
<p>关于 receiver 类型选择还有一个重要因素，就是类型是否要实现某个接口。这个会在下一条详细介绍。</p>
<p>如下是一个非常容易出错的实例，这里也用到了我们之前介绍过 <code>for 循环中变量复用</code> 的知识：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> field <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *field)</span></span> <span class="built_in">print</span>() &#123;</span><br><span class="line">    <span class="built_in">println</span>(p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data1 := []*field&#123;&#123;<span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="string">&quot;three&quot;</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data1 &#123;</span><br><span class="line">        <span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data2 := []field&#123;&#123;<span class="string">&quot;four&quot;</span>&#125;, &#123;<span class="string">&quot;five&quot;</span>&#125;, &#123;<span class="string">&quot;six&quot;</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data2 &#123;</span><br><span class="line">        <span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./main</span></span><br><span class="line">two</span><br><span class="line">six</span><br><span class="line">one</span><br><span class="line">six</span><br><span class="line">three</span><br><span class="line">six</span><br></pre></td></tr></table></figure>

<h2 id="方法集合决定接口实现"><a href="#方法集合决定接口实现" class="headerlink" title="方法集合决定接口实现"></a>方法集合决定接口实现</h2><p>自定义类型的方法和接口都是 Go 中重要概念，并且它们之间存在千丝万缕的联系。如下是一个示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    M1()</span><br><span class="line">    M2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> M1() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> M2() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> t T</span><br><span class="line">    <span class="keyword">var</span> pt = &amp;T&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> i Interface</span><br><span class="line"></span><br><span class="line">    i = pt</span><br><span class="line">    i = t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码会触发编译错误，这个错误其实就和类型的方法集合有关。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compiler: cannot use t (variable of <span class="keyword">type</span> T) as Interface value in assignment: T does not implement Interface (method M2 has pointer receiver)</span><br></pre></td></tr></table></figure>

<h3 id="方法集合"><a href="#方法集合" class="headerlink" title="方法集合"></a>方法集合</h3><p>Go 中自定义类型与接口之间是松耦合的：如果某个自定义类型 T 的方法集合是某个接口类型的方法集合的超集，那么就说类型 T 实现了该接口，并且类型 T 的变量可以被复制给该接口类型的变量。<strong>这也是我们所说的方法集合决定了接口实现</strong>。</p>
<p>要判断一个自定义类型是否实现了某接口类型，首先要识别出自定义类型的方法集合和接口类型的方法集合。如下函数可以打印某个类型的方法集合：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    M1()</span><br><span class="line">    M2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> M1() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> M2() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DumpMethodSet</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    v := reflect.TypeOf(i)</span><br><span class="line">    elemTyp := v.Elem()</span><br><span class="line"></span><br><span class="line">    n := elemTyp.NumMethod()</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s&#x27;s method set is empty!\n&quot;</span>, elemTyp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s&#x27;s method set:\n&quot;</span>, elemTyp)</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;-&quot;</span>, elemTyp.Method(j).Name)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> t T</span><br><span class="line">    <span class="keyword">var</span> pt = &amp;T&#123;&#125;</span><br><span class="line"></span><br><span class="line">    DumpMethodSet(&amp;t)</span><br><span class="line">    DumpMethodSet(&amp;pt)</span><br><span class="line">    DumpMethodSet((*Interface)(<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例很好地解释了 Go 语言的规范：</p>
<ul>
<li>对于非接口类型的自定义类型 T，其方法集合由所有 receiver 为 T 类型的方法组成</li>
<li>而类型 <code>*T</code> 的方法集合则包含所有 receiver 为 T 和 *T 类型的方法</li>
</ul>
<p>所以在为 receiver 选择类型时需要考虑是否支持将 T 类型实例赋值给某个接口类型变量。如果需要支持，我们就要实现 receiver 为 T 类型的接口类型方法集合中的所有方法。</p>
<h3 id="类型嵌入与方法集合"><a href="#类型嵌入与方法集合" class="headerlink" title="类型嵌入与方法集合"></a>类型嵌入与方法集合</h3><p><strong>Go 的设计哲学之一是偏好组合</strong>。Go 支持用组合的思想来实现一些面向对象领域经典的机制，比如继承。而具体方式就是类型嵌入。Go 支持以下嵌入：</p>
<ul>
<li>在接口类型中嵌入接口类型</li>
<li>在结构体类型中嵌入接口类型</li>
<li>在结构体类型中嵌入结构体类型</li>
</ul>
<p>通过在接口类型中嵌入其他接口类型可以实现接口的组合，这是 Go 语言中基于已有接口类型构建新接口类型的惯用法。通过嵌入其他接口类型而创建的新接口类型的方法集合包含了被嵌入接口类型的方法集合。</p>
<p>在结构体类型中嵌入接口类型后，该结构体类型的方法集合中将包含被嵌入接口类型的方法集合。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    M1()</span><br><span class="line">    M2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;</span><br><span class="line">    Interface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(T)</span></span> M3() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DumpMethodSet</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    v := reflect.TypeOf(i)</span><br><span class="line">    elemTyp := v.Elem()</span><br><span class="line"></span><br><span class="line">    n := elemTyp.NumMethod()</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s&#x27;s method set is empty!\n&quot;</span>, elemTyp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s&#x27;s method set:\n&quot;</span>, elemTyp)</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;-&quot;</span>, elemTyp.Method(j).Name)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> t T</span><br><span class="line">    <span class="keyword">var</span> pt = &amp;T&#123;&#125;</span><br><span class="line"></span><br><span class="line">    DumpMethodSet((*Interface)(<span class="literal">nil</span>))</span><br><span class="line">    DumpMethodSet(&amp;t)</span><br><span class="line">    DumpMethodSet(&amp;pt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嵌入了其他接口类型的结构体类型的实例在调用方法时，Go 选择方法的次序：</p>
<ul>
<li>优先选择结构体自身实现的方法</li>
<li>如果结构体自身并未实现，那么将查找结构体中的嵌入接口类型的方法集合中是否有该方法，如果有，则提升（promoted）为结构体的方法</li>
<li>如果结构体嵌入了多个接口类型且这些接口类型的方法集合存在交集，那么 Go 编译器将报错，除非结构体自己实现了交集中的所有方法</li>
</ul>
<p><strong>结构体类型在嵌入某接口类型的同时，也实现了这个接口</strong>。这一特性在单元测试中尤为有用。</p>
<p>在结构体类型中嵌入结构体类型为 Gopher 提供了一种实现 <code>继承</code> 的手段。外部的结构体类型 T 可以 <code>继承</code> 嵌入的结构体类型的所有方法的实现，并且无论是 T 类型的变量实例还是 *T 类型的变量实例，都可以调用所有继承的方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(T1)</span></span> T1M1() &#123; <span class="built_in">println</span>(<span class="string">&quot;T1&#x27;s M1&quot;</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(T1)</span></span> T1M2() &#123; <span class="built_in">println</span>(<span class="string">&quot;T1&#x27;s M2&quot;</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*T1)</span></span> PT1M3() &#123; <span class="built_in">println</span>(<span class="string">&quot;PT1&#x27;s M3&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T2 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(T2)</span></span> T2M1() &#123; <span class="built_in">println</span>(<span class="string">&quot;T2&#x27;s M1&quot;</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(T2)</span></span> T2M2() &#123; <span class="built_in">println</span>(<span class="string">&quot;T2&#x27;s M2&quot;</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*T2)</span></span> PT2M3() &#123; <span class="built_in">println</span>(<span class="string">&quot;PT2&#x27;s M3&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;</span><br><span class="line">    T1</span><br><span class="line">    *T2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DumpMethodSet</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    v := reflect.TypeOf(i)</span><br><span class="line">    elemTyp := v.Elem()</span><br><span class="line"></span><br><span class="line">    n := elemTyp.NumMethod()</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s&#x27;s method set is empty!\n&quot;</span>, elemTyp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s&#x27;s method set:\n&quot;</span>, elemTyp)</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;-&quot;</span>, elemTyp.Method(j).Name)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := T &#123;</span><br><span class="line">        T1: T1&#123;&#125;,</span><br><span class="line">        T2: &amp;T2&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;call method through t:\n&quot;</span>)</span><br><span class="line">    t.T1M1()</span><br><span class="line">    t.T1M2()</span><br><span class="line">    t.PT1M3()</span><br><span class="line">    t.T2M1()</span><br><span class="line">    t.T2M2()</span><br><span class="line">    t.PT2M3()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;call method through pt:\n&quot;</span>)</span><br><span class="line">    pt := &amp;t</span><br><span class="line">    pt.T1M1()</span><br><span class="line">    pt.T1M2()</span><br><span class="line">    pt.PT1M3()</span><br><span class="line">    pt.T2M1()</span><br><span class="line">    pt.T2M2()</span><br><span class="line">    pt.PT2M3()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t1  T1</span><br><span class="line">    <span class="keyword">var</span> pt1 *T1</span><br><span class="line">    DumpMethodSet(&amp;t1)</span><br><span class="line">    DumpMethodSet(&amp;pt1)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t2 T2</span><br><span class="line">    <span class="keyword">var</span> pt2 *T2</span><br><span class="line">    DumpMethodSet(&amp;t2)</span><br><span class="line">    DumpMethodSet(&amp;pt2)</span><br><span class="line"></span><br><span class="line">    DumpMethodSet(&amp;t)</span><br><span class="line">    DumpMethodSet(&amp;pt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./main</span></span><br><span class="line">call method through t:</span><br><span class="line"></span><br><span class="line">T1<span class="string">&#x27;s M1</span></span><br><span class="line"><span class="string">T1&#x27;</span>s M2</span><br><span class="line">PT1<span class="string">&#x27;s M3</span></span><br><span class="line"><span class="string">T2&#x27;</span>s M1</span><br><span class="line">T2<span class="string">&#x27;s M2</span></span><br><span class="line"><span class="string">PT2&#x27;</span>s M3</span><br><span class="line">call method through pt:</span><br><span class="line"></span><br><span class="line">T1<span class="string">&#x27;s M1</span></span><br><span class="line"><span class="string">T1&#x27;</span>s M2</span><br><span class="line">PT1<span class="string">&#x27;s M3</span></span><br><span class="line"><span class="string">T2&#x27;</span>s M1</span><br><span class="line">T2<span class="string">&#x27;s M2</span></span><br><span class="line"><span class="string">PT2&#x27;</span>s M3</span><br><span class="line">main.T1<span class="string">&#x27;s method set:</span></span><br><span class="line"><span class="string">- T1M1</span></span><br><span class="line"><span class="string">- T1M2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">*main.T1&#x27;</span>s method <span class="built_in">set</span>:</span><br><span class="line">- PT1M3</span><br><span class="line">- T1M1</span><br><span class="line">- T1M2</span><br><span class="line"></span><br><span class="line">main.T2<span class="string">&#x27;s method set:</span></span><br><span class="line"><span class="string">- T2M1</span></span><br><span class="line"><span class="string">- T2M2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">*main.T2&#x27;</span>s method <span class="built_in">set</span>:</span><br><span class="line">- PT2M3</span><br><span class="line">- T2M1</span><br><span class="line">- T2M2</span><br><span class="line"></span><br><span class="line">main.T<span class="string">&#x27;s method set:</span></span><br><span class="line"><span class="string">- PT2M3</span></span><br><span class="line"><span class="string">- T1M1</span></span><br><span class="line"><span class="string">- T1M2</span></span><br><span class="line"><span class="string">- T2M1</span></span><br><span class="line"><span class="string">- T2M2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">*main.T&#x27;</span>s method <span class="built_in">set</span>:</span><br><span class="line">- PT1M3</span><br><span class="line">- PT2M3</span><br><span class="line">- T1M1</span><br><span class="line">- T1M2</span><br><span class="line">- T2M1</span><br><span class="line">- T2M2</span><br></pre></td></tr></table></figure>

<p>从输出结果来看，无论是 T 类型的变量实例还是 *T 类型变量实例，都可以调用所有 <code>继承</code> 的方法。**但是 T 和 *T 类型的方法集合是有差别的**：</p>
<ul>
<li>T 类型的方法集合 &#x3D; T1 的方法集合 + *T2 的方法集合</li>
<li>*T 类型的方法集合 &#x3D; *T1 的方法集合 + *T2 的方法集合</li>
</ul>
<h3 id="defined-类型的方法集合"><a href="#defined-类型的方法集合" class="headerlink" title="defined 类型的方法集合"></a>defined 类型的方法集合</h3><p>Go 语言支持基于已有的类型创建新类型，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInterface I</span><br><span class="line"><span class="keyword">type</span> Mystruct T</span><br></pre></td></tr></table></figure>

<p>已有的类型（比如上面的 I、T）被称为 underlying 类型，而新类型称为 defined 类型。</p>
<ul>
<li>基于接口类型创建的 defined 类型与原接口类型的方法集合是一致的</li>
<li>而基于自定义非接口类型创建的 defined 类型则并没有继承 <code>原类型</code> 的方法集合，新的 defined 类型的方法集合是空的</li>
</ul>
<p>方法集合决定接口实现，基于自定义非接口类型的 defined 类型的方法集合为空，这决定了即便原类型实现了某些接口，基于其创建的 defined 类型也没有继承这一隐式关联。新 defined 类型想要实现那些接口，仍然要重新实现接口的所有方法。</p>
<h3 id="类型别名的方法集合"><a href="#类型别名的方法集合" class="headerlink" title="类型别名的方法集合"></a>类型别名的方法集合</h3><p>Go 也支持类型别名，支持为已有类型定义别名。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInterface = I</span><br><span class="line"><span class="keyword">type</span> MyStruct = T</span><br></pre></td></tr></table></figure>

<p>类型别名与原类型几乎等价。类型别名与原类型拥有完全相同的方法集合，无论原类型是接口类型还是非接口类型。</p>
<h2 id="了解变长参数函数的妙用"><a href="#了解变长参数函数的妙用" class="headerlink" title="了解变长参数函数的妙用"></a>了解变长参数函数的妙用</h2><h3 id="什么是变长参数函数"><a href="#什么是变长参数函数" class="headerlink" title="什么是变长参数函数"></a>什么是变长参数函数</h3><p>变长参数函数就是指调用时可以接受零个、一个或多个实际参数的函数。例如 Println 的原型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>这种接受 <code>...T</code> 类型形式参数的函数就称为 <code>变长参数函数</code>。一个变长参数函数只能有一个 <code>...T</code> 类型的形式参数，并且该形式参数应该为函数参数列表的最后一个形式参数。<strong>变长参数函数的 <code>...T</code> 类型形式参数在函数体内呈现为 <code>[]T</code> 类型的变量</strong>。</p>
<p><code>...T</code> 类型形式参数可以匹配和接受的实参类型有两种：</p>
<ul>
<li>多个 T 类型的变量</li>
<li>t…（t 为 T 类型变量）</li>
</ul>
<p>只能选择上述两种实参类型中的一种：要么是多个 T 类型的变量，要么是 <code>t...</code>（t 为 T 类型变量）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a ...<span class="type">int</span>)</span></span> (total <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">        total += v</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a, b, c <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(sum(a, b, c))</span><br><span class="line">    <span class="built_in">println</span>(sum(s...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用变长参数函数时，最容易出现的错误是实参与形参不匹配，例如如下例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dump</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> args &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="type">string</span>&#123;<span class="string">&quot;Tony&quot;</span>, <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Jim&quot;</span>&#125;</span><br><span class="line">    dump(s...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的变长参数类型为 <code>...interface&#123;&#125;</code>，因此匹配该形参的要么是 <code>interface&#123;&#125;</code> 类型变量，要么是 <code>t...</code>（t 为 []interface{}）。而这里传入 <code>[]string...</code>，并不匹配。这里需要注意的是，虽然 string 类型变量可以直接赋值给 interface{} 类型变量，<strong>但是 <code>[]string</code> 类型变量并不能直接赋值给 <code>[]interface&#123;&#125;</code> 类型变量</strong>。要消除该错误，只需要这样定义 s 即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;Tony&quot;</span>, <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Jim&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>有一个例外是 Go 内置的 append 函数，支持通过如下方式将字符串附加到一个字节切片后面：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">    b = <span class="built_in">append</span>(b, <span class="string">&quot;hello&quot;</span>...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是因为编译器自动将 string 隐式转换为了 <code>[]byte</code>，如果是我们自定义的函数，是无法支持这种用法的。</p>
<h3 id="模拟函数重载"><a href="#模拟函数重载" class="headerlink" title="模拟函数重载"></a>模拟函数重载</h3><p>Go 语言不允许在同一个作用域下定义名字相同但函数原型不同的函数，也就是说 Go 不支持类似于 C++ 中的函数重载机制。在 Go 的类型系统中，仅按照名称进行匹配并要求类型一致是一个主要的简化决策。</p>
<p>但是在 Go 中我们也可以对 <code>重载函数</code> 进行模拟：</p>
<ul>
<li>如果要重载的函数参数是相同类型，仅参数个数是变化的，那么变长参数函数就可以实现</li>
<li>如果参数类型不同且个数可变，那么还要结合 <code>interface&#123;&#125;</code> 类型的特性</li>
</ul>
<p>如下是一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concat</span><span class="params">(sep <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result <span class="type">string</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, v := <span class="keyword">range</span> args &#123;</span><br><span class="line">                <span class="keyword">if</span> i != <span class="number">0</span> &#123;</span><br><span class="line">                        result += sep</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> v.(<span class="keyword">type</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="type">int</span>, <span class="type">int8</span>, <span class="type">int16</span>, <span class="type">int32</span>, <span class="type">int64</span>,</span><br><span class="line">                        <span class="type">uint</span>, <span class="type">uint8</span>, <span class="type">uint16</span>, <span class="type">uint32</span>, <span class="type">uint64</span>:</span><br><span class="line">                        result += fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, v)</span><br><span class="line">                <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">                        result += fmt.Sprintf(<span class="string">&quot;%s&quot;</span>, v)</span><br><span class="line">                <span class="keyword">case</span> []<span class="type">int</span>:</span><br><span class="line">                        ints := v.([]<span class="type">int</span>)</span><br><span class="line">                        <span class="keyword">for</span> i, v := <span class="keyword">range</span> ints &#123;</span><br><span class="line">                                <span class="keyword">if</span> i != <span class="number">0</span> &#123;</span><br><span class="line">                                        result += sep</span><br><span class="line">                                &#125;</span><br><span class="line">                                result += fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, v)</span><br><span class="line">                        &#125;</span><br><span class="line">                <span class="keyword">case</span> []<span class="type">string</span>:</span><br><span class="line">                        strs := v.([]<span class="type">string</span>)</span><br><span class="line">                        result += strings.Join(strs, sep)</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                        fmt.Printf(<span class="string">&quot;the argument type [%T] is not support&quot;</span>, v)</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(concat(<span class="string">&quot;-&quot;</span>, <span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">        <span class="built_in">println</span>(concat(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;gopher&quot;</span>))</span><br><span class="line">        <span class="built_in">println</span>(concat(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>, []<span class="type">string</span>&#123;<span class="string">&quot;world&quot;</span>, <span class="string">&quot;test&quot;</span>&#125;, []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模拟实现函数的可选参数与默认参数"><a href="#模拟实现函数的可选参数与默认参数" class="headerlink" title="模拟实现函数的可选参数与默认参数"></a>模拟实现函数的可选参数与默认参数</h3><p>如果参数在传入时有隐式要求的固定顺序（这点由调用者保证），我们还可以利用变长参数函数模拟实现函数的可选参数和默认参数。</p>
<p>如下是一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> record <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    gender <span class="type">string</span></span><br><span class="line">    age <span class="type">uint16</span></span><br><span class="line">    city <span class="type">string</span></span><br><span class="line">    country <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">enroll</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (*record, <span class="type">error</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) &gt; <span class="number">5</span> || <span class="built_in">len</span>(args) &lt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;the number of arguments passed is wrong&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r := &amp;record &#123;</span><br><span class="line">        city: <span class="string">&quot;Beijing&quot;</span>,</span><br><span class="line">        country: <span class="string">&quot;China&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> args &#123;</span><br><span class="line">        <span class="keyword">switch</span> i &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            name, ok := v.(<span class="type">string</span>)</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;name is not passed as string&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            r.name = name</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            gender, ok := v.(<span class="type">string</span>)</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;gender is not passed as string&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            r.gender = gender</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            age, ok := v.(<span class="type">int</span>)</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;age is not passed as int&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            r.age = <span class="type">uint16</span>(age)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            city, ok := v.(<span class="type">string</span>)</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;city is not passed as string&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            r.city = city</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            country, ok := v.(<span class="type">string</span>)</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;country is not passed as string&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            r.country = country</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unknown argument passed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r, _ := enroll(<span class="string">&quot;lee&quot;</span>, <span class="string">&quot;male&quot;</span>, <span class="number">23</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, *r)</span><br><span class="line"></span><br><span class="line">    r, _ = enroll(<span class="string">&quot;jack&quot;</span>, <span class="string">&quot;female&quot;</span>, <span class="number">20</span>, <span class="string">&quot;Chengdu&quot;</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, *r)</span><br><span class="line"></span><br><span class="line">    r, _ = enroll(<span class="string">&quot;Mark&quot;</span>, <span class="string">&quot;male&quot;</span>, <span class="number">20</span>, <span class="string">&quot;NewYork&quot;</span>, <span class="string">&quot;USA&quot;</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, *r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个函数中，city 和 country 的默认值是在 record 类型实例创建时被赋予的初值。实现这样一个 enroll 函数的前提是其调用方要负责正确的顺序传入参数并保证参数类型满足函数要求。当然这种 Go 实现的可选参数和默认参数是有局限的，调用者只能从右侧的参数开始逐一进行省略的处理。</p>
<h2 id="实现功能选项模式"><a href="#实现功能选项模式" class="headerlink" title="实现功能选项模式"></a>实现功能选项模式</h2><p>在日常 Go 编程中，我们经常会实现一些带有设置选项的创建型函数，我们可以通过如下方式实现这个函数：</p>
<ul>
<li>版本 1：通过参数暴露配置选项，优点是能够快速实现，缺点则是该接口无法扩展</li>
<li>版本 2：通过结构体封装配置选项，这种方式也是目标比较常见的做法。</li>
</ul>
<p>这里要介绍的是第三种方式，即功能选项模式，这种模式应该是目前进行功能选项设计的最佳实践。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FinishedHouse <span class="keyword">struct</span> &#123;</span><br><span class="line">        style               <span class="type">int</span></span><br><span class="line">        centralConditioning <span class="type">bool</span></span><br><span class="line">        floolMaterial       <span class="type">string</span></span><br><span class="line">        wallMaterial        <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Option <span class="function"><span class="keyword">func</span><span class="params">(*FinishedHouse)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFininishedHouse</span><span class="params">(options ...Option)</span></span> *FinishedHouse &#123;</span><br><span class="line">        h := &amp;FinishedHouse&#123;</span><br><span class="line">                style:               <span class="number">0</span>,</span><br><span class="line">                centralConditioning: <span class="literal">true</span>,</span><br><span class="line">                floolMaterial:       <span class="string">&quot;wood&quot;</span>,</span><br><span class="line">                wallMaterial:        <span class="string">&quot;paper&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, option := <span class="keyword">range</span> options &#123;</span><br><span class="line">                option(h)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithStyle</span><span class="params">(style <span class="type">int</span>)</span></span> Option &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(fh *FinishedHouse)</span></span> &#123;</span><br><span class="line">                fh.style = style</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithFloorMaterial</span><span class="params">(material <span class="type">string</span>)</span></span> Option &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(fh *FinishedHouse)</span></span> &#123;</span><br><span class="line">                fh.floolMaterial = material</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithWallMaterial</span><span class="params">(material <span class="type">string</span>)</span></span> Option &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(fh *FinishedHouse)</span></span> &#123;</span><br><span class="line">                fh.wallMaterial = material</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCentralAirConditioning</span><span class="params">(c <span class="type">bool</span>)</span></span> Option &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(fh *FinishedHouse)</span></span> &#123;</span><br><span class="line">                fh.centralConditioning = c</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, NewFininishedHouse())</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, NewFininishedHouse(</span><br><span class="line">                WithStyle(<span class="number">1</span>),</span><br><span class="line">                WithFloorMaterial(<span class="string">&quot;ground-title&quot;</span>),</span><br><span class="line">                WithCentralAirConditioning(<span class="literal">false</span>),</span><br><span class="line">        ))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用功能选项模式的好处是：</p>
<ul>
<li>更漂亮的、不随时间变化的 API</li>
<li>参数可读性更好</li>
<li>配置选项高度可扩展</li>
<li>提供使用默认选型的最佳方式</li>
<li>使用更安全（不像版本 2 那样在创建函数被调用后，调用者仍然可以修改 Options）</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/Go/" rel="tag"># Go</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2024/10/02/improve-go-05/" rel="prev" title="《Go 语言精进之路》读书笔记（05）：接口">
      <i class="fa fa-chevron-left"></i> 《Go 语言精进之路》读书笔记（05）：接口
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2024/09/30/improve-go-03/" rel="next" title="《Go 语言精进之路》读书笔记（03）：声明、类型、语句与控制结构">
      《Go 语言精进之路》读书笔记（03）：声明、类型、语句与控制结构 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8-init-%E5%87%BD%E6%95%B0%E4%B8%AD%E6%A3%80%E6%9F%A5%E5%8C%85%E7%BA%A7%E5%88%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81"><span class="nav-number">1.</span> <span class="nav-text">在 init 函数中检查包级别变量的初始状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A4%E8%AF%86-init-%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.</span> <span class="nav-text">认识 init 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.2.</span> <span class="nav-text">程序初始化顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-init-%E5%87%BD%E6%95%B0%E6%A3%80%E6%9F%A5%E5%8C%85%E7%BA%A7%E5%88%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81"><span class="nav-number">1.3.</span> <span class="nav-text">使用 init 函数检查包级别变量的初始状态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AF%E4%BA%8E%E5%87%BD%E6%95%B0%E6%98%AF%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91"><span class="nav-number">2.</span> <span class="nav-text">让自己习惯于函数是一等公民</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91"><span class="nav-number">2.1.</span> <span class="nav-text">什么是一等公民</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA-%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91-%E7%9A%84%E7%89%B9%E6%AE%8A%E4%BD%9C%E7%94%A8"><span class="nav-number">2.2.</span> <span class="nav-text">函数作为 一等公民 的特殊作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-defer-%E8%AE%A9%E5%87%BD%E6%95%B0%E6%9B%B4%E7%AE%80%E6%B4%81%E3%80%81%E6%9B%B4%E5%81%A5%E5%A3%AE"><span class="nav-number">3.</span> <span class="nav-text">使用 defer 让函数更简洁、更健壮</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#defer-%E7%9A%84%E8%BF%90%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="nav-number">3.1.</span> <span class="nav-text">defer 的运作机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defer-%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">defer 的常见用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-defer-%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98"><span class="nav-number">3.3.</span> <span class="nav-text">关于 defer 的几个关键问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E6%96%B9%E6%B3%95%E7%9A%84%E6%9C%AC%E8%B4%A8%E4%BB%A5%E9%80%89%E6%8B%A9%E6%AD%A3%E7%A1%AE%E7%9A%84-receiver-%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.</span> <span class="nav-text">理解方法的本质以选择正确的 receiver 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">4.1.</span> <span class="nav-text">方法的本质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%AD%A3%E7%A1%AE%E7%9A%84-receiver-%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.2.</span> <span class="nav-text">选择正确的 receiver 类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E9%9B%86%E5%90%88%E5%86%B3%E5%AE%9A%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.</span> <span class="nav-text">方法集合决定接口实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E9%9B%86%E5%90%88"><span class="nav-number">5.1.</span> <span class="nav-text">方法集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%B5%8C%E5%85%A5%E4%B8%8E%E6%96%B9%E6%B3%95%E9%9B%86%E5%90%88"><span class="nav-number">5.2.</span> <span class="nav-text">类型嵌入与方法集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defined-%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95%E9%9B%86%E5%90%88"><span class="nav-number">5.3.</span> <span class="nav-text">defined 类型的方法集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E7%9A%84%E6%96%B9%E6%B3%95%E9%9B%86%E5%90%88"><span class="nav-number">5.4.</span> <span class="nav-text">类型别名的方法集合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E7%9A%84%E5%A6%99%E7%94%A8"><span class="nav-number">6.</span> <span class="nav-text">了解变长参数函数的妙用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0"><span class="nav-number">6.1.</span> <span class="nav-text">什么是变长参数函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="nav-number">6.2.</span> <span class="nav-text">模拟函数重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0%E4%B8%8E%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="nav-number">6.3.</span> <span class="nav-text">模拟实现函数的可选参数与默认参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD%E9%80%89%E9%A1%B9%E6%A8%A1%E5%BC%8F"><span class="nav-number">7.</span> <span class="nav-text">实现功能选项模式</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">155</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
