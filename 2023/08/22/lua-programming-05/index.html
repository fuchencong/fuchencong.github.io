<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="这篇文章将介绍 Lua 中的闭包，闭包特性使得我们可以在 Lua 中实现函数式编程。之后还将介绍 Lua 自己提供的模式匹配方法，这些模式匹配方法不同于一般的 Perl 正则表达式。">
<meta property="og:type" content="article">
<meta property="og:title" content="《lua 程序设计》读书笔记（5）：闭包 &amp; 模式匹配">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2023/08/22/lua-programming-05/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="这篇文章将介绍 Lua 中的闭包，闭包特性使得我们可以在 Lua 中实现函数式编程。之后还将介绍 Lua 自己提供的模式匹配方法，这些模式匹配方法不同于一般的 Perl 正则表达式。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-08-22T13:21:16.000Z">
<meta property="article:modified_time" content="2023-08-23T14:21:02.460Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="Lua">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2023/08/22/lua-programming-05/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>《lua 程序设计》读书笔记（5）：闭包 & 模式匹配 | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2023/08/22/lua-programming-05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《lua 程序设计》读书笔记（5）：闭包 & 模式匹配
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-22 21:21:16" itemprop="dateCreated datePublished" datetime="2023-08-22T21:21:16+08:00">2023-08-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/Lua/" itemprop="url" rel="index"><span itemprop="name">Lua</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这篇文章将介绍 Lua 中的闭包，闭包特性使得我们可以在 Lua 中实现函数式编程。之后还将介绍 Lua 自己提供的模式匹配方法，这些模式匹配方法不同于一般的 Perl 正则表达式。</p>
<span id="more"></span>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>Lua 中，函数是严格遵循词法定界的第一类值：</p>
<ul>
<li>第一类值意味着 Lua 中函数与其他类型（如数值、字符串）的值具有同等权限，可以将函数保存到变量中或表中、将函数作为参数传递给其他函数，或者作为函数返回值等</li>
<li>词法定界意味着 Lua 中的函数可以访问包含其自身的外部函数中的变量</li>
</ul>
<p>这个特性允许我们在 Lua 中使用很多函数式语言的强大编程特性。</p>
<h3 id="函数是第一类值"><a href="#函数是第一类值" class="headerlink" title="函数是第一类值"></a>函数是第一类值</h3><p>由于 Lua 中函数是第一类值，如下用法都是正确的：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; a = &#123;p = <span class="built_in">print</span>&#125;</span><br><span class="line">&gt; a.p(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">hello</span><br><span class="line">&gt; <span class="built_in">print</span> = <span class="built_in">math</span>.<span class="built_in">sin</span></span><br><span class="line">&gt; a.p(<span class="built_in">print</span>(<span class="number">1</span>))</span><br><span class="line"><span class="number">0.8414709848079</span></span><br><span class="line">&gt; <span class="built_in">math</span>.<span class="built_in">sin</span> = a.p</span><br><span class="line">&gt; <span class="built_in">math</span>.<span class="built_in">sin</span>(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="number">10</span>      <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>事实上，Lua 中常见的函数定义其实就是个语法糖：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(x)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*x</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>等效于</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="function"><span class="keyword">function</span><span class="params">(x)</span></span> <span class="keyword">return</span> <span class="number">2</span>*x <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>赋值语句右侧的 <code>function(x) body end</code> 就是函数构造器。函数定义其实就是创建类型为 function 的值并将它赋值给一个变量的语句。</p>
<p><strong>在 Lua 中，所有函数都是匿名的</strong>。像其他所有值一样，函数并没有名字。传统意义上的函数名（例如 print），实际上指的是保存该函数的变量。虽然我们通常将函数赋值给全局变量，从而似乎给函数起了一个名字，但是很多场景下仍然会保留函数的匿名性。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> network = &#123;</span><br><span class="line">    &#123;name = <span class="string">&quot;grauna&quot;</span>, IP = <span class="string">&quot;1.1.1.1&quot;</span>&#125;,</span><br><span class="line">    &#123;name = <span class="string">&quot;arraial&quot;</span>, IP = <span class="string">&quot;1.1.1.2&quot;</span>&#125;,</span><br><span class="line">    &#123;name = <span class="string">&quot;lua&quot;</span>, IP = <span class="string">&quot;1.1.1.3&quot;</span>&#125;,</span><br><span class="line">    &#123;name = <span class="string">&quot;derain&quot;</span>, IP = <span class="string">&quot;1.1.1.4&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">sort</span>(network, <span class="function"><span class="keyword">function</span><span class="params">(a, b)</span></span> <span class="keyword">return</span> a.name &gt; b.name <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>

<p>像 sort 这种以另一个函数作为参数的函数，称之为高阶函数。</p>
<h3 id="非全局函数"><a href="#非全局函数" class="headerlink" title="非全局函数"></a>非全局函数</h3><p>由于函数是第一类值，因此函数不仅可以被存储在全局变量中，还可以被存储在表字段和局部变量中。**大部分 Lua 库就是采用这种机制：<code>将函数存储在表字段中</code>**。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; lib = &#123;&#125;</span><br><span class="line">&gt; lib.foo = <span class="function"><span class="keyword">function</span><span class="params">(x, y)</span></span> <span class="keyword">return</span> x + y <span class="keyword">end</span></span><br><span class="line">&gt; lib.goo = <span class="function"><span class="keyword">function</span><span class="params">(x, y)</span></span> <span class="keyword">return</span> x - y <span class="keyword">end</span></span><br><span class="line">&gt; <span class="built_in">print</span>(lib.foo(<span class="number">2</span>, <span class="number">3</span>), lib.goo(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="number">5</span>       <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>或者采用表构造器的方式：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; lib = &#123;</span><br><span class="line">&gt;&gt; foo = <span class="function"><span class="keyword">function</span><span class="params">(x, y)</span></span> <span class="keyword">return</span> x + y <span class="keyword">end</span>,</span><br><span class="line">&gt;&gt; goo = <span class="function"><span class="keyword">function</span><span class="params">(x, y)</span></span> <span class="keyword">return</span> x - y <span class="keyword">end</span></span><br><span class="line">&gt;&gt; &#125;</span><br><span class="line">&gt; <span class="built_in">print</span>(lib.foo(<span class="number">2</span>, <span class="number">3</span>), lib.goo(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="number">5</span>       <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>Lua 还提供了另一种特殊的语法来定义这类函数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; lib = &#123;&#125;</span><br><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">lib.foo</span><span class="params">(x, y)</span></span> <span class="keyword">return</span> x + y <span class="keyword">end</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">lib.goo</span><span class="params">(x, y)</span></span> <span class="keyword">return</span> x - y <span class="keyword">end</span></span><br><span class="line">&gt; <span class="built_in">print</span>(lib.foo(<span class="number">2</span>, <span class="number">3</span>), lib.goo(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="number">5</span>       <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><strong>在表字段中存储函数是在 Lua 中实现面向对象编程的关键要素</strong>。</p>
<p>当把一个函数存储到局部变量，就得到了一个局部函数，即一个被限定在指定作用域中使用的函数。局部函数对于包（package）尤其有用：<strong>Lua 将每个程序段作为一个函数处理</strong>，所以在一段程序中声明的函数就是局部函数，这些局部函数只在该程序段中可见。词法定界保证了程序段中其他函数可以使用这些局部函数。</p>
<p>对于局部函数的使用，Lua 提供了一种语法糖：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(params)</span></span></span><br><span class="line">    body</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>在定义局部递归函数时，由于原来的方法不适用，所以有一点是极易出错的。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> fact = <span class="function"><span class="keyword">function</span><span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> n*fact(n<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>由于 Lua 编译函数体中的 fact(n-1) 调用时，局部的 fact 尚未定义，因此这个表达式会尝试调用全局的 fact 而非局部的 fact。可以通过先定义局部变量再定义函数的方式来解决这个问题。这样函数内的 fact 指向的是局部变量，尽管在定义函数时，这个局部变量的值尚未确定。但是执行函数时，fact 有了正确赋值。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> fact</span><br><span class="line">fact = <span class="function"><span class="keyword">function</span><span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> n*fact(n<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>局部函数语法糖 <code>local function foo(params) body end</code> 的定义会被展开成 <code>local foo; foo = function(params) body end</code>。所以使用这种语法来定义递归函数不会有问题。</p>
<p>这个技巧对于间接递归函数是无效的，在间接递归的情形下，必须使用与明确的前向声明等价的形式：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> f</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> funciton g()</span><br><span class="line">    some code f() some code</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line">    some code g() some code</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>注意，不能在最后一个函数定义前加上 local，否则 Lua 会创建一个全新的局部变量 f，从而使得先前声明的 f（函数 g 中使用的那个）会变成未定义状态。</p>
<h3 id="词法定界"><a href="#词法定界" class="headerlink" title="词法定界"></a>词法定界</h3><p>当编写一个被其他函数 B 包含的函数 A 时，被包含的函数 A 可以访问包含其的函数 B 的所有局部变量，这种特性称为词法定界。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortbygrade</span><span class="params">(names, grades)</span></span></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">sort</span>(names, <span class="function"><span class="keyword">function</span><span class="params">(n1, n2)</span></span> <span class="keyword">return</span> grades[n1] &gt; grades[n2] <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这里匿名函数可以访问函数 sortbygrade 的形参 grades。在匿名函数中，grades 既不是全局变量也不是局部变量，而是 <code>非局部变量</code>。</p>
<p>如下代码展示了闭包的概念，简单来说，<strong>一个闭包就是一个函数外加能够使该函数正确访问非局部变量所需的其他机制</strong>。如下代码中 c1 和 c2 都是不同的闭包，它们建立在相同的函数之上，但是各自拥有局部变量 count 的独立实例。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newCounter</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        count = count + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c1 = newCounter()</span><br><span class="line"><span class="built_in">print</span>(c1())</span><br><span class="line"><span class="built_in">print</span>(c1())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c2 = newCounter()</span><br><span class="line"><span class="built_in">print</span>(c2())</span><br><span class="line"><span class="built_in">print</span>(c2())</span><br></pre></td></tr></table></figure>

<p>闭包机制使得 Lua 程序能够综合运用函数式编程世界中许多精妙的编程技巧。由于函数可以被保存在局部变量中，因此在 Lua 中可以轻松重新定义函数，甚至预定义函数。这种机制也是 Lua 灵活的原因之一。如下代码使用 do 代码段来限制局部变量 oldSin 的作用范围，局部变量 oldSin 只在这部分代码段中有效，因此只有新版本的 sin 才能访问原来的 sin 函数，其他部分的代码则访问不了。可以使用同样的技巧来创建安全的运行时环境，即所谓的沙盒，借助这种机制可以根据特定的安全需求来裁剪具体的运行时环境。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">local</span> oldSin = <span class="built_in">math</span>.<span class="built_in">sin</span></span><br><span class="line">    <span class="keyword">local</span> k = <span class="built_in">math</span>.<span class="built_in">pi</span> / <span class="number">180</span></span><br><span class="line">    <span class="built_in">math</span>.<span class="built_in">sin</span> = <span class="function"><span class="keyword">function</span><span class="params">(x)</span></span> <span class="keyword">return</span> oldSin(x * k) <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="函数式编程示例"><a href="#函数式编程示例" class="headerlink" title="函数式编程示例"></a>函数式编程示例</h3><p>利用高阶函数和词法定界，如下定义了一个根据指定的圆心和半径创建圆盘的工厂：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">disk</span><span class="params">(cx, cy, r)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(x, y)</span></span></span><br><span class="line">        <span class="keyword">return</span> (x - cx)^<span class="number">2</span> + (y - cy)^<span class="number">2</span> &lt;= r^<span class="number">2</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>下面则创建了一个指定边界的轴对称矩形：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rect</span><span class="params">(left, right, bottom, up)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(x, y)</span></span></span><br><span class="line">        <span class="keyword">return</span> left &lt;= x <span class="keyword">and</span> x &lt;= right <span class="keyword">and</span> bottom &lt;= y <span class="keyword">and</span> y &lt;= up</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>按照该方式，每一种图形都具有完全独立的实现，所需要的仅仅是一个正确的特征函数。接下来继续考虑如何改变和组合区域：</p>
<ul>
<li>创建任何区域的补集</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">complement</span><span class="params">(r)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(x, y)</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> r(x, y)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>区域的并、交、差集</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">union</span><span class="params">(r1, r2)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(x, y)</span></span></span><br><span class="line">        <span class="keyword">return</span> r1(x, y) <span class="keyword">or</span> r2(x, y)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">intersection</span><span class="params">(r1, r2)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(x, y)</span></span></span><br><span class="line">        <span class="keyword">return</span> r1(x, y) <span class="keyword">and</span> r2(x, y)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">difference</span><span class="params">(r1, r2)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(x, y)</span></span></span><br><span class="line">        <span class="keyword">return</span> r1(x, y) <span class="keyword">and</span> <span class="keyword">not</span> r2(x, y)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>Lua 既没有使用 POSIX 正则表达式，也没有使用 Perl 正则表达式来进行模式匹配。之所以这么做的主要原因仍然是代码量大小的问题。尽管 Lua 的模式匹配做不到完整 POSIX 实现所需的功能，但是 Lua 语言的模式匹配仍然非常强大。</p>
<h3 id="模式匹配相关的函数"><a href="#模式匹配相关的函数" class="headerlink" title="模式匹配相关的函数"></a>模式匹配相关的函数</h3><p><code>string.find</code> 用于在指定的目标字符串中搜索指定的模式，如果查找成功，会返回两个值：匹配到模式开始位置的索引和结束位置的索引。如果没有找到匹配，则返回 nil。该函数还有两个可选参数：第 3 个参数是一个索引，用于指明从目标字符串的哪个位置开始搜索，第 4 个参数是一个布尔值，用于说明是否进行简单搜索。简单搜索是指忽略模式的含义而在目标字符串中进行单纯的 <code>查找子字符串</code> 的动作。</p>
<p><code>string.match</code> 也用于在一个字符串中搜索模式，但是返回的是目标字符串中与模式相匹配的那部分子串，而非模式所在的位置。</p>
<p><code>string.gsub</code> 有 3 个必选参数：目标字符串、模式和替换字符串。其基本用法是将目标字符串中所有出现的模式的地方均换成替换字符串。其还有一个可选的第 4 个参数，用于限制替换的次数。除了替换字符串之外，第 3 个参数也可以是一个函数或者表，这个函数或表会被调用（检索）以产生替换字符串。该函数还会返回第 2 个结果，即发生替换的次数。</p>
<p><code>string.gmatch</code> 返回一个函数，通过返回的函数可以遍历一个字符串中所有出现的指定模式。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; s = <span class="string">&#x27;some thing&#x27;</span></span><br><span class="line">&gt; words = &#123;&#125;</span><br><span class="line">&gt; <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(s, <span class="string">&quot;%a+&quot;</span>) <span class="keyword">do</span></span><br><span class="line">&gt;&gt;  words[#words + <span class="number">1</span>] = w</span><br><span class="line">&gt;&gt; <span class="keyword">end</span></span><br><span class="line">&gt; #words</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>对 Lua 解释器而言，模式仅仅是普通的字符串，模式与其他字符串一样遵循相同的规则，不会被特殊对待。只有模式匹配相关的函数才会把它们当做模式进行解析。<strong>Lua 中的模式使用 % 作为转义符，总体上被转义的字母都具有某些特殊含义，而所有被转义的非字母则代表其自身含义</strong>。下面列出了所有预置的字符分类及其对应的含义，所谓字符分类，就是模式中能够与一个特定集合中的任意字符相匹配的一项：</p>
<ul>
<li><code>.</code>：任意字符</li>
<li><code>%a</code>：字母</li>
<li><code>%c</code>：控制字符</li>
<li><code>%d</code>：数字</li>
<li><code>%g</code>：除空格外的可打印字符</li>
<li><code>%l</code>：小写字母</li>
<li><code>%p</code>：标点符号</li>
<li><code>%s</code>：空白字符</li>
<li><code>%u</code>：大写字母</li>
<li><code>%w</code>：字母和数字</li>
<li><code>%x</code>：十六进制数字</li>
</ul>
<p>这些类的大写形式表示类的补集。在模式使用中，还有一些被称为魔法字符的字符具有特殊含义，包括 <code>().%+-*?[]^$</code>，<code>%</code> 同样可以对魔法字符进行转义。<code>%</code> 不仅可以对魔法字符进行转义，还可以用于其他所有字母和数字之外的字符，当不确定是否需要转义时，保险起见总是可以使用转义符。</p>
<p>可以使用字符集来创建自定义的字符分类，只需要在方括号内将单个字符和字符分类组合起来即可。还可以在字符集中包含一段字符的范围，即写出字符范围的第一个字符和最后一个字符，并使用 <code>-</code> 将它们连接起来。在字符集前加上一个补字符 <code>^</code> 就可以得到该字符集对应的补集。</p>
<p>可以通过描述模式中重复和可选部分的修饰符来让模式更加有用。Lua 提供了 4 种修饰符。Lua 中的修饰符只能作用于一个字符模式，而无法作用于一组分类。</p>
<ul>
<li><code>+</code>：重复一次或多次</li>
<li><code>*</code>：重复零次或多次</li>
<li><code>-</code>：重复零次或多次（最小匹配）</li>
<li><code>?</code>：可选（出现零次或一次）</li>
</ul>
<p>以 <code>^</code> 开头的模式表示从目标字符串的开头开始匹配，以 <code>$</code> 结尾的模式表示匹配到目标字符串的结尾。这两个字符只有位于模式的开头和结尾才具有特殊含义，否则仅仅就是与其自身相匹配的普通字符。</p>
<p><code>%b</code> 用于匹配成对的字符，<code>%bxy</code> 匹配以 <code>x</code> 开始、以 <code>y</code> 结束的子串。<code>%f[char-set]</code> 表示前置模式，该模式匹配一个空字符，其该空字符的后一个字符位于 char-set 内而前一个字符不在 char-set。注意目标字符串中的第一个字符之前被认为拥有一个空字符，最后一个字符之后也被认为拥有一个空字符。所以如下模式会匹配两次 <code>the</code>，包括开头的 <code>the</code>：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">gsub</span>(s, <span class="string">&#x27;%f[%w]the%f[%W]&#x27;</span>, <span class="string">&#x27;one&#x27;</span>))</span><br><span class="line">one anthem is one theme <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h3><p>捕获机制允许根据一个模式从目标字符串中抽出与该模式匹配的内容用于后续用途。可以通过把模式中需要捕获的部分放到一对圆括号内来指定捕获。</p>
<p>对于具有捕获的模式，<code>string.match</code> 会将所有捕获到的值作为单独的结果返回：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; p = <span class="string">&quot;name = Anna&quot;</span></span><br><span class="line">&gt; k, v = <span class="built_in">string</span>.<span class="built_in">match</span>(p, <span class="string">&quot;(%a+)%s*=%s*(%a+)&quot;</span>)</span><br><span class="line">&gt; <span class="built_in">print</span>(k, v)</span><br><span class="line">name    Anna</span><br></pre></td></tr></table></figure>

<p>在模式中，形如 <code>%n</code> 的分类（n 是一个数字）表示匹配第 n 个捕获的副本：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; s = <span class="string">[[then he said: &quot;it&#x27;s all right&quot;!]]</span></span><br><span class="line">&gt; q, quotedPart = <span class="built_in">string</span>.<span class="built_in">match</span>(s, <span class="string">&quot;([\&quot;&#x27;])(.-)%1&quot;</span>)</span><br><span class="line">&gt; q</span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">&gt; quotedPart</span></span><br><span class="line"><span class="string">it&#x27;s all right</span></span><br></pre></td></tr></table></figure>

<p>如下是一个类似的示例，用于匹配 Lua 中的长字符串模式：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; p = <span class="string">&quot;%[(=*)%[(.-)%]%1%]&quot;</span></span><br><span class="line">&gt; s = <span class="string">&quot;a = [=[[[something ]] ]==] ]=]&quot;</span></span><br><span class="line">&gt; <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">match</span>(s, p))</span><br><span class="line">=       <span class="string">[[something ]]</span> ]==]</span><br></pre></td></tr></table></figure>

<p>被捕获对象的第 3 个用途是在函数 gsub 的替代字符串中。和模式一样，替换字符串同样可以包含像 <code>%n</code>，当发生替换时会被替换为相应的捕获，<code>%0</code> 意味着整个匹配。</p>
<h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p>上文讲过，<code>string.gsub</code> 的第 3 个参数不仅可以是字符串，还可以是一个函数或者表：</p>
<ul>
<li>当参数为函数时，<code>string.gsub</code> 会在每次查找到匹配时都调用该函数，参数是捕获到的内容而返回值则被作为替换字符串</li>
<li>当参数为表时，<code>string.gsub</code> 会把第一个捕获到的内容作为 key，然后将表中对应的该 key 的值作为替换字符串</li>
</ul>
<p>如果函数返回 nil 或者表中不包含该键，那么 gsub 不改变匹配。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">expand</span><span class="params">(s)</span></span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">string</span>.<span class="built_in">gsub</span>(s, <span class="string">&quot;$(%w+)&quot;</span>, <span class="built_in">_G</span>))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">name = <span class="string">&quot;Lua&quot;</span></span><br><span class="line"><span class="built_in">status</span> = <span class="string">&quot;great&quot;</span></span><br><span class="line"><span class="built_in">print</span>(expand(<span class="string">&quot;$name is $status, isn&#x27;t it&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>在这段代码中使用到了 <code>_G</code> 这个表，它是预先定义的包括所有全局变量的表。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toxml</span><span class="params">(s)</span></span></span><br><span class="line">    s = <span class="built_in">string</span>.<span class="built_in">gsub</span>(s, <span class="string">&quot;\\(%a+)(%b&#123;&#125;)&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">(tag, body)</span></span></span><br><span class="line">        body = <span class="built_in">string</span>.<span class="built_in">sub</span>(body, <span class="number">2</span>, <span class="number">-2</span>)</span><br><span class="line">        body = toxml(body)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;&lt;%s&gt;%s&lt;/%s&gt;&quot;</span>, tag, body, tag)</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(toxml(<span class="string">&quot;\\title&#123;The \\bold&#123;big&#125; example&#125;&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>在 Lua 中，<code>()</code> 空白捕获具有特殊的含义，该模式并不代表捕获空内容，而是捕获模式在目标字符串中的位置（该位置是数值）：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">match</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;()ll()&quot;</span>))</span><br><span class="line"><span class="number">3</span>       <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="诀窍"><a href="#诀窍" class="headerlink" title="诀窍"></a>诀窍</h3><ul>
<li>模式匹配是进行字符串处理的强大工具之一。但是模式匹配代替不了传统的解析器，对于那些用后即弃的程序来说，确实可以在源代码中做一些有用的操作，但是却很难构建出高质量的产品</li>
<li>尽管 Lua 中使用模式匹配时的效率是足够高的，但是仍然需要注意，应该永远使用尽可能精确的模式</li>
<li>要留心空模式，即匹配空字符串的模式，例如使用 <code>%a*</code> 来匹配名字，会发现到处是名字</li>
<li>有时使用 Lua 来构造一个模式也很有用，例如 <code>string.rep(&quot;[^\n]&quot;, 70) .. &quot;+&quot;</code> 可以构造出一个模式，用来匹配超过 70 个字符的行</li>
<li>模式匹配另一个有用的技巧是：在进行实际工作前先对目标字符串进行预先处理。</li>
<li>是否能够将模式匹配函数用于 UTF-8 字符串取决于模式本身，恰当的模式能够为 Unicode 带来额外的能力。例如预定义模式 <code>uft8.charpattern</code> 可以用来精确匹配一个 UTF-8 字符</li>
</ul>
<h3 id="一个示例程序"><a href="#一个示例程序" class="headerlink" title="一个示例程序"></a>一个示例程序</h3><p>如下代码用于统计出现频率最高的单词：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> counter = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">io</span>.<span class="built_in">lines</span>() <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(line, <span class="string">&quot;%w+&quot;</span>) <span class="keyword">do</span></span><br><span class="line">        counter[word] = (counter[word] <span class="keyword">or</span> <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> words = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">pairs</span>(counter) <span class="keyword">do</span></span><br><span class="line">    words[#words + <span class="number">1</span>] = w</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">sort</span>(words, <span class="function"><span class="keyword">function</span><span class="params">(w1, w2)</span></span></span><br><span class="line">    <span class="keyword">return</span> (counter[w1] &gt; counter[w2]) <span class="keyword">or</span></span><br><span class="line">           (counter[w1] == counter[w2] <span class="keyword">and</span> w1 &lt; w2)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> n = <span class="built_in">math</span>.<span class="built_in">min</span>(<span class="built_in">tonumber</span>(<span class="built_in">arg</span>[<span class="number">1</span>]) <span class="keyword">or</span> <span class="built_in">math</span>.<span class="built_in">huge</span>, #words)</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, n <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(words[i], <span class="string">&quot;\t&quot;</span>, counter[words[i]], <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/Lua/" rel="tag"># Lua</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2023/08/22/lua-programming-06/" rel="prev" title="《lua 程序设计》读书笔记（6）：日期时间 & 位和字节">
      <i class="fa fa-chevron-left"></i> 《lua 程序设计》读书笔记（6）：日期时间 & 位和字节
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2023/08/22/lua-programming-04/" rel="next" title="《lua 程序设计》读书笔记（4）：输入输出 & 补充知识">
      《lua 程序设计》读书笔记（4）：输入输出 & 补充知识 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AD%E5%8C%85"><span class="nav-number">1.</span> <span class="nav-text">闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%98%AF%E7%AC%AC%E4%B8%80%E7%B1%BB%E5%80%BC"><span class="nav-number">1.1.</span> <span class="nav-text">函数是第一类值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.</span> <span class="nav-text">非全局函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%8D%E6%B3%95%E5%AE%9A%E7%95%8C"><span class="nav-number">1.3.</span> <span class="nav-text">词法定界</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.4.</span> <span class="nav-text">函数式编程示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">2.</span> <span class="nav-text">模式匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">2.1.</span> <span class="nav-text">模式匹配相关的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.2.</span> <span class="nav-text">模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7"><span class="nav-number">2.3.</span> <span class="nav-text">捕获</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2"><span class="nav-number">2.4.</span> <span class="nav-text">替换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%80%E7%AA%8D"><span class="nav-number">2.5.</span> <span class="nav-text">诀窍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.6.</span> <span class="nav-text">一个示例程序</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">159</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
