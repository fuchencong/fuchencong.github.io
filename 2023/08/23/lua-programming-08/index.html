<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="虽然 Lua 被称为解释型语言，但是 Lua 总是在运行代码前先预先编译源码为中间代码。解释型语言的区分并不在于源码是否编译，而在于是否有能力执行动态生成的代码。正是由于dofile 这样的函数存在，才使得 Lua 能够被称为解释型语言。 这篇文章将介绍 Lua 的编译执行原理以及 Lua 的模块&#x2F;包管理机制。">
<meta property="og:type" content="article">
<meta property="og:title" content="《lua 程序设计》读书笔记（8）：编译、执行和错误 &amp; 模块和包">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2023/08/23/lua-programming-08/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="虽然 Lua 被称为解释型语言，但是 Lua 总是在运行代码前先预先编译源码为中间代码。解释型语言的区分并不在于源码是否编译，而在于是否有能力执行动态生成的代码。正是由于dofile 这样的函数存在，才使得 Lua 能够被称为解释型语言。 这篇文章将介绍 Lua 的编译执行原理以及 Lua 的模块&#x2F;包管理机制。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-08-23T13:43:24.000Z">
<meta property="article:modified_time" content="2023-08-24T02:21:58.605Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="Lua">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2023/08/23/lua-programming-08/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>《lua 程序设计》读书笔记（8）：编译、执行和错误 & 模块和包 | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2023/08/23/lua-programming-08/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《lua 程序设计》读书笔记（8）：编译、执行和错误 & 模块和包
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-23 21:43:24" itemprop="dateCreated datePublished" datetime="2023-08-23T21:43:24+08:00">2023-08-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/Lua/" itemprop="url" rel="index"><span itemprop="name">Lua</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>虽然 Lua 被称为解释型语言，但是 Lua 总是在运行代码前先预先编译源码为中间代码。解释型语言的区分并不在于源码是否编译，而在于是否有能力执行动态生成的代码。正是由于dofile 这样的函数存在，才使得 Lua 能够被称为解释型语言。</p>
<p>这篇文章将介绍 Lua 的编译执行原理以及 Lua 的模块&#x2F;包管理机制。</p>
<span id="more"></span>

<h2 id="编译、执行和错误"><a href="#编译、执行和错误" class="headerlink" title="编译、执行和错误"></a>编译、执行和错误</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>函数 <code>dofile</code> 是运行 Lua 代码段的主要方式之一。实际上 <code>dofile</code> 是一个辅助函数，<code>loadfile</code> 才完成了真正的核心工作。<code>loadfile</code> 是从文件中加载 Lua 代码段，但是它不会运行代码，而是编译代码，<strong>然后将编译后的代码段作为一个函数返回</strong>。</p>
<p>与函数 <code>dofile</code> 不同，函数 <code>loadfile</code> 只返回错误码而不抛出异常，可以认为 dofile 就是：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dofile</span><span class="params">(filename)</span></span></span><br><span class="line">    <span class="keyword">local</span> f = <span class="built_in">assert</span>(<span class="built_in">loadfile</span>(filename))</span><br><span class="line">    <span class="keyword">return</span> f()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>当发生错误时，函数 <code>loadfile</code> 会返回 nil 及错误信息，以允许我们按照自定义的方式来处理错误。而且如果需要多次运行同一个文件，只需要调用一次 loadfile 函数后再多次调用它的返回结果即可，此时只会编译一次文件。</p>
<p><code>load</code> 与 <code>loadfile</code> 类似，但是该函数是从一个字符串或函数中读取代码段，而不是从文件中读取。如下代码中，<code>f</code> 就是一个被调用时执行 <code>i = i + 1</code> 的函数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; f = <span class="built_in">load</span>(<span class="string">&quot;i = i + 1&quot;</span>)</span><br><span class="line">&gt; i = <span class="number">0</span></span><br><span class="line">&gt; f()</span><br><span class="line">&gt; i</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt; f()</span><br><span class="line">&gt; i</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>尽管 <code>load</code> 功能强大，但还是应该谨慎使用，该函数开销比较大并且可能会引起诡异问题。所以需要确定当下已经找不到更简单的解决方式后再使用该函数。</p>
<p>需要注意，函数 load 在编译时不涉及词法定界，所以下面的代码并不完全等价：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">32</span></span><br><span class="line"><span class="keyword">local</span> i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">f = <span class="built_in">load</span>(<span class="string">&quot;i = i + 1; print(i)&quot;</span>)</span><br><span class="line">g = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> i = i + <span class="number">1</span>; <span class="built_in">print</span>(i) <span class="keyword">end</span></span><br><span class="line">f()</span><br><span class="line">g()</span><br></pre></td></tr></table></figure>

<p>这里函数 <code>g()</code> 操作的是局部变量，而函数 <code>f()</code> 操作的是全局变量，<strong>这是因为函数 load 总是在全局环境中编译代码段</strong>。而且 <code>g()</code> 会随着其所在的代码文件一起编译，而 <code>f()</code> 则在调用函数 load 时会进行一次独立的编译。</p>
<p>函数 <code>load</code> 最典型的用法是执行外部代码（即那些来自程序本身之外的代码段）或者动态生成的代码。由于函数 <code>load</code> 所返回的函数就是一个普通的函数，因此可以对其反复调用。</p>
<p>也可以将读取函数（reader function）作为函数 load 的第一个参数。读取函数可以分几次返回一段程序，函数 load 会不断地调用读取函数直到读取函数返回 nil。</p>
<p>Lua 将所有独立的代码段当做匿名可变长参数函数的函数体。例如 <code>load(&quot;a = 1&quot;)</code> 的返回值与以下表达式等价。像其他任何函数一样，代码段中可以声明局部变量。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span><span class="params">(...)</span></span> a = <span class="number">1</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>函数 load 和 loadfile 从来不引发错误，当有错误发生时，它们会返回 nil 以及错误信息。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">print</span>(<span class="built_in">load</span>(<span class="string">&quot;i i&quot;</span>))</span><br><span class="line"><span class="literal">nil</span>     [<span class="built_in">string</span> <span class="string">&quot;i i&quot;</span>]:<span class="number">1</span>: syntax <span class="built_in">error</span> near <span class="string">&#x27;i&#x27;</span></span><br></pre></td></tr></table></figure>

<p>而且这些函数没有任何副作用，它们既不改变或创建变量，也不向文件写入等。<strong>这些函数只是将程序段编译为一种中间形式，然后将结果作为匿名函数返回</strong>。需要注意，<strong>在 Lua 中函数定义是在运行时而不是在编译时发生的一种赋值操作</strong>。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--foo.lua</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(x)</span></span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">loadfile</span>(<span class="string">&quot;foo.lua&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(foo)</span><br><span class="line">f()</span><br><span class="line"><span class="built_in">print</span>(foo)</span><br></pre></td></tr></table></figure>

<p>如果将 <code>foo.lua</code> 改写成以下形式，则更加清晰：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="function"><span class="keyword">function</span><span class="params">(x)</span></span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>如果线上产品级别的程序需要执行外部代码，那么应该处理加载程序段时报告的所有错误。而且，还应该在一个受保护的环境中执行这些代码。</p>
<h3 id="预编译的代码"><a href="#预编译的代码" class="headerlink" title="预编译的代码"></a>预编译的代码</h3><p>Lua 会在运行源代码之前先对其进行预编译，Lua 也允许我们以预编译的形式分发代码。生成预编译文件最简单的方式是使用标准发行版中附带的 luac 程序。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--foo.lua</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;test&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>如下生成创建文件 <code>foo.lua</code> 的预编译版本 <code>foo.lc</code>，Lua 解释器会像执行普通 Lua 代码一样执行这个新文件：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># luac -o foo.lc foo.lua</span><br><span class="line"># lua foo.lc</span><br><span class="line">test</span><br></pre></td></tr></table></figure>

<p>几乎在 Lua 中所有能够使用源代码的地方都可以使用预编译的代码，函数 <code>loadfile</code> 和 <code>load</code> 都可以接受预编译的代码。如下在 Lua 中实现一个最简单的 luac：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="built_in">loadfile</span>(<span class="built_in">arg</span>[<span class="number">1</span>])</span><br><span class="line">f = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="built_in">arg</span>[<span class="number">2</span>], <span class="string">&quot;wb&quot;</span>)</span><br><span class="line">f:<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">dump</span>(p))</span><br><span class="line">f:<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure>

<p>这里利用 <code>string.dump()</code>，它的入参是一个 Lua 函数，返回值则是该函数所对应的预编译代码（字符串形式，已经被正确格式化，可由 Lua 直接加载）。</p>
<p>luac 的 <code>-l</code> 选项可以为指定代码段生成操作码（opcode）：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># luac -l foo.lua</span><br><span class="line"></span><br><span class="line">main &lt;foo.lua:<span class="number">0</span>,<span class="number">0</span>&gt; (<span class="number">5</span> instructions at <span class="number">0x55719fabdcc0</span>)</span><br><span class="line"><span class="number">0</span>+ params, <span class="number">2</span> slots, <span class="number">1</span> upvalue, <span class="number">0</span> locals, <span class="number">2</span> constants, <span class="number">0</span> functions</span><br><span class="line">        <span class="number">1</span>       [<span class="number">1</span>]     VARARGPREP      <span class="number">0</span></span><br><span class="line">        <span class="number">2</span>       [<span class="number">1</span>]     GETTABUP        <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>   ; <span class="built_in">_ENV</span> <span class="string">&quot;print&quot;</span></span><br><span class="line">        <span class="number">3</span>       [<span class="number">1</span>]     LOADK           <span class="number">1</span> <span class="number">1</span>     ; <span class="string">&quot;test&quot;</span></span><br><span class="line">        <span class="number">4</span>       [<span class="number">1</span>]     CALL            <span class="number">0</span> <span class="number">2</span> <span class="number">1</span>   ; <span class="number">1</span> <span class="keyword">in</span> <span class="number">0</span> out</span><br><span class="line">        <span class="number">5</span>       [<span class="number">1</span>]     RETURN          <span class="number">0</span> <span class="number">1</span> <span class="number">1</span>   ; <span class="number">0</span> out</span><br></pre></td></tr></table></figure>

<p>预编译形式的代码不一定比源代码更小，但是却加载更快。预编译形式的代码另一个好处是，可以避免由于意外而修改源码。但是应该避免运行以预编译形式给出的非受信任代码。<code>load()</code> 函数第三个参数允许我们控制加载的代码段的类型：</p>
<ul>
<li><code>t</code> 允许加载文本类型的代码</li>
<li><code>b</code> 允许加载二进制（预编译）类型的代码段</li>
<li><code>bt</code> 允许同时加载上述两种类型的代码段</li>
</ul>
<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>由于 Lua 是一种经常被嵌入在应用程序中的扩展语言，所以当错误发生时并不能简单地崩溃或退出。</p>
<p>在 Lua 中可以显式通过调用函数 <code>error</code> 并传入一个错误信息来引发一个错误。由于针对某些情况调用函数 <code>error</code> 这样的代码结构太常见了，所以 Lua 提供了一个内建的 <code>assert</code> 来完成这类工作。<code>assert</code> 检查其第一个参数是否为真，如果该参数为真则返回该参数；否则引发一个错误，该函数的第二个参数是一个可选的错误信息。</p>
<p>当一个函数发现某种意外的情况发生时，在进行异常处理时可以采用两种基本方式：</p>
<ul>
<li>返回错误代码（通常是nil 或者 false）</li>
<li>通过调用 <code>error</code> 引发一个错误</li>
</ul>
<p>如何在这两种方式之间进行选择没有固定的规则，一条参考原则是：容易避免的异常应该引发错误，否则应该返回错误码。</p>
<h3 id="错误处理和异常"><a href="#错误处理和异常" class="headerlink" title="错误处理和异常"></a>错误处理和异常</h3><p>通常应用代码本身会负责处理错误，但是如果我们想在这些应用代码的外层处理错误，那么就应该使用函数 <code>pcall（protected call）</code> 来封装代码。假设要执行一段 Lua 代码并捕获执行中发生的所有错误，那么首先需要将这段代码封装到一个函数中，这个函数通常是一个匿名函数。之后通过 <code>pcall</code> 来调用这个函数。</p>
<p><code>pcall</code> 会以保护模式来调用它的第一个参数，以便捕获该函数执行中的错误。无论是否有错误发生，函数 <code>pcall</code> 都不会引发错误：</p>
<ul>
<li>如果没有错误发生：pcall 返回 true 以及被调用函数的所有返回值</li>
<li>否则返回 false 以及错误信息</li>
</ul>
<p>pcall 能够返回传递给 error 的任意 Lua 类型的值。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">status</span>, err = <span class="built_in">pcall</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="built_in">error</span>(&#123;code=<span class="number">121</span>&#125;) <span class="keyword">end</span>)</span><br><span class="line">&gt; err</span><br><span class="line"><span class="built_in">table</span>: <span class="number">0x55a1337505c0</span></span><br><span class="line">&gt; err.code</span><br><span class="line"><span class="number">121</span></span><br><span class="line">&gt; <span class="built_in">status</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>总结一下在 Lua 中进行异常处理：</p>
<ul>
<li>可以通过 <code>error</code> 来抛出异常</li>
<li>可以通过 <code>pcall</code> 来捕获异常，而错误信息则用来标识错误的类型</li>
</ul>
<h3 id="错误信息和栈回溯"><a href="#错误信息和栈回溯" class="headerlink" title="错误信息和栈回溯"></a>错误信息和栈回溯</h3><p>虽然能够使用任何类型的值作为错误对象，但是错误对象通常是一个描述出错内容的字符串。当遇到内部错误时，Lua 会负责产生错误对象（此时错误对象永远都是字符串，而其他情况下则是传递给函数 error 的值）。如果错误对象是一个字符串，那么 Lua 还会尝试把一些有关错误发生位置的信息附上。</p>
<p>函数 error 还有第 2 个可选参数 level，用于指出向函数调用层次中的哪层函数报告错误，以说明谁应该为错误负责。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(str)</span></span></span><br><span class="line">&gt;&gt; <span class="keyword">if</span> <span class="built_in">type</span>(str) ~= <span class="string">&quot;string&quot;</span> <span class="keyword">then</span></span><br><span class="line">&gt;&gt; <span class="built_in">error</span>(<span class="string">&quot;string expected&quot;</span>, <span class="number">2</span>)</span><br><span class="line">&gt;&gt; <span class="keyword">end</span></span><br><span class="line">&gt;&gt; <span class="keyword">end</span></span><br><span class="line">&gt; foo(&#123;x=<span class="number">1</span>&#125;)</span><br><span class="line"><span class="built_in">string</span> expected</span><br><span class="line">stack <span class="built_in">traceback</span>:</span><br><span class="line">        [C]: <span class="keyword">in</span> <span class="function"><span class="keyword">function</span> &#x27;<span class="title">error</span>&#x27;</span></span><br><span class="line"><span class="function">        <span class="title">stdin</span>:3: <span class="title">in</span> <span class="title">function</span> &#x27;<span class="title">foo</span>&#x27;</span></span><br><span class="line"><span class="function">        <span class="params">(...tail calls...)</span></span></span><br><span class="line">        [C]: <span class="keyword">in</span> ?</span><br></pre></td></tr></table></figure>

<p>为了在错误发生时能够得到完整函数调用栈的栈回溯，Lua 提供了函数 <code>xpcall</code>，该函数与 <code>pcall</code> 类似，但是它的第 2 个参数是消息处理函数，当发生错误时，Lua 会在栈展开之前调用这个消息处理函数。这样消息处理函数能够使用调试库来获取有关错误的更多信息。两个常用的消息处理：</p>
<ul>
<li><code>debug.debug</code>：为用户提供一个 Lua 提示符来让用户检查发生错误的原因</li>
<li><code>debug.traceback</code>：使用调用栈来构造详细的错误信息</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">xpcall</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="built_in">error</span>(<span class="string">&quot;test xpcall&quot;</span>) <span class="keyword">end</span>, <span class="built_in">debug</span>.<span class="built_in">debug</span>())</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lua xpcall.lua</span></span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<h2 id="模块和包"><a href="#模块和包" class="headerlink" title="模块和包"></a>模块和包</h2><p>Lua 从 5.1 版本开始为模块和包（package，模块的集合）定义了一系列的规则。<strong>从用户观点来看，一个模块就是一些代码（要么是 Lua 编写，要么是 C 编写），这些代码可以通过函数 <code>require</code> 加载，然后创建和返回一个表。这个表就像是某种命名空间，其中定义的内容是模块中导出的东西，比如函数和常量</strong>。</p>
<p>所有的都标准都是模块：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; m = <span class="built_in">require</span> <span class="string">&quot;math&quot;</span></span><br><span class="line">&gt; m.<span class="built_in">pi</span></span><br><span class="line"><span class="number">3.1415926535898</span></span><br></pre></td></tr></table></figure>

<p>Lua 的独立解释器会使用和如下代码等价的方式提前加载所有标准库，这种提前加载可以让我们不用加载模块 math 就可以直接使用其中导出的东西。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">math</span> = <span class="built_in">require</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"><span class="built_in">string</span> = <span class="built_in">require</span> <span class="string">&quot;string&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用表来实现模块的显著优点之一是：让我们可以像操作普通表那样操作模块，并且能够利用 Lua 的所有功能实现额外的功能。</p>
<p>用户调用模块中的函数有几种方法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">local</span> <span class="built_in">mod</span> = <span class="built_in">require</span> <span class="string">&quot;mod&quot;</span></span><br><span class="line">&gt; <span class="built_in">mod</span>.foo()</span><br></pre></td></tr></table></figure>

<p>可以为模块设置一个局部名称：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">local</span> m = <span class="built_in">require</span> <span class="string">&quot;mod&quot;</span></span><br><span class="line">&gt; m.foo()</span><br></pre></td></tr></table></figure>

<p>也可以为个别函数提供不同的名称：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">local</span> m = <span class="built_in">require</span> <span class="string">&quot;mod&quot;</span></span><br><span class="line">&gt; <span class="keyword">local</span> f = m.foo</span><br><span class="line">&gt; f()</span><br></pre></td></tr></table></figure>

<p>还可以只引入特定函数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">local</span> f = <span class="built_in">require</span> <span class="string">&quot;mod&quot;</span>.foo</span><br><span class="line">&gt; f()</span><br></pre></td></tr></table></figure>

<h3 id="函数-require"><a href="#函数-require" class="headerlink" title="函数 require"></a>函数 require</h3><p>函数 <code>require</code> 虽然是一个普通的函数，但是在 Lua 的模块实现中扮演核心角色。要加载模块时只需要简单地调用该函数，然后传入模块名作为参数。<strong>由于当函数的参数只有一个字符串常量时括号是可以省略的，而且一般在 require 时按照惯例也会省略括号</strong>。</p>
<p>函数 require 尝试对模块的定义做最小假设。对于该函数来说，模块可以是定义了一些变量的代码。典型地，这些代码返回一个由模块中函数组成的表。</p>
<ul>
<li>首先函数 require 在表 <code>package.loaded</code> 中检查模块是否已经加载，如果模块已经加载，函数 require 就返回相应的值。因此一旦一个模块被加载过，后续对同一模块的所有 require 调用都将返回同一个值，而不会再运行任何代码。</li>
<li>如果模块尚未加载，require 则搜索具有指定模块名的 Lua 文件，搜索路径由变量 <code>package.path</code> 指定。如果找到了相应的文件，就用函数 <code>loadfile</code> 将其进行加载，结果就是返回一个称为 loader 的函数（加载函数，当调用该函数时，模块被加载）</li>
<li>如果 require 找不到指定模块名对应的 Lua 文件，则搜索相应名称的 C 标准库，此时搜索路径由变量 <code>package.cpath</code> 指定。如果找到了一个 C 标准库，则由 <code>package.loadlib</code> 进行加载。该底层函数会查找名为 <code>luaopen_modname</code> 的函数，此时 loader 就是 loadlib 的执行结果，即一个表示为 Lua 函数的 C 函数 <code>luaopen_modname</code></li>
</ul>
<p>不管模块是在 Lua 文件还是 C 标准库中找到的，<code>require</code> 都具有了用于加载它的 <code>loader</code>。为了最终加载模块，函数 require 会带着两个参数调用 <code>loader</code>：模块名和 loader 所在文件的名称。如果加载函数有返回值，那么函数 require 会返回这个值，然后将其保存在表 package.loaded 中，这样将来加载同一模块时会返回相同的值。如果加载函数没有返回值，且表中 <code>package.loaded[@rep&#123;modname&#125;]</code> 为空，那么函数 <code>require</code> 就假设模块的返回值是 true。如果没有这种补偿，那么后续调用 <code>require</code> 将会重复加载模块。</p>
<p>所以要强制函数 require 加载同一模块两次，可以先将模块从 <code>package.loaded</code> 中删除。下一次再加载模块时，就会重新加载该模块：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">for</span> k, _ <span class="keyword">in</span> <span class="built_in">pairs</span>(<span class="built_in">package</span>.<span class="built_in">loaded</span>) <span class="keyword">do</span></span><br><span class="line">&gt;&gt; <span class="built_in">print</span>(k)</span><br><span class="line">&gt;&gt; <span class="keyword">end</span></span><br><span class="line"><span class="built_in">math</span></span><br><span class="line"><span class="built_in">_G</span></span><br><span class="line"><span class="built_in">package</span></span><br><span class="line"><span class="built_in">debug</span></span><br><span class="line"><span class="built_in">coroutine</span></span><br><span class="line"><span class="built_in">table</span></span><br><span class="line"><span class="built_in">io</span></span><br><span class="line">utf8</span><br><span class="line"><span class="built_in">os</span></span><br><span class="line"><span class="built_in">string</span></span><br></pre></td></tr></table></figure>

<p>如果希望给待加载的模块传递参数，最好使用一个显式地函数来设置参数。函数 <code>require</code> 不支持给待加载的模块传递参数。</p>
<p>通常我们使用模块本身的名称来使用它们，但有时也需要将一个模块改名以避免命名冲突。对于一个 Lua 语言模块来说，其内部名称并不是固定的，因此通常修改 <code>.lua</code> 文件的文件名即可，但是对于 C 标准库的二进制目标代码中的 <code>luaopen_*</code> 函数的名称我们是无法修改的。因此为了支持重命名，require 使用了一个技巧：</p>
<ul>
<li>如果一个模块名中包含连字符，那么 <code>require</code> 就会用连字符之前的内容创建 <code>luaopen_*</code> 函数的名称</li>
</ul>
<p>在搜索 Lua 文件时，require 使用的路径与典型的路径略有不同。典型的路径是很多目录组成的列表，并在其中搜索指定的文件。而 <code>require</code> 使用的路径是一组模版，其中每项都指定了将模块名转换为文件名的方式。更准确说，这种路径中的每一个模版都是一个包含可选问号的文件名。对于每个模块，<code>require</code> 会用模块名来替换每个问号，然后检查结果是否存在对应的文件。如果不存在，则尝试下一个模版。模版之间以 <code>;</code> 隔开。函数 <code>require</code> 只处理分号（作为分隔符）和问号，所有其他部分（包括目录分隔符和文件扩展名）则由路径自定义。</p>
<p>搜索 Lua 文件的路径是变量 <code>package.path</code> 的当前值，当 package 模块被初始化后，它会依次根据环境变量 LUA_PATH_5_3（与 Lua 版本相关）、LUA_PATH 设置该变量的值。如果环境变量都没有被定义，那么 Lua 则使用一个编译时定义的默认路径。另外环境变量中的 <code>;;</code> 将替换为默认路径。</p>
<p>搜索 C 标准库的路径的逻辑与此相同，但是 C 标准库的路径来自变量 <code>package.cpath</code> 而不是 <code>package.path</code>。类似的，该变量的初始值也可以通过环境变量 LUA_CPATH_5_3 或 LUA_CPATH 设置。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">print</span>(<span class="built_in">package</span>.<span class="built_in">path</span>)</span><br><span class="line">/usr/<span class="keyword">local</span>/share/lua/<span class="number">5.4</span>/?.lua;/usr/<span class="keyword">local</span>/share/lua/<span class="number">5.4</span>/?/init.lua;/usr/<span class="keyword">local</span>/lib/lua/<span class="number">5.4</span>/?.lua;/usr/<span class="keyword">local</span>/lib/lua/<span class="number">5.4</span>/?/init.lua;./?.lua;./?/init.lua</span><br><span class="line">&gt; <span class="built_in">print</span>(<span class="built_in">package</span>.<span class="built_in">cpath</span>)</span><br><span class="line">/usr/<span class="keyword">local</span>/lib/lua/<span class="number">5.4</span>/?.so;/usr/<span class="keyword">local</span>/lib/lua/<span class="number">5.4</span>/loadall.so;./?.so</span><br></pre></td></tr></table></figure>

<p>函数 <code>package.searchpath</code> 实现了搜索库的所有规则，该函数的参数包括文件名和路径，然后遵循上述规则来搜索文件。</p>
<p>实际的实现中，require 比上述描述复杂一些，搜索 Lua 文件和搜索 C 标准库的方式只是更加通用的搜索器（searcher）的两个实例。<strong>一个搜索器是一个以模块名为参数，以对应模块的加载器或nil（如果找不到加载器）为返回值的简单函数</strong>。</p>
<p>数组 <code>package.searchers</code> 列出了 <code>require</code> 使用的所有搜索器。寻找模块时，就会调用列表中的每个搜索器直到找到了指定模块的加载器。如果所有搜索器被调用完还找不到，<code>require</code> 就抛出一个异常。Lua 文件和 C 标准库的搜索器排在列表的第二、三位，在它们之前是预加载搜索器。预加载搜索器使得我们能够为要加载的模块定义任意的加载函数，它使用一个名为 <code>package.preload</code> 的表来映射模块名称和加载函数。当搜索到指定的模块名时，则在该表中进行查找，如果找到对于的函数，那么该函数将作为 loader 返回，否则返回 nil。<strong>预加载搜索器为处理非标场景提供了一种通用方式</strong>。</p>
<p><code>package.searchers</code> 的第 4 个函数只与子模块有关，下文会详细介绍。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(<span class="built_in">package</span>.searchers)</span><br><span class="line">&gt;&gt; <span class="keyword">do</span></span><br><span class="line">&gt;&gt; <span class="built_in">print</span>(k, v)</span><br><span class="line">&gt;&gt; <span class="keyword">end</span></span><br><span class="line"><span class="number">1</span>       <span class="function"><span class="keyword">function</span>: 0<span class="title">x56012c7a2930</span></span></span><br><span class="line"><span class="function">2       <span class="title">function</span>: 0<span class="title">x56012c7a2970</span></span></span><br><span class="line"><span class="function">3       <span class="title">function</span>: 0<span class="title">x56012c7a29b0</span></span></span><br><span class="line"><span class="function">4       <span class="title">function</span>: 0<span class="title">x56012c7a29f0</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Lua-中编写模块的方法"><a href="#Lua-中编写模块的方法" class="headerlink" title="Lua 中编写模块的方法"></a>Lua 中编写模块的方法</h3><p>Lua 中创建模块最简单的方法是：创建一个表，并将所有需要导出的函数放入其中，最后返回这个表。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> M = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span><span class="params">(r, i)</span></span></span><br><span class="line">    <span class="keyword">return</span> &#123;r = r, i = i&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">M.new = new</span><br><span class="line"></span><br><span class="line">M.i = new(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.add</span><span class="params">(c1, c2)</span></span></span><br><span class="line">    <span class="keyword">return</span> new(c1.r + c2.r, c1.i + c2.i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.sub</span><span class="params">(c1, c2)</span></span></span><br><span class="line">    <span class="keyword">return</span> new(c1.r - c2.r, c1.i - c2.i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> M</span><br></pre></td></tr></table></figure>

<p>如果不喜欢最后的返回语句，一种将其省略的方式就是直接把模块对应的表放到 <code>package.loaded</code> 中。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> M = &#123;&#125;</span><br><span class="line"><span class="built_in">package</span>.<span class="built_in">loaded</span>[...] = M</span><br></pre></td></tr></table></figure>

<p>由于函数 <code>require</code> 会把模块名称作为第一个参数传给加载函数，因此表索引中可变参数表达式 <code>...</code> 其实就是模块名。经过这条语句后就不再需要在模块的最后返回 M 了：因为一个模块没有返回值，那么函数 require 就会返回 <code>package.loaded[modname]</code> 的当前值。</p>
<p>另外一种编写模块的方法是把所有的函数定义为局部变量，然后在最后构造返回的表。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span><span class="params">(r, i)</span></span> <span class="keyword">return</span> &#123;r = r,  i = i&#125; <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> i = complex.new(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    new = new,</span><br><span class="line">    i = i,</span><br><span class="line">    add = add,</span><br><span class="line">    <span class="built_in">sub</span> = <span class="built_in">sub</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式的优点是无需在每个标识符前增加前缀 <code>M.</code> 或类似东西。这种方式的缺点在于导出表位于模块的最后而不是最前面，而且必须把每个名字写两遍（但这也允许函数在模块内和模块外具有不同的名称）。</p>
<h3 id="子模块和包"><a href="#子模块和包" class="headerlink" title="子模块和包"></a>子模块和包</h3><p><strong>Lua 支持具有层次结构的模块名，通过 <code>.</code> 来分隔名称中的层次</strong>。例如一个名为 <code>mod.sub</code> 的模块是模块 mod 的一个子模块。一个包（package）是一颗由模块组成的完整的树。它是 Lua 中用于发行程序的单位。</p>
<ul>
<li>当加载模块 <code>mod.sub</code> 时，函数 <code>require</code> 就是使用 <code>mod.sub</code> 作为键来查询表 <code>package.loaded</code> 和表 <code>package.preload</code>。此时模块名中的 <code>.</code> 没有特殊含义</li>
<li>但是当搜索一个定义子模块的文件时，<code>require</code> 就会将 <code>.</code> 转换为另一个字符，通常就是操作系统的目录分隔符，转换之后，<code>require</code> 就会像搜索其他名称一样搜索这个名称。这种行为使得一个包中的所有模块能够放到一个目录中。Lua 中使用的目录分隔符是在编译时配置的，可以是任意的字符串（Lua 并不知道目录的存在）。</li>
</ul>
<p>C 语言中的名称不能包含 <code>.</code>，因此一个用 C 编写的子模块 <code>a.b</code> 无法导出函数 <code>luaopen_a.b</code>，这时函数 <code>require</code> 会将 <code>.</code> 转换为下划线。因此一个名为 <code>a.b</code> 的 C 标准库应将其加载函数命名为 <code>luaopen_a_b</code>。</p>
<p>作为一种额外的机制，函数 <code>require</code> 在加载 C 编写的子模块时还有另外一个搜索器，该搜索器在 C 文件所在的路径中搜索包的名称。例如程序要加载子模块 <code>a.b.c</code>，搜索器会搜索文件 a。如果找到了 C 标准库 a，那么 require 就会在该库中搜索对应的加载函数 <code>luaopen_a_b_c</code>。这种机制允许一个发布包将几个子模块组织为一个 C 标准库，每个子模块由各自的加载函数。</p>
<p>从 Lua 本身的角度来看，同一个包中的子模块没有显式的关联，加载一个模块并不会自动加载它的任何子模块。同样，加载子模块也不会自动地加载其父模块。如果包的实现者愿意，也可以自行创造关联。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/Lua/" rel="tag"># Lua</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2023/08/24/lua-programming-09/" rel="prev" title="《lua 程序设计》读书笔记（9）：迭代器 & 元表">
      <i class="fa fa-chevron-left"></i> 《lua 程序设计》读书笔记（9）：迭代器 & 元表
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2023/08/23/lua-programming-07/" rel="next" title="《lua 程序设计》读书笔记（7）：数据结构 & 数据文件和序列化">
      《lua 程序设计》读书笔记（7）：数据结构 & 数据文件和序列化 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E3%80%81%E6%89%A7%E8%A1%8C%E5%92%8C%E9%94%99%E8%AF%AF"><span class="nav-number">1.</span> <span class="nav-text">编译、执行和错误</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91"><span class="nav-number">1.1.</span> <span class="nav-text">编译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E7%BC%96%E8%AF%91%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-number">1.2.</span> <span class="nav-text">预编译的代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF"><span class="nav-number">1.3.</span> <span class="nav-text">错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="nav-number">1.4.</span> <span class="nav-text">错误处理和异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E5%92%8C%E6%A0%88%E5%9B%9E%E6%BA%AF"><span class="nav-number">1.5.</span> <span class="nav-text">错误信息和栈回溯</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85"><span class="nav-number">2.</span> <span class="nav-text">模块和包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0-require"><span class="nav-number">2.1.</span> <span class="nav-text">函数 require</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lua-%E4%B8%AD%E7%BC%96%E5%86%99%E6%A8%A1%E5%9D%97%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.</span> <span class="nav-text">Lua 中编写模块的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85"><span class="nav-number">2.3.</span> <span class="nav-text">子模块和包</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">151</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
