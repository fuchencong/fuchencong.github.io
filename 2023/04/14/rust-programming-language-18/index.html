<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="这篇文章将介绍 Rust 中的一些高级特性，这些特性在一些特定的场景中非常有用，这些特性包括：  不安全的 Rust：舍弃 Rust 的某些安全保障并负责手动维护相关规则 高级 trait：关联类型、默认类型参数、完全限定语法、超 trait 以及与 trait 相关的 newtype 模式 高级类型：更多关于 newtype 模式的内容、类型别名、never 类型和动态大小类型 高级函数和闭包：">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust 权威指南（18）：高级特性">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2023/04/14/rust-programming-language-18/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="这篇文章将介绍 Rust 中的一些高级特性，这些特性在一些特定的场景中非常有用，这些特性包括：  不安全的 Rust：舍弃 Rust 的某些安全保障并负责手动维护相关规则 高级 trait：关联类型、默认类型参数、完全限定语法、超 trait 以及与 trait 相关的 newtype 模式 高级类型：更多关于 newtype 模式的内容、类型别名、never 类型和动态大小类型 高级函数和闭包：">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-04-14T14:45:54.000Z">
<meta property="article:modified_time" content="2024-01-09T03:44:59.485Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="Rust">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2023/04/14/rust-programming-language-18/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Rust 权威指南（18）：高级特性 | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2023/04/14/rust-programming-language-18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Rust 权威指南（18）：高级特性
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-14 22:45:54" itemprop="dateCreated datePublished" datetime="2023-04-14T22:45:54+08:00">2023-04-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/Rust/" itemprop="url" rel="index"><span itemprop="name">Rust</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这篇文章将介绍 Rust 中的一些高级特性，这些特性在一些特定的场景中非常有用，这些特性包括：</p>
<ul>
<li>不安全的 Rust：舍弃 Rust 的某些安全保障并负责手动维护相关规则</li>
<li>高级 trait：关联类型、默认类型参数、完全限定语法、超 trait 以及与 trait 相关的 newtype 模式</li>
<li>高级类型：更多关于 newtype 模式的内容、类型别名、never 类型和动态大小类型</li>
<li>高级函数和闭包：函数指针与返回闭包</li>
<li>宏：在编译器生成更多代码的方法</li>
</ul>
<span id="more"></span>

<h2 id="不安全的-Rust"><a href="#不安全的-Rust" class="headerlink" title="不安全的 Rust"></a>不安全的 Rust</h2><p>目前我们所有代码都拥有编译器强制实施的内存安全保障，但是 Rust 内部还隐藏了一种不会强制实施内存安全保障的语言：不安全的 Rust（unsafe Rust）。它和普通 Rust 代码没有区别，但是会给我们一些额外的超能力。</p>
<p>不安全 Rust 之所以存在是因为静态分析本质上是保守的。当编译器在判断一段代码是否拥有某种安全保障时，它总是宁可错杀一些合法的程序也不会接受可能非法的代码。通过使用不安全的代码来告知编译器：<code>相信我，我知道自己在干什么</code>，而缺点则是你需要为自己的行为负责。</p>
<p>另一个需要不安全 Rust 的原因在于底层计算机硬件固有的不安全性。Rust 作为一门系统语言需要能够进行底层编程，它允许你直接与操作系统打交道甚至编写自己的操作系统。</p>
<h3 id="不安全的超能力"><a href="#不安全的超能力" class="headerlink" title="不安全的超能力"></a>不安全的超能力</h3><p>可以在代码块前使用关键字 unsafe 来切换到不安全模式，并在被标记后的代码块中使用不安全的代码。不安全 Rust 允许你执行 4 种在安全 Rust 中不被允许的操作，它们就是所谓的 <code>不安全超能力（unsafe superpower）</code>，这些能力包括：</p>
<ul>
<li>解引用裸指针</li>
<li>调用不安全的函数或方法</li>
<li>访问或修改可变的静态变量</li>
<li>实现不安全的 trait</li>
</ul>
<p>注意，unsafe 关键字仅仅让你可以访问这 4 种不会被编译器进行内存安全检查的特性，因此即使是身处不安全的代码块中，仍然可以获得一定程度的安全性。而且 unsafe 并不意味着代码一定是危险或者会导致内存安全问题，它仅仅是将责任转移到了程序员的肩上，需要手动确定 unsafe 块的内的代码会以合法的方式访问内存。</p>
<p>为了尽可能隔离不安全代码，可以将不安全代码封装在一个安全的抽象上并提供一套安全 API。这种技术可以有效防止 unsafe 代码泄漏到任何调用它的地方，因为使用安全抽象总会是安全的。</p>
<h3 id="解引用裸指针"><a href="#解引用裸指针" class="headerlink" title="解引用裸指针"></a>解引用裸指针</h3><p>裸指针（raw pointer）是一种类似于引用的新指针类型，与引用类似，裸指针要么是可变的，要么是不可变的，它们分别写为 <code>*const T</code> 和 <code>*mut T</code>。这里星号是类型名的一部分而不是解引用操作。裸指针与引用、智能指针的区别在于：</p>
<ul>
<li>允许忽略借用规则，可以同时拥有指向同一个内存地址的可变和不可变指针，或者拥有指向同一个地址的多个可变指针</li>
<li>不能保证自己总是指向了有效的内存地址</li>
<li>允许为空</li>
<li>没有实现任何自动清理机制</li>
</ul>
<p>如下代码从一个引用中创建出不可变和可变的裸指针：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;r1 is: &#123;&#125;&quot;</span>, *p1);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;r2 is: &#123;&#125;&quot;</span>, *p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在安全代码内合法地创建裸指针，但不能在 unsafe 代码块外解引用裸指针。这里使用了 as 来分别将不可变引用和可变引用强制转换为对应的裸指针类型。创建一个指针并不会产生任何危害，只有当我们试图访问它指向的值才可能因为无效的值而导致程序异常。</p>
<p>裸指针一个主要用途便是与 C 代码接口进行交互，另外还可以被用来构造一些借用检查器无法理解的安全抽象。</p>
<h3 id="调用不安全函数或方法"><a href="#调用不安全函数或方法" class="headerlink" title="调用不安全函数或方法"></a>调用不安全函数或方法</h3><p>第二种需要使用不安全代码块的操作便是调用不安全函数（unsafe function）。除了在定义前面加上标记 unsafe，不安全函数或方法看上去与正常的函数或方法几乎一摸一样。unsafe 关键字意味着我们需要在调用函数时手动满足并维护一些先决条件，因为 Rust 无法对这些条件进行验证。通过在 unsafe 代码块中调用不安全函数，我们向 Rust 表明自己确实理解并实现了相关约定。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">dangerous</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">dangerous</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们必须在单独的 unsafe 代码块中调用 dangerous 函数。这其实也是一种确认，通过插入 unsafe 向 Rust 表明我们自己已经阅读了函数的文档，能够理解正确使用它的方式，并确认满足了它所要求的约定。</p>
<p>函数中包含不安全代码并不意味着我们需要将整个函数都标记为不安全的，实际上将不安全代码封装到安全函数中是一种十分常见的抽象。</p>
<p>如下是一个示例，如下函数接收一个切片并从给定的索引参数处将其分割为两个切片：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">split_at_mut</span>(slice: &amp;<span class="keyword">mut</span>[<span class="type">i32</span>], mid: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="keyword">mut</span>[<span class="type">i32</span>], &amp;<span class="keyword">mut</span>[<span class="type">i32</span>]) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = slice.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(mid &lt;= len);</span><br><span class="line"></span><br><span class="line">    (&amp;<span class="keyword">mut</span> slice[..mid],</span><br><span class="line">     &amp;<span class="keyword">mut</span> slice[mid..])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码无法编译通过，因为它只知道我们可变借用了两次同一个切片，虽然我们是借用同一个切片的不同部分，这两个切片没有交叉的地方，但 Rust 编译器不能理解信息。当我们能够确定某段代码的正确性而 Rust 却不能时，可以使用 <code>不安全代码</code>。</p>
<p>如下使用 unsafe 代码块、裸指针以及一些不安全函数来实现 <code>split_at_mut</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">split_at_mut</span>(slice: &amp;<span class="keyword">mut</span>[<span class="type">i32</span>], mid: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="keyword">mut</span>[<span class="type">i32</span>], &amp;<span class="keyword">mut</span>[<span class="type">i32</span>]) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = slice.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ptr</span> = slice.<span class="title function_ invoke__">as_mut_ptr</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(mid &lt;= len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        (slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(ptr, mid),</span><br><span class="line">         slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(ptr.<span class="title function_ invoke__">offset</span>(mid <span class="keyword">as</span> <span class="type">isize</span>), len - mid))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切片由一个指向数据的指针与切片长度组成，我们可以通过 <code>as_mut_ptr</code> 方法获得切片包含的裸指针。而 <code>slice::from_raw_parts_mut</code> 接受一个裸指针和长度来创建一个切片。我们的 <code>split_at_mut</code> 并没有标记为 unsafe，因为我们对不安全代码创建了一个安全抽象，并在实现时以安全的方式使用 unsafe 代码块，因为它仅仅创建了指向访问数据的有效指针。</p>
<p>有时候 Rust 代码可能需要与另外一种语言编写的代码交互。Rust 提供了 <code>extern</code> 关键字来简化创建和使用外部函数接口（Foreign Function Interface，FFI）的过程。</p>
<p>如下示例，集成了 C 标准库的 abs 函数。任何在 extern 块中声明的函数都是不安全的。因为其他语言不会执行 Rust 的规则，而 Rust 也无法对它们进行检查。所以调用外部函数的过程，需要开发者保证安全。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">abs</span>(input: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Absolute value of -3 according to C: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">abs</span>(-<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码在 extern “C” 中列出我们想要调用的外部函数名称和签名，其中 “C” 指明了外部函数使用的二进制接口（Application Binary Interface，ABI）：它被用来定义函数在汇编层面的调用方式。”C” ABI 正式 C 语言的 ABI，也是最常见的 ABI 格式之一。</p>
<p>同样可以使用 <code>extern</code> 来创建一个允许其他语言调用 Rust 函数的接口。但是不同于使用 extern 标注的代码块，需要将 extern 关键字及对应的 ABI 添加到函数签名的 fn 关键字之前，并且为函数添加 <code>#[no_mangle]</code> 注解来避免 Rust 在编译时改变它的名称。这一类型的 extern 功能不需要使用 unsafe。如下是一个例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_from_c</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Just called a Rust function from C!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问或修改一个可变静态变量"><a href="#访问或修改一个可变静态变量" class="headerlink" title="访问或修改一个可变静态变量"></a>访问或修改一个可变静态变量</h3><p>Rust 其实是支持全局变量的，但是在使用它们的过程中可能会因为 Rust 的所有权机制而产生某些问题。如果两个现成同时访问一个可变的全局变量，那么就会造成数据竞争。</p>
<p>在 Rust 中，全局变量也被称为静态（static）变量。如下定义并使用一个不可变的静态变量：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> HELLO_WORLD: &amp;<span class="type">str</span> = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;name is: &#123;&#125;&quot;</span>, HELLO_WORLD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态变量通常写为 <code>SCREAMING_SNAKE_CASE</code> 形式，必须要标注变量的类型。静态变量只能存储拥有 <code>&#39;static</code> 生命周期的引用，这意味着 Rust 编译器可以自己计算出它的生命周期而无需手动标注。访问一个不可变静态变量是安全的。</p>
<p>访问和修改一个可变静态变量都是不安全的，这些代码都必须放在 <code>unsafe</code> 代码块中。在拥有可全局访问的可变数据时，我们很难保证没有数据竞争发生，这也是 Rust 会将可变静态变量当做不安全的原因。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> COUNTER: <span class="type">u32</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_to_count</span>(inc: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        COUNTER += inc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">add_to_count</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;COUNTER: &#123;&#125;&quot;</span>, COUNTER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现不安全-trait"><a href="#实现不安全-trait" class="headerlink" title="实现不安全 trait"></a>实现不安全 trait</h3><p>最后一个只能在 unsafe 中执行的操作是实现某个不安全的 trait。当某个 trait 中存在至少一个方法拥有编译器无法校验的不安全因素时，就称该 trait 为不安全的。可以在 trait 定义的前面加上 unsafe 关键字来声明一个不安全 trait，同时该 trait 也只能在 unsafe 代码块中实现。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">trait</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="title class_">Foo</span> <span class="keyword">for</span> <span class="title class_">i32</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前介绍过，当我们的类型完全由实现了 Send 与 Sync 的类型组成时，编译器会自动为它实现 Send 与 Sync。如果我们的类型包含了没有实现 Send 或 Sync 的字段，而又希望把这个类型标记为 Send 与 Sync，就必须使用 unsafe。Rust 无法验证我们的类型是否能够安全地跨线程传递，或者安全地从多个线程访问。因此需要手动执行这些审查并使用 unsafe 关键字来实现这些 trait。</p>
<h3 id="使用不安全代码的时机"><a href="#使用不安全代码的时机" class="headerlink" title="使用不安全代码的时机"></a>使用不安全代码的时机</h3><p>在上述操作中使用 unsafe 并没有什么问题，但是由于它们缺少编译器提供的强制内存安全保障，所以要保持 unsafe 代码的正确性也并不是一件简单的事。当出现问题时，显式标记的 unsafe 关键字也可以比较轻松地定位到这些代码。</p>
<h2 id="高级-trait"><a href="#高级-trait" class="headerlink" title="高级 trait"></a>高级 trait</h2><p>接下来再介绍一些 trait 的高级特性。</p>
<h3 id="在-trait-的定义中使用关联类型指定占位类型"><a href="#在-trait-的定义中使用关联类型指定占位类型" class="headerlink" title="在 trait 的定义中使用关联类型指定占位类型"></a>在 trait 的定义中使用关联类型指定占位类型</h3><p>关联类型是 trait 中的类型占位符，它可以被用于 trait 的方法签名中。trait 的实现者需要根据特定的场景来为关联类型指定具体的类型。通过这一技术，我们可以定义出包含某些类型的 trait，而无需在实现前确定它们的具体类型是什么。</p>
<p>标准库的 Iterator 就是一个带有关联类型的 trait 示例，它拥有一个名为 Item 的关联类型，并使用该类型来替代迭代中出现的值类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里为什么不直接使用泛型来定义 Iterator trait 呢？例如如下所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;T&gt; &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这其中的区别在于，如果使用泛型版本，那么就需要在每次实现该 trait 的过程中标注类型。因为我们既可以实现 Iterator<String> for Counter，也可以实现其他任意的迭代类型，从而使得 Counter 可以拥有多个不同版本的 Iterator 实现。所以，<strong>如果 trait 有泛型参数，那么可以为一个类型多次实现 trait，并在每次实现中改变具体的泛型参数</strong>。我们在 Counter 上使用 next 方法时也需要提供类型标注来指明想要使用的 Iterator 实现。而通过关联类型，不需要在使用该 trait 的方法时标注类型，因为我们不能为 Counter 多次实现这样的 triat，Counter 只能拥有一个特定的 Item 类型。</p>
<h3 id="默认泛型参数和运算符重载"><a href="#默认泛型参数和运算符重载" class="headerlink" title="默认泛型参数和运算符重载"></a>默认泛型参数和运算符重载</h3><p>在使用泛型参数时可以为泛型指定一个默认的具体类型。当使用默认类型就能工作时，该 trait 的实现者可以不用在指定另外具体的类型。可以在定义泛型时通过 <code>&lt;PlaceholderType=ConcreteType&gt;</code> 来为泛型指定默认类型。</p>
<p>该技术常用于运算符重载中，在 Rust 中，可以实现 <code>std::ops</code> 中列出的那些 triat 来重载一部分相应的运算符。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Add;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span> <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Point;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, other: Point) <span class="punctuation">-&gt;</span> Point &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x + other.x,</span><br><span class="line">            y: <span class="keyword">self</span>.y + other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(Point&#123;x: <span class="number">1</span>, y: <span class="number">0</span>&#125; + Point&#123;x: <span class="number">2</span>, y: <span class="number">3</span>&#125;, Point&#123;x: <span class="number">3</span>, y: <span class="number">3</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 Add trait 使用了默认泛型参数，它的定义如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Add</span>(RHS=<span class="keyword">Self</span>) &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, rhs: RHS) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RUSH=Self</code> 就是默认类型参数，泛型参数 RHS 定义了 add 方法中 rhs 参数的类型。<strong>在上面的例子中，因为的确是将两个 Point 实例相加，所以在 Point 实现 Add 时使用了默认的 RHS</strong>。而下面的例子则有所不同：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Add;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Millimeters</span>(<span class="type">u32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Meters</span>(<span class="type">u32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span>&lt;Meters&gt; <span class="keyword">for</span> <span class="title class_">Millimeters</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Millimeters;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, other: Meters) <span class="punctuation">-&gt;</span> Millimeters&#123;</span><br><span class="line">        <span class="title function_ invoke__">Millimeters</span>(<span class="keyword">self</span>.<span class="number">0</span> + other.<span class="number">0</span> * <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了能够将 Millimeters 和 Meters 的值加起来，我们指定 <code>impl Add&lt;Meters&gt;</code> 来设置 RHS 类型参数的值，而没有使用默认的 Self。</p>
<p>默认类型参数主要被用于以下两种情景：</p>
<ul>
<li>扩展一个类型而不破坏现有的代码</li>
<li>允许在大部分用户都不需要的特定场合进行自定义</li>
</ul>
<h3 id="用于消除歧义的完全限定语法：调用相同名称的方法"><a href="#用于消除歧义的完全限定语法：调用相同名称的方法" class="headerlink" title="用于消除歧义的完全限定语法：调用相同名称的方法"></a>用于消除歧义的完全限定语法：调用相同名称的方法</h3><p>Rust 既不会阻止两个 trait 拥有相同名称的方法，也不会阻止你为同一个类型实现这样的两个 trait。你甚至可以在这个类型上直接实现与 trait 方法同名的方法。当你需要调用这些方法时，你需要明确地告诉 Rust 你期望调用的具体对象。</p>
<p>如下是一个实例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Pilot</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Wizard</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Human</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Pilot</span> <span class="keyword">for</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;this is your captain speaking.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Wizard</span> <span class="keyword">for</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Up&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;*waving arms furiously*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">person</span> = Human;</span><br><span class="line">    person.<span class="title function_ invoke__">fly</span>();</span><br><span class="line">    Pilot::<span class="title function_ invoke__">fly</span>(&amp;person);</span><br><span class="line">    Wizard::<span class="title function_ invoke__">fly</span>(&amp;person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当我们在 Human 的实例上调用 fly 时，编译器会默认调用直接实现在类型上的方法</li>
<li>为了调用 trait 中的 fly 方法，需要使用更加显式的语法来指定具体的 fly 方法。在方法名的前面指定 trait 名称向 Rust 表明我们需要调用哪个 fly 实现</li>
<li>直接使用 <code>Human::fly(&amp;person)</code> 也是可以的，它等价于 <code>person.fly()</code></li>
</ul>
<p>当拥有两种实现了同一个 trait 的类型时，对于 fly 等需要接收 self 作为参数的方法，Rust 可以自动地根据 self 的类型推导出具体的 trait 实现。但是 trait 中的关联函数没有 self 参数，所以当同一个作用域下有两个实现了这种 trait 的类型时，Rust 无法推导出你究竟想要调用哪一个具体类型，除非使用完全限定语法（Fully qualified syntax）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Spot&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animal</span> <span class="keyword">for</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;puppy&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;A baby dog is called a &#123;&#125;&quot;</span>, Dog::<span class="title function_ invoke__">baby_name</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A baby dog is called a Spot</span><br></pre></td></tr></table></figure>

<p>如果我们想调用在 Dog 上实现的 Animal trait 的 baby_name 函数，直接使用 <code>Animal::baby_name()</code> 是会有编译错误的，因为该函数是一个没有 self 参数的关联函数而不是方法，所以 Rust 无法推断出我们想要调用哪一个 <code>Animal::baby_name</code> 的实现。为了消除歧义并指示 Rust 使用 Dog 为 Animal trait 实现的 baby_name 函数，需要使用完全限定语法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;A baby dog is called a &#123;&#125;&quot;</span>, &lt;Dog <span class="keyword">as</span> Animal&gt;::<span class="title function_ invoke__">baby_name</span>());</span><br></pre></td></tr></table></figure>

<p>完全限定语法的形式如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Type <span class="keyword">as</span> Trait&gt;::<span class="title function_ invoke__">function</span>(receiver_if_method, next_arg, ...);</span><br></pre></td></tr></table></figure>

<p>可以在任何调用函数或方法的地方使用完全限定语法，而 Rust 允许你忽略那些能够从其他上下文信息中推导出来的部分。</p>
<h3 id="用于在-trait-中附带另外一个-trait-功能的超-trait"><a href="#用于在-trait-中附带另外一个-trait-功能的超-trait" class="headerlink" title="用于在 trait 中附带另外一个 trait 功能的超 trait"></a>用于在 trait 中附带另外一个 trait 功能的超 trait</h3><p>有时需要在一个 trait 中使用另外一个 trait 的功能，在这种情况下，需要使当前 trait 的功能依赖于另外一个同时被实现的 trait。这个被依赖的 trait 也是当前 trait 的 <code>超 trait</code>（supertrait）。</p>
<p>如下是一个示例，<code>OutlinePrint trait</code> 拥有一个方法 <code>outline_print</code>，它的默认实现使用 Display trait 的功能，所以 <code>OutlinePrint</code> 必须注明自己只能用于那些提供了 Display 功能的类型。可以在定义 trait 时指定 <code>OutlinePrint: Display</code> 来完成该声明，这有些类似于为泛型添加 trait 约束。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">OutlinePrint</span>: fmt::Display &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">outline_print</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">output</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">len</span> = output.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;*&quot;</span>.<span class="title function_ invoke__">repeat</span>(len + <span class="number">4</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot; &quot;</span>.<span class="title function_ invoke__">repeat</span>(len + <span class="number">2</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, output);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot; &quot;</span>.<span class="title function_ invoke__">repeat</span>(len + <span class="number">2</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;*&quot;</span>.<span class="title function_ invoke__">repeat</span>(len + <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们注明了 OutlinePrint 依赖于 Display trait，所以能够在随后的方法中使用 <code>to_string</code> 函数。</p>
<h3 id="使用-newtype-模式在外部类型上实现外部-trait"><a href="#使用-newtype-模式在外部类型上实现外部-trait" class="headerlink" title="使用 newtype 模式在外部类型上实现外部 trait"></a>使用 newtype 模式在外部类型上实现外部 trait</h3><p>之前介绍过，只有当类型和对应的 trait 的任意一个定义在本包内时，我们才能够为该类型实现这一 trait。实际上，我们可以通过 newtype 模式来绕过这个限制，它会利用元组结构体创建一个新的类型，这个元组结构体只有一个字段，是我们想要实现 trait 类型的（thin wrapper），由于封装后的类型位于本地包内，所以可以为该类型实现对应的 trait。使用这一模式不会导致任何额外的运行时开销，封装后的类型会在编译过程中被优化掉。</p>
<p>如下是一个示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper</span>(<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;[&#123;&#125;]&quot;</span>, <span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">join</span>(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">w</span> = <span class="title function_ invoke__">Wrapper</span>(<span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world&quot;</span>)]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;w = &#123;&#125;&quot;</span>, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种技术有个缺点：由于 Wrapper 是一个新的类型，所以它没有自己内部值的方法。为了让 Wrapper 的行为与 <code>Vec&lt;T&gt;</code> 完全一致，需要在 Wrapper 中实现所有的 <code>Vec&lt;T&gt;</code> 的方法，并将这些方法委托给 self.0。<strong>如果我们希望新类型具备内部类型的所有方法，我们也可以为 Wrapper 实现 Deref trait 来直接返回内部类型</strong>。</p>
<h2 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h2><h3 id="使用-newtype-模式实现类型安全与抽象"><a href="#使用-newtype-模式实现类型安全与抽象" class="headerlink" title="使用 newtype 模式实现类型安全与抽象"></a>使用 newtype 模式实现类型安全与抽象</h3><p>newtype 模式还有一些用途，它可以被用来静态地保证各种值之间不会被混淆及表明值使用的单位。newtype 模式另外一个用途是为类型的某些细节提供抽象能力，newtype 模式还可以被用来隐藏内部实现，它可以通过轻量级的封装隐藏实现细节。</p>
<h3 id="使用类型别名创建同义类型"><a href="#使用类型别名创建同义类型" class="headerlink" title="使用类型别名创建同义类型"></a>使用类型别名创建同义类型</h3><p>除了 newtype 模式，Rust 还提供了创建类型别名（type alias）的功能，它可以为现有的类型生成另外的名称。这一特性需要使用 type 关键字。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Kilometers</span> = <span class="type">i32</span>;</span><br></pre></td></tr></table></figure>

<p>不同于 newtype 模式，这里 Kilometers 和 i32 其实是同一种类型，所以可以直接将这两个类型的值相加，甚至可以将 Kilometers 类型的值传递给 i32 类型作为参数的函数。而缺点则是无法享有 newtype 模式带来的类型检查便利性。</p>
<p>类型别名主要用途是减少代码字符重复。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Thunk</span> = <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span>&lt;T&gt; = <span class="type">Result</span>&lt;T, std::io::Error&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="永远不返回的-Never-类型"><a href="#永远不返回的-Never-类型" class="headerlink" title="永远不返回的 Never 类型"></a>永远不返回的 Never 类型</h3><p>Rust 有一个名为 <code>!</code> 的特殊类型，它在类型系统中的术语为空类型（empty type），因为它没有任何的值，倾向于叫它 never 类型，因为它在从不返回的函数中充当返回值的类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">bar</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不会返回值的函数也被称为 <code>发散函数</code>，不能创建出类型为 <code>!</code> 的值来让 bar 返回。那 <code>never</code> 类型到底有什么用处呢？如下是拥有一个 continue 结尾的分支的 match 语句：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(num) =&gt; num,</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>match 有一个限制，即 match 的所有分支都必须返回相同的类型。<strong>continue 的返回类型是 <code>!</code>，因为 <code>!</code> 无法产生一个可供返回的值，所以在上面的例子中，Rust 直接采用 u32 作为 guess 的类型</strong>。</p>
<p>或者还有一种更为正式的说法，类型 ! 的表达式可以被强制转换为其他任意类型。我们之所以能够使用 continue 来结束 match 分支，是因为 continue 永远不会返回值，相反它会将程序的控制流转移到上层循环，<strong>因此这段代码在输入值为 Err 的情况下不会对 guess 进行赋值</strong>。</p>
<p><code>panic!</code> 宏同样使用了 never 类型，还有一个以 <code>!</code> 作为返回类型的表达式是 loop，由于 loop 循环永远不会结束，所以这个表达式以 <code>!</code> 作为自己的返回类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;forever&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;and ever&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态大小类型和-Sized-trait"><a href="#动态大小类型和-Sized-trait" class="headerlink" title="动态大小类型和 Sized trait"></a>动态大小类型和 Sized trait</h3><p>Rust 需要在编译时获取一些特定的信息来完成自己的工作，例如需要为一个特定的类型的值分配多少空间等。但 Rust 的类型系统中也存在 <code>动态大小类型</code>（Dynamically Sized Type，DST）的概念，有时也被称为 <code>不确定大小类型</code>（unsized type），这些类型使我们在编写代码时使用只有在运行时才能确定大小的值。</p>
<p>str 就是动态大小类型（大小无法确定的类型），这也意味着我们无法创建一个 str 类型的变量，或者使用 str 类型来作为函数的参数。如下代码无法正确工作：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span>: <span class="type">str</span> = <span class="string">&quot;hello there&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span>: <span class="type">str</span> = <span class="string">&quot;How&#x27;s it going?&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>因为 Rust 需要在编译时确定某个特定类型的值究竟会占据多少内存，而同一个类型的所有值都需要使用等量的内存。而字符串确实具有不同的长度，所以它的内存空间是无法确定的，所以我们就无法创建出动态大小类型变量。</p>
<p>所以我们都是使用 <code>&amp;str</code> 来处理字符串，<code>&amp;str</code> 实际上是由两个值组成的：str 的地址与它的长度。这使得我们可以在编译时确定 <code>&amp;str</code> 值的大小：其长度为 uszie 的两倍。所以无论指向什么样的字符串，总是能够知道 <code>&amp;str</code> 的大小。这就是 Rust 使用动态大小类型的通用方式：他们会附带一些额外的元数据来存储动态信息的大小，我们在使用动态大小类型时总是会把它的值放在某种指针后面。</p>
<p>可以将 <code>&amp;str</code> 可以与所有种类的指针组合起来，例如 <code>Box&lt;str&gt;</code> 或 <code>Rc&lt;str&gt;</code> 等。trait 也是动态大小类型，每一个 trait 都是一个可以通过其名称来进行引用的动态大小类型，为了把 trait 用作 trait 对象，必须将它防止在某种指针之后，例如 <code>&amp;dyn Trait</code>、<code>Box&lt;dyn Trait&gt;</code>。</p>
<p>为了处理动态大小类型，Rust 提供了一个特殊的 Sized trait 来确定一个类型的大小在编译时是否可知。编译时可以计算出大小的类型会自动实现这一 trait，另外 Rust 还会为每个泛型函数隐式添加 Sized 约束：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generic</span>&lt;T&gt;(t: T) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会被隐式转换为：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generic</span>&lt;T: <span class="built_in">Sized</span>&gt;(t: T) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在默认情况下，泛型函数只能被用于在编译时已经知道大小的类型，但是可以通过如下语法来解除这一限制：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generic</span>&lt;T: ?<span class="built_in">Sized</span>&gt;(t: &amp;T) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 <code>?Size trait</code> 约束表达了与 Sized 相反的含义，可以将它读做 <code>T 可能是也可能不是 Sized 的</code>。这个语法只能用于 Sized 上，而不能用于其他 trait。另外将 t 参数的类型由 T 修改为 &amp;T，因为类型可能不是 Sized，所以需要将它放置在某种指针后面。</p>
<h2 id="高级函数与闭包"><a href="#高级函数与闭包" class="headerlink" title="高级函数与闭包"></a>高级函数与闭包</h2><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>之前介绍过如何将闭包传递给函数，但是同样可以将普通函数传递给其他函数。函数会在传递的过程中被强制转换为 fn 类型。注意 fn 与 Fn 的区别，Fn 是闭包 trait，而 fn 是类型，即函数指针。将参数声明为函数指针与闭包语法类似：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add_one</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">do_twice</span>(f: <span class="title function_ invoke__">fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>, arg: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>(arg) + <span class="title function_ invoke__">f</span>(arg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">answer</span> = <span class="title function_ invoke__">do_twice</span>(add_one, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, answer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与闭包不同，fn 是一个类型而不是一个 trait，因此可以直接指定 fn 为参数类型，而不用声明一个以 Fn trait 为约束的泛型参数。</p>
<p>由于函数指针实现了全部三种闭包 trait（Fn、FnMut 以及 FnOnce），所以总是可以把函数指针用作参数传递给一个接收闭包的函数。所以我们倾向于搭配闭包 trait 的泛型来编写函数，这样函数可以同时处理闭包和普通函数。当然某些情况下的确可能只想接收 fn 而不想接收闭包（例如与某种不支持闭包的外部代码进行交互，C 函数可以接受函数作为参数，但是却没有闭包）。</p>
<p>如下是一个例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">list_of_numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">list_of_strings</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = list_of_numbers</span><br><span class="line">    .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">    .<span class="title function_ invoke__">map</span>(|i| i.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">    .<span class="title function_ invoke__">collect</span>()</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">list_of_numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">list_of_strings</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = list_of_numbers</span><br><span class="line">    .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">    .<span class="title function_ invoke__">map</span>(<span class="built_in">ToString</span>::to_string)</span><br><span class="line">    .<span class="title function_ invoke__">collect</span>()</span><br></pre></td></tr></table></figure>

<p>由于元组结构体、元组结构枚举变体这些类型的初始化语法与调用函数相似（它们的构造器的确也被实现为了函数），因此可以将构造器视为实现了闭包 trait 的函数指针，并在那些接收闭包的方法中使用它们。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Value</span>(<span class="type">u32</span>),</span><br><span class="line">    Stop,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">list_of_statuses</span>: <span class="type">Vec</span>&lt;Status&gt; =</span><br><span class="line">    (<span class="number">0u32</span>..<span class="number">20</span>)</span><br><span class="line">    .<span class="title function_ invoke__">map</span>(Status::Value)</span><br><span class="line">    .<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure>

<h3 id="返回闭包"><a href="#返回闭包" class="headerlink" title="返回闭包"></a>返回闭包</h3><p>由于闭包使用了 trait 来进行表达，所以无法在函数中直接返回一个闭包。在大多数希望返回 trait 的情形下，可以将一个实现了该 trait 的具体类型作为返回值。但是无法对闭包执行同样的操作，因为闭包没有一个可供返回的具体类型，无法将函数指针 fn 用作返回类型。</p>
<p>如下代码尝试返回一个闭包，但是无法通过编译：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_closure</span>() <span class="punctuation">-&gt;</span> <span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    |x| x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用 trait 对象来解决这一问题：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_closure</span>() <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(|x| x + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><p>宏是 Rust 中一组相关功能的集合称谓，其中包括使用 <code>macro_rules!</code> 构造的声明宏以及另外 3 种过程宏：</p>
<ul>
<li>用于结构体或枚举的自定义 <code>#[derive]</code> 宏，它可以指定随 derive 属性自动添加的代码</li>
<li>用于为任意条目添加自定义属性的属性宏</li>
<li>看起来类似于函数的函数宏，它可以接收并处理一段标记（token）序列</li>
</ul>
<h3 id="宏与函数的区别"><a href="#宏与函数的区别" class="headerlink" title="宏与函数的区别"></a>宏与函数的区别</h3><p>从根本上来讲，宏是一种用于编写其他代码的代码的编写方式，即所谓的元编程。元编程可以极大程度减少你需要编写和维护的代码数量，虽然这也是函数的作用之一，但是宏却有一些函数所不具备的能力。</p>
<p>函数在定义签名时需要声明自己参数的个数与类型，但是宏却具有一些函数所不具备的能力。例如函数在定义签名时必须声明自己参数的个数与类型，而宏则能够处理可变数量的参数。另外由于编译器会在解释代码之前展开宏，所以宏可以被用来执行比较特殊的任务，例如为类型实现 trait。函数无法做到这一点，因为 trait 需要在编译时实现，而函数则是运行时调用执行的。</p>
<p>宏的定义比函数定义复杂得多，因为我们编写的是用于生成 Rust 代码的 Rust 代码，正是这种间接性，宏定义通常要比函数定义更加难以阅读、理解和维护。</p>
<p>另外宏和函数还有一个重要区别：在某个文件中调用宏时，需要提前定义宏或者将宏引入当前作用域中，而函数则可以在任意位置定义并在任意位置使用。</p>
<h3 id="用于通用元编程的-macro-rules-声明宏"><a href="#用于通用元编程的-macro-rules-声明宏" class="headerlink" title="用于通用元编程的 macro_rules! 声明宏"></a>用于通用元编程的 macro_rules! 声明宏</h3><p>声明宏有时也被称为模版宏（macros by example）”macro_rules!” 宏，或者直接称为 <code>宏</code>。从核心形式上来讲，声明宏要求你编写出类似于 match 表达式的东西。声明宏将输入的值与带有相关执行代码的模式进行比较：</p>
<ul>
<li>这里的值是传递给宏的字面 Rust 源代码</li>
<li>这里的模式则是可以用来匹配这些源代码的结构</li>
</ul>
<p>当某个模式匹配成功时，该分支下的代码就会被用来替换传入宏的代码。所有这一切都会发生在编译时期。为了定义一个宏，需要用到 <code>macro_rules!</code>。</p>
<p>如下展示了一个简化后的 <code>vec!</code> 宏定义：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> vec &#123;</span><br><span class="line">    ($( $x:expr ),*) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">temp_vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">            $(</span><br><span class="line">                temp_vec.<span class="title function_ invoke__">push</span>($x);</span><br><span class="line">            )*</span><br><span class="line">            temp_vec</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>#[macro_export]</code> 标注意味着这个宏会在它所处的包被引入作用域后可用，缺少该标注的宏不能被引入作用域</li>
<li>使用 <code>macro_rules!</code> 以及不带感叹号的名称来开始定义宏，宏名称后面则是一对包含了宏定义体的花括号</li>
<li>之后则是一个模式为 <code>( $($x:expr),* )</code> 的分支，模式后紧跟着的是 <code>=&gt;</code> 及对应的代码块，这些关联代码会在模式匹配成功时执行</li>
</ul>
<p>宏定义中的模式匹配语法与一般的 Rust 模式匹配不同，因为宏模式匹配的是 Rust 代码结构，而不是值。如下简单解释了这里的匹配语法，完整地宏模式匹配语法，参考 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/reference/macros.html">Rust 手册</a>，另外也可以参考 <code>The Little Book of Rust Macros</code>。</p>
<ul>
<li>首先使用圆括号将整个模式包裹起来，接着是一个 $ 符号，以及另外一对包裹着匹配模式的圆括号，这些被匹配并捕获的值最终会被用于生成替换代码</li>
<li><code>$x:expr</code> 可以匹配任意的 Rust 表达式，并将其命名为 $x</li>
<li><code>$()</code> 之后的逗号意味着一个可能的字面逗号分隔符会出现在捕获代码的后面，而逗号后的 * 则意味着这个模式可以匹配 0 个或多个 * 之前的东西</li>
<li>而在匹配分支代码，它会为模式中匹配到的每一个 <code>$()</code> 生成 <code>$()*</code> 中的代码，这一展开过程会重复 0 或多次，取决于匹配成功的表达式数量，而 <code>$x</code> 则会被每个匹配到的表达式所替代</li>
</ul>
<h3 id="基于属性创建代码的过程宏"><a href="#基于属性创建代码的过程宏" class="headerlink" title="基于属性创建代码的过程宏"></a>基于属性创建代码的过程宏</h3><p>这种形式的宏更像是函数（某种形式的过程）一些，因此被称为 <code>过程宏</code>。过程宏会接受并操作输入的 Rust 代码，并生成另外一些 Rust 代码作为结果，这与声明宏根据模式匹配来替换代码的行为有所不同。虽然过程宏有 3 种不同的类型（自定义派生宏、属性宏、以及函数宏），但是它们都具有某种相似的工作机制。</p>
<p>创建过程宏时，宏的定义必须单独放置在自己的包中，并使用特殊的包类型（未来可能会消除该限制）。如下是过程宏的实例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> proc_macro;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[some_attribute]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">some_name</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该定义了过程宏的函数接收一个 TokenStream 作为输入，并产生一个 TokenStream 作为输出。TokenStream 类型在 <code>proc_macro</code> 包中定义，表示一段标记序列。这也说明了过程宏的核心机制：需要被宏处理的源代码组成了输入的 TokenStream，而宏生成的代码则组成了输出的 TokenStream。</p>
<h4 id="编写一个自定义-derive-宏"><a href="#编写一个自定义-derive-宏" class="headerlink" title="编写一个自定义 derive 宏"></a>编写一个自定义 derive 宏</h4><p>这里我们将实现了一个 <code>自定义 derive 宏</code>。在 <code>hello_macro</code> 包中定义了一个拥有关联函数 <code>hello_macro</code> 的 <code>HelloMacro trait</code> 中。为了避免让用户在他们的每一个类型上逐一实现 HelloMacro trait，会提供一个能够自动实现 trait 的过程宏。因此用户可以在它们的类型上标注 <code>#[derive(HelloMacro)]</code>，从而得到 <code>hello_macro</code> 函数的默认实现。</p>
<p><code>hello_macro</code> 函数用于输出类型的名称，而 Rust 没有提供反射的功能，所以无法再运行时查找类型的名称。因此需要的一个能够在编译时生成代码的宏。</p>
<p>由于过程宏需要单独放置在自己的包内（未来可能会去除该限制），目前组织主包和宏包的惯例是，对于一个名为 <code>foo</code> 的包，会生成一个用于放置自定义派生过程宏的包 <code>foo_derive</code>。</p>
<p>首先创建代码包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new hello_macro --lib</span><br></pre></td></tr></table></figure>

<p>定义 HelloMacro trait</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">HelloMacro</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">hello_macro</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来创建 <code>hello_macro_derive</code> 包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cargo new hello_macro_derive --lib</span></span><br></pre></td></tr></table></figure>

<p>修改 <code>hello_macro_derive/Cargo.toml</code> 文件，声明它是一个拥有过程宏的包，同时添加依赖：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[lib]</span><br><span class="line">proc-macro = lib</span><br><span class="line"></span><br><span class="line">[dependencies]</span><br><span class="line">syn = <span class="string">&quot;0.14.4&quot;</span></span><br><span class="line">quote = <span class="string">&quot;0.6.3&quot;</span></span><br></pre></td></tr></table></figure>

<p>接下来定义过程宏，首先将如下代码放入 <code>hello_macro_derive</code> 包的 <code>src/lib.rs</code> 中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> proc_macro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::proc_macro::TokenStream;</span><br><span class="line"><span class="keyword">use</span> quote::quote;</span><br><span class="line"><span class="keyword">use</span> syn;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#[proc_macro_derive(HelloMacro)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">hello_macro_derive</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ast</span> = syn::<span class="title function_ invoke__">parse</span>(input).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="title function_ invoke__">impl_hello_macro</span>(&amp;ast)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">impl_hello_macro</span>(ast: &amp;syn::DeriveInput) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = &amp;ast.ident;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">gen</span> = quote! &#123;</span><br><span class="line">        <span class="keyword">impl</span> <span class="title class_">HelloMacro</span> <span class="keyword">for</span> #name &#123;</span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">hello_macro</span>() &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Hello, Macro! My name is &#123;&#125;&quot;</span>, <span class="built_in">stringify!</span>(#name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gen.<span class="title function_ invoke__">into</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将负责解析 TokenStream 的代码放入 <code>hello_macro_derive</code> 函数中</li>
<li><code>impl_hello_macro</code> 函数则只负责语法树</li>
<li>我们可以借助 <code>proc_macro</code> 包提供的编译器接口在代码中读取和操作 Rust 代码，由于它已经被内置在 Rust 中，因此不需要添加到 Cargo.toml 依赖中，syn 包用来将 Rust 代码从字符串转换为可供我们进一步操作的数据结构体，quote 包则将 syn 包产生的数据结构重新转换为 Rust 代码。这些工具可以让解析 Rust 代码更加轻松</li>
<li>当包的用户在某个类型标注 <code>[#derive(HelloMacro)]</code> 时，<code>hello_macro_derive</code> 函数就会被自动调用。这是因为我们在这个函数上标注了 <code>proc_macro_derive</code>，并在该属性中指定了可以匹配到的 trait 名称 <code>HelloMacro</code>。这也是大多数过程宏需要遵循的编写惯例</li>
<li><code>syn</code> 的 parse 函数接收一个 TokenStream 作为输入，并返回一个 DeviceInput 结构体作为结果，它表示解析后的 Rust 代码</li>
<li><code>impl_hello_macro</code> 函数的产出物是一个 TokenStream，它会被添加到使用这个宏的用户代码中，并使用户在编译自己的包时获得额外的功能</li>
<li><code>quote!</code> 宏允许我们的定义那些希望返回的 Rust 代码，<code>quote!</code> 宏的返回结果还需要通过 <code>into()</code> 方法将其转换为 TokenStream 类型</li>
<li><code>quote!</code> 宏也提供了一套模版机制，例如这里使用 <code>#name</code>替换为变量 <code>name</code> 中的值</li>
<li>这里我们编写的过程宏，就是为用户标注的类型生成一份 <code>HelloMacro trait</code> 的实现，而类型的名称可以通过 <code>#name</code> 得到</li>
<li><code>stringify!</code> 宏接收一个 Rust 表达式并在编译时将其转换为字符串字面量</li>
</ul>
<p>接下来我们在一个新的项目中使用该宏：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> hello_macro::HelloMacro;</span><br><span class="line"><span class="keyword">use</span> hello_macro_derive::HelloMacro;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(HelloMacro)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pancackes</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    Pancackes::<span class="title function_ invoke__">hello_macro</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, Macro! My name is Pancackes</span><br></pre></td></tr></table></figure>

<h4 id="属性宏"><a href="#属性宏" class="headerlink" title="属性宏"></a>属性宏</h4><p>属性宏与自定义派生宏类似，它允许你创建新的属性，而不是为 derive 属性生成代码。属性宏也更加灵活，因为 <code>derive</code> 宏只能用于结构体和枚举，而属性则可以用于其他条目，例如函数。如下是一个示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[route(GET, &quot;/&quot;)]</span></span><br><span class="line">fn <span class="function"><span class="title">index</span></span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 <code>#[route]</code> 属性是由框架本身作为一个过程宏来定义的，这个宏定义的函数签名如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[proc_macro_attribute]</span></span><br><span class="line">pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里 attr 是属性本身的内容，即这里的 <code>GET, &quot;/&quot;</code></li>
<li>item 则是该属性所所附件的条目，即这里的 <code>fn index() &#123;&#125;</code></li>
</ul>
<h4 id="函数宏"><a href="#函数宏" class="headerlink" title="函数宏"></a>函数宏</h4><p>函数宏用于定义出类似于函数调用的宏，但比普通函数更加灵活。不同于 <code>macro_rules</code> 只能使用类似于 match 的语法来进行定义。函数宏可以接受一个 TokenStream 作为参数，并与另外两种过程宏一样在定义中使用 Rust 代码来操作 TokenStream。</p>
<p>例如如下调用一个名为 <code>sql!</code> 的函数宏：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">sql</span> = sql!(SELECT * FROM posts WHERE id=<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>它会解析圆括号内的 SQL 语句语法的正确性，这要比 <code>macro_rules</code> 宏所做的事情复杂的多。它的定义应该是这个样子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[proc_macro]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sql</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/Rust/" rel="tag"># Rust</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2023/08/21/lua-programming-01/" rel="prev" title="《lua 程序设计》读书笔记（1）：Lua 语言入门">
      <i class="fa fa-chevron-left"></i> 《lua 程序设计》读书笔记（1）：Lua 语言入门
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2023/04/12/rust-programming-language-17/" rel="next" title="Rust 权威指南（17）：模式匹配">
      Rust 权威指南（17）：模式匹配 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84-Rust"><span class="nav-number">1.</span> <span class="nav-text">不安全的 Rust</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E8%B6%85%E8%83%BD%E5%8A%9B"><span class="nav-number">1.1.</span> <span class="nav-text">不安全的超能力</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%BC%95%E7%94%A8%E8%A3%B8%E6%8C%87%E9%92%88"><span class="nav-number">1.2.</span> <span class="nav-text">解引用裸指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E4%B8%8D%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0%E6%88%96%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">调用不安全函数或方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%88%96%E4%BF%AE%E6%94%B9%E4%B8%80%E4%B8%AA%E5%8F%AF%E5%8F%98%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="nav-number">1.4.</span> <span class="nav-text">访问或修改一个可变静态变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%AE%89%E5%85%A8-trait"><span class="nav-number">1.5.</span> <span class="nav-text">实现不安全 trait</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%AE%89%E5%85%A8%E4%BB%A3%E7%A0%81%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="nav-number">1.6.</span> <span class="nav-text">使用不安全代码的时机</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7-trait"><span class="nav-number">2.</span> <span class="nav-text">高级 trait</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8-trait-%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B%E6%8C%87%E5%AE%9A%E5%8D%A0%E4%BD%8D%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.</span> <span class="nav-text">在 trait 的定义中使用关联类型指定占位类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">2.2.</span> <span class="nav-text">默认泛型参数和运算符重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E4%BA%8E%E6%B6%88%E9%99%A4%E6%AD%A7%E4%B9%89%E7%9A%84%E5%AE%8C%E5%85%A8%E9%99%90%E5%AE%9A%E8%AF%AD%E6%B3%95%EF%BC%9A%E8%B0%83%E7%94%A8%E7%9B%B8%E5%90%8C%E5%90%8D%E7%A7%B0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">2.3.</span> <span class="nav-text">用于消除歧义的完全限定语法：调用相同名称的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E4%BA%8E%E5%9C%A8-trait-%E4%B8%AD%E9%99%84%E5%B8%A6%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA-trait-%E5%8A%9F%E8%83%BD%E7%9A%84%E8%B6%85-trait"><span class="nav-number">2.4.</span> <span class="nav-text">用于在 trait 中附带另外一个 trait 功能的超 trait</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-newtype-%E6%A8%A1%E5%BC%8F%E5%9C%A8%E5%A4%96%E9%83%A8%E7%B1%BB%E5%9E%8B%E4%B8%8A%E5%AE%9E%E7%8E%B0%E5%A4%96%E9%83%A8-trait"><span class="nav-number">2.5.</span> <span class="nav-text">使用 newtype 模式在外部类型上实现外部 trait</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">高级类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-newtype-%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E6%8A%BD%E8%B1%A1"><span class="nav-number">3.1.</span> <span class="nav-text">使用 newtype 模式实现类型安全与抽象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E5%88%9B%E5%BB%BA%E5%90%8C%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.2.</span> <span class="nav-text">使用类型别名创建同义类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B0%B8%E8%BF%9C%E4%B8%8D%E8%BF%94%E5%9B%9E%E7%9A%84-Never-%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.3.</span> <span class="nav-text">永远不返回的 Never 类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%A4%A7%E5%B0%8F%E7%B1%BB%E5%9E%8B%E5%92%8C-Sized-trait"><span class="nav-number">3.4.</span> <span class="nav-text">动态大小类型和 Sized trait</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0%E4%B8%8E%E9%97%AD%E5%8C%85"><span class="nav-number">4.</span> <span class="nav-text">高级函数与闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-number">4.1.</span> <span class="nav-text">函数指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E9%97%AD%E5%8C%85"><span class="nav-number">4.2.</span> <span class="nav-text">返回闭包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8F"><span class="nav-number">5.</span> <span class="nav-text">宏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8F%E4%B8%8E%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.</span> <span class="nav-text">宏与函数的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E4%BA%8E%E9%80%9A%E7%94%A8%E5%85%83%E7%BC%96%E7%A8%8B%E7%9A%84-macro-rules-%E5%A3%B0%E6%98%8E%E5%AE%8F"><span class="nav-number">5.2.</span> <span class="nav-text">用于通用元编程的 macro_rules! 声明宏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%B1%9E%E6%80%A7%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%87%E7%A8%8B%E5%AE%8F"><span class="nav-number">5.3.</span> <span class="nav-text">基于属性创建代码的过程宏</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89-derive-%E5%AE%8F"><span class="nav-number">5.3.1.</span> <span class="nav-text">编写一个自定义 derive 宏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E5%AE%8F"><span class="nav-number">5.3.2.</span> <span class="nav-text">属性宏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AE%8F"><span class="nav-number">5.3.3.</span> <span class="nav-text">函数宏</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">180</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
