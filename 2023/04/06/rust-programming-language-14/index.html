<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="指针是一个通用的概念，它指代那些包含内存地址的变量。Rust 中最常用的指针就是之前介绍过的 引用。引用是用 &amp; 符号表示的，会借用它所指向的值。引用除了指向数据之外没有任何其他功能，也没有任何开销，它是 Rust 中最常见的指针。而智能指针（smart pointer）则是一些数据结构，它们的行为类似于指针但是拥有额外的元数据和附件功能。Rust 标准库中不同的智能指针提供了比引用更为强">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust 权威指南（14）：智能指针">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2023/04/06/rust-programming-language-14/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="指针是一个通用的概念，它指代那些包含内存地址的变量。Rust 中最常用的指针就是之前介绍过的 引用。引用是用 &amp; 符号表示的，会借用它所指向的值。引用除了指向数据之外没有任何其他功能，也没有任何开销，它是 Rust 中最常见的指针。而智能指针（smart pointer）则是一些数据结构，它们的行为类似于指针但是拥有额外的元数据和附件功能。Rust 标准库中不同的智能指针提供了比引用更为强">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-04-06T12:20:52.000Z">
<meta property="article:modified_time" content="2024-05-05T08:40:18.408Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="Rust">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2023/04/06/rust-programming-language-14/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Rust 权威指南（14）：智能指针 | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2023/04/06/rust-programming-language-14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Rust 权威指南（14）：智能指针
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-06 20:20:52" itemprop="dateCreated datePublished" datetime="2023-04-06T20:20:52+08:00">2023-04-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/Rust/" itemprop="url" rel="index"><span itemprop="name">Rust</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>指针是一个通用的概念，它指代那些包含内存地址的变量。Rust 中最常用的指针就是之前介绍过的 <code>引用</code>。引用是用 <code>&amp;</code> 符号表示的，会借用它所指向的值。<strong>引用除了指向数据之外没有任何其他功能，也没有任何开销，它是 Rust 中最常见的指针</strong>。而智能指针（smart pointer）则是一些数据结构，它们的行为类似于指针但是拥有额外的元数据和附件功能。Rust 标准库中不同的智能指针提供了比引用更为强大的功能。</p>
<span id="more"></span>

<p>在拥有所有权和借用概念的 Rust 中，引用和智能指针之间还有另外一个差别：引用是只借用数据的指针，而相反地，大多数智能指针本身就拥有它们指向的数据。其实 <code>String</code> 和 <code>Vec&lt;T&gt;</code> 也可以算作智能指针，它们都拥有一片内存区域并允许用户对其进行操作，它们还拥有元数据（例如容量等），并提供额外功能。</p>
<p>通常会使用结构体来实现智能指针，但区别于一般结构体的地方在于它们会实现 Deref 和 Drop 这两个 trait：</p>
<ul>
<li>Deref trait 使得智能指针结构体的实例拥有与引用一致的行为，它使得你可以编写出同时用于引用和智能指针的代码</li>
<li>Drop trait 则使你可以自定义智能指针离开作用域时运行的代码</li>
</ul>
<h2 id="使用-Box-lt-T-gt-在堆上分配数据"><a href="#使用-Box-lt-T-gt-在堆上分配数据" class="headerlink" title="使用 Box&lt;T&gt; 在堆上分配数据"></a>使用 <code>Box&lt;T&gt;</code> 在堆上分配数据</h2><p><code>Box&lt;T&gt;</code> 是最简单直接的智能指针，它可以让我们将数据存储在堆上，并在栈中保留一个指向堆数据的指针。<code>Box&lt;T&gt;</code> 常被用于以下场景：</p>
<ul>
<li>当拥有一个无法在编译时确定大小的类型，但又想在一个要求固定尺寸的上下文环境中使用这个类型的值时</li>
<li>当需要传递大量数据的所有权，但又不希望产生大量数据的复制行为时</li>
<li>当希望拥有一个实现了指定 trait 类型的值时，但又不关心具体的类型时</li>
</ul>
<p>如下是一个简单示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中用来访问 <code>Box&lt;T&gt;</code> 数据的语法与访问栈数据的语法非常类似。另外，和其他任何拥有所有权的值一样，<code>Box&lt;T&gt;</code> 会在离开自己作用域时被释放，被释放的东西除了存储在栈上的指针，还有它指向的那些堆数据。</p>
<h3 id="使用-Box-lt-T-gt-定义递归类型"><a href="#使用-Box-lt-T-gt-定义递归类型" class="headerlink" title="使用 Box&lt;T&gt; 定义递归类型"></a>使用 <code>Box&lt;T&gt;</code> 定义递归类型</h3><p>Rust 在编译时必须知道每一种类型占据的空间大小，但是递归类型却无法在编译时确定具体大小。由于 <code>Box&lt;T&gt;</code> 拥有固定的大小，因此我们可以在递归类型定义中使用 <code>Box&lt;T&gt;</code> 即可。</p>
<p>如下尝试用一个枚举定义一个链接列表：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, List),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">l</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">1</span>, <span class="title function_ invoke__">Cons</span>(<span class="number">2</span>, <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, Nil)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码无法编译通过，因为无法确定 <code>List</code> 类型的具体大小：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">error[E0072]: recursive <span class="built_in">type</span> `List` has infinite size</span><br><span class="line"> --&gt; src/main.rs:1:1</span><br><span class="line">  |</span><br><span class="line">1 | enum List &#123;</span><br><span class="line">  | ^^^^^^^^^</span><br><span class="line">2 |     Cons(i32, List),</span><br><span class="line">  |               ---- recursive without indirection</span><br><span class="line">  |</span><br><span class="line"><span class="built_in">help</span>: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to <span class="built_in">break</span> the cycle</span><br><span class="line">  |</span><br><span class="line">2 |     Cons(i32, Box&lt;List&gt;),</span><br><span class="line">  |               ++++    +</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0072`.</span><br></pre></td></tr></table></figure>

<p>其实 Rust 已经给出了建议，<code>indirection</code> 意味着需要改变数据结构来存储指向这个值的指针，而不是直接存储这个值。因为 <code>Box&lt;T&gt;</code> 是一个指针，所以 Rust 总是可以确定 <code>Box&lt;T&gt;</code> 的具体大小：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">l</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">1</span>,</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">2</span>,</span><br><span class="line">            <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">3</span>,</span><br><span class="line">                <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了间接访问内存和堆分配之外，<code>Box&lt;T&gt;</code> 并没有提供其他特殊功能。<code>Box&lt;T&gt;</code> 属于智能指针的一种，因为它实现了 <code>Deref trait</code>，并允许我们将 <code>Box&lt;T&gt;</code> 的值当做引用对待。当一个 <code>Box&lt;T&gt;</code> 离开作用域时，由于它实现了 <code>Drop trait</code>，因此 <code>Box&lt;T&gt;</code> 指向的堆数据会自动释放。</p>
<h2 id="通过-Deref-trait-将智能指针视作常规引用"><a href="#通过-Deref-trait-将智能指针视作常规引用" class="headerlink" title="通过 Deref trait 将智能指针视作常规引用"></a>通过 <code>Deref trait</code> 将智能指针视作常规引用</h2><p>实现 <code>Deref trait</code> 使得我们可以自定义 <code>解引用运算符</code>（dereference operator）* 的行为。通过实现 Deref，可以将智能指针视为常规引用来进行处理，这也就意味着原先处理引用的代码可以不加修改地用于处理智能指针。</p>
<h3 id="使用解引用运算符跳转到指针指向的值"><a href="#使用解引用运算符跳转到指针指向的值" class="headerlink" title="使用解引用运算符跳转到指针指向的值"></a>使用解引用运算符跳转到指针指向的值</h3><p><strong>常规引用就是一种类型的指针</strong>。如下代码中，对于变量 y，我们需要使用解引用运算符 <code>*</code> 来跟踪引用并跳转到它指向的值（即解引用）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>由于数值和引用是两种不同的类型，所以不能直接比较这两者</strong>。对于上述代码，也可以使用 <code>Box&lt;T&gt;</code> 来替换引用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义自己的智能指针"><a href="#定义自己的智能指针" class="headerlink" title="定义自己的智能指针"></a>定义自己的智能指针</h3><p>接下来将实现一个类似于 <code>Box&lt;T&gt;</code> 类型的智能指针：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T) <span class="punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = MyBox::<span class="title function_ invoke__">new</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义了一个名为 MyBox 的结构体，它带有泛型参数 T，它也是一个拥有 T 类型单元素的元组结构体</li>
<li>为了支持使用 <code>*</code> 完成解引用操作，需要实现 Deref trait。标准库的 Deref trait 要求我们实现一个 deref 方法，该方法会借用 self 并返回一个指向内部数据的引用<ul>
<li>type Target &#x3D; T 定义了 Deref trait 的一个关联类型，关联类型是一种有些不同的泛型参数定义方式，后续会详细介绍</li>
<li>在 <code>deref</code> 方法中填入了 <code>&amp;self.0</code>，因此返回一个指向值的引用，所以允许调用者通过 <code>*</code> 运算符访问值</li>
</ul>
</li>
</ul>
<p>在没有 Deref trait 的情形下，编译器只能对 <code>&amp;</code> 形式的常规引用执行解引用操作。deref 方法可以让编译器从任何实现了 Deref 类型中获取值，<strong>并且能够调用 deref 方法获得一个可以进行解引用的引用</strong>。上述代码 <code>*y</code> 等效于：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(y.<span class="title function_ invoke__">deref</span>())</span><br></pre></td></tr></table></figure>

<p><strong>需要注意，这种将 * 运算符替换为 deref 方法和另外一个朴素 * 运算符的过程，对代码中的每一个 <code>*</code> 都只会进行一次</strong>。</p>
<h3 id="函数和方法的隐式解引用转换"><a href="#函数和方法的隐式解引用转换" class="headerlink" title="函数和方法的隐式解引用转换"></a>函数和方法的隐式解引用转换</h3><p><strong>解应用转换是 Rust 为函数&#x2F;方法的参数提供的一种便捷特性。当某个类型实现了 Deref trait 时，它能够将 T 的引用转换为 T 经过 Deref 操作后生成的引用。当我们将某个类型的值引用作为参数传递给函数或者方法时，但传入的类型和参数类型不一致时，解引用转换就会自动发生。编译器会插入一系列的 deref 方法调用来将我们提供的类型转换为参数所需的类型</strong>。</p>
<p>Rust 通过实现解引用转换功能，使能在方法或函数调用时无需多次显式地使用 &amp; 和 * 运算符来进行引用和解引用操作。如下是一个示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">hello</span>(name: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;&#125;&quot;</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">hello</span>(<span class="string">&quot;rust&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">m</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;rust&quot;</span>));</span><br><span class="line"><span class="title function_ invoke__">hello</span>(&amp;m);</span><br><span class="line"><span class="title function_ invoke__">hello</span>(&amp;(*m)[..]);</span><br></pre></td></tr></table></figure>

<p>由于 <code>&amp;m</code> 是一个指向 MyBox<String> 值的引用，因为我们的 <code>MyBox&lt;T&gt;</code> 实现了 Deref trait，所以 Rust 可以通过 deref 来将 <code>&amp;MyBox&lt;String&gt;</code> 转换为 <code>&amp;String</code>。又因为标准库 <code>String</code> 提供的 Deref 操作实现会返回字符串切片，所以 Rust 可以继续调用 deref 来将 <code>&amp;String</code> 转换为 <code>&amp;str</code>，最终与 hello 函数定义相匹配。</p>
<p>而 <code>&amp;(*m)[..]</code> 则是复杂写法：</p>
<ul>
<li><code>*m</code> 对 <code>MyBox&lt;String&gt;</code> 进行解引用得到 String</li>
<li>通过 <code>&amp;</code> 和 <code>[..]</code> 来获取包含整个 String 的<strong>字符串切片</strong></li>
</ul>
<p>只要代码涉及的类型实现了 Deref trait，Rust 就会自动分析类型并不断尝试插入 <code>Deref::deref</code> 来获得与参数类型匹配的引用。该过程在编译时完成，所以解引用转换不会带来任何运行时开销。</p>
<h3 id="解引用转换与可变性"><a href="#解引用转换与可变性" class="headerlink" title="解引用转换与可变性"></a>解引用转换与可变性</h3><p>使用 <code>Deref trait</code> 能够重载不可变引用的 * 运算符，类似地，DerefMut trait 可以重载可变引用的 * 运算符。Rust 会在类型与 trait 满足下面三种情形时执行解引用转换：</p>
<ul>
<li>当 T：Deref&lt;Target&#x3D;U&gt; 时，允许 &amp;T 转换为 &amp;U</li>
<li>当 T：DerefMut&lt;Target&#x3D;U&gt; 时，允许 &amp;mut T 转换为 &amp;mut U</li>
<li>当 T：Deref&lt;Target&#x3D;U&gt; 时，允许 &amp;mut T 转换为 &amp;U</li>
</ul>
<p>第三种情况说明 Rust 可以将一个可变引用自动的转换为一个不可变引用。但这个过程不可逆，即不可变引用永远不能转换为可变引用。</p>
<h2 id="借助-Drop-trait-在清理时运行代码"><a href="#借助-Drop-trait-在清理时运行代码" class="headerlink" title="借助 Drop trait 在清理时运行代码"></a>借助 Drop trait 在清理时运行代码</h2><p>另一个对智能指针十分重要的 trait 就是 Drop，它允许我们在变量离开作用域时执行某些自定义操作。可以为任意一个类型执行一个 Drop trait，它尝尝被用来释放诸如文件、网络等连接资源。几乎所有智能指针的实现都会用到这一 trait。</p>
<p>Drop trait 要求实现一个接收 self 可变引用作为参数的 drop 函数。如下是一个示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomSmartPointer</span> &#123;</span><br><span class="line">    data: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">CustomSmartPointer</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Dropping CustomSmartPointer with data &#123;&#125;&quot;</span>, <span class="keyword">self</span>.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = CustomSmartPointer&#123;data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;c stuff&quot;</span>)&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d</span> = CustomSmartPointer&#123;data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;d stuff&quot;</span>)&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;CustomSmartPointer created&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Drop trait 已经被包含在了预导入模块中，所以不需要显式导入作用域</li>
<li>Rust 实例离开作用域时自动调用了我们编写的 Drop 代码，变量的丢弃顺序与创建顺序相反</li>
</ul>
<p>我们不能禁止一个值离开作用域时自动插入 Drop，也无法手动调用 Drop trait 的 drop 方法（也被称为析构方法），但是可以调用标准库中的 <code>std::mem::drop</code> 函数来提前清理某个值。<code>std::mem::drop</code> 函数接收需要提前丢弃的值作为参数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomSmartPointer</span> &#123;</span><br><span class="line">    data: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">CustomSmartPointer</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Dropping CustomSmartPointer with data &#123;&#125;&quot;</span>, <span class="keyword">self</span>.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = CustomSmartPointer&#123;data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;c stuff&quot;</span>)&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d</span> = CustomSmartPointer&#123;data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;d stuff&quot;</span>)&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;CustomSmartPointer created&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(c);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;CustomSmartPointer c dropped before main end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CustomSmartPointer created</span><br><span class="line">Dropping CustomSmartPointer with data c stuff</span><br><span class="line">CustomSmartPointer c dropped before main end</span><br><span class="line">Dropping CustomSmartPointer with data d stuff</span><br></pre></td></tr></table></figure>

<p>所有权系统会保证所有的引用有效，而 drop 只会在确定不再使用这个值时被调用一次。</p>
<h2 id="基于引用计数的智能指针-Rc"><a href="#基于引用计数的智能指针-Rc" class="headerlink" title="基于引用计数的智能指针 Rc"></a>基于引用计数的智能指针 Rc<T></h2><p>Rust 提供了一个名为 <code>Rc&lt;T&gt;</code> 的类型来支持多重所有权。Rc 是 Reference counting（引用计数）的缩写。它的实例会在内部维护一个用于记录值引用次数的计数器，从而确认该值是否仍然在使用。如果一个值的引用计数为 0，则该值可以被安全释放，而不会触发引用失效问题。<code>Rc&lt;T&gt;</code> 只能用于单线程场景。</p>
<p>如下代码会出现编译错误：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>,</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于整个 a 列表会在我们创建 b 列表时被移动至 b 中，所以 b 列表持有了 a 列表的所有权，之后 c 就无法再持有 a 了。虽然我们可以改变 Cons 的定义让它持有一个引用而不是所有权，并为其指定对应的生命周期参数。但是这个生命周期参数会要求列表中所有元素的存活时间都至少和列表本身一样长。</p>
<p>如下使用 <code>Rc&lt;T&gt;</code> 来解决这个问题，每次调用 <code>Rc::clone</code> 都会使得引用计数增加，而 Rc<List> 智能指针中的数据只有在引用计数器减少为 0 时才会被真正清理掉。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>,</span><br><span class="line">        Rc::<span class="title function_ invoke__">new</span>(Nil)));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Rc&lt;T&gt;</code> 没有包含在预导入模块中，所以需要使用 use 语句将它引入作用域中</li>
<li>可以使用 <code>Rc::strong_count</code> 来读取引用计数</li>
<li><code>Rc&lt;T&gt;</code> 的 Drop 实现会在 <code>Rc&lt;T&gt;</code> 离开作用域时自动将引用计数减 1</li>
</ul>
<p>使用 <code>Rc&lt;T&gt;</code> 可以让单个值拥有多个所有者，而引用计数机制则保证了这个值会在其拥有的所有者存活时一直有效，并在所有者离开作用域时被自动清理。需要注意，<code>Rc&lt;T&gt;</code> 通过不可变引用使你可以在程序的不同部分之间共享只读数据。</p>
<h2 id="RefCell-lt-T-gt-和内部可变性模式"><a href="#RefCell-lt-T-gt-和内部可变性模式" class="headerlink" title="RefCell&lt;T&gt; 和内部可变性模式"></a><code>RefCell&lt;T&gt;</code> 和内部可变性模式</h2><p>内部可变性（interior mutability）是 Rust 的设计模式之一，它允许你在只持有不可变引用的前提下对数据进行修改，通常类似行为会被借用规则所禁止。为了能够改变数据，内部可变性模式在它的数据结构中使用了 unsafe 代码来绕过 Rust 正常的可变性和借用规则。<strong>假如我们能够保证自己的代码在运行时符合借用规则，那么即使编译器无法在编译阶段保证符合借用规则，也能使用那些采取了内部可变性模式的类型</strong>。实现过程中不安全的代码被封装在安全的 API 内，而类型本身从外部看来依然是不可变的。<code>RefCell&lt;T&gt;</code> 就是一种使用了内部可变性模式的类型。</p>
<p><strong>对于使用一般引用和 Box<T> 的代码，Rust 会在编译阶段强制代码遵守借用规则，而对于使用 RefCell<T> 的代码，Rust 则只会在运行时检查这些规则，并在出现违反借用规则的情况下触发 panic 来提前中止程序</strong>。编译期检查借用规则可以帮助我们在开发阶段尽早暴露出问题，而且不会带来任何运行时开销。而运行时检查借用规则可以使我们实现某些特定的内存安全场景，即便这些场景无法通过编译时检查。与 <code>Rc&lt;T&gt;</code> 类似，<code>RefCell&lt;T&gt;</code> 也只能用于单线程场景中。</p>
<p>内部可变性模式允许用户更改一个不可变值的内部数据。某些情况下，我们会需要一个值在对外保持不可变性的同时能够在方法内部修改自身。除了这个值本身的方法，其余的代码依然不能修改这个值。RefCell<T> 就是获得这种内部可变性的一种方法。但是 RefCell<T> 并没有完全绕开借用规则：虽然使用内部可变性通过了编译阶段的借用检查，但是借用检查的工作仅仅是被延后到了运行阶段。如果违反了借用规则，就会得到一个 panic! 运行时错误。</p>
<p>我们在创建不可变和可变引用时分别使用语法 <code>&amp;</code> 和 <code>&amp;mut</code>，对于 <code>RefCell&lt;T&gt;</code> 则是通过如下方式：</p>
<ul>
<li>通过调用 <code>RefCell&lt;T&gt;</code> 的 borrow 方法，可以获取 RefCell<T> 内部值的不可变引用</li>
<li>通过调用 <code>RefCell&lt;T&gt;</code> 的 borrow_mut 方法可以获取 RefCell<T> 内部值的可变引用</li>
</ul>
<p>其实这两个方法分别返回的是 <code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code> 这两种智能指针，这两种智能指针都实现了 Deref，所以可以当做一般的引用来对待。RefCell<T> 会记录当前活跃的 Ref<T> 和 RefMut<T> 智能指针个数，基于这些信息来维护和编译器同样的借用规则：在任何一个给定的时间只允许拥有多个不可变借用或者一个可变借用。违背借用规则时会在运行时触发 panic。</p>
<p>使用 RefCell<T> 可以让我们在不可变的环境中修改自身数据，只要能够正确做出取舍，就可以借助 RefCell<T> 来完成某些常规引用无法完成的功能。</p>
<p>将 RefCell<T> 和 Rc<T> 结合使用是一种常见用法，Rc<T> 允许多个持有者持有同一数据，但是只能提供针对数据的不可变访问，如果我们在 <code>Rc&lt;T&gt;</code> 内存储了 <code>RefCell&lt;T&gt;</code>，那么就可以拥有多个所有者且能够进行修改的值了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">use std::rc::Rc;</span><br><span class="line">use std::cell::RefCell;</span><br><span class="line"></span><br><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> value = Rc::new(RefCell::new(5));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">let</span> a = Rc::<span class="built_in">clone</span>(&amp;value);</span><br><span class="line"></span><br><span class="line">    *a.borrow_mut() = 10;</span><br><span class="line">    println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标准库还提供了其他一些类型来实现内部可见性，例如 <code>Cell&lt;T&gt;</code> 或者 <code>Mutex&lt;T&gt;</code>，具体参考标准库文档。</p>
<h2 id="循环引用会造成内存泄漏"><a href="#循环引用会造成内存泄漏" class="headerlink" title="循环引用会造成内存泄漏"></a>循环引用会造成内存泄漏</h2><p>Rust 提供的内存安全机制可以让我们很难在程序中制造出 <code>永远不会释放的内存空间</code>（即内存泄漏），但也并非是不可能的。通过使用 <code>Rc&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 看到 Rust 是会出现内存泄漏的：我们能够创建出相互引用成环状的实例，由于环中每一个指针的引用计数都不可能减少为 0，所以对应的值也不会被丢弃，从而造成内存泄漏。</p>
<p>如果程序中存在 RefCell<T> 包含了 Rc<T> 或其他联用了内部可变性与引用计数的情形，那么你就需要自行确保不会在代码中创建出循环引用。</p>
<p>我们可以通过 <code>Rc::downgrade</code> 函数创建出 Rc<T> 实例中值的弱引用。使用 <code>Rc&lt;T&gt;</code> 的引用来调用 <code>Rc::downgrade</code> 函数会返回一个类型为 <code>Weak&lt;T&gt;</code> 的智能指针，它会让 <code>Rc&lt;T&gt;</code> 的 weak_count 计数增加 1，而不会改变 strong_count。Rc<T> 并不会在执行清理操作前要求 weak_count 为 0。弱引用不会造成循环引用。</p>
<p>由于我们无法确定 <code>Weak&lt;T&gt;</code> 引用的值是否已经被释放，所以在使用 <code>Weak&lt;T&gt;</code> 指向的值之前，需要使用 <code>Weak&lt;T&gt;</code> 的 upgrade 方法来确认它所指向的值依然存在，它返回一个 Option 类型，所以 Rust 能够确保不会 Some 和 None 两个分支都得到妥善处理，不会产生无效指针。</p>
<p><strong>通过在形成的环状实例中让某些指向关系持有所有权，并让另外某些指向关系不持有所有权，可以避免循环引用</strong>。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/Rust/" rel="tag"># Rust</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2023/04/08/rust-programming-language-15/" rel="prev" title="Rust 权威指南（15）：无畏并发">
      <i class="fa fa-chevron-left"></i> Rust 权威指南（15）：无畏并发
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2023/04/06/rust-programming-language-13/" rel="next" title="Rust 权威指南（13）：进一步认识 Cargo 及 crates.io">
      Rust 权威指南（13）：进一步认识 Cargo 及 crates.io <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Box-lt-T-gt-%E5%9C%A8%E5%A0%86%E4%B8%8A%E5%88%86%E9%85%8D%E6%95%B0%E6%8D%AE"><span class="nav-number">1.</span> <span class="nav-text">使用 Box&lt;T&gt; 在堆上分配数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Box-lt-T-gt-%E5%AE%9A%E4%B9%89%E9%80%92%E5%BD%92%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">使用 Box&lt;T&gt; 定义递归类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-Deref-trait-%E5%B0%86%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%A7%86%E4%BD%9C%E5%B8%B8%E8%A7%84%E5%BC%95%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">通过 Deref trait 将智能指针视作常规引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%A3%E5%BC%95%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E8%B7%B3%E8%BD%AC%E5%88%B0%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E5%80%BC"><span class="nav-number">2.1.</span> <span class="nav-text">使用解引用运算符跳转到指针指向的值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">2.2.</span> <span class="nav-text">定义自己的智能指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E9%9A%90%E5%BC%8F%E8%A7%A3%E5%BC%95%E7%94%A8%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.3.</span> <span class="nav-text">函数和方法的隐式解引用转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%BC%95%E7%94%A8%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="nav-number">2.4.</span> <span class="nav-text">解引用转换与可变性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%80%9F%E5%8A%A9-Drop-trait-%E5%9C%A8%E6%B8%85%E7%90%86%E6%97%B6%E8%BF%90%E8%A1%8C%E4%BB%A3%E7%A0%81"><span class="nav-number">3.</span> <span class="nav-text">借助 Drop trait 在清理时运行代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-Rc"><span class="nav-number">4.</span> <span class="nav-text">基于引用计数的智能指针 Rc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RefCell-lt-T-gt-%E5%92%8C%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.</span> <span class="nav-text">RefCell&lt;T&gt; 和内部可变性模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">6.</span> <span class="nav-text">循环引用会造成内存泄漏</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">171</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
