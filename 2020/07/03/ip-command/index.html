<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="iproute2 是 Linux 系统上提供的网络管理套件，用于取代之前 Linux 系统上提供的网络管理命令（例如 ifconfig、arp、route 等命令）。其主要包括 ip、tc 以及其他一些命令。虽然为了向后兼容，Linux 系统仍然提供了 ifconfig 等命令，但是这些命令已经不支持新的特性，例如 network namespace 等，甚至很多新 Linux 发行版本已经不再包">
<meta property="og:type" content="article">
<meta property="og:title" content="ip 命令概览">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2020/07/03/ip-command/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="iproute2 是 Linux 系统上提供的网络管理套件，用于取代之前 Linux 系统上提供的网络管理命令（例如 ifconfig、arp、route 等命令）。其主要包括 ip、tc 以及其他一些命令。虽然为了向后兼容，Linux 系统仍然提供了 ifconfig 等命令，但是这些命令已经不支持新的特性，例如 network namespace 等，甚至很多新 Linux 发行版本已经不再包">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-07-03T03:12:55.000Z">
<meta property="article:modified_time" content="2023-12-15T03:04:04.488Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="Network">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2020/07/03/ip-command/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>ip 命令概览 | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2020/07/03/ip-command/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ip 命令概览
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-03 11:12:55" itemprop="dateCreated datePublished" datetime="2020-07-03T11:12:55+08:00">2020-07-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/Network/" itemprop="url" rel="index"><span itemprop="name">Network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>iproute2 是 Linux 系统上提供的网络管理套件，用于取代之前 Linux 系统上提供的网络管理命令（例如 ifconfig、arp、route 等命令）。其主要包括 ip、tc 以及其他一些命令。虽然为了向后兼容，Linux 系统仍然提供了 ifconfig 等命令，但是这些命令已经不支持新的特性，例如 network namespace 等，甚至很多新 Linux 发行版本已经不再包含这些陈旧的网络管理命令了。这篇文章将学习 iproute2 中 ip 命令的使用。</p>
<p>其实 iproute2 早在 2000 年就已经存在了，但是其文档比较少，导致很多人并不怎么使用这些新的命令。iproute2 能够让你对 Linux 的网络特性有更多的控制手段，同时也能丰富你的调试工具箱。</p>
<span id="more"></span>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>IP 命令的格式为 <code>ip [ OPTIONS ] OBJECT &#123; COMMAND | help &#125;</code>。其中，OBJECT 为 link、address、route 等等，而不同 OBJECT 能够使用的 OPTIONS 和 COMMAND 也有所不同。这里需要强调，OPTIONS 、OBJECT、COMMAND 之间的顺序是不能改变的，否则会出现命令解析错误。</p>
<p>ip 命令中的很多部分可以简写，但是本文统一使用命令的标准形式，这方便于理解与记忆。另外，很多 ip 配置命令需要 root 权限。</p>
<p>iproute2 提供了不同选项，以支持格式化其输出内容：</p>
<ul>
<li>-o (–oneline)：用反斜线取代每一个换行符</li>
<li>-br (–brief)：产生简洁的、面向机器的输出内容，以便对输出使用 awk&#x2F;sed 等文本解析命令</li>
<li>-j (json)：产生 JSON 格式的输出。其支持使用 –pretty 以及 –brief 选项来改变格式以及输出的详细程度</li>
</ul>
<h2 id="地址管理"><a href="#地址管理" class="headerlink" title="地址管理"></a>地址管理</h2><p>ip address 用于管理 IP 地址。</p>
<h3 id="显示-IP-地址"><a href="#显示-IP-地址" class="headerlink" title="显示 IP 地址"></a>显示 IP 地址</h3><p>显示所有接口 IP 地址，可以使用 -4 或 -6 选项来只显示 IPv4 或 IPv6 地址</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip address show</span><br><span class="line">ip -4 address show</span><br><span class="line">ip -6 address show</span><br></pre></td></tr></table></figure>

<p>显示指定接口的 IP 地址</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip address show <span class="variable">$&#123;interface name&#125;</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ ip address show lo</span><br></pre></td></tr></table></figure>

<ul>
<li>只显示运行的接口的 IP 地址</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip address show up</span><br></pre></td></tr></table></figure>

<ul>
<li>只显示静态或动态配置的 地址</li>
</ul>
<p>只显示静态配置的地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip address show [dev <span class="variable">$&#123;interface&#125;</span>] permanent</span><br></pre></td></tr></table></figure>

<p>只显示动态分配的地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip address show [dev <span class="variable">$&#123;interface&#125;</span>] dynamic</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ip address show dev ens32 permanent</span><br><span class="line">2: ens32: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 00:0c:29:40:81:a0 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet6 fe80::b8f:2cae:5d8c:7d1b/64 scope <span class="built_in">link</span></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line">$ ip address show dev ens32 dynamic</span><br><span class="line">2: ens32: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 00:0c:29:40:81:a0 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.204.145/24 brd 192.168.204.255 scope global dynamic ens32</span><br><span class="line">       valid_lft 1092sec preferred_lft 1092sec</span><br></pre></td></tr></table></figure>

<h3 id="添加-IP-地址"><a href="#添加-IP-地址" class="headerlink" title="添加 IP 地址"></a>添加 IP 地址</h3><p>使用如下命令向指定接口添加 IP 地址，这里 ${address} 使用点分十进制格式指定，${mask} 可以使用点分十进制格式，也可以使用前缀长度格式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip address add <span class="variable">$&#123;address&#125;</span>/<span class="variable">$&#123;mask&#125;</span> dev <span class="variable">$&#123;interface name&#125;</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ip address add 127.0.0.2/255.0.0.0 dev lo</span><br><span class="line">$ sudo ip address add 127.0.0.3/8 dev lo</span><br><span class="line">$ ip -4 address show lo</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet 127.0.0.2/8 scope host secondary lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet 127.0.0.3/8 scope host secondary lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<p>可以在一个接口上添加多个 IP 地址，目的地址为这些 IP 地址的 IP 报文都会被系统接受。而对于从该接口上发出去的 IP 报文，默认将使用该接口上配置的第一个 IP 地址，也被称 primary IP 地址，其他的 IP 地址则被称为 secondary IP 地址。</p>
<p>另外，使用如下命令为 IPv4 地址添加可读的描述信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip address add <span class="variable">$&#123;address&#125;</span>/<span class="variable">$&#123;mask&#125;</span> dev <span class="variable">$&#123;interface name&#125;</span> label <span class="variable">$&#123;interface name&#125;</span>:<span class="variable">$&#123;description&#125;</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ip address add 127.0.0.4/8 dev lo label lo:LoopbackInterface</span><br><span class="line">RTNETLINK answers: Numerical result out of range</span><br><span class="line">$ sudo ip address add 127.0.0.4/8 dev lo label lo:LoopbackIP</span><br></pre></td></tr></table></figure>

<p>label 必须以接口名作为起始，之后使用 : 隔开描述信息。整个 label 字符串不能超过 16 个字符，否则会出现错误提示。另外，对于 IPv6 地址，该命令的 label 子命令没有效果。也就是说只会添加 IPv6 地址，无法设置 label 描述信息。</p>
<h3 id="删除地址"><a href="#删除地址" class="headerlink" title="删除地址"></a>删除地址</h3><p>使用如下命令，从接口上删除一个 IP 地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip address delete <span class="variable">$&#123;address&#125;</span>/<span class="variable">$&#123;prefix&#125;</span> dev <span class="variable">$&#123;interface name&#125;</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~$ sudo ip address delete 127.0.0.4/8 dev lo</span><br><span class="line">~$ sudo ip address delete 127.0.0.3/8 dev lo</span><br><span class="line">~$ sudo ip address delete 127.0.0.2/8 dev lo</span><br><span class="line">~$ ip --brief -4 address show lo</span><br><span class="line">lo               UNKNOWN        127.0.0.1/8</span><br></pre></td></tr></table></figure>

<p>需要注意，interface 是必须指定的，因为 Linux 允许在多个接口上配置同一个 IP 地址。</p>
<h3 id="删除所有地址"><a href="#删除所有地址" class="headerlink" title="删除所有地址"></a>删除所有地址</h3><p>使用如下命令删除一个接口下的所有 IP 地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip address flush dev <span class="variable">$&#123;interface name&#125;</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ip --brief address show lo</span><br><span class="line">lo               UNKNOWN        127.0.0.1/8 ::1/128</span><br><span class="line">$ sudo ip -6 address flush dev lo</span><br><span class="line">$ ip --brief address show lo</span><br><span class="line">lo               UNKNOWN        127.0.0.1/8</span><br></pre></td></tr></table></figure>

<p>默认情况下该命令移除该接口下所有的 IPv4 和 IPv6 地址，如果你想仅移除 IPv4 或 IPv6 地址，可以使用 -4 或 -6 选项。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>没有办法交换接口上的 primary 地址和 secondary 地址，因此总是应该首先设置 primary 地址。但是如果 sysctl 变量 <code>net.ipv4.conf.$&#123;interface&#125;.promote_secondaries</code> 被设置为 1 时，当 primary 地址被删除后，第一个 secondary 地址将变成 primary 地址。如果该变量设置为 0，那么当删除 primary 地址，该接口上的所有地址都会被删除。另外，变量 <code>net.ipv4.conf.default.promote_secondaries</code> 的值也会影响其行为。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl net.ipv4.conf.default.promote_secondaries</span><br><span class="line">net.ipv4.conf.default.promote_secondaries = 0</span><br><span class="line">$ sysctl net.ipv4.conf.lo.promote_secondaries</span><br><span class="line">net.ipv4.conf.lo.promote_secondaries = 0</span><br></pre></td></tr></table></figure>

<p>而对于 IPv6 地址，如果 primary 地址被删除了，那么第一个 secondary 地址将总是提升为 primary 地址，而无需关心 systemctl 设置。</p>
<h2 id="邻接表（ARP、ND）管理"><a href="#邻接表（ARP、ND）管理" class="headerlink" title="邻接表（ARP、ND）管理"></a>邻接表（ARP、ND）管理</h2><h3 id="显示邻接表"><a href="#显示邻接表" class="headerlink" title="显示邻接表"></a>显示邻接表</h3><ul>
<li>显示这个邻接表</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip neighbor show</span><br></pre></td></tr></table></figure>

<p>这里 show 命令支持 -4 和 -6 选项，以只查看 IPv4（ARP）和 IPv6（ND）邻居。默认所有的邻居都会显示。</p>
<ul>
<li>只显示单个接口上的邻居</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip neighbor show dev <span class="variable">$&#123;interface name&#125;</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ip neighbor show dev ens32</span><br><span class="line">192.168.204.2 lladdr 00:50:56:f4:ca:d8 REACHABLE</span><br><span class="line">192.168.204.1 lladdr 00:50:56:c0:00:08 REACHABLE</span><br></pre></td></tr></table></figure>

<h3 id="清空接口上的邻接表"><a href="#清空接口上的邻接表" class="headerlink" title="清空接口上的邻接表"></a>清空接口上的邻接表</h3><p>使用如下命令清空指定接口上的邻接表</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip neighbor flush dev <span class="variable">$&#123;interface name&#125;</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ip neighbor flush dev lo</span><br></pre></td></tr></table></figure>

<h3 id="添加邻接表项"><a href="#添加邻接表项" class="headerlink" title="添加邻接表项"></a>添加邻接表项</h3><p>使用如下命令在一个接口上添加一条邻接表项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip neighbor add <span class="variable">$&#123;network address&#125;</span> lladdr <span class="variable">$&#123;link layer address&#125;</span> dev <span class="variable">$&#123;interface name&#125;</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ip neighbor add 192.168.204.3 lladdr 10:10:10:10:10:10 dev ens32</span><br><span class="line">$ ip neighbor show dev ens32</span><br><span class="line">192.168.204.2 lladdr 00:50:56:f4:ca:d8 STALE</span><br><span class="line">192.168.204.254 lladdr 00:50:56:fe:b9:9e STALE</span><br><span class="line">192.168.204.3 lladdr 10:10:10:10:10:10 PERMANENT</span><br><span class="line">192.168.204.1 lladdr 00:50:56:c0:00:08 REACHABLE</span><br></pre></td></tr></table></figure>

<p>该命令的用途之一：可以将接口的 ARP 功能禁用，同时为接口添加静态静态表项，从而限制接口只能和特定机器通信。</p>
<h3 id="删除邻接表项"><a href="#删除邻接表项" class="headerlink" title="删除邻接表项"></a>删除邻接表项</h3><p>使用如下命令在一个接口上删除一条邻接表项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip neighbor delete <span class="variable">$&#123;network address&#125;</span> lladdr <span class="variable">$&#123;link layer address&#125;</span> dev <span class="variable">$&#123;interface name&#125;</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ip neighbor delete 192.168.204.3 lladdr 10:10:10:10:10:10 dev ens32</span><br><span class="line">$ ip neighbor show dev ens32</span><br><span class="line">192.168.204.2 lladdr 00:50:56:f4:ca:d8 STALE</span><br><span class="line">192.168.204.254 lladdr 00:50:56:fe:b9:9e STALE</span><br><span class="line">192.168.204.3  FAILED</span><br><span class="line">192.168.204.1 lladdr 00:50:56:c0:00:08 REACHABLE</span><br></pre></td></tr></table></figure>

<p>通过该命令可以删除某条静态表项，或者某条动态学习到的表项。</p>
<h2 id="链路管理"><a href="#链路管理" class="headerlink" title="链路管理"></a>链路管理</h2><p>链路其实就是指网络接口，ip link 系列命令可以对所有接口类型进行操作，例如查看链路信息、修改 MTU 等。从 3.16 版本以后，ip link 命令可以创建除 L2TPv3 以外的所有类型的接口。</p>
<p>显示接口<br>显示所有接口的信息<br>1<br>2<br>ip link show<br>ip link list<br>这两个命令完全等效，可以使用相同的参数。</p>
<p>显示指定接口的信息<br>1<br>ip link show dev ${interface name}<br>示例：</p>
<p>1<br>2<br>3<br>p4@p4:~$ ip link show lo<br>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1<br>    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>设置接口 up&#x2F;down<br>通过如下命令，将接口状态设置为 up 或者 down：</p>
<p>1<br>2<br>ip link set dev ${interface name} up<br>ip link set dev ${interface name} down<br>示例：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>p4@p4:<del>$ ip link show lo<br>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1<br>    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>p4@p4:</del>$ sudo ip link set dev lo down<br>p4@p4:~$ ip link show lo<br>1: lo: <LOOPBACK> mtu 65536 qdisc noqueue state DOWN mode DEFAULT group default qlen 1<br>    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>虚拟链路在创建完成之后其初始状态为 down，如果需要使用他们需要使用该命令将接口设置为 up。</p>
<p>设置接口描述信息<br>通过如下命令为接口添加可读的描述信息：</p>
<p>1<br>ip link set dev ${interface name} alias “${description}”<br>示例：</p>
<p>1<br>2<br>3<br>4<br>5<br>p4@p4:<del>$ sudo ip link set dev lo alias loopback_if<br>p4@p4:</del>$ ip link show lo<br>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1<br>    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    alias loopback_if<br>通过 ip link show 可以查看接口的描述信息。</p>
<p>重命名接口<br>通过如下命令可以重命名接口：</p>
<p>1<br>ip link set dev ${old interface name} name ${new interface name}<br>示例：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>p4@p4:<del>$ sudo ip link set dev lo name loif<br>RTNETLINK answers: Device or resource busy<br>p4@p4:</del>$ sudo ip link set dev lo down<br>p4@p4:<del>$ sudo ip link set dev lo name loif<br>p4@p4:</del>$ ip link show loif<br>1: loif: <LOOPBACK> mtu 65536 qdisc noqueue state DOWN mode DEFAULT group default qlen 1<br>    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    alias loopback_if<br>需要注意，你不能对 up 的接口进行重命名，因此在重命名之前需要接口设置为 down。</p>
<p>修改链路层地址<br>通过如下命令修改接口的链路层地址，通常也就是 Mac 地址（对于以太设备）：</p>
<p>1<br>ip link set dev ${interface name} address ${address}<br>示例：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>p4@p4:<del>$ ip link show lo<br>1: lo: <LOOPBACK> mtu 65536 qdisc noqueue state DOWN mode DEFAULT group default qlen 1<br>    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    alias loopback_if<br>p4@p4:</del>$ sudo ip link set dev lo address 00:00:00:00:00:01<br>p4@p4:~$ ip link show lo<br>1: lo: <LOOPBACK> mtu 65536 qdisc noqueue state DOWN mode DEFAULT group default qlen 1<br>    link&#x2F;loopback 00:00:00:00:00:01 brd 00:00:00:00:00:00<br>    alias loopback_if<br>修改 MTU<br>通过如下命令修改接口的 MTU：</p>
<p>1<br>ip link set dev ${interface name} mtu ${MTU value}<br>示例：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>p4@p4:<del>$ ip link show lo<br>1: lo: <LOOPBACK> mtu 65536 qdisc noqueue state DOWN mode DEFAULT group default qlen 1<br>    link&#x2F;loopback 00:00:00:00:00:01 brd 00:00:00:00:00:00<br>    alias loopback_if<br>p4@p4:</del>$ sudo ip link set dev lo mtu 1500<br>p4@p4:~$ ip link show lo<br>1: lo: <LOOPBACK> mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default qlen 1<br>    link&#x2F;loopback 00:00:00:00:00:01 brd 00:00:00:00:00:00<br>    alias loopback_if<br>MTU 即最大传输单元，即接口一次能够传输的最大帧大小。如果你的以太设备支持 jumbo 帧，那么你可以通过该命令设置以太接口的 MTU，从而提高 gigabit 以太接口的性能。</p>
<p>使能&#x2F;去使能组播<br>通过如下命令，可以在接口上使能或去使能组播特性：</p>
<p>1<br>2<br>ip link set ${interface name} multicast on<br>ip link set ${interface name} multicast off<br>除非你明确知道你在做什么，否则最好不要修改该标志。</p>
<p>使能&#x2F;去使能 ARP<br>通过如下命令，可以在接口上使能&#x2F;去使能 ARP 特性：</p>
<p>1<br>2<br>ip link set ${interface name} arp on<br>ip link set ${interface name} arp off<br>通过去使能 ARP，可以强化安全策略，限制该接口只能和特定 MAC 通信，当然此时需要在邻接表手动添加 IP&#x2F;MAC 白名单，否则该接口无法和任何主机通信。但是大多数情况下都是在接入层交换机设置 MAC 安全策略，除非你明确知道你在做什么，否则最好不要修改该标志。</p>
<p>删除接口<br>通过如下命令删除指定接口：</p>
<p>1<br>ip link delete dev ${interface name}<br>显然，只能删除虚拟接口，例如 VLAN 接口、Bridge 接口等。</p>
<p>示例：</p>
<p>1<br>p4@p4:~$ sudo ip link delete dev ens32.10<br>创建 VLAN 接口<br>使用如下命令创建 VLAN 接口:</p>
<p>1<br>ip link add name ${VLAN interface name} link ${parent interface name} type vlan id ${tag}<br>示例：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>p4@p4:<del>$ sudo ip link add name ens32.10 link ens32 type vlan id 10<br>p4@p4:</del>$ ip link show<br>1: lo: <LOOPBACK> mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default qlen 1<br>    link&#x2F;loopback 00:00:00:00:00:01 brd 00:00:00:00:00:00<br>    alias loopback_if<br>2: ens32: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000<br>    link&#x2F;ether 00:0c:29:40:81:a0 brd ff:ff:ff:ff:ff:ff<br>3: ens32.10@ens32: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000<br>    link&#x2F;ether 00:0c:29:40:81:a0 brd ff:ff:ff:ff:ff:ff<br>p4@p4:<del>$ sudo ip link set dev ens32.10 up<br>p4@p4:</del>$ ip link show<br>1: lo: <LOOPBACK> mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default qlen 1<br>    link&#x2F;loopback 00:00:00:00:00:01 brd 00:00:00:00:00:00<br>    alias loopback_if<br>2: ens32: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000<br>    link&#x2F;ether 00:0c:29:40:81:a0 brd ff:ff:ff:ff:ff:ff<br>3: ens32.10@ens32: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default qlen 1000<br>    link&#x2F;ether 00:0c:29:40:81:a0 brd ff:ff:ff:ff:ff:ff<br>Linux 系统上唯一支持的 VLAN 类型就是 IEEE 802.1q VLAN。一旦创建一个 VLAN 接口，那么所有从 ${parent interface} 上接收的带 VLAN tag 的、且 tag 值为 id 命令中指定的 ${tag} 的报文都会被该 VLAN 接口处理。</p>
<p>eth0.110 这种命名格式是惯例命名，但不是必须的，你也可以参照其他类型接口的命名方式。</p>
<p>创建 QinQ 接口<br>使用如下命令创建带双层 tag 的 QinQ 接口：</p>
<p>1<br>ip link add name ${service interface} link ${physical interface} type vlan proto 802.1ad id ${service tag}<br>1<br>ip link add name ${client interface} link ${service interface} type vlan proto 802.1q id ${client tag}<br>示例：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>p4@p4:<del>$ sudo ip link add name ens32.10 link ens32 type vlan proto 802.1ad id 100<br>p4@p4:</del>$ sudo ip link add name ens32.10.100 link ens32.10 type vlan proto 802.1q id 100<br>p4@p4:~$ ip –brief link show<br>lo               DOWN           00:00:00:00:00:01 <LOOPBACK><br>ens32            UP             00:0c:29:40:81:a0 &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;<br>ens32.10@ens32   DOWN           00:0c:29:40:81:a0 &lt;BROADCAST,MULTICAST&gt;<br><a href="mailto:&#101;&#110;&#115;&#51;&#50;&#46;&#x31;&#48;&#x2e;&#x31;&#x30;&#48;&#64;&#101;&#x6e;&#x73;&#x33;&#50;&#46;&#x31;&#x30;">&#101;&#110;&#115;&#51;&#50;&#46;&#x31;&#48;&#x2e;&#x31;&#x30;&#48;&#64;&#101;&#x6e;&#x73;&#x33;&#50;&#46;&#x31;&#x30;</a> DOWN           00:0c:29:40:81:a0 &lt;BROADCAST,MULTICAST,M-DOWN&gt;<br>802.1ad QinQ 也被称为 VLAN statcking，可以通过另一个 VLAN 传输本身就携带 VLAN tag 的报文。通常的使用场景是：在运营商网络中，有时客户想要通过运营商的网络设施来连接它们自己的网络分段，由于客户网络本身就可以包含多个 VLAN，那么当客户流量（本身携带 VLAN tag）进入运营商网络时就需要通过 QinQ 来在客户网络流量上添加第二个 tag，然后当流量离开运营商网络时，由运营商边缘设备负责将外层 vlan tag 移除。外层 tag 用于客户流量在运营商网络中的传输，同时隔离不同客户的流量。</p>
<p>${service tag} 就是 ISP 提供的 VLAN tag，用于在 ISP 网络中传输客户流量。而 ${client tag} 则是客户流量本身携带的 tag。</p>
<p>需要注意，${client interface} 的 MTU 并不会自动调整，需要你自己考虑相关的 MTU 问题。你可以将 ${client interface} 的 MTU 减少 4 字节，或者增加其 parent interface 的 MTU。</p>
<p>从 Linux 3.10 开始兼容标准 QinQ。</p>
<p>创建伪以太（macvlan）接口<br>使用如下命令可以创建 macvlan 接口：</p>
<p>1<br>ip link add name ${macvlan interface name} link ${parent interface} type macvlan<br>示例：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>p4@p4:<del>$ sudo ip link add pens32 link ens32 type macvlan<br>p4@p4:</del>$ ip link show<br>1: lo: <LOOPBACK> mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default qlen 1<br>    link&#x2F;loopback 00:00:00:00:00:01 brd 00:00:00:00:00:00<br>    alias loopback_if<br>2: ens32: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000<br>    link&#x2F;ether 00:0c:29:40:81:a0 brd ff:ff:ff:ff:ff:ff<br>6: pens32@ens32: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1<br>    link&#x2F;ether fa:8d:42:88:4b:8a brd ff:ff:ff:ff:ff:ff<br>可以将 macvlan 接口当成 parent interface 下的一个虚拟接口，但是其拥有自己的 MAC 地址以及 IP 地址。从用户角度来看，macvlan 接口和普通的以太接口没有什么区别，所有从 parent interface 上接收到的流量，如果其 MAC 地址为该 macvlan 接口的 MAC 地址，那么流量将交由该 macvlan 接口处理。</p>
<p>macvlan 接口也可以用于 IP 地址隔离，而不用在同一个物理接口上添加多个 IP 地址。</p>
<p>创建 dummy 接口<br>使用如下命令可以创建 dummy 接口：</p>
<p>1<br>ip link add name ${dummy interface name} type dummy<br>示例：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>p4@p4:<del>$ sudo ip link add name dummy0 type dummy<br>p4@p4:</del>$ ip link show<br>1: lo: <LOOPBACK> mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default qlen 1<br>    link&#x2F;loopback 00:00:00:00:00:01 brd 00:00:00:00:00:00<br>    alias loopback_if<br>2: ens32: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000<br>    link&#x2F;ether 00:0c:29:40:81:a0 brd ff:ff:ff:ff:ff:ff<br>8: dummy0: &lt;BROADCAST,NOARP&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000<br>    link&#x2F;ether 4e:13:b6:d5:f6:72 brd ff:ff:ff:ff:ff:ff<br>dummy 接口的工作方式和 loopback 接口类似，但是你可以创建任意多的 dummy 接口。dummy 接口主要有两个用途：</p>
<p>用于主机内的程序通信<br>由于 dummy 接口总是 up（除非显式将管理状态设置为 down），在拥有多个物理接口的网络上，可以将 service 地址设置为 loopback 接口或 dummy 接口的地址，这样 service 地址不会因为物理接口的状态而受影响<br>创建 bridge 接口<br>使用如下命令创建 bridge：</p>
<p>1<br>ip link add name ${bridge name} type bridge<br>实例：</p>
<p>1<br>2<br>3<br>4<br>5<br>p4@p4:<del>$ ip link add name br0 type bridge<br>p4@p4:</del>$ sudo ip link set dev br0 up<br>p4@p4:~$ ip link show br0<br>9: br0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000<br>    link&#x2F;ether 22:b5:e1:3c:34:e8 brd ff:ff:ff:ff:ff:ff<br>bridge 接口就是 Linux 系统提供的虚拟以太交换机，可以用于在以太接口之间透明地桥接流量，典型应用场景：在运行多个虚拟机的 hypervisor 中作为以太交换机使用。</p>
<p>可以为 bridge 接口添加一个 IP 地址，该 IP 地址对于所有桥接接口都是可见的。</p>
<p>如果该命令失败，需要检查 bridge 模块是否加载。</p>
<p>添加接口到 bridge<br>使用如下命令在 bridge 中添加一个接口：</p>
<p>1<br>ip link set dev ${interface name} master ${bridge name}<br>示例：</p>
<p>1<br>p4@p4:~$ sudo ip link set dev ens32 master br0<br>在 bridge 中添加的接口将成为虚拟交换接口，它工作在数据链路层，并终止所有网络层操作。</p>
<p>从 bridge 中移除接口<br>使用如下命令从 bridge 中移除一个接口：</p>
<p>1<br>ip link set dev ${interface name} nomaster<br>示例：</p>
<p>1<br>p4@p4:~$ sudo ip link set dev ens32 nomaster<br>创建 bonding 接口<br>使用如下命令创建 bonding 接口：</p>
<p>1<br>ip link add name ${name} type bond<br>示例：</p>
<p>1<br>2<br>3<br>4<br>p4@p4:<del>$ sudo ip link add name bond0 type bond<br>p4@p4:</del>$ ip link show bond0<br>11: bond0: &lt;BROADCAST,MULTICAST,MASTER&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000<br>    link&#x2F;ether 1a:22:22:05:ea:c7 brd ff:ff:ff:ff:ff:ff<br>在实际应用中，要配置 bonding 接口（链路聚合），这条命令还不够，你还需要根据你的网络设置相应的聚合参数等。向聚合组中添加接口的命令和向 bridge 中添加接口的命令一样，需要注意，只有在接口状态为 down 时才能添加成功。</p>
<p>创建 ifb 接口<br>使用如下命令创建 ifb 接口：</p>
<p>1<br>ip link add ${interface name} type ifb<br>示例：</p>
<p>1<br>2<br>3<br>4<br>p4@p4:<del>$ sudo ip link add ifb0 type ifb<br>p4@p4:</del>$ ip link show ifb0<br>14: ifb0: &lt;BROADCAST,NOARP&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 32<br>    link&#x2F;ether 76:38:b6:4d:93:66 brd ff:ff:ff:ff:ff:ff<br>ifb （Intermediate Functional Block ）接口用于重定向流量以及流量 mirror，以配合 tc 使用。</p>
<p>创建 veth pair<br>使用如下命令创建 veth pair：</p>
<p>1<br>ip link add name ${first device name} type veth peer name ${second device name}<br>示例：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>p4@p4:<del>$ sudo ip link add name veth0 type veth peer name veth1<br>p4@p4:</del>$ ip link show<br>……<br>15: veth1@veth0: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000<br>    link&#x2F;ether 36:d7:ac:11:27:9a brd ff:ff:ff:ff:ff:ff<br>16: veth0@veth1: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000<br>    link&#x2F;ether f6:ab:0c:87:cb:57 brd ff:ff:ff:ff:ff:ff<br>虚拟以太设备（Virtual ethernet）总是成对出现，因此有时也被称为 veth pair。其工作方式就像双向管道，无论流量从哪一端进入，都将从另一端发出。典型的应用场景是：在不同网络 namespace 之间通过 veth 进行连接。</p>
<p>接口组管理<br>接口组类似于交换机中的端口范围，你可以将一个网络接口添加到一个指定的接口组中，然后对该接口组执行操作，就等效于对接口组中的每个接口执行这些操作。没有添加到任何接口组中的接口，默认属于 group 0（也称为 default group）。</p>
<p>添加接口到 group<br>通过如下命令将接口添加到指定 group 中：</p>
<p>1<br>ip link set dev ${interface name} group ${group number}<br>示例：</p>
<p>1<br>2<br>p4@p4:<del>$ sudo ip link set dev ens32 group 1<br>p4@p4:</del>$ sudo ip link set dev ens35 group 1<br>将接口从 group 中移除<br>通过将接口添加到 group 0 中，可以将接口从其他 group 中移除</p>
<p>1<br>2<br>ip link set dev ${interface name} group 0<br>ip link set dev ${interface} group default<br>示例：</p>
<p>1<br>2<br>p4@p4:<del>$ sudo ip link set dev ens32 group 0<br>p4@p4:</del>$ sudo ip link set dev ens35 group 0<br>对 group 设置符号名<br>group 的符号名保存在 &#x2F;etc&#x2F;iproute2&#x2F;group 文件中，group 0 的 符号名 default 就是来自这里：</p>
<p>1<br>2<br>3<br>p4@p4:~$ cat &#x2F;etc&#x2F;iproute2&#x2F;group</p>
<h1 id="device-group-names"><a href="#device-group-names" class="headerlink" title="device group names"></a>device group names</h1><p>0	default<br>一旦你为 group 设置符号名之后，在 ip 命令中可以随意使用 group 号或 group 名。</p>
<p>可以如下方式为 group 设置符号名：</p>
<p>1<br>2<br>3<br>4<br>5<br>p4@p4:<del>$ sudo sh -c ‘echo “10    customer-vlans” &gt;&gt; &#x2F;etc&#x2F;iproute2&#x2F;group’<br>p4@p4:</del>$ cat &#x2F;etc&#x2F;iproute2&#x2F;group</p>
<h1 id="device-group-names-1"><a href="#device-group-names-1" class="headerlink" title="device group names"></a>device group names</h1><p>0	default<br>10    customer-vlans<br>之后你可以在所有操作中使用该名称，例如：</p>
<p>1<br>p4@p4:~$ sudo ip link set dev lo group customer-vlans<br>对 group 执行操作<br>使用如下命令，对 group 中的接口执行批量操作：</p>
<p>1<br>ip link set group ${group number} ${operation and arguments}<br>示例：</p>
<p>1<br>2<br>3<br>4<br>p4@p4:<del>$ sudo ip link set group 10 mtu 1000<br>p4@p4:</del>$ ip link show lo<br>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 1000 qdisc noqueue state UNKNOWN mode DEFAULT group customer-vlans qlen 1<br>    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>查看指定 group 中接口的信息<br>在普通的显示命令中，结合 group ${group} 可以查看 group 中所有接口的信息：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>p4@p4:<del>$ ip link list group 10<br>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 1000 qdisc noqueue state UNKNOWN mode DEFAULT group customer-vlans qlen 1<br>    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>p4@p4:</del>$ ip address show group customer-vlans<br>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 1000 qdisc noqueue state UNKNOWN group customer-vlans qlen 1<br>    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    inet 127.0.0.1&#x2F;8 scope host lo<br>       valid_lft forever preferred_lft forever<br>Tun 和 Tap 设备<br>Tun 和 Tap 设备允许用户空间程序仿真一个网络设备。当用户空间程序打开 Tup 或 Tap 设备时，它们将得到一个文件描述符。内核网络栈路由到这些设备的报文都可以通过该文件描述符进行读取，用户态程序通过该文件描述符写入的数据如同本地向外发出的报文一样，也将注入到内核网络栈进行处理。</p>
<p>这两类设备的差异如下：</p>
<p>tap 设备发送和接收原始以太帧<br>tun 设备爱发送和接收原始 IP 数据报<br>有两种类型的 tun&#x2F;tap 设备：persistent（永久性的）和 transient（瞬时性的）。当用户态程序打开某个特定设备时，永久性的 tun&#x2F;tap 设备就被创建，当相关的文件描述符关闭时，对应的 tun&#x2F;tap 设备也自动销毁。</p>
<p>以下列出的命令用来操纵 persistent 设备。</p>
<p>查看 tun&#x2F;tap 设备<br>通过如下命令查看 tun&#x2F;tap 设备：</p>
<p>1<br>2<br>ip tuntap<br>ip tuntap show<br>通过该命令能够确定设备是处于 tun 还是 tap 模式。</p>
<p>添加 tun&#x2F;tap 设备（root 用户使用）<br>通过如下命令创建的 tun&#x2F;tap 设备，只能被 root 用户使用：</p>
<p>1<br>ip tuntap add dev ${interface name} mode ${mode}<br>示例：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>p4@p4:<del>$ sudo ip tuntap add dev tun0 mode tun<br>p4@p4:</del>$ ip tuntap show<br>tun0: tun UNKNOWN_FLAGS:800<br>p4@p4:<del>$ sudo ip tuntap add dev tap0 mode tap<br>p4@p4:</del>$ ip tuntap show<br>tap0: tap UNKNOWN_FLAGS:800<br>tun0: tun UNKNOWN_FLAGS:800<br>添加 tun&#x2F;tap 设备（普通用户使用）<br>通过如下命令创建的 tun&#x2F;tap 可以被普通用户使用：</p>
<p>1<br>ip tuntap add dev ${interface name} mode ${mode} user ${user} group ${group}<br>示例：</p>
<p>1<br>2<br>3<br>p4@p4:<del>$ sudo ip tuntap add dev tun1 mode tun user p4 group p4<br>p4@p4:</del>$ ip tuntap show<br>tun1: tun UNKNOWN_FLAGS:800 user 1001 group 1001<br>添加 tun&#x2F;tap 设备，并指定报文格式<br>通过如下命令，在添加 tun&#x2F;tap 设备的同时，可以指定通过文件描述符所接收到的报文的元信息。</p>
<p>1<br>ip tuntap add dev ${interface name} mode ${mode} pi<br>示例：</p>
<p>1<br>2<br>3<br>p4@p4:<del>$ sudo ip tuntap add dev tap1 mode tap pi<br>p4@p4:</del>$ ip tuntap show<br>tap1: tap pi UNKNOWN_FLAGS:800<br>添加 tun&#x2F;tap 设备，并忽略流控<br>正常情况下，报文通过 tun&#x2F;tap 设备发送时，其发送流程和其他设备的发送流程是一样。报文被添加到一个队列中，然后由流量控制引擎进行处理（通过 tc 命令进行配置）。这个过程可以被旁路（bypassed），这样就禁用了 tun&#x2F;tap 设备上的流控机制。</p>
<p>1<br>ip tuntap add dev ${interface name} mode ${mode} one_queue<br>示例：</p>
<p>1<br>2<br>3<br>p4@p4:<del>$ sudo ip tuntap add dev tun2 mode tun one_queue<br>p4@p4:</del>$ ip tuntap show<br>tun2: tun one_queue UNKNOWN_FLAGS:800<br>删除 tun&#x2F;tap 设备<br>使用如下命令删除 tun&#x2F;tap 设备：</p>
<p>1<br>ip tuntap del dev ${interface name} mode ${mode}<br>示例：</p>
<p>1<br>2<br>3<br>4<br>5<br>p4@p4:<del>$ sudo ip tuntap delete dev tap1 mode tap<br>p4@p4:</del>$ sudo ip tuntap delete dev tun1 mode tun<br>p4@p4:<del>$ sudo ip tuntap delete dev tun2 mode tun<br>p4@p4:</del>$ sudo ip tuntap delete dev tun0 mode tun<br>p4@p4:~$ ip tuntap show<br>使用该命令时必须执行 mode，ip link show 的输出中不会显示其 mode，需要使用命令 ip tuntap show。</p>
<p>隧道管理<br>隧道看起来和普通的网络接口一样，但是通过隧道发送的报文，会被封装成另一种协议，然后被送到隧道的另一端，这期间可能要经过多个网络设备，然后在隧道的另一端进行解封装，再按照正常方式进行发送。通过隧道，你可以认为两个机器之间是直连的，但事实上却不是。</p>
<p>隧道通常用于虚拟局域网（Virtual Private Network，VPN），并配合加密传输协议如 IPSec 一起使用，或者用于连接两个使用相同协议的网络（但是中间传输网络却使用不同的协议），例如被 IPv4 网络分隔的两个 IPv6 网络。</p>
<p>需要注意，隧道本身不提供安全性，它们的安全性和 underlay 网络是一样的。所以如果需要考虑隧道安全，可以使用加密传输，例如 IPsec。</p>
<p>Linux 当前支持 IPIP（IPv4 in IPv4），SIT（IPv6 in IPv4），IPIP6（IPv4 in IPv6），IP6IP6（IPv6 in IPv6），GRE（virtually anything to anything）以及最近新增的 VTI（IPv4 in IPsec）。</p>
<p>需要注意，隧道创建之后，其初始状态为 down 状态，需要手动将其设置为 up。</p>
<p>在以下命令中，${local endpoint address} 和 ${remote endpoint address} 代表端点物理接口的地址，${address} 代表隧道接口的地址。</p>
<p>创建 IPIP 隧道<br>使用如下命令，创建 IPIP（IPv4 in IPv4）隧道：</p>
<p>1<br>ip tunnel add ${interface name} mode ipip local ${local endpoint address} remote ${remote endpoint address}<br>示例：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>p4@p4:<del>$ sudo ip tunnel add tun0 mode ipip local 192.0.2.1 remote 198.51.100.3<br>p4@p4:</del>$ sudo ip link set dev tun0 up<br>p4@p4:<del>$ sudo ip address add 10.0.0.1&#x2F;30 dev tun0<br>p4@p4:</del>$ ip -4 address show<br>11: tun0@NONE: &lt;POINTOPOINT,NOARP,UP,LOWER_UP&gt; mtu 1480 qdisc noqueue state UNKNOWN group default qlen 1<br>    inet 10.0.0.1&#x2F;30 scope global tun0<br>       valid_lft forever preferred_lft forever<br>创建 SIT 隧道<br>使用如下命令，创建 SIT（IPv6 in IPv4） 隧道：</p>
<p>1<br>sudo ip tunnel add ${interface name} mode sit local ${local endpoint address} remote ${remote endpoint address}<br>示例：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>p4@p4:<del>$ sudo ip tunnel add tun9 mode sit local 192.0.2.1 remote 198.51.100.3<br>p4@p4:</del>$ sudo ip link set dev tun9 up<br>p4@p4:~$ sudo ip address add 2001:db8:1::1&#x2F;64 dev tun9<br>13: tun9@NONE: &lt;POINTOPOINT,NOARP,UP,LOWER_UP&gt; mtu 1480 state UNKNOWN qlen 1<br>    inet6 2001:db8:1::1&#x2F;64 scope global<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::c000:201&#x2F;64 scope link<br>       valid_lft forever preferred_lft forever<br>该类型的隧道通常用于为使用 IPv4 网络互连的两个 IPv6 网络之间提供连通性。</p>
<p>创建 IPIP6 隧道<br>使用如下命令，创建 IPIP6（IPv4 in IPv6）隧道：</p>
<p>1<br>ip -6 tunnel add ${interface name} mode ipip6 local ${local endpoint address} remote ${remote endpoint address}<br>示例：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>p4@p4:<del>$ sudo ip -6 tunnel add tun8 mode ipip6 local 2001:db8:1::1 remote 2001:db8:1::2<br>p4@p4:</del>$ sudo ip link set dev tun8 up<br>p4@p4:<del>$ sudo ip address add 192.0.2.1 dev tun8<br>p4@p4:</del>$ ip -r address show tun8<br>15: tun8@NONE: &lt;POINTOPOINT,NOARP,UP,LOWER_UP&gt; mtu 1432 qdisc noqueue state UNKNOWN group default qlen 1<br>    link&#x2F;tunnel6 2001:db8:1::1 peer 2001:db8:1::2<br>    inet 192.0.2.1&#x2F;32 scope global tun8<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::50e7:55ff:feee:5aab&#x2F;64 scope link<br>       valid_lft forever preferred_lft forever<br>创建 IP6IP6 隧道<br>使用如下命令，创建 IP6IP6（IPv6 in IPv6）隧道：</p>
<p>1<br>ip -6 tunnel add ${interface name} mode ip6ip6 local ${local endpoint address} remote ${remote endpoint address}<br>示例：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>p4@p4:<del>$ sudo ip -6 tunnel add tun3 mode ip6ip6 local 2001:db8:1::3 remote 2001:db8:1::4<br>p4@p4:</del>$ sudo ip link set dev tun3 up<br>p4@p4:<del>$ sudo ip address add 2001:db8:2:2::1&#x2F;64 dev tun3<br>p4@p4:</del>$ ip -6 address show tun3<br>16: tun3@NONE: &lt;POINTOPOINT,NOARP,UP,LOWER_UP&gt; mtu 1432 state UNKNOWN qlen 1<br>    inet6 2001:db8:2:2::1&#x2F;64 scope global<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::68cb:22ff:fe4d:b42c&#x2F;64 scope link<br>       valid_lft forever preferred_lft forever<br>创建 gretap 设备<br>使用如下命令，创建 gretap（ethernet over GRE）设备：</p>
<p>1<br>ip link add ${interface name} type gretap local ${local endpoint address} remote ${remote endpoint address}<br>示例：</p>
<p>1<br>2<br>3<br>4<br>5<br>p4@p4:<del>$ sudo ip link add gretap3 type gretap local 192.0.2.3 remote 203.0.113.3<br>p4@p4:</del>$ sudo ip link set dev gretap3 up<br>p4@p4:~$ sudo ip link show gretap3<br>19: gretap3@NONE: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1462 qdisc pfifo_fast state UNKNOWN mode DEFAULT group default qlen 1000<br>    link&#x2F;ether 62:ac:61:24:af:1d brd ff:ff:ff:ff:ff:ff<br>这种类型的隧道将以太帧封装到 IPv4 报文中。最新的 Linux kernel 和 iproute2 版本也支持 gretap over IPv6，只需要将 type 设置为 ip6gretap 即可创建基于 IPv6 的链路。使用这种命令创建的隧道就如同一个二层链路，可以被加入到 bridge 中。</p>
<p>该类型的隧道通常用于通过一个路由网络连接两个二层网段。</p>
<p>创建 GRE 隧道<br>使用如下命令，创建 GRE 隧道：</p>
<p>1<br>ip tunnel add ${interface name} mode gre local ${local endpoint address} remote ${remote endpoint address}<br>示例：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>p4@p4:<del>$ sudo ip tunnel add tun7 mode gre local 192.0.2.7 remote 192.0.2.7<br>p4@p4:</del>$ sudo ip link set dev tun7 up<br>p4@p4:<del>$ sudo ip address add 192.168.0.1&#x2F;30 dev tun7<br>p4@p4:</del>$ sudo ip address add 2001:db8:1::1&#x2F;64 dev tun7<br>p4@p4:<del>$<br>p4@p4:</del>$ ip address show tun7<br>20: tun7@NONE: &lt;POINTOPOINT,NOARP,UP,LOWER_UP&gt; mtu 1476 qdisc noqueue state UNKNOWN group default qlen 1<br>    link&#x2F;gre 192.0.2.7 peer 192.0.2.7<br>    inet 192.168.0.1&#x2F;30 scope global tun7<br>       valid_lft forever preferred_lft forever<br>    inet6 2001:db8:1::1&#x2F;64 scope global<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::5efe:c000:207&#x2F;64 scope link<br>       valid_lft forever preferred_lft forever<br>GRE 隧道可以同时封装 IPv4 和 IPv6 流量，默认它使用 IPv4 进行传输，如果向使用 GRE over IPv6，可以将 mode 指定为 ip6gre。</p>
<p>创建到某个端点的多个 GRE 隧道<br>使用如下命令，创建到某个端点的多个 GRE 隧道：</p>
<p>1<br>ip tunnel add ${interface name} mode gre local ${local endpoint address} remote ${remote endpoint address} key ${key value}<br>示例：</p>
<p>1<br>2<br>p4@p4:<del>$ sudo ip tunnel add tun11 mode gre local 192.0.2.11 remote 203.0.113.11 key 123<br>p4@p4:</del>$ sudo ip tunnel add tun12 mode gre local 192.0.2.11 remote 203.0.113.11 key 124<br>注意，这里的 key 并不会提供任何安全特性，而是仅仅作为一个标识符来区分各个隧道。</p>
<p>创建点到多点 GRE 隧道<br>使用如下命令创建点到多点隧道：</p>
<p>1<br>ip tunnel add ${interface name} mode gre local ${local endpoint address} key ${key value}<br>示例：</p>
<p>1<br>2<br>3<br>4<br>5<br>p4@p4:<del>$ ip tunnel add tun13 mode gre local 192.0.2.13 key 130<br>p4@p4:</del>$ sudo ip link set dev tun13 up<br>p4@p4:<del>$ sudo ip address add 10.0.0.1&#x2F;27 dev tun13<br>p4@p4:</del>$ ip tunnel show tun13<br>tun13: gre&#x2F;ip  remote any  local 192.0.2.13  ttl inherit  key 130<br>注意，这里没有指定 ${remote endpoint address}，由于没有指定 ${remote endpoint address}，key 是唯一的方式来区分 tunnel 流量。所以 ${key value} 是必须的。</p>
<p>该类型的隧道允许你通过隧道接口和多个远端端点通信，它通常用于复杂的 VPN 环境中，用于实现一对多的通信（在 Cisco 术语中称为 dynamic multipoint VPN）。</p>
<p>由于没有指定远端端点的地址，所以上述命令不足以创建出隧道，你的系统需要知道另一端点位于哪里。实际应用中 NHRP（Next Hop Resolution Protocol）用于实现该目的。如果是处于测试目的，你可以手动添加对端。</p>
<p>假设对端物理接口的 IP 地址为 203.0.113.6，隧道接口地址为 10.0.0.2，使用如下方式添加对端</p>
<p>1<br>ip neighbor add 10.0.0.2 lladdr 203.0.113.6 dev tun8<br>在对端上也要进行手动配置。有趣的是，这里链路层地址和邻接地址都是 IP 地址。</p>
<p>创建 GRE over IPv6 隧道<br>最近的内核和 iproute2 版本已经支持 GRE over IPv6，使用如下命令创建不带 key 的点到点隧道：</p>
<p>1<br>ip -6 tunnel add name ${interface name} mode ip6gre local ${local endpoint} remote ${remote endpoint}<br>对于上述 IPv4 GRE 隧道所支持的所有选项和特性，GRE over IPv6 也同样支持。</p>
<p>删除隧道<br>使用如下命令删除隧道：</p>
<p>1<br>2<br>ip tunnel del ${interface name}<br>ip tunnel delete ${interface name}<br>示例：</p>
<p>1<br>p4@p4:~$ sudo ip tunnel delete tun0<br>修改隧道<br>使用如下命令修改隧道的某些选项参数：</p>
<p>1<br>ip tunnel change ${interface name} ${options}<br>示例：</p>
<p>1<br>2<br>3<br>4<br>5<br>p4@p4:<del>$ ip tunnel show tun9<br>tun9: ipv6&#x2F;ip  remote 198.51.100.3  local 192.0.2.1  ttl inherit  6rd-prefix 2002::&#x2F;16<br>p4@p4:</del>$ sudo ip tunnel change tun9 remote 198.51.100.4<br>p4@p4:~$ ip tunnel show tun9<br>tun9: ipv6&#x2F;ip  remote 198.51.100.4  local 192.0.2.1  ttl inherit  6rd-prefix 2002::&#x2F;16<br>对于 unkeyed 隧道，你不能给其设置 key。你也不能通过这种方式修改隧道的模式。</p>
<p>查看隧道信息<br>使用如下命令查看隧道信息：</p>
<p>1<br>2<br>ip tunnel show<br>ip tunnel show ${interface name}<br>示例：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>p4@p4:<del>$ ip tunnel show<br>gre0: gre&#x2F;ip  remote any  local any  ttl inherit  nopmtudisc<br>sit0: ipv6&#x2F;ip  remote any  local any  ttl 64  nopmtudisc 6rd-prefix 2002::&#x2F;16<br>tun9: ipv6&#x2F;ip  remote 198.51.100.4  local 192.0.2.1  ttl inherit  6rd-prefix 2002::&#x2F;16<br>tun13: gre&#x2F;ip  remote any  local 192.0.2.13  ttl inherit  key 130<br>tun12: gre&#x2F;ip  remote 203.0.113.11  local 192.0.2.11  ttl inherit  key 124<br>tun11: gre&#x2F;ip  remote 203.0.113.11  local 192.0.2.11  ttl inherit  key 123<br>tun7: gre&#x2F;ip  remote 192.0.2.7  local 192.0.2.7  ttl inherit<br>tunl0: ip&#x2F;ip  remote any  local any  ttl inherit  nopmtudisc<br>p4@p4:</del>$ ip -6 tunnel show<br>tun8: ip&#x2F;ipv6 remote 2001:db8:1::2 local 2001:db8:1::1 encaplimit 4 hoplimit 64 tclass 0x00 flowlabel 0x00000 (flowinfo 0x00000000)<br>ip6tnl0: ipv6&#x2F;ipv6 remote :: local :: encaplimit 0 hoplimit 0 tclass 0x00 flowlabel 0x00000 (flowinfo 0x00000000)<br>tun3: ipv6&#x2F;ipv6 remote 2001:db8:1::4 local 2001:db8:1::3 encaplimit 4 hoplimit 64 tclass 0x00 flowlabel 0x00000 (flowinfo 0x00000000)<br>L2TPv3 伪线管理<br>L2TPv3 是一种隧道协议，通常用于实现 L2 伪线。</p>
<p>在许多发行版本中，L2TPv3 被编译成一个模块，默认没有被加载。如果在使用 ip l2tp 命令时得到一些错误信息，可能就是由于 L2TPv3 模块没有被加载。L2TPv3 涉及到 l2tp_netlink 和 l2tp_eth 两个内核模块，如果你想使用 L2TPv3 over IP 而不是 L2TPv3 over UDP，那么还需要加载 l2tp_ip。</p>
<p>和其他 Linux 隧道协议的实现不同，在 L2TPv3 中首先需要创建一个隧道，然后将会话绑定到隧道上。你可以将具有不同标识符的多个会话绑定到同一个隧道。虚拟网络接口（默认命名为 l2tpethX）和会话相关联。</p>
<p>注意，Linux 内核实现只能处理 L2TPv3 的数据平面，所以使用 iproute2 只能创建 unmanaged 隧道，也就是说隧道的两端都需要手工配置。</p>
<p>创建 L2TPv3 over UDP 隧道<br>使用如下命令，创建 L2TPv3 over UDP 隧道：</p>
<p>1<br>2<br>ip l2tp add tunnel tunnel_id ${local tunnel numeric identifier} peer_tunnel_id ${remote tunnel numeric identifier} udp_sport ${source port} udp_dport ${destination port} encap udp<br>local ${local endpoint address} remote ${remote endpoint address}<br>示例：</p>
<p>1<br>p4@p4:~$ sudo ip l2tp add tunnel tunnel_id 1 peer_tunnel_id 1 udp_sport 5000 udp_dport 5000 encap udp local 192.0.2.1 remote 203.0.113.2<br>隧道两端的标识符和其他设置必须相匹配。</p>
<p>创建 L2TPv3 over IP 隧道<br>使用如下命令，创建 L2TPv3 over IP 隧道：</p>
<p>1<br>ip l2tp add tunnel tunnel_id ${local tunnel numeric identifier} peer_tunnel_id {remote tunnel numeric identifier } encap ip local ${local endpoint address} remote ${remote endpoint address}<br>示例：</p>
<p>1<br>p4@p4:~$ sudo ip l2tp add tunnel tunnel_id 2 peer_tunnel_id 2 encap ip local 192.0.2.1 remote 203.0.113.2<br>基于 IP 的 L2TPv3 封装格式的封装开销更小，但是一般无法穿越 NAT。</p>
<p>创建 L2TPv3 会话<br>使用如下命令创建 L2TPv3 会话：</p>
<p>1<br>ip l2tp add session tunnel_id ${local tunnel identifier} session_id ${local session numeric identifier} peer_session_id ${remote session numeric identifier}<br>示例：</p>
<p>1<br>p4@p4:~$ sudo ip l2tp add session tunnel_id 1 session_id 10 peer_session_id 10<br>隧道 id 必须匹配之间所创建隧道的 id 值，会话两端的标识符也必须匹配。一旦你创建了隧道和会话，l2tpethX 接口就会自动出现，但是初始状态为 down，需要手动将其状态设置为 up。</p>
<p>删除 L2TPv3 会话<br>使用如下命令删除 L2TPv3 会话：</p>
<p>1<br>ip l2tp del session tunnel_id ${tunnel identifier} session_id ${session identifier}<br>示例：</p>
<p>1<br>p4@p4:~$ sudo ip l2tp del session tunnel_id 1 session_id 10<br>删除 L2TPv3 隧道<br>使用如下命令删除 L2TPv3 隧道：</p>
<p>1<br>ip l2tp del tunnel tunnel_id ${tunnel identifier}<br>示例:</p>
<p>1<br>p4@p4:~$ sudo ip l2tp del tunnel tunnel_id 1<br>在删除隧道之前，需要删除和该隧道相关联的所有会话。</p>
<p>查看 L2TPv3 隧道信息<br>使用如下命令查看 L2TPv3 隧道信息：</p>
<p>1<br>2<br>ip l2tp show tunnel<br>ip l2tp show tunnel tunnel_id ${tunnel identifier}<br>示例：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>p4@p4:~$ sudo ip l2tp show tunnel<br>Tunnel 2, encap IP<br>  From 192.0.2.1 to 203.0.113.2<br>  Peer tunnel 2<br>Tunnel 1, encap UDP<br>  From 192.0.2.1 to 203.0.113.2<br>  Peer tunnel 1<br>  UDP source &#x2F; dest ports: 5000&#x2F;5000<br>查看 L2TPv3 会话信息<br>使用如下命令查看 L2TPv3 会话信息：</p>
<p>1<br>2<br>ip l2tp show session<br>ip l2tp show session session_id ${session identifier} tunnel_id ${tunnel identifier}<br>示例：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>p4@p4:<del>$ sudo ip l2tp show session<br>Session 10 in tunnel 1<br>  Peer session 10, tunnel 1<br>  interface name: l2tpeth0<br>  offset 0, peer offset 0<br>p4@p4:</del>$ sudo ip l2tp show session session_id 10 tunnel_id 1<br>Session 10 in tunnel 1<br>  Peer session 10, tunnel 1<br>  interface name: l2tpeth0<br>  offset 0, peer offset 0<br>VXLAN 管理<br>VXLAN 是一个二层隧道协议，通常用于连接运行在不同 hypervisor 节点上的虚拟机。和 GRE 或 L2TPv3 这种点对点隧道不同，VXLAN 可以通过 IP 多播提供多点访问特性。通过在数据帧中携带网络标识符，VXLAN 也支持虚拟网络之间的隔离。VXLAN 的底层封装协议是 UDP。</p>
<p>创建单播 VXLAN 链路<br>使用如下命令创建单播 VXLAN 链路：</p>
<p>1<br>ip link add name ${interface name} type vxlan id &lt;0-16777215&gt; dev ${source interface} remote ${remote endpoint address} local ${local endpoint address} dstport ${VXLAN destination port}<br>示例：</p>
<p>1<br>p4@p4:~$ sudo ip link add name vxlan0 type vxlan id 42 dev eth0 remote 203.0.113.6 local 192.0.2.1 dstport 4789<br>这里的 id 选项就是 VXLAN 中的 VNI（VXLAN Network Identifier）。</p>
<p>创建多播 VXLAN 链路<br>使用如下命令创建多播 VXLAN 链路：</p>
<p>1<br>ip link add name ${interface name} type vxlan id &lt;0-16777215&gt; dev ${source interface} group ${multicast address} dstport ${VXLAN destination port}<br>示例：</p>
<p>1<br>p4@p4:~$ sudo ip link add name vxlan1 type vxlan id 42 dev eth0 group 239.0.0.1 dstport 4789<br>路由管理<br>以下是在 Linux 系统进行路由管理的一些注意事项：</p>
<p>对于 IPv4 路由，你可以使用点分十进制或前缀长度来指定子网掩码。也就是说，192.0.2.0&#x2F;24 和 192.0.2.0&#x2F;255.255.255.0 两种方式是等效的<br>如果你创建了一条静态路由，但是如果因为接口 down 而导致该路由变得不可达，该路由会被移除，并且不会自动恢复<br>如果你想将 Linux 主机作为一台路由器，需要考虑安装路由协议套件，例如 Quagga 或 BIRD。它们可以跟踪接口的状态，并且当接口由 down 状态恢复成 up 状态时，自动恢复路由。当然这些套件也允许你使用动态路由协议，例如 OSPF 和 BGP<br>直连路由：当你为某个网络接口设置 IP 地址时，系统会自动计算它的网络地址，并生成到该网络的一条路由。这种类型的路由也被称为直连路由。当接口变为 down 时，和该接口相关的直连路由也会被移除<br>查看所有路由<br>使用如下命令查看所有路由：</p>
<p>1<br>2<br>ip route<br>ip route show<br>示例：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>p4@p4:<del>$ ip -4 route<br>default via 192.168.204.2 dev ens32  proto static  metric 100<br>169.254.0.0&#x2F;16 dev ens32  scope link  metric 1000<br>172.16.27.0&#x2F;24 dev ens35  proto kernel  scope link  src 172.16.27.128  metric 100<br>192.168.204.0&#x2F;24 dev ens32  proto kernel  scope link  src 192.168.204.145  metric 100<br>p4@p4:</del>$ ip -6 route<br>fe80::&#x2F;64 dev ens35  proto kernel  metric 256  pref medium<br>fe80::&#x2F;64 dev gretap3  proto kernel  metric 256  mtu 1462 pref medium<br>fe80::&#x2F;64 dev ens32  proto kernel  metric 256  pref medium<br>你可以使用 -4 或 -6 选项来只查看 IPv4 路由或 IPv6 路由。如果没有指定选项，默认将只显示 IPv4 路由。</p>
<p>查看到指定网络及其所有子网的路由<br>使用如下命令查看到指定网络及其所有子网的所有路由：</p>
<p>1<br>ip route show to root ${address}&#x2F;${mask}<br>示例：</p>
<p>1<br>2<br>p4@p4:~$ ip route show to root 192.168.0.0&#x2F;16<br>192.168.204.0&#x2F;24 dev ens32  proto kernel  scope link  src 192.168.204.145  metric 100<br>这里命令字 to 是可选的（后文命令中的 to 也都是可选的）。</p>
<p>查看到指定网络及其所有超网的路由<br>使用如下命令查看到指定网络及其所有超网的所有路由：</p>
<p>1<br>ip route show to match ${address}&#x2F;${mask}<br>示例：</p>
<p>1<br>2<br>3<br>p4@p4:~$ ip route show to match 192.168.204.0&#x2F;24<br>default via 192.168.204.2 dev ens32  proto static  metric 100<br>192.168.204.0&#x2F;24 dev ens32  proto kernel  scope link  src 192.168.204.145  metric 100<br>路由器在进行三层转发时执行的是最长前缀匹配，当到特定子网的流量被错误路由时，可以使用这些命令进行调试。</p>
<p>查看到特定子网的路由<br>使用如下命令查看到特定子网的精确路由：</p>
<p>1<br>ip route show to exact ${address}&#x2F;${mask}<br>示例：</p>
<p>1<br>2<br>p4@p4:~$ ip route show to exact 192.168.204.0&#x2F;24<br>192.168.204.0&#x2F;24 dev ens32  proto kernel  scope link  src 192.168.204.145  metric 100<br>查看内核所使用的路由<br>使用如下命令查看到指定网络内核所使用的路由：</p>
<p>1<br>ip route get ${address}&#x2F;${mask}<br>示例：</p>
<p>1<br>2<br>3<br>p4@p4:~$ ip route get 192.168.204.0&#x2F;24<br>broadcast 192.168.204.0 dev ens32  src 192.168.204.145<br>    cache &lt;local,brd&gt;<br>在复杂路由场景中（例如多路径路由），该结果可能正确但是不完全，因为它总是显示首先使用的第一条路由。绝大多数情况下这不会有什么问题。</p>
<p>查看路由缓存区<br>使用如下命令查看路由缓存区：</p>
<p>1<br>ip route show cached<br>在内核版本 3.6 之前，Linux 使用路由缓存区，该命令显示路由缓存区的内容，上面命令的修饰关键字同样适用于该命令。在更新的内核上，该命令无效果。</p>
<p>以指定 gateway 的方式增加路由<br>使用如下命令，以指定 gateway 的方式增加一条路由表项：</p>
<p>1<br>ip route add ${address}&#x2F;${mask} via ${next hop}<br>示例：</p>
<p>1<br>sudo ip route add 192.168.203.0&#x2F;24 via 192.168.204.1<br>以指定接口的方式增加路由<br>使用如下命令，以指定接口的方式增加一条路由表项：</p>
<p>1<br>ip route add ${address}&#x2F;${mask} dev ${interface name}<br>示例：</p>
<p>1<br>sudo ip route add 192.168.202.0&#x2F;24 dev ens32<br>以指定接口的方式指定路由通常适用于点对点链路（例如 PPP 隧道），此时并不需要指定下一跳地址。</p>
<p>改变或替换路由<br>可以使用 change 命令修改已存在路由的一些参数，而 replace 命令也可以已存在路由的参数，但是如果路由不存在，replace 命令将新增该路由。</p>
<p>示例：</p>
<p>1<br>2<br>ip route change 192.168.2.0&#x2F;24 via 10.0.0.1<br>ip route replace 192.0.2.1&#x2F;27 dev tun0<br>删除路由<br>使用如下命令删除一条路由：</p>
<p>1<br>ip route delete ${rest of the route statement}<br>示例：</p>
<p>1<br>p4@p4:~$ sudo ip route delete 192.168.204.0&#x2F;24 dev ens32<br>添加默认路由<br>使用如下快捷命令添加默认路由：</p>
<p>1<br>2<br>ip route add default via ${address}&#x2F;${mask}<br>ip route add default dev ${interface name}<br>该命令等效于：</p>
<p>1<br>2<br>ip route add 0.0.0.0&#x2F;0 via ${address}&#x2F;${mask}<br>ip route add 0.0.0.0&#x2F;0 dev ${interface name}<br>对于 IPv6，该命令也同样适用，其等效于添加了 ::&#x2F;0 这条路由表项：</p>
<p>示例：</p>
<p>1<br>p4@p4:~$ sudo ip -6 route add default via 2001:db8::1<br>添加黑洞路由<br>使用如下命令添加黑洞路由：</p>
<p>1<br>ip route add blackhole ${address}&#x2F;${mask}<br>示例：</p>
<p>1<br>p4@p4:~$ sudo ip route add blackhole 192.0.2.1&#x2F;32<br>匹配黑洞路由的流量将直接被丢弃。使用黑洞路由有两个目的：</p>
<p>对于目的地为某些特定地址的流量，直接将其丢弃<br>有时需要通过创建黑洞路由，来控制路由的通告<br>创建特殊路由<br>使用如下命令创建特殊类型的路由：</p>
<p>1<br>2<br>3<br>ip route add unreachable ${address}&#x2F;${mask}<br>ip route add prohibit ${address}&#x2F;${mask}<br>ip route add throw ${address}&#x2F;${mask}<br>匹配这些路由表项的流量，会被系统丢弃，同时向发送者返回 ICMP 错误消息。</p>
<p>unreachable：返回 ICMP 主机不可达错误<br>prohibit：返回 ICMP administratively prohibited 错误<br>throw：返回 ICMP 网络不可达错误<br>不像黑洞路由，并不推荐使用这些特殊路由来丢弃某些流量（例如 DDoS），因为这些路由会对每个丢弃的报文都生成一个 ICMP 应答报文，这样就消耗了额外系统资源和网络资源。这些路由可以用来实现网络访问策略。另外这些路由类型可以用于实现基于策略的路由，在非默认路由表中，这些路由将停止当前路由表的查找，并且不返回 ICMP 错误消息。</p>
<p>设置路由的度量<br>使用如下命令为路由设置设置度量：</p>
<p>1<br>ip route add ${address}&#x2F;${mask} via ${gateway} metric ${number}<br>示例：</p>
<p>1<br>p4@p4:~$ sudo ip route add 192.168.201.0&#x2F;24 dev ens32 metric 5<br>如果到达某个网络有多条路由，但是这些路由的度量值不同，具有最低度量值的路由将优先考虑。通过该特性，可以为某些重要目的网络提供备份路由。</p>
<p>多路径路由<br>使用如下命令，为目的网络添加多路径路由：</p>
<p>1<br>ip route add ${addresss}&#x2F;${mask} nexthop via ${gateway 1} weight ${number} nexthop via ${gateway 2} weight ${number}<br>示例：</p>
<p>1<br>2<br>3<br>4<br>5<br>p4@p4:<del>$ sudo ip route add 192.168.200.0&#x2F;24 nexthop via 192.168.204.1 weight 1 nexthop dev ens32 weight 10<br>p4@p4:</del>$ ip route show exact 192.168.200.0&#x2F;24<br>192.168.200.0&#x2F;24<br>    nexthop via 192.168.204.1  dev ens32 weight 1<br>    nexthop dev ens32 weight 10<br>通过多路径路由，系统可以根据路径的权重来实现非等价负载均衡，在这个命令中，可以混合使用 gateway 和 interface 来指定下一跳。</p>
<p>策略路由<br>在 Linux 系统中，基于策略的路由（Policy-based routing，PBR）按照如下方式进行设计：</p>
<p>创建自定义路由表<br>创建 rules 来告诉内核对特定的流量应该使用自定义路由表，而非默认路由表<br>已经预先定义了一些路由表：</p>
<p>local（table 255）：包括控制本地和广播地址的路由<br>main（table 254）：包含所有的非 PBR路由，当你添加路由时如果没有指定路由表，添加的路由将存放在这里<br>default（table 253）：用于预处理，正常情况下不使用<br>对于用户自定义的路由表，当向该路由表中添加第一条路由时，该路由表就自动被创建。</p>
<p>创建策略路由<br>使用如下命令创建一条策略路由：</p>
<p>1<br>ip route add ${route options} table ${table id or name}<br>示例：</p>
<p>1<br>p4@p4:~$ sudo ip route add 192.168.204.0&#x2F;24 via 192.168.204.1 table 10<br>前面路由管理一节所使用的各种选项也同样适用于策略路由，唯一的区别是策略路由的命令中会包含 table ${table id or name} 部分。</p>
<p>table 的数字标识符和字符标识符可以交替使用。如果想为 table 指定符号名，也可以编辑文件 &#x2F;etc&#x2F;iproute2&#x2F;rt_tables。</p>
<p>delete、change、replace 或其他路由动作都可以适用于策略路由表。而且，如果操作的 table 为 main，那么其实 table 部分可以不用指定。</p>
<p>查看策略路由<br>使用如下命令查看策略路由</p>
<p>1<br>ip route show table ${table id or name}<br>示例：</p>
<p>1<br>2<br>p4@p4:~$ ip route show table 10<br>192.168.204.0&#x2F;24 via 192.168.204.1 dev ens32<br>通用 rule 语法<br>使用如下命令创建一条 rule：</p>
<p>1<br>ip rule add ${options} &lt;lookup ${table id or name}|blackhole|prohibit|unreachable&gt;<br>如果使用了 lookup 命令关键字，那么匹配 ${options} 的流量将根据 ${table id or name} 所指定的路由表进行路由查找，而不是默认的 main&#x2F;254 路由表。而 backhole、prohibit 以及 unreachable 的工作方式和路由管理一节中相应的路由类型工作方式一致。</p>
<p>对于 IPv6 rules，可以使用 -6 选型。另外，如果动作是 lookup，可以省略关键字 lookup。</p>
<p>创建匹配源网络的 rule<br>使用如下命令，创建一条匹配源网络的 rule</p>
<p>1<br>ip rule add from ${source network} ${action}<br>示例：</p>
<p>1<br>p4@p4:~$ sudo ip rule add from 192.168.203.0&#x2F;24 lookup 10<br>创建匹配目的网络的 rule<br>使用如下命令，创建一条匹配目的网络的 rule</p>
<p>1<br>ip rule add to ${destination network} ${action}<br>示例：</p>
<p>1<br>p4@p4:~$ sudo ip rule add to 192.168.200.0&#x2F;24 blackhole<br>创建匹配 ToS 字段的 rule<br>使用如下命令，创建一条匹配 tos 的 rule</p>
<p>1<br>ip rule add tos ${ToS value} ${action}<br>示例：</p>
<p>1<br>p4@p4:~$ sudo ip rule add tos 10 lookup 10<br>创建匹配防火墙标志的 rule<br>使用如下命令，创建匹配防火墙标志的 rule</p>
<p>1<br>ip rule add fwmark ${mark} ${action}<br>示例：</p>
<p>1<br>p4@p4:~$ sudo ip rule add fwmark 10 lookup 10<br>对于防火墙标志规则，需要将其插入到路由决策前的处理链中，否则它不会有效果。关于 netfilter 的处理流程可以参考 netfilter flowchart。</p>
<p>创建匹配入接口的 rule<br>使用如下命令创建匹配入接口的 rule：</p>
<p>1<br>ip rule add iif ${interface name} ${action}<br>示例：</p>
<p>1<br>p4@p4:~$ sudo ip rule add iif ens32 lookup 10<br>创建匹配出接口的 rule<br>使用如下命令创建匹配出接口的 rule</p>
<p>1<br>ip rule add oif ${interface name} ${action}<br>示例：</p>
<p>1<br>p4@p4:~$ sudo ip rule add oif ens32 lookup 10<br>创建匹配用户 id 的 rule<br>使用如下命令创建一条匹配用户 id 范围的 rule：</p>
<p>1<br>ip rule add uidrange ${start}-${end}<br>如果该规则想匹配单个用户，只需要将用户 id 范围的 start 和 end 值设置为同一个值即可。</p>
<p>设置 rule 优先级<br>使用如下命令设置 rule 的优先级：</p>
<p>1<br>ip rule add ${options} ${action} priority ${value}<br>示例：</p>
<p>1<br>2<br>3<br>4<br>p4@p4:<del>$ sudo ip rule add oif lo lookup 10 priority 100<br>p4@p4:</del>$ ip rule show<br>0:	from all lookup local<br>100:	from all oif lo lookup 10<br>由于规则是按低优先级到高优先级依次处理，所以需要将更具体的规则放在前面（优先级更低）。</p>
<p>显示所有 rule<br>使用如下命令显示所有 rule：</p>
<p>1<br>2<br>ip rule show<br>ip -6 rule show<br>删除一条 rule<br>使用如下命令删除指定 rule：</p>
<p>1<br>ip rule del ${options} ${action}<br>示例：</p>
<p>1<br>p4@p4:~$ sudo ip rule delete oif lo lookup 10<br>删除所有 rule<br>使用如下命令删除所有 rule：</p>
<p>1<br>2<br>ip rule flush<br>ip -6 rule flush<br>需要注意，该命令破坏性非常大，即使你没有配置任何 rule，默认也会创建 from all lookup main rule。所以即使是未显式配置 rule 的机器，你也可以看到如下 rule：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>$ ip rule show<br>0:	from all lookup local<br>32766:	from all lookup main<br>32767:	from all lookup default</p>
<p>$ ip -6 rule show<br>0:	from all lookup local<br>32766:	from all lookup main<br>from all lookup local rule 是一条特殊规则，不能被删除。但是 from all lookup main 并不是，有时你可能想要删除这条规则，例如你只想使用你显式创建的 rule 来路由流量。因此在执行 ip rule flush 命令之后，这条规则会被删除，这可能导致你的系统无法路由任何流量。</p>
<p>VRF 管理<br>VRF（Virtual Routing and Forwarding）是一种用来将某个网络的路由隔离到单独路由表的机制。它允许在同一个路由器上建立多个网络，每个网络的 IP 编址都相互独立，互不影响。典型的应用场景是建立多租户环境和 VPN，在每个 VPN 中客户都可以独立编址。</p>
<p>它和基于策略的路由的主要区别是：在 PBR 中使用的其他非默认路由表只能隔离静态路由，不能隔离直连路由，所以它们不能解决地址冲突。而当一个网络接口绑定到某个 VRF，该网络接口上的所有直连路由将会存放到某个单独的路由表中。</p>
<p>也不像 network namespace，VRF 完全工作在网络层。VRF 并不会创建完全隔离的网络栈，也无法和二层协议交互，例如 LLDP，一个进程可以将一个 socket 绑定到多个 VRF（对于路由协议进程或 IPsec 进程非常有用）。</p>
<p>创建 VRF<br>使用如下命令创建一个 VRF：</p>
<p>1<br>ip link add ${name} type vrf table ${table}<br>示例：</p>
<p>1<br>p4@p4:~$ sudo ip link add foo type vrf table 100<br>如果该路由表不存在，将自动创建该路由表。</p>
<p>显示 VRF<br>使用如下命令显示 VRF：</p>
<p>1<br>2<br>ip vrf show<br>ip link show vrf ${vrf}<br>该命令的输出结果只显示 VRF 和路由表之间的绑定关系，并不会显示 VRF 和 网络接口之间的关联。如果想查看某个 VRF 中的所有接口，可以使用命令 ip link show vrf ${vrf}。</p>
<p>绑定接口到 VRF<br>使用如下命令将接口绑定到某个 VRF：</p>
<p>1<br>ip link set ${interface} master ${vrf}<br>和该接口相关的所有直连路由都会被移动到 VRF 的路由表中。</p>
<p>将接口从 VRF 中移除<br>使用如下命令将接口从 VRF 中移除：</p>
<p>1<br>ip link set ${interface} nomaster<br>和接口相关的所有直连路由将重新移动回默认路由表（main table）。</p>
<p>在 VRF 中运行一个命令<br>使用如下命令在 VRF 中运行某个命令：</p>
<p>1<br>ip vrf exec ${vrf} ${command}<br>由于路由器将根据 VRF 中的路由表来转发流量，因此该命令有助于调试。</p>
<p>网络 namespace 管理<br>网络 namespace 用来在一个机器内隔离多个网络栈实例。它们可以用于实现安全域隔离、虚拟机之间的流量管理，等等。每一个 namespace 都是一个完全独立的网络栈，拥有自己的接口、地址、路由等等。</p>
<p>创建 namespace<br>使用如下命令创建 namespace ：</p>
<p>1<br>ip netns add ${namespace name}<br>示例：</p>
<p>1<br>p4@p4:~$ sudo ip netns add host1<br>列出已经存在的 namespace<br>使用如下命令列出 namespace：</p>
<p>1<br>ip netns list<br>删除 namespace<br>使用如下命令删除 namespace：</p>
<p>1<br>ip netns delete ${namespace name}<br>示例：</p>
<p>1<br>p4@p4:~$ sudo ip netns delete host1<br>在 namespace 中运行命令<br>使用如下命令在 namespace 中运行一个命令：</p>
<p>1<br>ip netns exec ${namespace name} ${command}<br>示例：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>p4@p4:<del>$ ip -4 address show<br>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1<br>    inet 127.0.0.1&#x2F;8 scope host lo<br>       valid_lft forever preferred_lft forever<br>2: ens32: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000<br>    inet 192.168.204.145&#x2F;24 brd 192.168.204.255 scope global dynamic ens32<br>       valid_lft 1096sec preferred_lft 1096sec<br>3: ens35: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000<br>    inet 172.16.27.128&#x2F;24 brd 172.16.27.255 scope global dynamic ens35<br>       valid_lft 1699sec preferred_lft 1699sec<br>p4@p4:</del>$ sudo ip netns exec host1 ip -4 address show<br>需要注意，在一个非默认 namespace 中运行命令需要 root 权限。你可以在 namespace 中运行任何命令，包括 ip 命令它自己，你也可以在 namespae 中运行一个交互式 shell。</p>
<p>列出绑定到 namespace 的所有进程<br>使用如下命令列出绑定到某个 namespace 的所有进程：</p>
<p>1<br>ip netns pids ${namespace name}<br>示例：</p>
<p>1<br>p4@p4:~$ ip netns pid host1<br>标识某个进程的 primary namepsace<br>使用如下命令标识某个进程的 primary namespace：</p>
<p>1<br>ip netns identify ${pid}<br>示例：</p>
<p>1<br>p4@p4:~$ sudo ip netns identify 1<br>将网络接口添加到 namespace<br>使用如下命令将接口添加到某个 namespace 中：</p>
<p>1<br>2<br>ip link set dev ${interface name} netns ${namespace name}<br>ip link set dev ${interface name} netns ${pid}<br>示例：</p>
<p>1<br>2<br>3<br>p4@p4:<del>$  sudo ip link add name veth0 type veth peer name veth1<br>p4@p4:</del>$ sudo ip link set dev veth0 netns host1<br>p4@p4:~$ sudo ip link set dev veth1 netns host2<br>一旦你将接口添加到某个 namespace 中，它将从默认 namespace 中移除，该接口上的所有配置都将丢失，而且接口的状态也将变为 down 状态。你需要重新讲求设置为 up 并重配置。</p>
<p>如果你指定 PID 而不是 namespace 名，接口将添加到该 pid 对应进程的 primary namespace 中。例如通过如下方式，你可以重新将某个接口设置回默认 namespace：</p>
<p>1<br>ip netns exec ${namespace name} ip link set dev ${intf} netns 1<br>这里用到了一个假设：PID 1 的进程相比于其他进程，其 network namespace 更有可能是是默认 namespace。</p>
<p>连接两个 namespace<br>通过创建一个 veth pair 并将其两端分别添加到两个不同的 namespace 中，这样就可以在两个 namespace 之间建立连接。假设你想连接 default namespace host1 以及 namespace host1，可以通过如下命令实现：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>p4@p4:<del>$ sudo ip link add name veth0 type veth peer name veth1<br>p4@p4:</del>$ sudo ip link set dev veth0 netns host1<br>p4@p4:<del>$ sudo ip link set dev veth1 netns host2<br>p4@p4:</del>$ sudo ip netns exec host1 ip link set dev veth0 up<br>p4@p4:<del>$ sudo ip netns exec host2 ip link set dev veth1 up<br>p4@p4:</del>$ sudo ip netns exec host1 ip address add 192.168.100.1&#x2F;24 dev veth0<br>p4@p4:~$ sudo ip netns exec host2 ip address add 192.168.100.2&#x2F;24 dev veth1</p>
<p>p4@p4:<del>$ sudo ip netns exec host1 ping 192.168.100.2<br>PING 192.168.100.2 (192.168.100.2) 56(84) bytes of data.<br>64 bytes from 192.168.100.2: icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.150 ms<br>64 bytes from 192.168.100.2: icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.037 ms<br>64 bytes from 192.168.100.2: icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;0.038 ms<br>^C<br>— 192.168.100.2 ping statistics —<br>3 packets transmitted, 3 received, 0% packet loss, time 1998ms<br>rtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 0.037&#x2F;0.075&#x2F;0.150&#x2F;0.053 ms<br>p4@p4:</del>$ sudo ip netns exec host1 ip neighbor show<br>192.168.100.2 dev veth0 lladdr 26:5c:22:e0:22:e5 REACHABLE<br>p4@p4:~$ sudo ip netns exec host2 ip link show veth1<br>28: veth1@if29: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default qlen 1000<br>    link&#x2F;ether 26:5c:22:e0:22:e5 brd ff:ff:ff:ff:ff:ff link-netnsid 0<br>现在可以在 namespace host1 中，ping 位于 namespace host2 中的 192.168.100.2。</p>
<p>监控网络 namespace 子系统事件<br>使用如下命令，可以监控网络 namespace 子系统事件：</p>
<p>1<br>ip netns monitor<br>这样当出现 namespace 的创建、删除时，将会显示事件信息。</p>
<p>多播管理<br>多播通常由应用程序和路径进程使用，所以通常并不需要手动管理多播。多播相关的 ip 命令主要用于调试。</p>
<p>查看多播组<br>使用如下命令，查看多播地址：</p>
<p>1<br>2<br>ip maddress show<br>ip maddress show ${interface name}<br>示例：</p>
<p>1<br>2<br>3<br>4<br>5<br>p4@p4:~$ ip maddress show<br>1:	lo<br>    inet  224.0.0.1<br>    inet6 ff02::1<br>    inet6 ff01::1<br>添加链路层多播地址<br>你无法手动加入一个 IP 多播组，但是你可以添加一个多播 MAC 地址：</p>
<p>1<br>ip maddress add ${MAC address} dev ${interface name}<br>示例：</p>
<p>1<br>p4@p4:~$ sudo ip maddress add 01:00:5e:00:00:03 dev ens32<br>查看多播路由<br>多播路由无法手动添加，该命令只能显示通过路由进程添加的多播路由。单播路由管理命令使用的选项，也同样适用于该命令：</p>
<p>1<br>ip mroute show<br>网络事件监控<br>通过 iproute2，你可以监控指定的网络事件，例如网络配置的改变、路由表的改变、ARP&#x2F;NDP 表的改变。</p>
<p>监控所有事件<br>使用如下命令监控所有网络事件：</p>
<p>1<br>2<br>ip monitor<br>ip monitor all<br>监控指定事件<br>使用如下命令监控指定网络事件：</p>
<p>1<br>ip monitor ${event type}<br>事件类型可以是：</p>
<p>link：链路状态变化，例如接口的 up&#x2F;down，虚拟接口的创建&#x2F;删除等<br>address：地址变化<br>route：路由变化<br>mroute：组播路由变化<br>neigh：链接表（ARP 和 NDP）的变化<br>另外通过 -4 或 -6 可以指定 IPv4 或 IPv6 子系统。</p>
<p>读取 rtmon 的日志文件<br>iproute2 提供的 rtmon 程序也是用于对网络事件进行监控，但是它将事件信息写入一个二进制日志文件中。ip monitor 命令可以让你读取 rtmon 的日志文件：</p>
<p>1<br>ip monitor ${event type} file ${path to the log file}<br>rtmon 的语法类似于 ip monitor，但是它所允许监控的事件类型只有：link、address、route 和 all，通过 -family 选项指定地址族：</p>
<p>1<br>rtmon [-family &lt;inet|inet6&gt;] [&lt;route|link|address|all&gt;] file ${log file path}<br>netconf（查看 sysctl 配置）<br>查看所有接口上的 sysctl 配置<br>使用如下命令查看所有接口上的 sysctl 配置：</p>
<p>1<br>ip netconf show<br>查看指定接口上的 sysctl 配置<br>使用如下命令查看指定接口上的 sysctl 配置：</p>
<p>1<br>ip netconf show dev ${interface}<br>示例：</p>
<p>1<br>2<br>p4@p4:~$ sudo ip netconf show dev ens32<br>ipv4 dev ens32 forwarding off rp_filter strict mc_forwarding 0 proxy_neigh off</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/Network/" rel="tag"># Network</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2021/04/20/cpp-develop-notes-1/" rel="prev" title="一个编译宏引发的 bug">
      <i class="fa fa-chevron-left"></i> 一个编译宏引发的 bug
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2020/05/16/pro-git-03/" rel="next" title="Pro Git（3）：Git 分支">
      Pro Git（3）：Git 分支 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E"><span class="nav-number">1.</span> <span class="nav-text">说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">地址管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA-IP-%E5%9C%B0%E5%9D%80"><span class="nav-number">2.1.</span> <span class="nav-text">显示 IP 地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0-IP-%E5%9C%B0%E5%9D%80"><span class="nav-number">2.2.</span> <span class="nav-text">添加 IP 地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%9C%B0%E5%9D%80"><span class="nav-number">2.3.</span> <span class="nav-text">删除地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E5%9C%B0%E5%9D%80"><span class="nav-number">2.4.</span> <span class="nav-text">删除所有地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.5.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%88ARP%E3%80%81ND%EF%BC%89%E7%AE%A1%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">邻接表（ARP、ND）管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="nav-number">3.1.</span> <span class="nav-text">显示邻接表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%85%E7%A9%BA%E6%8E%A5%E5%8F%A3%E4%B8%8A%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="nav-number">3.2.</span> <span class="nav-text">清空接口上的邻接表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E9%82%BB%E6%8E%A5%E8%A1%A8%E9%A1%B9"><span class="nav-number">3.3.</span> <span class="nav-text">添加邻接表项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%82%BB%E6%8E%A5%E8%A1%A8%E9%A1%B9"><span class="nav-number">3.4.</span> <span class="nav-text">删除邻接表项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%B7%AF%E7%AE%A1%E7%90%86"><span class="nav-number">4.</span> <span class="nav-text">链路管理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#device-group-names"><span class="nav-number"></span> <span class="nav-text">device group names</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#device-group-names-1"><span class="nav-number"></span> <span class="nav-text">device group names</span></a></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">115</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
