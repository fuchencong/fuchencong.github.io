<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="几乎所有的版本控制系统都以某种形式支持分支。使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。在很多版本控制系统中，这是一个略微低效的过程：常常需要完全创建一个源代码目录的副本。对于大项目来说，这样的过程会耗费很多时间。 Git 的分支模型可以认为是它的 必杀技特性。Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是">
<meta property="og:type" content="article">
<meta property="og:title" content="Pro Git（3）：Git 分支">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2020/05/16/pro-git-03/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="几乎所有的版本控制系统都以某种形式支持分支。使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。在很多版本控制系统中，这是一个略微低效的过程：常常需要完全创建一个源代码目录的副本。对于大项目来说，这样的过程会耗费很多时间。 Git 的分支模型可以认为是它的 必杀技特性。Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2020/05/16/pro-git-03/images/tree.jpg">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2020/05/16/pro-git-03/images/tree2.jpg">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2020/05/16/pro-git-03/images/branch.jpg">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2020/05/16/pro-git-03/images/merge.jpg">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2020/05/16/pro-git-03/images/merge2.jpg">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2020/05/16/pro-git-03/images/remote.jpg">
<meta property="article:published_time" content="2020-05-16T06:55:06.000Z">
<meta property="article:modified_time" content="2023-05-25T07:17:02.016Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="git">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fuchencong.github.io/fuchencong.github.io/2020/05/16/pro-git-03/images/tree.jpg">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2020/05/16/pro-git-03/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Pro Git（3）：Git 分支 | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2020/05/16/pro-git-03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Pro Git（3）：Git 分支
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-16 14:55:06" itemprop="dateCreated datePublished" datetime="2020-05-16T14:55:06+08:00">2020-05-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">开发工具</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>几乎所有的版本控制系统都以某种形式支持分支。使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。在很多版本控制系统中，这是一个略微低效的过程：常常需要完全创建一个源代码目录的副本。对于大项目来说，这样的过程会耗费很多时间。</p>
<p>Git 的分支模型可以认为是它的 <code>必杀技特性</code>。Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。理解和精通这一特性，你便会意识到 Git 是如此的强大而又独特，并且从此真正改变你的开发方式。</p>
<span id="more"></span>

<h2 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h2><p>Git 保存的不是文件的变化或者差异，而是一系列不同时刻的快照。在进行提交操作时，Git 会保存一个提交对象（commit object）。<strong>该提交对象会包含一个指向暂存内容快照的指针</strong>。不仅如此，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交对象没有父对象，<strong>普通提交操作产生的提交对象有一个父对象， 而由多个分支合并产生的提交对象有多个父对象</strong>。</p>
<p>假设一个工作目录中里面包含 3 个被暂存的文件。暂存操作会为每一个文件计算校验和，然后会把当前版本的文件快照保存到 Git 仓库中（Git 使用 blob 对象来保存它们）。当使用 <code>git commit</code> 进行提交操作时，Git 会先计算每一个子目录的校验和，然后在 Git 仓库中将这些校验和保存为树对象。随后，Git 便会创建一个提交对象， 它除了包含上面提到的那些信息 外，还包含指向这个树对象（项目根目录）的指针。</p>
<p>现在，Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个树对象（记录着目录结构和 blob 对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）。如下所示：</p>
<img src="/fuchencong.github.io/2020/05/16/pro-git-03/images/tree.jpg" class="">

<p>做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。如下所示：</p>
<img src="/fuchencong.github.io/2020/05/16/pro-git-03/images/tree2.jpg" class="">

<p><strong>Git 的分支，其实本质上仅仅是指向提交对象的可变指针</strong>。Git 的默认分支名字是 master。在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 master 分支会在每次提交时自动向前移动。</p>
<p>Git 的 master 分支并不是一个特殊分支。它就跟其它分支完全没有区别。之所以几乎每一个仓库都有 master 分支，是因为 git init 命令默认创建它，并且大多数人都懒得去改动它。</p>
<p>如下展示了分支及其提交历史的关系：</p>
<img src="/fuchencong.github.io/2020/05/16/pro-git-03/images/branch.jpg" class="">

<h2 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h2><p>在 Git 中创建分支只是为你创建了一个可以移动的新的指针。使用 git branch 命令创建分支，如下所示，这会在当前所在的提交对象上创建一个指针：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git branch testing</span></span><br></pre></td></tr></table></figure>

<p>那么，Git 又是怎么知道当前在哪一个分支上呢？也很简单，它有一个名为 HEAD 的特殊指针。请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 HEAD 概念完全不同。<strong>在 Git 中，它是一个指针，指向当前所在的本地分支，可以认为它是当前分支的别名</strong>。</p>
<p>可以使用 <code>git log --decorate</code> 命令查看各个分支当前所指的对象。</p>
<h2 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h2><p>需要注意，<code>git branch</code> 命令仅仅创建新的分支，并不会自动切换到新分支中去。要切换到一个已存在的分支，你需要使用 <code>git checkout</code> 命令。如果想创建一个新分支后立即切换过去，可以用 <code>git checkout -b &lt;newbranchname&gt;</code> 一条命令搞定。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git checkout testing</span></span><br><span class="line">Switched to branch <span class="string">&#x27;testing&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这样 HEAD 就指向 testing 分支了。假如此时我们做一次简单修改，testing 分支向前移动了，但是 master 分支却没有。它仍然指向运行 git checkout 时所指的对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git commit -a -m &quot;made a change&quot;</span></span><br><span class="line"><span class="comment"># cat LICENSE</span></span><br><span class="line">TEST</span><br><span class="line">TEST</span><br></pre></td></tr></table></figure>

<p>我们重新切回到 master 分支上。此时 HEAD 指回 master 分支，同时将工作目录恢复成 master 分支所指向的快照内容。也就是说，此时做修改的话，项目将始于一个较旧的版本。本质上来讲，这就是忽略 testing 分支所做的修改，以便于向另一个方向进行开发。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git checkout master</span></span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line"><span class="comment"># cat LICENSE</span></span><br><span class="line">TEST</span><br></pre></td></tr></table></figure>

<p>在切换分支时，一定要注意你工作目录里的文件会被改变。如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。如下所示，在 master 分支上进行修改但是没有提交，如果此时尝试切换到 testing 分支，将得到错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo &quot;another change&quot; &gt;&gt; LICENSE</span></span><br><span class="line"><span class="comment"># git checkout testing</span></span><br><span class="line">error: Your <span class="built_in">local</span> changes to the following files would be overwritten by checkout:</span><br><span class="line">	LICENSE</span><br><span class="line">Please, commit your changes or stash them before you can switch branches.</span><br><span class="line">Aborting</span><br></pre></td></tr></table></figure>

<p>你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。而所有这些工作，你需要的命令只有 branch、checkout 和 commit。</p>
<p>如果项目的提交历史产生了分叉，可以简单地使用 git log 命令查看分叉历史。运行 <code>git log --oneline --decorate --graph --all</code> 输出你的提交历史、各个分支的指向以及项目的分支分叉情况。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git log --oneline --decorate --graph --all</span></span><br><span class="line">* bbbdc72 (HEAD, master) another change</span><br><span class="line">| * bb974ab (testing) made a change</span><br><span class="line">|/</span><br><span class="line">* 3352c55 made a change</span><br><span class="line">* e3a0da4 made a change</span><br><span class="line">* fdb9795 initial commit</span><br></pre></td></tr></table></figure>

<p>由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（即共同祖先）也是同样的简单和高效。这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。</p>
<h2 id="分支的新建与合并"><a href="#分支的新建与合并" class="headerlink" title="分支的新建与合并"></a>分支的新建与合并</h2><p>切换分支之前，要留意你的工作目录和暂存区里那些还没有被提交的修改，它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。最好的方法是，在你切换分支之前，保持好一个干净的状态。</p>
<p>使用 <code>git merge</code> 命令完成分支之间的合并。当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 <code>快进(fast-forward)</code>。</p>
<p>如下所示，创建 hotfix 分支并进行改动，然后将 hotfix 分支 merge 到 master 分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git checkout -b &quot;hotfix&quot;</span></span><br><span class="line">Switched to a new branch <span class="string">&#x27;hotfix&#x27;</span></span><br><span class="line"><span class="comment"># echo &quot;new fix in hotfix branch&quot; &gt;&gt; LICENSE</span></span><br><span class="line"><span class="comment"># git commit -a -m &quot;fix in hotfix&quot;</span></span><br><span class="line">[hotfix a29f621] fix <span class="keyword">in</span> hotfix</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git checkout master</span></span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line"><span class="comment"># git merge hotfix</span></span><br><span class="line">Updating bbbdc72..a29f621</span><br><span class="line">Fast-forward</span><br><span class="line"> LICENSE | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"><span class="comment"># cat LICENSE</span></span><br><span class="line">TEST</span><br><span class="line">another change</span><br><span class="line">new fix <span class="keyword">in</span> hotfix branch</span><br></pre></td></tr></table></figure>

<p>使用带 -d 选项的 git branch 命令来删除分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git branch -d hotfix</span></span><br><span class="line">Deleted branch hotfix (was a29f621).</span><br></pre></td></tr></table></figure>

<p>但是如果要 merge 的两个分支并不是直接的祖先关系，Git 不得不做一些额外的工作。如下所示，出现这种情况的时候，Git 会使用两个分支的末端所指的快照，（C4 和 C5）以及这两个分支的工作祖先（C2），做一个简单的三方合并。</p>
<img src="/fuchencong.github.io/2020/05/16/pro-git-03/images/merge.jpg" class="">

<p>和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。这个被称作一次合并提交，它的特别之处在于他有不止一个父提交，如下所示：</p>
<img src="/fuchencong.github.io/2020/05/16/pro-git-03/images/merge2.jpg" class="">

<p>有时候合并操作不会如此顺利。如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。如果在合并它们的时候产生合并冲突，此时 Git 会暂停下来，等待你去解决合并产生的冲突。你可以在合并冲突后的任意时刻使用 <code>git status</code> 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git merge testing</span></span><br><span class="line">Auto-merging LICENSE</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> LICENSE</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git status</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># You have unmerged paths.</span></span><br><span class="line"><span class="comment">#   (fix conflicts and run &quot;git commit&quot;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unmerged paths:</span></span><br><span class="line"><span class="comment">#   (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#	both modified:      LICENSE</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。</p>
<p>如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat LICENSE</span></span><br><span class="line">TEST</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="string">HEAD</span></span><br><span class="line"><span class="string">another change</span></span><br><span class="line"><span class="string">new fix in hotfix branch</span></span><br><span class="line"><span class="string">=======</span></span><br><span class="line"><span class="string">TEST</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; testing</span></span><br></pre></td></tr></table></figure>

<p>在这里例子中，<code>=======</code> 的上半部分为 HEAD 所指示分支（这里为master）在这个区段的内容，<code>=======</code> 的下半部分为 testing 分支在这个区段的内容。为了解决冲突，你必须选择使用由 <code>=======</code> 分割的两部分中的一个，或者你也可以自行合并这些内容。</p>
<p>在解决完冲突并将 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> , <code>=======</code> , 和 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 这些行完全删除后，对每个文件使用 git add 命令来将其标记为冲突已解决。一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。</p>
<p>如果你想使用图形化工具来解决冲突，你可以运行 <code>git mergetool</code>，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突。等你退出合并工具之后，Git 会询问刚才的合并是否成功。如果你回答是，Git 会暂存那些文件以表明冲突已解决。你可以再次运行 git status 来确认所有的合并冲突都已被解决。</p>
<p>如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 <code>git commit</code> 来完成合并提交。</p>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p><code>git branch</code> 命令不只是可以创建与删除分支。如果不加任何参数运行它，会得到当前所有分支的一个列表。输出结果中的 * 字符代表现在检出的那一个分支（也就是说，当前 HEAD 指针所指向的分支）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git branch</span></span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure>

<p>如果需要查看每一个分支的最后一次提交，可以运行 <code>git branch -v</code> 命令。<code>--merged</code> 与 <code>--no-merged</code> 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。如果要查看哪些分支已经合并到当前分支，可以运行 <code>git branch --merged</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git branch --merged</span></span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure>

<p>在这个列表中分支名字前没有 * 的分支通常可以使用 <code>git branch -d</code> 删除掉。因为你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。</p>
<p>查看所有包含未合并工作的分支，可以运行 git branch –no-merged：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git checkout testing</span></span><br><span class="line">Switched to branch <span class="string">&#x27;testing&#x27;</span></span><br><span class="line"><span class="comment"># git branch --no-merged</span></span><br><span class="line">  master</span><br></pre></td></tr></table></figure>

<p>如果包含了还未合并的工作，那么尝试使用 <code>git branch -d</code> 命令删除未合并分支时会失败。如果真的想要删除分支并丢掉那些工作，可以使用 -D 选项强制删除它。</p>
<p>上面描述的选项 –merged 和 –no-merged 会在没有给定提交或分支名作为参数时，分别<br>列出已合并或未合并到 当前分支 的分支。你总是可以提供一个附加的参数来查看其它分支的合并状态而不必检出它们。</p>
<h2 id="分支开发工作流"><a href="#分支开发工作流" class="headerlink" title="分支开发工作流"></a>分支开发工作流</h2><p>接下来会介绍一些常见的利用分支进行开发的工作流程，而正是由于分支管理的便捷，才衍生出这些典型的工作模式。</p>
<h3 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h3><p>在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支，你可以定期地把某些主题分支合并入其他分支中。</p>
<p>许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 master 分支上保留完全稳定的代码（有可能仅仅是已经发布或即将发布的代码）。他们还有一些名为 develop 或者 next 的平行分支，被用来做后续开发或者测试稳定性：这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 master 分支了。</p>
<p>事实上我们刚才讨论的，是随着你的提交而不断右移的指针。稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。<strong>你可以用这种方法维护不同层次的稳定性</strong>。使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。</p>
<h3 id="主题分支"><a href="#主题分支" class="headerlink" title="主题分支"></a>主题分支</h3><p>主题分支对任何规模的项目都适用。主题分支是一种短期分支，它被用来实现单一特性或其相关工作。</p>
<h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><p>请牢记，当你做这么多操作的时候，这些分支全部都存于本地。当你新建和合并分支的时候，所有这一切都只发生在你本地的 Git 版本库中：没有与服务器发生交互。</p>
<p>远程引用是对远程仓库的引用（指针），包括分支、标签等等。你可以通过 <code>git ls-remote &lt;remote&gt;</code> 来显式地获得远程引用的完整列表， 或者通过 <code>git remote show &lt;remote&gt;</code> 获得远程分支的更多信息。</p>
<p>远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信， Git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签，这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。</p>
<p>它们以 <code>&lt;remote&gt;/&lt;branch&gt;</code> 的形式命名。举个例子，假设你的网络里有一个在 git.ourcompany.com 的 Git 服务器。如果你从这里克隆，Git 的 clone 命令会为你自动将其命名为 <code>origin</code>，拉取它的所有数据，创建一个指向它的 master 分支的指针，并且在本地将其命名为 <code>origin/master</code>。Git 也会给你一个与 origin 的 master 分支在指向同一个地方的本地 master 分支，这样你就有工作的基础。</p>
<img src="/fuchencong.github.io/2020/05/16/pro-git-03/images/remote.jpg" class="">

<p>如果要与给定的远程仓库同步数据，运行 <code>git fetch &lt;remote&gt;</code> 命令。例如 <code>git fetch origin</code> 查找 origin 是哪一个服务器，从中抓取本地没有的数据，并且更新本地数据库，移动 origin&#x2F;master 指针到更新之后的位置。</p>
<h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><p>当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。本地的分支并不会自动与远程仓库同步：你必须显式地推送想要分享的分支。使用命令 <code>git push &lt;remote&gt; &lt;branch&gt;</code> 进行推送。如果本地分支和远程分支的命名不相同，可以使用 <code>git push origin local_branch:remote_branch</code> 的命令格式进行推送。</p>
<p>需要注意的是，是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。也就是说只会在本地生成一个 <code>&lt;remote&gt;/&lt;branch&gt;</code> 远程分支引用。</p>
<p>使用命令 <code>git merge &lt;remote&gt;/&lt;branch&gt;</code> 可以将远程分支的工作合并到当前分支。如果想要在本地生成某个远程分支的副本，并将其建立在远程跟踪分支之上，可以使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b branch remote/branch</span><br></pre></td></tr></table></figure>

<p>该例子会给你一个用于工作的本地分支，并且起点位于 remote&#x2F;branch。</p>
<h3 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h3><p>从一个远程跟踪分支检出一个本地分支会自动创建所谓的 <code>跟踪分支</code>，它跟踪的分支叫做 <code>上游分支</code>。跟踪分支是与远程分支有直接关系的本地分支。<strong>如果在一个跟踪分支上输入 <code>git pull</code>，Git 能自动地识别去哪个服务器上抓取</strong>。</p>
<p><strong>当克隆一个仓库时，它通常会自动地创建一个跟踪 origin&#x2F;master 的 master 分支</strong>。运行 <code>git checkout -b &lt;branch&gt; &lt;remote&gt;/&lt;branch&gt;</code> 命令可以创建本地 branch 分支，并跟踪远程分支 <code>&lt;remote&gt;/&lt;branch&gt;</code>。该操作十分常用，所以 Git 提供了 –track 快捷方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --track origin/branch</span><br></pre></td></tr></table></figure>

<p>由于这个操作太常用了，因此 Git 还有一种更快捷的方法。如果你尝试检出的分支不存在且刚好只有一个名字与之匹配的远程分支，那么 Git 就会为你创建一个跟踪分支。如果想要将本地分支与远程分支设置为不同的名字，那么可以使用 git <code>checkout -b &lt;branch&gt; &lt;remote&gt;/&lt;branch&gt;</code>。</p>
<p>想要修改正在跟踪的上游分支，可以在任意时间使用 <code>-u</code> 或 <code>--set-upstream-to</code> 选项运行 <code>git branch</code> 来显式地设置。</p>
<p>当设置好跟踪分支后，可以通过简写 <code>@&#123;upstream&#125;</code> 或 <code>@&#123;u&#125;</code> 来引用它的上游分支。如果想要查看设置的所有跟踪分支，可以使用 <code>git branch</code> 的 <code>-vv</code> 选项。这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支，本地分支是否是领先、落后或是都有。</p>
<p><strong>需要重点注意的一点是这些信息来自于你从每个服务器上最后一次抓取的数据</strong>。这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all; git branch -vv</span><br></pre></td></tr></table></figure>

<h3 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h3><p>当 <code>git fetch</code> 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。它只会获取数据然后让你自己合并。 而 <code>git pull</code> 在大多数情况下它的含义是一个 <code>git fetch</code> 紧接着一个 <code>git merge</code> 命令。git pull 会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并那个远程分支。</p>
<h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>可以运行带有 <code>--delete</code> 选项的 <code>git push</code> 命令来删除一个远程分支。基本上这个命令做的只是从服务器上移除指针。Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p>
<h2 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h2><p>在 Git 中整合来自不同分支的修改主要有两种方法：<code>merge</code> 以及 <code>rebase</code>。这里我们将介绍变基 rebase。</p>
<h3 id="变基的基本操作"><a href="#变基的基本操作" class="headerlink" title="变基的基本操作"></a>变基的基本操作</h3><p>可以使用 rebase 命令将提交到某一分支上的所有修改都移至另一分支上。它的原理是首先找到这两个分支的最近共同祖先，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底，最后将之前另存为临时文件的修改依序应用在目标基底上。</p>
<p>如下所示，将 experiment 分支变基到 master（即当前分支 experiment、变基操作的目标基底分支 master）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout experiment</span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure>

<p>也可以使用 <code>git rebase &lt;basebranch&gt; &lt;topicbranch&gt;</code> 命令形式，可以直接将主题分支 <code>topicbranch</code> 变基到目标分支 <code>master</code> 分支上，这样做能省去你先切换到 <code>topicbranch</code> 分支，再对其执行变基命令的多个步骤。</p>
<p>现在回到 master 分支，进行一次快进合并：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge experiment</span><br></pre></td></tr></table></figure>

<p>merge 和 rebase 这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。</p>
<p>一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁。例如向某个其他人维护的项目贡献代码时。在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 <code>origin/master</code> 上，然后再向主项目提交修改。这样的话，该项目的维护者就不再需要进行整合工作，只需要 <code>快进合并</code> 便可。</p>
<p>请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p>
<p>在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。使用 git rebase 命令的 <code>--onto 选项</code> 可以实现这一点。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --onto master server client</span><br></pre></td></tr></table></figure>

<p>以上命令的意思是：取出 client 分支，找出它从 server 分支分歧之后的补丁，然后把这些补丁在 master 分支上重放一遍，让 client 看起来像直接基于 master 修改一样。</p>
<h3 id="变基的风险"><a href="#变基的风险" class="headerlink" title="变基的风险"></a>变基的风险</h3><p>使用变基得遵守一条准则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。</span><br></pre></td></tr></table></figure>

<p><strong>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交</strong>。如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 git rebase 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p>
<p>如果你只对不会离开你电脑的提交执行变基，那就不会有事。如果你对已经推送过的提交执行变基，但别人没有基于它的提交，那么也不会有事。如果你对已经推送至共用仓库的提交上执行变基命令，并因此丢失了一些别人的开发所基于的提交，那你就有大麻烦了。</p>
<h3 id="变基-vs-合并"><a href="#变基-vs-合并" class="headerlink" title="变基 vs 合并"></a>变基 vs 合并</h3><p><strong>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利</strong>。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/git/" rel="tag"># git</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2020/07/03/ip-command/" rel="prev" title="ip 命令概览">
      <i class="fa fa-chevron-left"></i> ip 命令概览
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2020/05/14/pro-git-02/" rel="next" title="Pro Git（2）：Git 基础">
      Pro Git（2）：Git 基础 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">分支简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E5%88%9B%E5%BB%BA"><span class="nav-number">2.</span> <span class="nav-text">分支创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E5%88%87%E6%8D%A2"><span class="nav-number">3.</span> <span class="nav-text">分支切换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6"><span class="nav-number">4.</span> <span class="nav-text">分支的新建与合并</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86"><span class="nav-number">5.</span> <span class="nav-text">分支管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="nav-number">6.</span> <span class="nav-text">分支开发工作流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%BF%E6%9C%9F%E5%88%86%E6%94%AF"><span class="nav-number">6.1.</span> <span class="nav-text">长期分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E9%A2%98%E5%88%86%E6%94%AF"><span class="nav-number">6.2.</span> <span class="nav-text">主题分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="nav-number">6.3.</span> <span class="nav-text">远程分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A8%E9%80%81"><span class="nav-number">6.4.</span> <span class="nav-text">推送</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%9F%E8%B8%AA%E5%88%86%E6%94%AF"><span class="nav-number">6.5.</span> <span class="nav-text">跟踪分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%89%E5%8F%96"><span class="nav-number">6.6.</span> <span class="nav-text">拉取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="nav-number">6.7.</span> <span class="nav-text">删除远程分支</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E5%9F%BA"><span class="nav-number">7.</span> <span class="nav-text">变基</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E5%9F%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">7.1.</span> <span class="nav-text">变基的基本操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E5%9F%BA%E7%9A%84%E9%A3%8E%E9%99%A9"><span class="nav-number">7.2.</span> <span class="nav-text">变基的风险</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E5%9F%BA-vs-%E5%90%88%E5%B9%B6"><span class="nav-number">7.3.</span> <span class="nav-text">变基 vs 合并</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">192</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
