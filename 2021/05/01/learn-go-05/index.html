<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="这篇文章学习 Go 语言中的包结构，同时 Go 语言原生支持了反射，这里一并介绍。">
<meta property="og:type" content="article">
<meta property="og:title" content="Go 语言学习笔记（5）：包结构、反射">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2021/05/01/learn-go-05/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="这篇文章学习 Go 语言中的包结构，同时 Go 语言原生支持了反射，这里一并介绍。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-05-01T01:06:37.000Z">
<meta property="article:modified_time" content="2024-09-29T07:01:40.402Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2021/05/01/learn-go-05/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Go 语言学习笔记（5）：包结构、反射 | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2021/05/01/learn-go-05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Go 语言学习笔记（5）：包结构、反射
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-01 09:06:37" itemprop="dateCreated datePublished" datetime="2021-05-01T09:06:37+08:00">2021-05-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这篇文章学习 Go 语言中的包结构，同时 Go 语言原生支持了反射，这里一并介绍。</p>
<span id="more"></span>

<h2 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h2><h3 id="工作空间"><a href="#工作空间" class="headerlink" title="工作空间"></a>工作空间</h3><p>依照规范，工作空间（workspace）由 src、bin、pkg 三个目录组成。通常需要将空间路径添加到 GOPATH 环境列表中，以便相关工具能够正常工作（Go1.7 之前必须设置 <code>GOPATH</code> 这个变量，且不能够与 <code>GOROOT</code> 相同。1.8之后，GOPATH有默认值–<code>$HOME/go</code>）。</p>
<p>在工作空间里，包括子包在内的所有源码文件都保存在 src 目录中，而 bin、pkg 两个目录，主要影响 go install&#x2F;get 命令中，它们会将编译结果（可执行文件或静态库）安装到这两个目录下，以实现增量编译。</p>
<p>编译器等相关工具按照 GOPATH 设置的路径搜索目标。在导入目标库时，排在列表前面的路径比当前工作空间优先级更高。另外，<code>go get</code> 默认将下载的第三方包保存到列表的第一个工作空间内。</p>
<p>环境变量 GOROOT 用于指示工具链和标准库的存放位置。在生成工具链时，相关路径就已经嵌入到可执行文件内，无需额外设置。除了通过设置 GOROOT 环境变量来覆盖内部路径外，还可以移动目录或重新编译工具链来解决。</p>
<p>GOBIN 则是强制替代工作空间的 bin 目录，作为 go install 目标保存路径。这可以避免将所有工作空间的 bin 路径添加到 PATH PATH 环境变量中。</p>
<p>在使用 Git 等版本管理工具时，建议忽略 pkg、bin 目录，直接在 src 或具体的子包下创建代码库。</p>
<h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><p>使用标准库或第三方包前，必须使用 import 导入。参数是以工作空间中以 src 为起始的绝对路径。<strong>编译器从标准库开始搜索，然后依次搜索 GOPATH 列表中的各个工作空间</strong>。</p>
<p>除了使用默认包名，还可以使用别名以解决同名冲突问题。import 导入参数是路径，而不是包名，<strong>尽管习惯将包和目录名保持一致，但并不是强制的。在代码中引用包成员时，使用包名而非目录名</strong>。</p>
<p>有 4 种导入包的方式：</p>
<ul>
<li>import “github.com&#x2F;fuchencong&#x2F;test”，默认方式：test.A</li>
<li>import X “github.com&#x2F;fuchencong&#x2F;test”，别名方式：X.A</li>
<li>import . “github.com&#x2F;fuchencong&#x2F;test”，简便方式：A，不推荐在正式项目代码中使用</li>
<li>import _ “github.com&#x2F;fuchencong&#x2F;test”，初始化方式：无法引用，仅用于来初始化目标包</li>
</ul>
<p>不能直接或间接导入自己，不支持任何形式的循环的导入。未使用的导入会被编译器视为错误。</p>
<p>除了工作空间和绝对路径外，部分工具支持相对路径。可以在非工作空间目录下，直接运行、编译一些测试代码。只要路径准确，就可以使用 <code>go build/run/test</code> 进行编译、运行或测试。但是因为缺少工作空间相关目录，<code>go install</code> 无法工作。在设置了 GOPATH 的工作空间中，相对路径会导致编译失败。</p>
<p>即便将代码托管在 github，有时也希望使用自有域名定义下载和导入路径。方法很简单，在 Web 服务器对应路径中返回包含 <code>go-import</code> 跳转信息即可。此时该包就有两个下载路径，本地也有可能存在两个副本。为避免版本不一致的情况发生，可以添加 <code>import comment</code> 让编译器检查导入路径是否与该注释一致。</p>
<h3 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h3><p>包（package）是由一个或多个保存在同一个目录下（不含子目录）的源码文件组成。包的作用类似于名字空间，是成员作用域和访问权限的边界。</p>
<p>包名通常使用单数形式，源文件必须使用 UTF-8 格式，否则会导致编译出错。同一目录下所有的源码文件必须使用相同包名称。因为导入时使用绝对路径，所以在搜索路径下，包必须有唯一路径，但无需是唯一名字。</p>
<p>使用 <code>go list</code> 显示包路径列表。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> list net/...</span><br><span class="line">net</span><br><span class="line">net/http</span><br><span class="line">net/http/cgi</span><br><span class="line">net/http/cookiejar</span><br><span class="line">net/http/fcgi</span><br><span class="line">net/http/httptest</span><br><span class="line">net/http/httptrace</span><br><span class="line">net/http/httputil</span><br><span class="line">net/http/internal</span><br><span class="line">net/http/pprof</span><br><span class="line">net/internal/socktest</span><br><span class="line">net/mail</span><br><span class="line">net/rpc</span><br><span class="line">net/rpc/jsonrpc</span><br><span class="line">net/smtp</span><br><span class="line">net/textproto</span><br><span class="line">net/url</span><br></pre></td></tr></table></figure>

<p>另外有几个被保留、有特殊含义的包名称：</p>
<ul>
<li>main：可执行入口</li>
<li>all：标准库以及 GOPATH 中能找到的所有包</li>
<li>std,cmd：标准库以及工具链</li>
<li>documentation：存储文档信息，无法导入</li>
</ul>
<p><strong>所有成员在包内均可以访问，无论其是否在同一源码文件中。但是只有名称首字母大写的为可导出成员，在包外可见</strong>。该规则适合全局变量、全局常量、类型、结构字段、函数、方法等。可以通过指针转换等方式绕开该限制。</p>
<p>包内每个源码文件都可以定义一个或多个初始化函数，但是编译器不保证执行次序。实际上这些初始化函数都是由编译器自动生成的一个包装函数进行调用，因此可以保证在单一线程上执行，且仅执行一次。</p>
<p><strong>编译器确保首先完成所有全局变量的初始化，然后才开始执行初始化函数。直到这些全部结束后，运行时才正式进入 main.main 入口函数</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;init: &quot;</span>, x)</span><br><span class="line">	x++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;main: &quot;</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./init</span><br><span class="line">init:  100</span><br><span class="line">main:  101</span><br></pre></td></tr></table></figure>

<p>可以在初始化函数中创建 goroutine，并可以等到它执行结束。如果在多个初始化函数中引用全局变量，那么最好在变量定义处直接赋值，因为无法保证执行次序，所以任何初始化函数中的赋值都有可能由于延迟而造成程序运行不符合预期。</p>
<p>需要注意，初始化函数无法直接调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;init&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	init()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go build call_init.go</span><br><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">./call_init.go:8:2: undefined: init</span><br></pre></td></tr></table></figure>

<h3 id="内部包"><a href="#内部包" class="headerlink" title="内部包"></a>内部包</h3><p>在进行代码重构时，通常会把一些内部模块陆续分离出来，以独立包的形式维护，此时基于首字母大小写的访问权限控制机制就显得比较粗犷。因为我们希望这些成员仅在特定范围内访问，而不是向所有用户公开。</p>
<p>内部包机制相当于增加了新的访问机制：所有保存在 internal 目录下的包（包括自身）仅能被其父目录下（含所有层次的子目录）的包访问。导入内部包必须使用完整路径。</p>
<h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>如何管理和保存第三方包，一直存在争议。将项目的所有第三方依赖都放在一个独立的工作空间，可能会导致版本冲突。但是放到项目工作空间，又会把工作目录搞乱。为此引入了 vendor 机制，专门存放第三方的包，实现将源码和依赖完整打包分发。</p>
<p>导入 vendor 中的第三方包时，参数是以 vendor 为起点的绝对路径，这就避免了 vendor 目录位置带来的麻烦，<strong>这使得导入无论使用 vendor，还是 GOPATH 都能保持一致</strong>。</p>
<p>引入的第三方包也有可能有自己的 vendor 依赖目录，此时匹配规则是：从当前源文件所在目录开始，逐级向上构建 vendor 全路径，直到发现路径匹配的目标为止。匹配失败，则依旧搜索 GOPATH。另外，vendor 比标准库优先级跟高。</p>
<p>要使用 vendor 机制，必须开始 <code>GO15VENDOREXPERIMENT=1</code> 环境变量开关，且必须是设置了 GOPATH 的工作空间。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p><strong>反射让我们能在运行期探知对象的类型信息和内存结构</strong>，这从一定程度上弥补了静态语言在动态行为上的不足，同时反射还是实现元编程的重要手段。</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>和 C 数据结构一样，Go 对象头部并没有类型指针，通过其自身是无法在运行期获知任何类型相关信息的。反射操作所需的全部信息都源自接口变量，接口变量除了存储自身类型外，还会保存实际对象的数据类型。如下两个反射入口函数，会将任何传入的对象转换为接口类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value</span><br></pre></td></tr></table></figure>

<p>在面对类型时，需要区分 Type 和 Kind。前者表示真实的类型（静态类型），后者表示其基础结构（底层类型）类别：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> X <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a X = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">	t := reflect.TypeOf(a)</span><br><span class="line">	fmt.Println(t.Name(), t.Kind())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./type</span><br><span class="line">X int</span><br></pre></td></tr></table></figure>

<p>所以在类型判断上，需要选择正确的方式。除了通过实际对象获取类型外，还可以直接构造一些基础复合类型，例如通过 <code>reflect.ArrayOf</code> 构造数组，通过 <code>reflect.MapOf</code> 构造 map。</p>
<p>另外，传入对象应区分基类型和指针类型，因为它们并不属于同一类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="number">100</span></span><br><span class="line"></span><br><span class="line">	tx, tp := reflect.TypeOf(x), reflect.TypeOf(&amp;x)</span><br><span class="line">	fmt.Println(tx, tp, tx == tp)</span><br><span class="line">	fmt.Println(tx.Kind(), tp.Kind())</span><br><span class="line">	fmt.Println(tx == tp.Elem())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./type_pointer</span><br><span class="line">int *int <span class="literal">false</span></span><br><span class="line">int ptr</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>这里使用方法 Elem 返回指针、数组、切片、字典（值）或通道的基类型。只有在获取结构体指针的基类型后，才能遍历它的字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> manager <span class="keyword">struct</span> &#123;</span><br><span class="line">	user</span><br><span class="line">	title <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m manager</span><br><span class="line"></span><br><span class="line">	t := reflect.TypeOf(&amp;m)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> t.Kind() == reflect.Ptr &#123;</span><br><span class="line">		t = t.Elem()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">		f := t.Field(i)</span><br><span class="line">		fmt.Println(f.Name, f.Type, f.Offset)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> f.Anonymous &#123;</span><br><span class="line">			<span class="keyword">for</span> x := <span class="number">0</span>; x &lt; f.Type.NumField(); x++ &#123;</span><br><span class="line">				af := f.Type.Field(x)</span><br><span class="line">				fmt.Println(<span class="string">&quot; &quot;</span>, af.Name, af.Type)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./<span class="keyword">struct</span></span><br><span class="line">user main.user <span class="number">0</span></span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">  age <span class="type">int</span></span><br><span class="line">title <span class="type">string</span> <span class="number">24</span></span><br></pre></td></tr></table></figure>

<p>对于匿名字段，可以用多级索引（按定义顺序）直接访问：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> manager <span class="keyword">struct</span> &#123;</span><br><span class="line">	user</span><br><span class="line">	title <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m manager</span><br><span class="line"></span><br><span class="line">	t := reflect.TypeOf(m)</span><br><span class="line"></span><br><span class="line">	name, _ := t.FieldByName(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">	fmt.Println(name.Name, name.Type)</span><br><span class="line"></span><br><span class="line">	age := t.FieldByIndex([]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125;)</span><br><span class="line">	fmt.Println(age.Name, age.Type)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样地，输出方法集时，一样区分基类型和指针类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">	A</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(A)</span></span> Av() <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Av&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*A)</span></span> Ap() <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Ap&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(B)</span></span> Bv() <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Bv&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*B)</span></span> Bp() <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Bp&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b B</span><br><span class="line"></span><br><span class="line">	t := reflect.TypeOf(&amp;b)</span><br><span class="line">	s := []reflect.Type&#123;t, t.Elem()&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, t := <span class="keyword">range</span> s &#123;</span><br><span class="line">		fmt.Println(t, <span class="string">&quot;:&quot;</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumMethod(); i++ &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot; &quot;</span>, t.Method(i))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*main.B :</span><br><span class="line">  &#123;Ap  func(*main.B) string &lt;func(*main.B) string Value&gt; 0&#125;</span><br><span class="line">  &#123;Av  func(*main.B) string &lt;func(*main.B) string Value&gt; 1&#125;</span><br><span class="line">  &#123;Bp  func(*main.B) string &lt;func(*main.B) string Value&gt; 2&#125;</span><br><span class="line">  &#123;Bv  func(*main.B) string &lt;func(*main.B) string Value&gt; 3&#125;</span><br><span class="line">main.B :</span><br><span class="line">  &#123;Av  func(main.B) string &lt;func(main.B) string Value&gt; 0&#125;</span><br><span class="line">  &#123;Bv  func(main.B) string &lt;func(main.B) string Value&gt; 1&#125;</span><br></pre></td></tr></table></figure>

<p>反射能够探知当前包或外包的非导出结构。还可以利用反射提取 struct tag，还能自动分解。常用于 ORM 映射，或数据格式验证。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span> <span class="string">`field:&quot;name&quot; type:&quot;varchar(50)&quot;`</span></span><br><span class="line">	age  <span class="type">int</span>    <span class="string">`field:&quot;age&quot; type:&quot;int&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> u user</span><br><span class="line">	t := reflect.TypeOf(u)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">		f := t.Field(i)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s: %s %s\n&quot;</span>, f.Name, f.Tag.Get(<span class="string">&quot;field&quot;</span>), f.Tag.Get(<span class="string">&quot;type&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./struct_tag</span><br><span class="line">name: name varchar(<span class="number">50</span>)</span><br><span class="line">age: age <span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>辅助判断方法 Implements、ConvertibleTo、AssignableTo 都是运行期进行动态调用和赋值所必须的。</p>
<h3 id="值"><a href="#值" class="headerlink" title="值"></a>值</h3><p>和 Type 获取类型信息不同，<strong>Value 专注于对象实例数据读写</strong>。ValueOf 接受一个接口变量作为参数。之前说过，接口变量会复制对象，并且是 unaddressable 的，所以要修改目标对象，就必须使用指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">100</span></span><br><span class="line">	va, vp := reflect.ValueOf(a), reflect.ValueOf(&amp;a).Elem()</span><br><span class="line"></span><br><span class="line">	fmt.Println(va.CanAddr(), va.CanSet())</span><br><span class="line">	fmt.Println(vp.CanAddr(), vp.CanSet())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./value</span><br><span class="line">false false</span><br><span class="line">true true</span><br></pre></td></tr></table></figure>

<p>就算传入指针，也需要通过 Elem 获取目标对象，因为被接口存储的指针本身是不能寻址和进行设置操作的。注意，不能对非导出字段直接进行设置操作，无论是当前包还是外包。</p>
<p>注意，不能对非导出字段直接进行设置操作，无论是当前包还是外包。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    code <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := <span class="built_in">new</span>(User)</span><br><span class="line">    v := reflect.ValueOf(p).Elem()</span><br><span class="line"></span><br><span class="line">    name := v.FieldByName(<span class="string">&quot;Name&quot;</span>)</span><br><span class="line">    code := v.FieldByName(<span class="string">&quot;code&quot;</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;name: canaddr = %v, canset = %v\n&quot;</span>, name.CanAddr(), name.CanSet())</span><br><span class="line">    fmt.Printf(<span class="string">&quot;code: canaddr = %v, canset = %v\n&quot;</span>, code.CanAddr(), code.CanSet())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> name.CanSet() &#123;</span><br><span class="line">        name.SetString(<span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> code.CanAddr() &#123;</span><br><span class="line">        *(*<span class="type">int</span>)(unsafe.Pointer(code.UnsafeAddr())) = <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, *p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./not_export</span><br><span class="line">name: canaddr = <span class="literal">true</span>, canset = <span class="literal">true</span></span><br><span class="line">code: canaddr = <span class="literal">true</span>, canset = <span class="literal">false</span></span><br><span class="line">&#123;Tom 100&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过 Interface 方法进行类型推断和转换。当然也可以直接用 <code>Value.Int、Value.Bool</code> 等方法进行类型转换，但是失败时会引发 panic，且不支持 ok-idiom。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name <span class="type">string</span></span><br><span class="line">        Age <span class="type">int</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    u := user &#123;</span><br><span class="line">        <span class="string">&quot;test&quot;</span>,</span><br><span class="line">        <span class="number">20</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v := reflect.ValueOf(&amp;u)</span><br><span class="line">    <span class="keyword">if</span> !v.CanInterface() &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;CanInterface fail&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p, ok := v.Interface().(*user)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Interface fail&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.Age++</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, u)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口有两种 nil 状态（接口真实为 nil&#x2F;接口中的类型信息不为 nil，但是保存的数据为 nil）。解决方法是用 <code>IsNil</code> 判断值是否为 nil。也可以用 unsafe 转换后直接判断 <code>iface.data</code> 是否为零值。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>动态调用方法，需要按照 In 列表准备好所需参数。对于变参来说，用 CallSlice 更方便一些，此时传入一个 <code>[]interface&#123;&#125;</code> 即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> X <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(X)</span></span> Test(x, y <span class="type">int</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y, fmt.Errorf(<span class="string">&quot;err: %d&quot;</span>, x + y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a X</span><br><span class="line">    v := reflect.ValueOf(&amp;a)</span><br><span class="line">    m := v.MethodByName(<span class="string">&quot;Test&quot;</span>)</span><br><span class="line"></span><br><span class="line">    in := []reflect.Value&#123;</span><br><span class="line">        reflect.ValueOf(<span class="number">1</span>),</span><br><span class="line">        reflect.ValueOf(<span class="number">2</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    out := m.Call(in)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> out &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无法调用非导出方法，甚至无法获取有效地址。</p>
<h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>反射库提供了内置函数 make 和 new 的对应操作。这里介绍一下 MakeFunc，使用它可以实现通用模板，适应不同数据类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(args []reflect.Value)</span></span> (results []reflect.Value) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ret reflect.Value</span><br><span class="line">    <span class="keyword">switch</span> args[<span class="number">0</span>].Kind() &#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.Int:</span><br><span class="line">        n := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _, a := <span class="keyword">range</span> args &#123;</span><br><span class="line">            n += <span class="type">int</span>(a.Int())</span><br><span class="line">        &#125;</span><br><span class="line">        ret = reflect.ValueOf(n)</span><br><span class="line">    <span class="keyword">case</span> reflect.String:</span><br><span class="line">        ss := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(args))</span><br><span class="line">        <span class="keyword">for</span> _, s := <span class="keyword">range</span> args &#123;</span><br><span class="line">            ss = <span class="built_in">append</span>(ss, s.String())</span><br><span class="line">        &#125;</span><br><span class="line">        ret = reflect.ValueOf(strings.Join(ss, <span class="string">&quot;&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    results = <span class="built_in">append</span>(results, ret)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeAdd</span><span class="params">(fptr <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fn := reflect.ValueOf(fptr).Elem()</span><br><span class="line">    v := reflect.MakeFunc(fn.Type(), add)</span><br><span class="line">    fn.Set(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> intAdd <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> strAdd <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">string</span>)</span></span> <span class="type">string</span></span><br><span class="line">    makeAdd(&amp;intAdd)</span><br><span class="line">    makeAdd(&amp;strAdd)</span><br><span class="line">    fmt.Println(intAdd(<span class="number">100</span>, <span class="number">200</span>))</span><br><span class="line">    fmt.Println(strAdd(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world!&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果语言能够原生支持泛型（例如 C++），就不需要按照上面这种方式来实现了。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>反射带来方便的同时，也会造成性能损失。如下是一个简单的测试：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Data <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">new</span>(Data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    d.X = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rset</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    v := reflect.ValueOf(d).Elem()</span><br><span class="line">    f := v.FieldByName(<span class="string">&quot;X&quot;</span>)</span><br><span class="line">    f.Set(reflect.ValueOf(x))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSet</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        set(<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkRSet</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        rset(<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -run None -bench . -benchmem</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: bench</span><br><span class="line">BenchmarkSet-8    	1000000000	         0.611 ns/op	       0 B/op	       0 allocs/op</span><br><span class="line">BenchmarkRSet-8   	14663288	        84.1 ns/op	       8 B/op	       1 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok  	bench	2.950s</span><br></pre></td></tr></table></figure>

<p>通过对比，性能差距还是比较大的，因此如果对性能要求较高，还是谨慎使用反射。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/Go/" rel="tag"># Go</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2021/05/02/learn-go-06/" rel="prev" title="Go 语言学习笔记（6）：测试与工具链">
      <i class="fa fa-chevron-left"></i> Go 语言学习笔记（6）：测试与工具链
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2021/04/29/learn-go-04/" rel="next" title="Go 语言学习笔记（4）：并发">
      Go 语言学习笔记（4）：并发 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">包结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4"><span class="nav-number">1.1.</span> <span class="nav-text">工作空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5%E5%8C%85"><span class="nav-number">1.2.</span> <span class="nav-text">导入包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.</span> <span class="nav-text">组织结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E5%8C%85"><span class="nav-number">1.4.</span> <span class="nav-text">内部包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86"><span class="nav-number">1.5.</span> <span class="nav-text">依赖管理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">2.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.</span> <span class="nav-text">类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%80%BC"><span class="nav-number">2.2.</span> <span class="nav-text">值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">2.3.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA"><span class="nav-number">2.4.</span> <span class="nav-text">构建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD"><span class="nav-number">2.5.</span> <span class="nav-text">性能</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">180</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
