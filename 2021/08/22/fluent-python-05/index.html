<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="这篇文章主要介绍 Python 的面对对象惯用法，首先介绍对象与对象名称的区别，解释对象标识、值和别名等概念，以及垃圾回收、del 命令、如何通过弱引用记住对象，而无需对象本身存在。最后会介绍符合 Python 风格的对象。">
<meta property="og:type" content="article">
<meta property="og:title" content="流畅的 Python（5）：符合 Python 风格的对象">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2021/08/22/fluent-python-05/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="这篇文章主要介绍 Python 的面对对象惯用法，首先介绍对象与对象名称的区别，解释对象标识、值和别名等概念，以及垃圾回收、del 命令、如何通过弱引用记住对象，而无需对象本身存在。最后会介绍符合 Python 风格的对象。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2021/08/22/fluent-python-05/images/object_lable.svg">
<meta property="article:published_time" content="2021-08-22T04:11:15.000Z">
<meta property="article:modified_time" content="2022-08-25T12:04:03.804Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fuchencong.github.io/fuchencong.github.io/2021/08/22/fluent-python-05/images/object_lable.svg">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2021/08/22/fluent-python-05/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>流畅的 Python（5）：符合 Python 风格的对象 | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2021/08/22/fluent-python-05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          流畅的 Python（5）：符合 Python 风格的对象
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-22 12:11:15" itemprop="dateCreated datePublished" datetime="2021-08-22T12:11:15+08:00">2021-08-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/Python-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Python 读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这篇文章主要介绍 Python 的面对对象惯用法，首先介绍对象与对象名称的区别，解释对象标识、值和别名等概念，以及垃圾回收、del 命令、如何通过弱引用记住对象，而无需对象本身存在。最后会介绍符合 Python 风格的对象。</p>
<span id="more"></span>

<h2 id="对象引用、可变性和垃圾回收"><a href="#对象引用、可变性和垃圾回收" class="headerlink" title="对象引用、可变性和垃圾回收"></a>对象引用、可变性和垃圾回收</h2><h3 id="变量不是盒子"><a href="#变量不是盒子" class="headerlink" title="变量不是盒子"></a>变量不是盒子</h3><p>Python 变量类似于 Java 中的引用式变量，最好把他们理解为附加在对象上的标签。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>如果把变量看做便利贴，就能很好地说明变量 a 和变量 b 引用用一个列表，而不是那个列表的副本：</p>
<img src="/fuchencong.github.io/2021/08/22/fluent-python-05/images/object_lable.svg" class="">

<p>对于应用式变量而言，说把变量分配给对象更合理，因为对象在赋值前之前已经创建。对于赋值语句而言，对象在右边创建或获取，在此之后左边的变量才会绑定到对象上，就如同为对象贴上标签：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">SimpleObject</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = SimpleObject() * <span class="number">10</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unsupported operand <span class="built_in">type</span>(s) <span class="keyword">for</span> *: <span class="string">&#x27;SimpleObject&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;int&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>()</span><br><span class="line">[<span class="string">&#x27;SimpleObject&#x27;</span>, <span class="string">&#x27;__annotations__&#x27;</span>, <span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__loader__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__spec__&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="标识、相等性和别名"><a href="#标识、相等性和别名" class="headerlink" title="标识、相等性和别名"></a>标识、相等性和别名</h3><p>因为变量只不过是标注，所以可以为对象贴上多个标注。贴的多个标注就是别名：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lily = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;lily&#x27;</span>, <span class="string">&#x27;born&#x27;</span>:<span class="number">2000</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lily_alias = lily</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(lily), <span class="built_in">id</span>(lily_alias)</span><br><span class="line">(<span class="number">4559355456</span>, <span class="number">4559355456</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lily[<span class="string">&#x27;born&#x27;</span>] = <span class="number">2001</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lily_alias[<span class="string">&#x27;born&#x27;</span>]</span><br><span class="line"><span class="number">2001</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_lily = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;lily&#x27;</span>, <span class="string">&#x27;born&#x27;</span>:<span class="number">2001</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lily == another_lily</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lily <span class="keyword">is</span> another_lily</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(lily), <span class="built_in">id</span>(another_lily)</span><br><span class="line">(<span class="number">4559355456</span>, <span class="number">4559391360</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>lily 和 lily_alias 绑定的是同一个对象，而 lily 和 another_lily 虽然内容相同，但是是两个不同的对象</li>
<li>通过 <code>a is b</code> 的方式，可以判断变量所引用对象的标识是否相同</li>
<li><code>==</code> 运算符比较的是两个对象的值（对象中保存的数据），而 is 比较对象的标识</li>
<li>在判断变量和单例值（例如 None）比较时，应该使用 is</li>
</ul>
<p>每个对象都有标识、类型和值。对象一旦创建，它的标识绝对不会变，可以把标识理解为对象在内存中的地址，is 运算符比较两个对象的标识，id() 函数返回对象标识的整数表示。</p>
<p>元祖和多数 Python 集合（列表、字典、集合等等）一样，保存的是对象的引用。如果引用的元素是可变的，即便元祖本身不可变，元素依然可变。元祖的不可变性其实指的是 tuple 数据结构里的物理内容（即保存的引用），与引用的对象无关。元祖的值会随着引用的可变对象的变化而变化，元祖不可变的是元素的标识：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 == t2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 <span class="keyword">is</span> t2</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(t1[-<span class="number">1</span>])</span><br><span class="line"><span class="number">4559353984</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(t2[-<span class="number">1</span>])</span><br><span class="line"><span class="number">4557663808</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1[-<span class="number">1</span>].append(<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(t1[-<span class="number">1</span>])</span><br><span class="line"><span class="number">4559353984</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 == t2</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="默认做浅复制"><a href="#默认做浅复制" class="headerlink" title="默认做浅复制"></a>默认做浅复制</h3><p>复制列表（或多数内置的可变集合）最简单的方式是使用内置的类型构造方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">3</span>, [<span class="number">55</span>, <span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = <span class="built_in">list</span>(l1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 == l2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 <span class="keyword">is</span> l1</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<ul>
<li>副本和源列表值相同，但是二者引用不同的对象</li>
<li>对于列表和其他可变序列来说，还能使用 <code>l2 = l1[:]</code> 创建副本</li>
</ul>
<p>构造方法或 [:] 做的是浅复制，即复制了最外层容器，副本中元素是源容器中元素的引用。如果所有元素都是不可变的，那么这样做没有什么问题，还能节省内存。但是如果有可变的元素，那么可能会导致意想不到的问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1.append(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1</span><br><span class="line">[<span class="number">3</span>, [<span class="number">55</span>, <span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>), <span class="number">100</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2</span><br><span class="line">[<span class="number">3</span>, [<span class="number">55</span>, <span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1[<span class="number">1</span>].remove(<span class="number">55</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1</span><br><span class="line">[<span class="number">3</span>, [<span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>), <span class="number">100</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2</span><br><span class="line">[<span class="number">3</span>, [<span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2[<span class="number">1</span>] += [<span class="number">33</span>, <span class="number">22</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1</span><br><span class="line">[<span class="number">3</span>, [<span class="number">44</span>, <span class="number">33</span>, <span class="number">22</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>), <span class="number">100</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2</span><br><span class="line">[<span class="number">3</span>, [<span class="number">44</span>, <span class="number">33</span>, <span class="number">22</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2[<span class="number">2</span>] += (<span class="number">10</span>, <span class="number">11</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1</span><br><span class="line">[<span class="number">3</span>, [<span class="number">44</span>, <span class="number">33</span>, <span class="number">22</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>), <span class="number">100</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2</span><br><span class="line">[<span class="number">3</span>, [<span class="number">44</span>, <span class="number">33</span>, <span class="number">22</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(l1[<span class="number">2</span>])</span><br><span class="line"><span class="number">4559064576</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(l2[<span class="number">2</span>])</span><br><span class="line"><span class="number">4558943312</span></span><br></pre></td></tr></table></figure>

<ul>
<li>列表复制后，l1 l2 是两个不同的对象，但是二者引用了同一个列表和同一个元祖</li>
<li>往 l1 中添加元素，对 l2 没有影响，因为二者是不同的列表对象</li>
<li>往 l1[1] 中删除元素，对 l2 有影响，因为二者引用了同一个列表</li>
<li>同样，使用就地运算符修改 l2[1]，对 l1 也有影响，因为二者引用的是同一个列表</li>
<li>但是，使用就地运算符修改 l2[2]，由于其是元祖，是不可变类型，就地运算符将产生一个新的元祖来保存结果，因此 l2[2] 引用了这个新的元祖，而 l1[1] 仍然引用之前的元祖</li>
</ul>
<p>浅复制容易操作，但是得到的结果可能并不是你想要的。有时我们需要的是深复制（即副本不共享内部对象的引用）。copy 模块提供的 deepcopy 和 copy 函数能为任意对象做深复制和浅复制。</p>
<p>如下展示了浅拷贝（copy）和深拷贝（deepcopy）的区别：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, passengers = <span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> passengers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.passengers = []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.passengers = <span class="built_in">list</span>(passengers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pick</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.passengers.append(name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drop</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.passengers.remove(name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> bus</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1 = bus.Bus([<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2 = copy.copy(bus1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3 = copy.deepcopy(bus1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(bus1), <span class="built_in">id</span>(bus2), <span class="built_in">id</span>(bus3)</span><br><span class="line">(<span class="number">4307324736</span>, <span class="number">4308831200</span>, <span class="number">4308828368</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.drop(<span class="string">&quot;D&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.passengers</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3.passengers</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(bus1.passengers)</span><br><span class="line"><span class="number">4308849344</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(bus2.passengers)</span><br><span class="line"><span class="number">4308849344</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(bus3.passengers)</span><br><span class="line"><span class="number">4308826688</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到 bus1 和 bus2 共享同一个列表，因为 bus2 是 bus1 的浅拷贝</li>
<li>而 bus3 和 bus1 引用的是不同的列表对象，因为 bus3 是 bus1 的深拷贝</li>
</ul>
<p>深拷贝不是简单的事，如果对象有循环引用，那么朴素的算法会进入无限循环，deepcopy 函数会记住已经复制的对象，因此能够优雅地处理循环引用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [a, <span class="number">30</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, [[...], <span class="number">30</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = deepcopy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, [[...], <span class="number">30</span>]]</span><br></pre></td></tr></table></figure>

<p>此外深复制有时可能太深了。我们可以实现特殊方法 <code>__copy__</code> 和 <code>__deepcopy__</code>，控制 copy 和 deepcopy 的行为。</p>
<h3 id="函数的参数作为引用时"><a href="#函数的参数作为引用时" class="headerlink" title="函数的参数作为引用时"></a>函数的参数作为引用时</h3><p>Python 唯一支持的参数传递模式是共享传参（call by sharing），共享传参指各个形式参数获得实参中引用关系的副本，即形参与实参引用的是同一个对象。这样函数可以通过参数修改传入的可变对象，但是无法修改实参让其引用另一个对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, b</span>):</span><br><span class="line"><span class="meta">... </span>    a += b</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> a</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(x, y)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(a, b)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = (<span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(t, u)</span><br><span class="line">(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u</span><br><span class="line">(<span class="number">30</span>, <span class="number">40</span>)</span><br></pre></td></tr></table></figure>

<p>参数可以有默认值，这样可以在 API 进化的同时保持向后兼容，但是我们应该避免使用可变对象作为参数的默认值，如下展示了一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">TestList</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">list</span>=[]</span>):</span><br><span class="line"><span class="meta">... </span>            self.<span class="built_in">list</span> = <span class="built_in">list</span></span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = TestList()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = TestList()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1.<span class="built_in">list</span>.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2.<span class="built_in">list</span></span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2.<span class="built_in">list</span></span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l3 = TestList([])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l4 = TestList([])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l3.<span class="built_in">list</span>.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l3.<span class="built_in">list</span></span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l4.<span class="built_in">list</span></span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l5 = TestList()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l5.<span class="built_in">list</span></span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1.<span class="built_in">list</span> <span class="keyword">is</span> l2.<span class="built_in">list</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1.<span class="built_in">list</span> <span class="keyword">is</span> l5.<span class="built_in">list</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1.<span class="built_in">list</span> <span class="keyword">is</span> l3.<span class="built_in">list</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1.<span class="built_in">list</span> <span class="keyword">is</span> l4.<span class="built_in">list</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<ul>
<li>TestList 的构造函数，list 参数默认为空列表</li>
<li>创建两个 TestList 对象，都使用默认参数进行初始化，对 l1 中的列表添加元素，l2 也受到影响</li>
<li>创建两个 TestList 对象，这次显式传入空列表，对 l3 中的列表添加元素，对 l4 没有影响</li>
<li>最后创建一个 TestList 对象，仍然使用默认参数进行初始化，l5 初始化完成后，list 元素并不为空</li>
<li>最后可以看到 l1、l2、l5 的 list 是同一个对象，但是和 l3、l4 的 list 不是同一个对象</li>
</ul>
<p>出现这个问题的根源是，默认值是在定义函数时计算的（通常在加载模块时），因此默认值变成了函数对象的属性，因此如果默认值是可变对象，而且修改了它的值，那么后续的函数调用都会受到影响：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(TestList.__init__)</span><br><span class="line">[<span class="string">&#x27;__annotations__&#x27;</span>, <span class="string">&#x27;__call__&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__closure__&#x27;</span>, <span class="string">&#x27;__code__&#x27;</span>, <span class="string">&#x27;__defaults__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__get__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__globals__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__kwdefaults__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__module__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__qualname__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>TestList.__init__.__defaults__</span><br><span class="line">([<span class="number">1</span>],)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(TestList.__init__.__defaults__[<span class="number">0</span>])</span><br><span class="line"><span class="number">4532205312</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(l1.<span class="built_in">list</span>)</span><br><span class="line"><span class="number">4532205312</span></span><br></pre></td></tr></table></figure>

<p>默认参数是可变对象时，可以使用 None 作为接收可变值参数的默认值，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">MyList</span>():</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">list</span> = <span class="literal">None</span></span>):</span><br><span class="line"><span class="meta">... </span>            self.<span class="built_in">list</span> = [] <span class="keyword">if</span> <span class="built_in">list</span> <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="built_in">list</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = MyList()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1.<span class="built_in">list</span>.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = MyList()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1.<span class="built_in">list</span></span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2.<span class="built_in">list</span></span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(l1.<span class="built_in">list</span>)</span><br><span class="line"><span class="number">4358035520</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(l2.<span class="built_in">list</span>)</span><br><span class="line"><span class="number">4358049856</span></span><br></pre></td></tr></table></figure>

<p>该程序虽然解决了默认参数是可变对象带来的奇怪调用问题，但是如果构造时传入了列表，那么 MyList 中 list 和该实参参数引用的是同一个列表，对 MyList 的修改，将影响原有的 list 对象:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l_arg = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l3 = Mylist(l_arg)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l3.<span class="built_in">list</span>.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l3.<span class="built_in">list</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l_arg</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>在设计接口时，如果定义的函数接收可变参数，也应该谨慎考虑调用方是否期望修改传入的参数。例如函数如果接受一个字典，而且的过程中要修改它，那么要考虑这个修改的副作用要不要体现到函数外部。具体情况具体分析，需要函数的编写者和调用者达成共识。接口的设计应该符合 <code>最小惊讶原则</code>。</p>
<p>为了解决该问题，可以在 MyList 中创建一个实参的副本，这样处理方式还更灵活，因为实参可以是任何可迭代对象了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">MyList</span>():</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">list</span> = <span class="literal">None</span></span>):</span><br><span class="line"><span class="meta">... </span>            self.<span class="built_in">list</span> = [] <span class="keyword">if</span> <span class="built_in">list</span> <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="built_in">list</span>(<span class="built_in">list</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="del-和垃圾回收"><a href="#del-和垃圾回收" class="headerlink" title="del 和垃圾回收"></a>del 和垃圾回收</h3><p>对象绝对不会自行销毁，但是无法得到对象时，可能会被当做垃圾回收。del 语句用于删除名称，而不是删除对象。del 命令可能导致对象当做垃圾回收，但是仅当删除的变量保存的是对象的最后一个引用，或者无法得到对象时。重新绑定也可能导致对象的引用计数归零，导致对象被销毁。</p>
<p>在 CPython 中垃圾回收使用的主要算法是引用计数，每个对象都会统计有多少引用指向自己，当引用计数归零时，对象立即被销毁：CPython 会在对象上调用 <code>__del__</code> 方法（如果定义了，该方法给实例最后的机会，释放外部资源），然后释放分配给对象的内存。Python 的其他实现有更复杂的垃圾回收程序，而且不依赖于引用计数，对象的引用计数为 0 时，可能不会立即调用 <strong>del</strong> 方法。</p>
<p>如下演示了对象声明结束时的情形：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = s1</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">bye</span>():</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;Gone with wind&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ender = weakref.finalize(s1, bye)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ender.alive</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> s1</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ender.alive</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="string">&#x27;another&#x27;</span></span><br><span class="line">Gone <span class="keyword">with</span> wind</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ender.alive</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这里注销时的回调函数一定不能绑定要销毁的对象，否则永远会有一个指向该对象的引用，该对象也就永远不会被销毁。这里 fininalize 持有的是 s1 的弱引用，不会增加对象的引用计数</li>
<li>del 不删除对象，只是删除该对象上的一个引用。del s1 后 s2 仍然指向元祖对象，所以该对象不会被销毁</li>
<li>s2 重新赋值后，元祖对象无法获取，对象被销毁了</li>
</ul>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>因为有引用，对象才会在内存中存在。当对象的引用计数归零后，垃圾回收程序会把对象销毁。弱引用不会增加对象的引用数量，引用的目标对象被称为所指对象。因此弱引用不会妨碍所指对象被当做垃圾回收。弱引用在缓存应用中很有用，因为不想仅因为着缓存引用而始终保存着缓存对象。在 Python 控制台里，会自动把变量 <code>_</code> 绑定到结果不为 None 的表达式上。</p>
<p>使用 weakref.ref 实例创建某个实例的弱引用。弱引用是可调用的对象，返回的是被引用的对象，如果所指对象不存在了，返回 None：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref = weakref.ref(a_set)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref</span><br><span class="line">&lt;weakref at <span class="number">0x1058989f0</span>; to <span class="string">&#x27;set&#x27;</span> at <span class="number">0x105994ac0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref()</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(_)</span><br><span class="line"><span class="number">4388899520</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a_set)</span><br><span class="line"><span class="number">4388899520</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref() <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>wref()</code> 返回被引用的对象，由于当前在控制台会话中，所以 <code>_</code> 变量也指向它</li>
<li>之后 a_set 指向另一个集合，由于 <code>_</code> 现在也指向最近的表达式上，因此 <code>&#123;0, 1&#125;</code> 这个集合没有强引用了，因此 <code>wref()</code> 返回 None</li>
</ul>
<p>weakref 类其实是低层接口，供高级用途使用。多数程序最好使用 weakref 集合和 finalize，即应该使用 WeakKeyDictionary、WeakValueDictionary、WeakSet 和 finalize（在内部使用弱引用），不要自己动手创建并处理 weakref.ref 的实例。</p>
<p>WeakValueDictionary 类实现的是一种可变映射，里面的值是对象的弱引用。被引用的对象在程序中的其他地方被当做垃圾回收后，对应的键会自动从 WeakValueDictionary 中删除。因此 WeakValueDictionary 常用于缓存。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cheese</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, kind</span>):</span><br><span class="line">        self.kind = kind</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Cheese(%r)&#x27;</span> % self.kind</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> cheese</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stock = weakref.WeakValueDictionary()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>catalog = [cheese.Cheese(<span class="string">&#x27;A&#x27;</span>), cheese.Cheese(<span class="string">&#x27;B&#x27;</span>), cheese.Cheese(<span class="string">&#x27;C&#x27;</span>), cheese.Cheese(<span class="string">&#x27;D&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> catalog:</span><br><span class="line"><span class="meta">... </span>    stock[c.kind] = c</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(stock.keys())</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> catalog</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(stock.keys())</span><br></pre></td></tr></table></figure>

<ul>
<li>stock 保存了 catalog 中 Cheese 实例的弱引用</li>
<li>当 catalog 被删除后，理论上 stock 中的 cheese 应该都消失，但是最后还存在一个 <code>Cheese(D)</code>。这是因为 for 循环中的变量 c 其实是全局变量（在 Python 控制台中），循环结束后，它还是指向 <code>Cheese(D)</code>，所以引用计数不为 0 ，不被销毁</li>
</ul>
<p>与 WeakValueDictionary 对应的是 WeakKeyDictionary，后者的键是弱引用。WeakSet 是保存元素弱引用的集合类，元素没有强引用使时，集合会把它删除。如果一个类需要知道所有实例，可以创建一个 WeakSet 类型的类属性，保存实例的引用。如果使用常规 set，实例永远不会被垃圾回收，因为类中对实例的强引用，而类存在的时间与 Python 进程一样长，除非显式删除类。</p>
<p>不是每个 Python 对象都可以作为弱引用的目标，这些局限基本上是 CPython 的实现细节，其他 Python 解释器中情况可能不一样。list 和 dict 实例不能作为弱引用的目标，但是它们的子类可以解决这个问题。set 实例可以作为引用目标。用户定义的类型也没有问题。int 和 tuple 的实例不能作为弱引用的目标，甚至它们的子类也不行。</p>
<p>对于元祖 t 来说，你可能会复现，t[:] 和 tuple(t) 都不会创建副本，它们返回的都是同一个元祖的引用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(t)</span><br><span class="line"><span class="number">4347625664</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = t[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t3 = <span class="built_in">tuple</span>(t)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(t2)</span><br><span class="line"><span class="number">4347625664</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(t3)</span><br><span class="line"><span class="number">4347625664</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t4 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t4 <span class="keyword">is</span> t</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>str、bytes 和 frozenset 实例也有这种行为。甚至对于 str、即使新建一个同样内容的字符串，它们也都是指向同一个对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&#x27;test&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">&#x27;test&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c <span class="keyword">is</span> d</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = <span class="number">123456789</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="number">123456789</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e <span class="keyword">is</span> f</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>共享字符串字面量是一种优化措施，称为驻留，CPython 还会在小的整数上使用这个优化措施，防止重复创建热门的数字。注意 CPython 不会驻留所有字符串和整数，驻留的条件是实现细节，没有文档说明。所以千万不要依赖字符串或整数的驻留。</p>
<p>Python 对不可变类型施加的优化能节省内存，提升解释器的速度。而且不会给你带来麻烦，因为它们都是不可变类型。如果两个变量指向的不可变对象具有相同的值，实际上它们指代的是副本还是同一个对象的别名基本没有什么关系。</p>
<h2 id="符合-Python-风格的对象"><a href="#符合-Python-风格的对象" class="headerlink" title="符合 Python 风格的对象"></a>符合 Python 风格的对象</h2><p>得益于 Python 数据模型，自定义类型的行为可以像内置类型那样自然。实现如此自然的行为，靠的不是继承，而是鸭子类型，即只需要按照预定行为实现对象所需方法即可。</p>
<h3 id="对象表示形式"><a href="#对象表示形式" class="headerlink" title="对象表示形式"></a>对象表示形式</h3><p>Python 提供了两种方式用于获取一种对象的字符串表示形式：</p>
<ul>
<li>repr()：以便于开发者理解的方式返回对象的字符串表示形式</li>
<li>str()：以便于用于理解的方式返回对象的字符串表示形式</li>
</ul>
<p>我们需要自己实现 <code>__repr__</code> 和 <code>__str__</code> 特殊方法，为 <code>repr()</code> 和 <code> str()</code> 提供支持。另外还有两个特殊的方法：</p>
<ul>
<li>__bytes__：bytes() 函数调用它获取对象的字节序列表示</li>
<li>__formats__：会被内置的 format() 函数和 str.format() 方法调用，使用特殊的格式代码显示对象的字符串表示形式</li>
</ul>
<h3 id="重新实现向量类"><a href="#重新实现向量类" class="headerlink" title="重新实现向量类"></a>重新实现向量类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector2d</span>:</span><br><span class="line">    typecode = <span class="string">&#x27;d&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = <span class="built_in">float</span>(x)</span><br><span class="line">        self.y = <span class="built_in">float</span>(y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self.x, self.y))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        class_name = <span class="built_in">type</span>(self).__name__</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#123;&#125;(&#123;!r&#125;, &#123;!r&#125;)&#x27;</span>.<span class="built_in">format</span>(class_name, *self)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">tuple</span>(self))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__bytes__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytes</span>([<span class="built_in">ord</span>(self.typecode)]) + <span class="built_in">bytes</span>(array(self.typecode, self))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">tuple</span>(self) == <span class="built_in">tuple</span>(other)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__bool__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bool</span>(<span class="built_in">abs</span>(self))</span><br></pre></td></tr></table></figure>

<ul>
<li>typecode 是类属性</li>
<li>在 <code>__init__</code> 方法中把 x、y 转型为浮点数，这样能尽早捕获错误，以防止传入不当参数</li>
<li>实现了 <code>__iter__</code> 方法，把 Vector2d 对象变成可迭代对象，这样能实现拆包。这里直接通过生成器表达式不断产生分量</li>
<li><code>__repr__</code> 方法首先输出类名，然后使用 <code>&#123;!r&#125;</code> 输出各个分量的表示形式。因为 Vector2d 是一个可迭代对象，所以 *self 会把 x 和 y 分量提供给 format 函数</li>
<li><code>__bytes__</code> 方法首先输出 typecode 的字节形式，然后将该对象转化为数组，再输出数组的字节序列</li>
</ul>
<p>如下展示了 Vector2d 的使用方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> vector2d_v0 <span class="keyword">import</span> Vector2d</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(v1.x, v1.y)</span><br><span class="line"><span class="number">3.0</span> <span class="number">4.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = v1</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y</span><br><span class="line">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1</span><br><span class="line">Vector2d(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1_clone = <span class="built_in">eval</span>(<span class="built_in">repr</span>(v1))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 == v1_clone</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(v1)</span><br><span class="line">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets = <span class="built_in">bytes</span>(v1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets</span><br><span class="line"><span class="string">b&#x27;d\x00\x00\x00\x00\x00\x00\x08@\x00\x00\x00\x00\x00\x00\x10@&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(v1)</span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(v1), <span class="built_in">bool</span>(Vector2d(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">(<span class="literal">True</span>, <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>这里使用 eval 函数来调用 repr() 函数的返回结果，得到了正确的实例。这说明 repr() 函数的返回结果是对构造方法的准确描述。</li>
<li>print 函数调用 str() 函数，进而调用实例的 <code>__str__</code> 方法。而控制台输出一个实例，是调用该实例的 <code>__repr__</code> 方法</li>
<li>bytes 函数会调用实例的 <code>__bytes__</code> 方法</li>
<li>abs 函数会调用实例的 <code>__abs__</code> 方法</li>
<li>bool 函数会调用实例的 <code>__bool__</code> 方法</li>
</ul>
<p>为了能够从字节序列转换成 Vector2d 的实例，接下来在定义一个 frombytes 类方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">frombytes</span>(<span class="params">cls, octets</span>):</span><br><span class="line">    typecode = <span class="built_in">chr</span>(octets[<span class="number">0</span>])</span><br><span class="line">    memv = <span class="built_in">memoryview</span>(octets[<span class="number">1</span>:]).cast(typecode)</span><br><span class="line">    <span class="keyword">return</span> cls(*memv)</span><br></pre></td></tr></table></figure>

<ul>
<li>这里用 classmethod 装饰器表示类方法，它的第一个参数是 cls 类名参数</li>
<li>从第一个字节中读取 typecode，通过 memoryview 的 cast 将其转换为 <code>typecode</code> 类型的序列</li>
<li>通过 <code>*memv</code> 进行拆包，得到构造方法所需要的参数，构造对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v3 = vector2d_v0.Vector2d.frombytes(<span class="built_in">bytes</span>(v1))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v3 == v1</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="classmethod-和-staticmethod"><a href="#classmethod-和-staticmethod" class="headerlink" title="classmethod 和 staticmethod"></a>classmethod 和 staticmethod</h3><p>classmethod 定义了操作类，而不是操作实例的方法，类方法的第一个参数是类本身（按照约定，通常命名为 cls），而不是实例。classmethod 最常见的用途是定义备选构函数。</p>
<p>staticmethod 装饰器也会改变方法的调用方法，但是第一个参数不是特殊的值。静态方法就是普通的函数，只是碰巧在类的定义体中，而不是在模块层定义。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Demo</span>:</span><br><span class="line"><span class="meta">... </span>    @<span class="built_in">classmethod</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">klassmeth</span>(<span class="params">*args</span>):</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> args</span><br><span class="line"><span class="meta">... </span>    @<span class="built_in">staticmethod</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">statmeth</span>(<span class="params">*args</span>):</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> args</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Demo.klassmeth()</span><br><span class="line">(&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Demo&#x27;</span>&gt;,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Demo.klassmeth(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">(&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Demo&#x27;</span>&gt;, <span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Demo.statmeth()</span><br><span class="line">()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Demo.statmeth(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;test&#x27;</span>,)</span><br></pre></td></tr></table></figure>

<ul>
<li>无论怎么调用，classmethod 的第一个参数始终是类型</li>
<li>而静态方法的行为与普通函数相似</li>
</ul>
<p>classmethod 装饰器非常有用，但是 staticmethod 则不存在不得不用的情况，有时函数虽然不处理类，但是函数的功能与类紧密相关，可以把它作为类内的静态方法，但是也可以在同一模块中的类前面或者后面定义该函数。</p>
<h3 id="格式化显示"><a href="#格式化显示" class="headerlink" title="格式化显示"></a>格式化显示</h3><p>内置的 format() 函数和 str.format() 方法把各个类型的格式化方式委托给相应的 <code>.__format__(format_spec)</code> 方法。format_spec 是格式说明符，它是：</p>
<ul>
<li>format(my_obj, format_spec) 的第二个参数</li>
<li>str.format() 方法的格式化字符串，{} 里替换字段中冒号后面的部分</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="number">1</span> / <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">format</span>(f, <span class="string">&#x27;0.4f&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;0.3333&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;:0.4f&#125;&#x27;</span>.<span class="built_in">format</span>(f)</span><br><span class="line"><span class="string">&#x27;0.3333&#x27;</span></span><br></pre></td></tr></table></figure>

<p>类似于 <code>&#123;0.mass:5.3e&#125;</code> 这样的格式字符串包含两部分：</p>
<ul>
<li>冒号左边的在替换字段语法中是字段名，它可以通过关键字或位置参数的方式指定要输出的字段</li>
<li>冒号右边的是格式说明符，格式说明符使用的表示方法称为 <code>格式规范微语言</code></li>
</ul>
<p>格式规范微语言是可以扩展的，各个类可以自行决定如何解释 format_spec 参数。如果类没有定义 <code>__format__</code> 方法，从 <code>object</code> 继承的方法会返回 <code>str(my_object)</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = vector2d_v0.Vector2d(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">format</span>(v1)</span><br><span class="line"><span class="string">&#x27;(3.0, 4.0)&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(v1)</span><br><span class="line"><span class="string">&#x27;(3.0, 4.0)&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;:.f&#125;&#x27;</span>.<span class="built_in">format</span>(v1)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unsupported <span class="built_in">format</span> string passed to Vector2d.__format__</span><br></pre></td></tr></table></figure>

<p>此时传入格式说明符将会报错，我们需要实现自己的微语言来解决这个问题，方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__format__</span>(<span class="params">self, fmt_spec=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    components = (<span class="built_in">format</span>(c, fmt_spec) <span class="keyword">for</span> c <span class="keyword">in</span> self)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#123;&#125;, &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(*components)</span><br></pre></td></tr></table></figure>

<ul>
<li>通过将 fmt_spec 应用到向量的各个分量上，构成一个生成器</li>
<li>最后将将该生成器应用到格式化字符串中，输出每一个分量格式化的字符串</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = vector2d_v0.Vector2d(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">format</span>(v1, <span class="string">&#x27;.3f&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;3.000, 4.000&#x27;</span></span><br></pre></td></tr></table></figure>

<p>我们也可以为类型添加自定义的格式代码，例如如下代码增加了格式代码 <code>p</code> 用来显示向量的极坐标：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">angle</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> math.atan2(self.y, self.x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__format__</span>(<span class="params">self, fmt_spec=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> fmt_spec.endswith(<span class="string">&#x27;p&#x27;</span>):</span><br><span class="line">        fmt_spec = fmt_spec[:-<span class="number">1</span>]</span><br><span class="line">        coords = (<span class="built_in">abs</span>(self), self.angle())</span><br><span class="line">        outer_fmt = <span class="string">&#x27;&lt;&#123;&#125; &#123;&#125;&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        coords = self</span><br><span class="line">        outer_fmt = <span class="string">&#x27;(&#123;&#125; &#123;&#125;)&#x27;</span></span><br><span class="line"></span><br><span class="line">    components = (<span class="built_in">format</span>(c, fmt_spec) <span class="keyword">for</span> c <span class="keyword">in</span> coords)</span><br><span class="line">    <span class="keyword">return</span> outer_fmt.<span class="built_in">format</span>(*components)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> vector2d_v0</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = vector2d_v0.Vector2d(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">format</span>(v1, <span class="string">&#x27;.3f&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;(3.000 4.000)&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">format</span>(v1, <span class="string">&#x27;.3fp&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&lt;5.000 0.927&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="可散列的-Vector2d"><a href="#可散列的-Vector2d" class="headerlink" title="可散列的 Vector2d"></a>可散列的 Vector2d</h3><p>目前实现的 Vector2d 还不是可散列的，因此不能放入集合中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>(v1)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;Vector2d&#x27;</span></span><br></pre></td></tr></table></figure>

<p>之前已经实现了 <code>__eq__</code> 方法，为了把 Vector2d 实例变为可散列的，还必须使用 <code>__hash__</code> 方法，另外向量必须为不可变的，为此需要把 x 和 y 设置为只读属性，为此重新实现其 <code>__init__</code> 方法，并添加两个读值方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">    self.__x = <span class="built_in">float</span>(x)</span><br><span class="line">    self.__y = <span class="built_in">float</span>(y)</span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">x</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self.__x</span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">y</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self.__y</span><br></pre></td></tr></table></figure>

<ul>
<li>使用两个前导下划线（尾部没有下划线，或者有一个下划线）把属性标记为私有的</li>
<li>@property 装饰器把读值方法标记为特性，读值方法与公开属性同名。需要读取 x 和 y 分量的方法可以保持不变，仍然通过 self.x 和 self.y 来读取公开属性，而不必读取私有属性</li>
</ul>
<p>通过将对象的属性设置为只读属性，这些对象才是不可变的。接下来才能实现 <code>__hash__</code> 方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span>(self.__x) ^ <span class="built_in">hash</span>(self.__y)</span><br></pre></td></tr></table></figure>

<p>现在改类型就是可散列类型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = vector2d_v0.Vector2d(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>(v1)</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v2 = vector2d_v0.Vector2d(<span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>(v2)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">set</span>([v1, v2])</span><br></pre></td></tr></table></figure>

<p>如果定义的类型有标量数值，可能还需要实现 <code>__int__</code> 和 <code>__float__</code> 方法（分别被 int() 和 float() 构造函数调用），以便在某些情况下用于强制类型转换。</p>
<p>要想得到功能完善的对象，这些方法可能是必备的。当然如果你的应用用不到，就没有必要全部实现这些方法。</p>
<h3 id="Python-的私有属性和受保护的属性"><a href="#Python-的私有属性和受保护的属性" class="headerlink" title="Python 的私有属性和受保护的属性"></a>Python 的私有属性和受保护的属性</h3><p>Python 不能像 Java 那样使用 private 修饰符创建私有属性，但是 Python 有个简单的机制，能够避免子类意外覆盖私有属性。如果以 <code>__x</code>（两个前导下划线，尾部没有下划线或者最多有一个下划线）命名实例属性，Python 会把属性名存入实例的 <strong>dict</strong> 属性中，而且会在前面加上一个下划线和类名。这个语言特性叫做改写（name mangling）：</p>
<p>名称改写是一种安全措施，不能保证万不一失，它的目的是避免意外访问，不能防止故意做错事。只要知道改写私有属性名的机制，任何人都能直接读取私有属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;_Vector2d__x&#x27;</span>: <span class="number">3.0</span>, <span class="string">&#x27;_Vector2d__y&#x27;</span>: <span class="number">4.0</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1._Vector2d__x</span><br><span class="line"><span class="number">3.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1._Vector2d__x = <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(v1)</span><br><span class="line">(<span class="number">4</span>, <span class="number">4.0</span>)</span><br></pre></td></tr></table></figure>

<p>不是所有程序员都喜欢名称改写功能，也不是所有人都喜欢 <code>self.__x</code> 这种不对称的名称。他们约定使用一个下划线前缀编写 <code>受保护的</code> 属性（例如 self._x）。Python 解释器不会对使用单个下划线的属性名称做特殊处理，这只是 Python 程序员严格遵守的约定，它们不会在类外部访问这种属性。Python 文档中有时会把使用一个下划线前缀标记的属性称为 <code>受保护的属性</code>。</p>
<h3 id="使用-slots-类属性节省空间"><a href="#使用-slots-类属性节省空间" class="headerlink" title="使用 slots 类属性节省空间"></a>使用 <strong>slots</strong> 类属性节省空间</h3><p>默认情况下，Python 在各个实例中的 <code>__dict__</code> 属性中存储实例属性。为了使用底层的散列表提升访问速度，字典会消耗大量内存。如果要处理包含数百万个属性的实例，通过 <code>__slots__</code> 类属性，能节省大量内存，方法是让解释器在元祖中存储实例属性，而不用字典。需要注意，继承自超类的 <code>__slots__</code> 属性没有效果，Python 只会使用各个类中定义的 <code>__slots__</code> 属性。</p>
<p>定义 <code>__slots__</code> 的方式，创建一个类属性，使用 <code>__slots__</code> 这个名称，并且把它的值设为一个字符串构成的可迭代对象，其中各个元素表示各个实例属性。在类中定义 <code>__slots__</code> 属性的目的是告诉解释器：这个类中的所有实例属性都在这儿了。这样 Python 会在各个实例中使用类似元祖的结构存储实例属性，从而避免使用消耗内存的 <code>__dict__</code>。</p>
<p>在类中定义 <code>__slots__</code> 属性之后，实例不能再有 <code>__slots__</code> 中所列名称之外的其他属性了。这只是一个副作用，不是 <code>__slots__</code> 存在的真正原因，所以不要使用 <code>__slots__</code> 属性禁止类的用户新增实例属性。</p>
<p>如果把 <code>__dict__</code> 这个名称添加到 <code>__slots__</code> 中，实例会在元祖中保存各个实例的属性，此外还支持动态创建属性，这些属性存储在常规的 <code>__dict__</code> 中。还有一个实例属性需要注意：<code>__weakref__</code> 属性。为了让对象支持弱引用，必须有这个属性，用户定义的类中默认就有 <code>__weakref__</code> 属性，可是如果类中定义了 <code>__slots__</code> 属性，而且想把实例作为弱引用的目标，那么要把 <code>__weakref__</code> 添加到 <code>__slots__</code> 中。</p>
<h3 id="覆盖类属性"><a href="#覆盖类属性" class="headerlink" title="覆盖类属性"></a>覆盖类属性</h3><p>Python 中有个很独特的特性，类属性可以为实例属性提供默认值，在上面的例子中，我们通过 <code>self.typecode</code> 的方式获取类属性 typecode，实例对象本身没有这个属性。但是如果为不存在的实例属性赋值，会新建实例属性，并为新建的实例属性赋值，同名的类属性不受影响。之后实例读取的 <code>self.typecode</code> 也是实例属性 <code>typecode</code>，即把同名的类属性给覆盖了。</p>
<p>如果想修改类属性的值，必须直接在类上修改，不能通过实例修改，例如如果想修改所有实例的 typecode 属性的默认值，可以通过如下方式实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector2d.typecode = <span class="string">&#x27;f&#x27;</span></span><br></pre></td></tr></table></figure>

<p>有种修改方法更符合 Python 风格，而且效果持久，也更有针对性，类属性是公开的，因此会被子类继承，于是经常会创建一个子类，只用于定制类的数据属性。</p>
<p>不管怎么样，符合 Python 风格的对象应该正好符合所需，而不是堆砌语言特性。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/Python/" rel="tag"># Python</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2021/09/05/fluent-python-06/" rel="prev" title="流畅的 Python（6）：序列的修改、散列和切片">
      <i class="fa fa-chevron-left"></i> 流畅的 Python（6）：序列的修改、散列和切片
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2021/08/08/fluent-python-04/" rel="next" title="流畅的 Python（4）：函数装饰器和闭包">
      流畅的 Python（4）：函数装饰器和闭包 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E3%80%81%E5%8F%AF%E5%8F%98%E6%80%A7%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">1.</span> <span class="nav-text">对象引用、可变性和垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8D%E6%98%AF%E7%9B%92%E5%AD%90"><span class="nav-number">1.1.</span> <span class="nav-text">变量不是盒子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AF%86%E3%80%81%E7%9B%B8%E7%AD%89%E6%80%A7%E5%92%8C%E5%88%AB%E5%90%8D"><span class="nav-number">1.2.</span> <span class="nav-text">标识、相等性和别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%81%9A%E6%B5%85%E5%A4%8D%E5%88%B6"><span class="nav-number">1.3.</span> <span class="nav-text">默认做浅复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%BC%95%E7%94%A8%E6%97%B6"><span class="nav-number">1.4.</span> <span class="nav-text">函数的参数作为引用时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#del-%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">1.5.</span> <span class="nav-text">del 和垃圾回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="nav-number">1.6.</span> <span class="nav-text">弱引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%A6%E5%90%88-Python-%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.</span> <span class="nav-text">符合 Python 风格的对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F"><span class="nav-number">2.1.</span> <span class="nav-text">对象表示形式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%96%B0%E5%AE%9E%E7%8E%B0%E5%90%91%E9%87%8F%E7%B1%BB"><span class="nav-number">2.2.</span> <span class="nav-text">重新实现向量类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#classmethod-%E5%92%8C-staticmethod"><span class="nav-number">2.3.</span> <span class="nav-text">classmethod 和 staticmethod</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%98%BE%E7%A4%BA"><span class="nav-number">2.4.</span> <span class="nav-text">格式化显示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E6%95%A3%E5%88%97%E7%9A%84-Vector2d"><span class="nav-number">2.5.</span> <span class="nav-text">可散列的 Vector2d</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Python-%E7%9A%84%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">2.6.</span> <span class="nav-text">Python 的私有属性和受保护的属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-slots-%E7%B1%BB%E5%B1%9E%E6%80%A7%E8%8A%82%E7%9C%81%E7%A9%BA%E9%97%B4"><span class="nav-number">2.7.</span> <span class="nav-text">使用 slots 类属性节省空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%B1%BB%E5%B1%9E%E6%80%A7"><span class="nav-number">2.8.</span> <span class="nav-text">覆盖类属性</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">182</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
