<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="函数是结构化编程的最小模块单元，它将复杂算法过程分解为若干较小任务，隐藏相关细节，使得程序结构更加清晰，易于维护。函数被设计成相对独立、通过接收输入参数完成一段算法，输出或存储相关结果。因此函数也是代码复用和测试的基本单元。">
<meta property="og:type" content="article">
<meta property="og:title" content="Go 语言学习笔记（2）：函数与数据">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2021/04/26/learn-go-02/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="函数是结构化编程的最小模块单元，它将复杂算法过程分解为若干较小任务，隐藏相关细节，使得程序结构更加清晰，易于维护。函数被设计成相对独立、通过接收输入参数完成一段算法，输出或存储相关结果。因此函数也是代码复用和测试的基本单元。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-04-26T11:36:14.000Z">
<meta property="article:modified_time" content="2024-09-29T07:01:40.265Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2021/04/26/learn-go-02/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Go 语言学习笔记（2）：函数与数据 | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2021/04/26/learn-go-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Go 语言学习笔记（2）：函数与数据
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-26 19:36:14" itemprop="dateCreated datePublished" datetime="2021-04-26T19:36:14+08:00">2021-04-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>函数是结构化编程的最小模块单元，它将复杂算法过程分解为若干较小任务，隐藏相关细节，使得程序结构更加清晰，易于维护。函数被设计成相对独立、通过接收输入参数完成一段算法，输出或存储相关结果。因此函数也是代码复用和测试的基本单元。</p>
<span id="more"></span>
<h2 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h2>
<h3 id="函数基础"><a class="markdownIt-Anchor" href="#函数基础"></a> 函数基础</h3>
<p>关键字 func 用于定义函数，同样，左花括号不能另起一行：</p>
<ul>
<li>无需前置声明</li>
<li>支持不定长变参</li>
<li>支持任意个数返回值（0 个、1 个，多个）</li>
<li>支持命名返回值</li>
<li>支持匿名函数和闭包</li>
<li>不支持命名嵌套定义</li>
<li>不支持同名函数重载</li>
<li>不支持默认参数</li>
</ul>
<p>函数属于第一类对象（指可以在运行期创建，可用作函数参数或者返回值，可存入变量的实体），具有相同签名（参数及返回值列表）的视为同一类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exec</span><span class="params">(f <span class="keyword">func</span>()</span></span>) &#123;</span><br><span class="line">	f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	exec(hello)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从阅读和代码维护的角度来说，使用命名类型更加方便。函数只能判断其是否为 nil，不支持其他比较操作。<strong>从函数返回局部变量指针是安全的，编译器会通过逃逸分析（escape analysis）来决定是否在堆上分配内存</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> heap.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">func <span class="built_in">test</span>() *int &#123;</span><br><span class="line">	a := 0x100</span><br><span class="line">	<span class="built_in">return</span> &amp;a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	p := <span class="built_in">test</span>()</span><br><span class="line">	println(p, *p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go build -gcflags <span class="string">&quot;-l -m&quot;</span> heap.go</span><br><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">./heap.go:4:2: moved to heap: a</span><br></pre></td></tr></table></figure>
<p>函数内联（inline）对内存分配有一定影响，如果出现内联，那么会直接在栈上分配内存。</p>
<p>在避免冲突的情况下，函数命名要本着精简短小、望文知意的原则：</p>
<ul>
<li>通常是动词和介词加上名词</li>
<li>避免不必要的缩写</li>
<li>避免使用类型关键字</li>
<li>避免歧义</li>
<li>避免只能通过大小写区分的同名函数</li>
<li>避免与内置函数同名，这会导致误用</li>
<li>避免使用数字，除非是特定专有名字</li>
<li>避免添加作用域提示前缀</li>
<li>统一使用 camel/pascal case 拼写风格</li>
<li>统一使用相同术语，保持一致性</li>
<li>使用习惯用语，比如 init 表示初始化，is/has 返回布尔结果</li>
<li>使用反义词组命名行为相反的函数，比如 get/set，min/max 等</li>
</ul>
<p>另外，函数和方法的命名规则稍有些不同，方法通过选择符调用，且具备状态上下文，可以使用更简单的动词命名。</p>
<h3 id="参数"><a class="markdownIt-Anchor" href="#参数"></a> 参数</h3>
<p>Go 对参数的处理偏向保守，不支持有默认值的可选参数，不支持命名实参。调用时必须按照签名顺序传递指定类型和数量的实参，就算以 <code>_</code> 命名的参数也不能忽略。在函数形参列表中，相邻的同类型参数可以合并。函数可以视为函数局部变量，因此不能在相同层次定义同名变量。</p>
<p>不管是指针、引用类型还是其他类型参数，都是值拷贝传递（pass-by-value）。区别无非是拷贝目标对象，还是拷贝指针。在函数调用前，会为形参和返回值分配内存空间，并将实参拷贝到形参内存。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;pointer %p, target %v&quot;</span>, &amp;x, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">0x100</span></span><br><span class="line">	p := &amp;a</span><br><span class="line">	fmt.Printf(<span class="string">&quot;pointer: %p, target: %v\n&quot;</span>, &amp;p, p)</span><br><span class="line">	test(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>被复制的指针会延长目标对象生命周期，还可能会导致它被分配到堆上</strong>，那么其性能就得加上堆内存分配和垃圾回收的成本。在栈上复制小对象只需很少的指令即可，远比运行时进行堆内存分配要快的多。</p>
<p>要实现传出参数，通常建议使用返回值。也可以使用二级指针，如果函数参数过多，建议将其重构为一个复合结构类型，也算是变相实现可选参数和命名实参功能。将过多的参数独立成 <code>option struct</code>，既便于扩展参数集，也方便通过 <code>newOption()</code> 函数设置默认配置。</p>
<h4 id="变参"><a class="markdownIt-Anchor" href="#变参"></a> 变参</h4>
<p><strong>变参本质上就是一个切片，只能接收一到多个同类型的参数，且必须放到参数列表尾部</strong>。将切片本身作为变参时，需要进行展开。如果是数组，需要先将其转换为切片。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func test(a ...int) &#123;</span><br><span class="line">	fmt.Printf(&quot;%T, %v\n&quot;, a, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	test(1, 2, 3, 4)</span><br><span class="line"></span><br><span class="line">	a := make([]int, 3)</span><br><span class="line">	a[0] = 5</span><br><span class="line">	test(a...)</span><br><span class="line"></span><br><span class="line">	b := [3]int&#123;10, 20, 30&#125;</span><br><span class="line">	test(b[:]...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>由于变参是切片，那么参数复制的仅仅是切片自身，并不包括底层数组，也因此可修改原数据。如果需要，可以使用内置函数 copy 底层数据</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a ...<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> a &#123;</span><br><span class="line">		a[i] += <span class="number">100</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">	test(a...)</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./var_param_2</span><br><span class="line">[<span class="number">110</span> <span class="number">120</span> <span class="number">130</span>]</span><br></pre></td></tr></table></figure>
<h3 id="返回值"><a class="markdownIt-Anchor" href="#返回值"></a> 返回值</h3>
<p>有返回值的函数，必须有明确的 return 终止语句。有 panic 或者死循环（无break），则无需 return 终止语句。Go 函数支持多返回值，因此函数可以返回更多状态，尤其是 error 模式。<strong>但是需要注意，不能用数组、切片接收多返回值，但是可以用 <code>_</code> 忽略掉不想要的返回值</strong>。</p>
<p>也可以对返回值进行命名，这样让函数声明更加清晰，同时也会改善帮助文档和代码编辑器提示。<strong>命名返回值和参数一样，可当做局部变量使用，最后由 return 语句隐式返回</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> (z <span class="type">int</span>) &#123;</span><br><span class="line">	z = x + y</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(add(<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些特殊的局部变量会被不同层级的同名变量遮蔽，但是编译器能够检查到此类错误，只需要改为显式的 return 即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> (z <span class="type">int</span>) &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		z := x + y</span><br><span class="line">		<span class="keyword">return</span>		<span class="comment">// z is shadowed during return, 需要改为 return z</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(add(<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了遮蔽问题，还需要注意，如果对返回值命名，则需要对全部返回值命名，否则编译器会搞不清楚状况。它无法确认 return 语句中的返回值是如何对应的（此时编译器会跳过未命名的返回值，无法准确匹配）。如果返回值类型能够明确表明其含义，就不要对其进行命名。</p>
<h3 id="匿名函数"><a class="markdownIt-Anchor" href="#匿名函数"></a> 匿名函数</h3>
<p>匿名函数是指没有定义名字符号的函数。除了没有名字外，匿名函数和普通函数完全相同。最大的区别是函数内部定义匿名函数，形成类似嵌套的效果，<strong>匿名函数可以直接调用，保存到变量，作为参数或返回值</strong>。普通函数和匿名函数都可以作为结构体字段，或者经通道传递。不曾使用的匿名函数会被编译器当做错误。</p>
<p>闭包（closure）是指在其词法上下文中引用了自由变量的函数，或者说是函数和其引用环境的组合体。如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(x)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := test(<span class="number">123</span>)</span><br><span class="line">	f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 test 返回的匿名函数会引用上下文环境变量。当该函数在 main 中执行时，依然能够正确读取该值，这种现象就称为闭包。<strong>对于一个闭包，返回的不仅仅是匿名函数，还包括所引用的环境变量的指针。所以说，闭包是匿名函数和引用环境的组合体</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(&amp;x)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(&amp;x, x)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := test(<span class="number">0x100</span>)</span><br><span class="line">	f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./closure_pointer</span><br><span class="line"><span class="number">0xc00008e000</span></span><br><span class="line"><span class="number">0xc00008e000</span> <span class="number">256</span></span><br></pre></td></tr></table></figure>
<p>正是因为闭包通过指针引用环境变量，那么可能会导致其生命周期延长，甚至被分配到堆内存中，而且还具有 <code>延迟求值</code> 的特性：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> []<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		s = <span class="built_in">append</span>(s, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="built_in">println</span>(&amp;i, i)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> test() &#123;</span><br><span class="line">		f()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xc00008e000</span> <span class="number">2</span></span><br><span class="line"><span class="number">0xc00008e000</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，由于每次添加的匿名函数都是引用的同一个变量，添加操作仅仅是将匿名函数放到列表中，并未执行该匿名函数，<strong>当在 main 中真正执行这些匿名函数时，它读取的就是该变量 i 的最新值</strong>。要解决这个问题，就是每次使用不同的环境变量变量或者传参复制，让各自闭包环境各不相同。多个匿名函数引用同一环境变量，也会让事情变得更加复杂，任何修改行为都会影响其他函数取值，在并发模式下可能需要做同步处理。</p>
<p>闭包让我们不用传递参数就可以读取或修改环境状态，当然也要为此付出额外代价，对于性能要求较高的场合，需要慎重使用。匿名函数也是一种常见的重构手段，可将大函数分解成多个相对独立的匿名函数块，然后用相对简洁的调用完成逻辑流程，以实现框架和细节分离。</p>
<h3 id="延迟调用"><a class="markdownIt-Anchor" href="#延迟调用"></a> 延迟调用</h3>
<p>语句 defer 向当前函数注册稍后执行的函数调用，这些调用被称为延迟调用。它们在当前函数执行结束前才被执行，常用于资源的释放，解除锁定、以及错误处理等操作。<strong>延迟调用注册的是调用，因此必须提供所需参数（哪怕为空）</strong>。参数值在注册时被复制缓存起来。如过对状态敏感，可改用指针或闭包。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x, y := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;defer x, y = %d %d&quot;</span>, a, y)</span><br><span class="line">	&#125;(x)</span><br><span class="line"></span><br><span class="line">	x += <span class="number">100</span></span><br><span class="line">	y += <span class="number">200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./<span class="keyword">defer</span></span><br><span class="line"><span class="keyword">defer</span> x, y = <span class="number">1</span> <span class="number">202</span></span><br></pre></td></tr></table></figure>
<p>多个延迟注册按 FILO 次序执行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器通过插入额外指令来实现延迟调用执行，而 return 和 panic 语句都会终止当前函数流程，引发延迟调用。另外，先是由 return 语句更新返回值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> (z <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;defer:&quot;</span>, z)</span><br><span class="line">		z += <span class="number">100</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;test:&quot;</span>, test())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要牢记，延迟调用在函数结束时才被执行，不合理的使用方式会浪费更多资源，甚至造成逻辑错误。相比直接用 CALL 指令调用函数，<strong>延迟调用会花费更大的代价，这其中包括注册、调用等操作，还有额外的缓存开销</strong>。</p>
<h3 id="错误处理"><a class="markdownIt-Anchor" href="#错误处理"></a> 错误处理</h3>
<p>官方推荐的做法是返回 error 状态。标准库将 <code>error</code> 定义为接口类型，以便实现自定义错误类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">	Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照惯例，error 总是最后一个返回参数，标准库提供了相关创建函数，可以方便地创建包含简单错误文本的 error 对象。<strong>应该通过错误变量，而非文本内容来判定错误类型</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> errDivByZero = errors.New(<span class="string">&quot;division by zero&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(x, y <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> y == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, errDivByZero</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> x / y, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	z, err := div(<span class="number">5</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err == errDivByZero &#123;</span><br><span class="line">		log.Fatalln(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">println</span>(z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与 errors.New 类似的还有 fmt.Errorf，它返回一个格式化内容的错误对象。错误变量的字符串内容通常全部小写，没有结束标点，以便于嵌入到其他格式化字符串中进行输出。</p>
<p>有时候我们需要自定义错误类型，以容纳更多上下文状态信息，这样的话，还可以基于类型做判断：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DivError <span class="keyword">struct</span> &#123;</span><br><span class="line">	x, y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(DivError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;division by zero&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(x, y <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> y == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, DivError&#123;x, y&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> x / y, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_, err := div(<span class="number">5</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> e := err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> DivError:</span><br><span class="line">			fmt.Println(e, e.x, e.y)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(e)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义错误类型通常以 Error 为名称后缀，在用 switch 按类型匹配时，需要注意 case 的顺序。应将自定义类型放在前面，有限匹配更具体的错误类型。大量函数和方法返回 error，使得调用代码变得很难看，代码里有一堆的检查语句，解决思路有：</p>
<ul>
<li>使用专门的检查函数处理逻辑错误，简化检查代码</li>
<li>在不影响逻辑的情况下，使用 defer 延后处理错误状态（err 退化赋值）</li>
<li>在不中断逻辑的情况下，将错误作为内部状态保存，等待最终提交时再做处理</li>
</ul>
<p>与 error 相比，panic/recover 在使用方法上更接近 try/catch 结构化异常。它们都是内置函数而非语句，panic 会立即中断当前函数流程，执行延迟调用，而在延迟调用函数中，recover 可以捕获并返回 panic 提交的错误对象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panic</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recover</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>由于 panic 参数是空接口类型，因此可以使用任何对象作为错误状态。而 recover 的结果也需要做转型才能获得具体的信息。无论是否执行 recover，所有延迟调用都会被执行，但中断性错误会沿调用堆栈向外传递，要么被外层捕获，要么导致进程崩溃。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">&quot;test.1&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">&quot;test.2&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;i am dead&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		log.Println(<span class="built_in">recover</span>())</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>连续调用 panic，仅最后一个会被 recover 捕获。在延迟函数中 panic，不会影响后续延迟调用执行，而 recover 之后 panic，可以再次被捕获。另外，<strong>recover 必须在延迟函数中执行才能正常工作</strong>。考虑到 recover 的特性，如果要保护代码片段，那么只能将其重构为函数调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	z := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">recover</span>() != <span class="literal">nil</span> &#123;</span><br><span class="line">				z = <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		z = x / y</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;x / y = &quot;</span>, z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	test(<span class="number">5</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调试阶段，可以使用 runtime/debug.PrintStack 函数输出完整的调用堆栈信息。除非是不可恢复的、导致系统无法正常工作的错误，否则不建议使用 panic。</p>
<h2 id="数据"><a class="markdownIt-Anchor" href="#数据"></a> 数据</h2>
<h3 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h3>
<p>字符串是不可变字节（byte）序列，其本身是一个复合结构。头部指针指向字节数组，但没有 NULL 结尾，默认以 UTF-8 编码存储 Unicode 字符，字面量允许使用十六进制、八进制和 UTF 编码格式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stringStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    str unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串默认值不是 nil，而是 <code>&quot;&quot;</code>。使用 `` 定义不做转义处理的原始字符串，支持跨行。编译器不会解析原始字符串内的注释语句，且前置缩进空格也属于字符串内容。</p>
<p>支持 <code>!=、==、&lt;、&gt;、+、+=</code> 操作符。允许以索引号访问字节数组（非字符），但不能获取元素地址。len(str) 返回的也是字符串所占据的字节数（并不一定等于字符数）。以切片语法（起始和结束索引号）返回子串时，其内部依旧指向原字节数组：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">&quot;abcdefg&quot;</span></span><br><span class="line"></span><br><span class="line">	s1 := s[:<span class="number">3</span>]</span><br><span class="line">	s2 := s[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">	s3 := s[<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println</span>(s1, s2, s3)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, (*reflect.StringHeader)(unsafe.Pointer(&amp;s)))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, (*reflect.StringHeader)(unsafe.Pointer(&amp;s1)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abc bcd cdefg</span><br><span class="line">&amp;reflect.StringHeader&#123;Data:0x10cd924, Len:7&#125;</span><br><span class="line">&amp;reflect.StringHeader&#123;Data:0x10cd924, Len:3&#125;</span><br></pre></td></tr></table></figure>
<p>使用 for 遍历字符串时，分 byte 和 rune 两种方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">&quot;我们&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d: [%c]\n&quot;</span>, i, s[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d: [%c]\n&quot;</span>, i, c)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./for_string</span><br><span class="line">0: [æ]</span><br><span class="line">1: []</span><br><span class="line">2: []</span><br><span class="line">3: [ä]</span><br><span class="line">4: [»]</span><br><span class="line">5: [¬]</span><br><span class="line">0: [我]</span><br><span class="line">3: [们]</span><br></pre></td></tr></table></figure>
<p>要修改字符串，需要将其转换为可变类型（[]rune 或 []byte），待完成后再转换回来。但是不管如何转换，都需要重新分配内存，并复制数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pp</span><span class="params">(format <span class="type">string</span>, ptr <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	p := reflect.ValueOf(ptr).Pointer()</span><br><span class="line">	h := (*<span class="type">uintptr</span>)(unsafe.Pointer(p))</span><br><span class="line">	fmt.Printf(format, *h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">	pp(<span class="string">&quot;s: %x\n&quot;</span>, &amp;s)</span><br><span class="line"></span><br><span class="line">	bs := []<span class="type">byte</span>(s)</span><br><span class="line">	s2 := <span class="type">string</span>(bs)</span><br><span class="line"></span><br><span class="line">	pp(<span class="string">&quot;string to []byte, bs: %x\n&quot;</span>, &amp;bs)</span><br><span class="line">	pp(<span class="string">&quot;[]byte to string, s2: %x\n&quot;</span>, &amp;s2)</span><br><span class="line"></span><br><span class="line">	rs := []<span class="type">rune</span>(s)</span><br><span class="line">	s3 := <span class="type">string</span>(rs)</span><br><span class="line"></span><br><span class="line">	pp(<span class="string">&quot;string to []rune, rs: %x\n&quot;</span>, &amp;rs)</span><br><span class="line">	pp(<span class="string">&quot;[]rune to string, s3: %x\n&quot;</span>, &amp;s3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./string_covt</span><br><span class="line">s: 10ce705</span><br><span class="line">string to []byte, bs: c00001a0b0</span><br><span class="line">[]byte to string, s2: c00001a0c0</span><br><span class="line">string to []rune, rs: c00001e030</span><br><span class="line">[]rune to string, s3: c00001a0e0</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，<code>pp</code> 函数是为了打印 <code>字符串</code>、<code>slice</code> 的内部数据保存地址。对 string 而言，即打印的是 stringStruct 结构体中的 str 成员的值。</p>
<p>某些时候，转换操作会拖累算法性能，可尝试使用非安全的方法进行改善：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;unsafe&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toString</span><span class="params">(bs []<span class="type">byte</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> *(*<span class="type">string</span>)(unsafe.Pointer(&amp;bs))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这种方法是利用了 []byte 和 string 结构<code>部分相同</code>，以非安全的指针类型转换来实现类型变更，从而避免了底层数组复制</strong>。在高并发压力下，这种做法能有效改善执行性能，使用 unsafe 存在一定的风险，需要小心谨慎。</p>
<p>使用 append 函数，可以将 string 直接追加到 []byte 内。考虑到字符串只读特征，转换时复制数据到新分配的内存是可以理解的，但是性能也很重要，编译器会为某些场合进行专门的优化，避免额外分配和赋复制操作：</p>
<ul>
<li>将 []byte 转换为 string，去 map[string] 查询的时候</li>
<li>将 string 转换为 []byte，进行 for range 迭代的时候，直接取字节赋值给局部变量</li>
</ul>
<p>除类型转换为，动态构建字符串也容易造成性能问题。用加法操作符拼接字符串时，每次都必须重新分配内存。因此在构建超大字符串时性能较差。改进思路是预分配足够多的空间，常用方法有 strings.Join 函数，它会统计所有参数长度，并一次性完成内存分配。另外，通过 bytes.Buffer 也能完成类似操作，且性能相当。</p>
<p>类型 rune 专门用来存储 unicode 码点，它是 int32 的别名，相当于 UTF-32 编码格式。使用单引号的字面量，其默认类型就是 rune：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := <span class="string">&#x27;我&#x27;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, r)</span><br><span class="line"></span><br><span class="line">	rs := <span class="string">&quot;我们&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i, s := <span class="keyword">range</span> rs &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d %T [%c]\n&quot;</span>, i, s, s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./rune</span><br><span class="line">int32</span><br><span class="line">0 int32 [我]</span><br><span class="line">3 int32 [们]</span><br></pre></td></tr></table></figure>
<p>除 <code>[]rune</code> 外，还可以直接在 rune、byte、string 间进行转换。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := <span class="string">&#x27;我&#x27;</span></span><br><span class="line"></span><br><span class="line">	s := <span class="type">string</span>(r)</span><br><span class="line">	b := <span class="type">byte</span>(r)</span><br><span class="line"></span><br><span class="line">	s2 := <span class="type">string</span>(b)</span><br><span class="line">	r2 := <span class="type">rune</span>(b)</span><br><span class="line"></span><br><span class="line">	fmt.Println(s, b, s2, r2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要知道，字符串字节数组里存储的内容，并不一定就是合法的 UTF-8 文本。标准库 unicode 里提供了丰富的操作函数，例如 ValidString 可以验证字符串是否为合法的 UTF-8 文本，另外还可以用 RuneCountInString 替代 len 返回准确的 Unicode 字符数量。</p>
<h3 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h3>
<p>定义数组类型时，数组长度必须是非负整形常量表达式，长度是类型的组成部分。以下都是数组的初始化方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a [<span class="number">4</span>]<span class="type">int</span></span><br><span class="line"></span><br><span class="line">	b := [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">5</span>&#125;</span><br><span class="line">	c := [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">3</span>: <span class="number">10</span>&#125;</span><br><span class="line"></span><br><span class="line">	d := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	e := [...]<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">3</span>: <span class="number">100</span>&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(a, b, c, d, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>] [<span class="number">2</span> <span class="number">5</span> <span class="number">0</span> <span class="number">0</span>] [<span class="number">5</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10</span>] [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>] [<span class="number">10</span> <span class="number">0</span> <span class="number">0</span> <span class="number">100</span>]</span><br></pre></td></tr></table></figure>
<p>其他的一些数组使用规则：</p>
<ul>
<li>对于结构等复合类型，可省略元素初始化类型标签：</li>
<li>在定义多维数组时，仅第一维允许使用 <code>...</code></li>
<li>内置函数 len 和 cap 都返回第一维度长度</li>
<li>如果元素类型支持 <code>==</code> 或 <code>!=</code> 操作符，那么数组也支持该操作</li>
</ul>
<p>另外，要分清指针数组和数组指针的区别，指针数组是指元素为指针类型的数组，数组指针是获取数组变量的地址：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x, y := <span class="number">10</span>, <span class="number">20</span></span><br><span class="line"></span><br><span class="line">	a := [...]*<span class="type">int</span>&#123;&amp;x, &amp;y&#125;</span><br><span class="line">	p := &amp;a</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T, %v\n&quot;</span>, a, a)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T, %v\n&quot;</span>, p, p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./point_array</span><br><span class="line">[<span class="number">2</span>]*<span class="type">int</span>, [<span class="number">0xc00012c008</span> <span class="number">0xc00012c010</span>]</span><br><span class="line">*[<span class="number">2</span>]*<span class="type">int</span>, &amp;[<span class="number">0xc00012c008</span> <span class="number">0xc00012c010</span>]</span><br></pre></td></tr></table></figure>
<p><strong>数组指针可以直接用来操作元素</strong>。特别需要注意，与 C 数组变量隐式作为指针使用不同，Go 数组是值类型，赋值和传参操作都会复制整个数组数据。如果需要，可以改用指针或者切片，以避免数据复制。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x [2]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;x: %p, %v\n&quot;</span>, &amp;x, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> b [<span class="number">2</span>]<span class="type">int</span></span><br><span class="line"></span><br><span class="line">	b = a</span><br><span class="line">	fmt.Printf(<span class="string">&quot;x: %p, %v\n&quot;</span>, &amp;a, a)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;x: %p, %v\n&quot;</span>, &amp;b, b)</span><br><span class="line"></span><br><span class="line">	test(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x: 0xc00001a090, [10 20]</span><br><span class="line">x: 0xc00001a0a0, [10 20]</span><br><span class="line">x: 0xc00001a0f0, [10 20]</span><br></pre></td></tr></table></figure>
<h3 id="切片"><a class="markdownIt-Anchor" href="#切片"></a> 切片</h3>
<p>切片本身并非动态数组或者数组指针，它内部通过指针引用底层数组，设定相关的属性将数据读写操作限定在指定区域内：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span> <span class="type">int</span></span><br><span class="line">    <span class="built_in">cap</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切片本身是一个只读对象，其工作机制类似数组指针的一种包装。<strong>可基于数组或者数组指针创建切片，以开始和结束索引确定所引用的数组片段</strong>，不支持反向索引，实际范围是一个右半开区间。通过 <code>x[low:high:max]</code> 的形式创建切片，len = high - low，cap = max - low。属性 cap 表示切片所引用数组片段的真实长度，len 用于限定可读写的元素数量，另外数组必须是 addressable，否则会引发错误。</p>
<p>和数组一样，切片同样使用索引号访问元素内容，起始索引为 0，而非对应的底层数组真实索引的位置：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := [...]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">	s := x[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		<span class="built_in">println</span>(s[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以直接创建切片对象，无需预先准备数组。<strong>因为是引用类型，需要使用 make 函数或显式初始化语句</strong>，它会自动完成底层数组内存分配。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">	s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">	s3 := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">5</span>: <span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(s1, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line">	fmt.Println(s2, <span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2))</span><br><span class="line">	fmt.Println(s3, <span class="built_in">len</span>(s3), <span class="built_in">cap</span>(s3))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./make_slice</span><br><span class="line">[0 0 0] 3 5</span><br><span class="line">[0 0 0] 3 3</span><br><span class="line">[10 20 0 0 0 30] 6 6</span><br></pre></td></tr></table></figure>
<p>需要注意以下两种定义方式的区别，<strong>前者定义了一个 []int 类型的变量，并未执行初始化操作，其值为 nil，而后者利用初始化表达式完成了全部创建过程，只不过其 len 和 cap 都为 0</strong>。另外可以直接对 nil 切片执行 slice[:] 操作，同样返回 nil。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a []<span class="type">int</span></span><br><span class="line">	b := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;a: %#v\n&quot;</span>, (*reflect.SliceHeader)(unsafe.Pointer(&amp;a)))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;b: %#v\n&quot;</span>, (*reflect.SliceHeader)(unsafe.Pointer(&amp;b)))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;a size: %d\n&quot;</span>, unsafe.Sizeof(a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./slice_init</span><br><span class="line">a: &amp;reflect.SliceHeader&#123;Data:<span class="number">0x0</span>, Len:<span class="number">0</span>, Cap:<span class="number">0</span>&#125;</span><br><span class="line">b: &amp;reflect.SliceHeader&#123;Data:<span class="number">0x119e428</span>, Len:<span class="number">0</span>, Cap:<span class="number">0</span>&#125;</span><br><span class="line">a size: <span class="number">24</span></span><br></pre></td></tr></table></figure>
<p><strong>切片不支持比较操作，即使元素类型支持也不行，仅能判断其是否为 nil</strong>。另外可以获取元素地址，但是不能像数组那样直接用 slice 指针访问元素内容。</p>
<p>切片只是很小的结构体对象，用来代替数组传参可避免复制开销。还有 make 函数允许在运行期动态指定数组长度，绕开了数组类型必须使用编译期常量的限制。但是并非所有时候都适合用切片替代数组，因为切片底层数组可能会在堆上分配内存，而且小数组在栈上拷贝的消耗也未必比 make 代价大。</p>
<p>reslice 操作是指将切片视为 <code>[cap]slice</code> 数据源，据此创建新的切片对象，不能超过 cap，但是不受 len 限制。新建的切片对象依旧指向原底层数组，也就是说修改对所有关联切片可见。</p>
<p>append 函数用于向切片尾部（slice[len]）添加数据，返回新的切片对象。数据被追加到原底层数组，如果超过 cap 限制，则为新切片对象重新分配数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">	s1 := s[:<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">	s2 := <span class="built_in">append</span>(s1, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;s1: %p: %v\n&quot;</span>, &amp;s1[<span class="number">0</span>], s1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;s2: %p: %v\n&quot;</span>, &amp;s2[<span class="number">0</span>], s2)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;s data: %v\n&quot;</span>, s[:<span class="number">10</span>])</span><br><span class="line">	fmt.Printf(<span class="string">&quot;s1 cap: %d, s2 cap: %d\n&quot;</span>, <span class="built_in">cap</span>(s1), <span class="built_in">cap</span>(s2))</span><br><span class="line"></span><br><span class="line">	s2 = <span class="built_in">append</span>(s1, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;s1: %p: %v\n&quot;</span>, &amp;s1[<span class="number">0</span>], s1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;s2: %p: %v\n&quot;</span>, &amp;s2[<span class="number">0</span>], s2)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;s data: %v\n&quot;</span>, s[:<span class="number">10</span>])</span><br><span class="line">	fmt.Printf(<span class="string">&quot;s1 cap: %d, s2 cap: %d\n&quot;</span>, <span class="built_in">cap</span>(s1), <span class="built_in">cap</span>(s2))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./<span class="built_in">append</span></span><br><span class="line">s1: <span class="number">0xc0000b8000</span>: [<span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">s2: <span class="number">0xc0000b8000</span>: [<span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line">s data: [<span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">s1 <span class="built_in">cap</span>: <span class="number">4</span>, s2 <span class="built_in">cap</span>: <span class="number">4</span></span><br><span class="line">s1: <span class="number">0xc0000b8000</span>: [<span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">s2: <span class="number">0xc0000b6040</span>: [<span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line">s data: [<span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">s1 <span class="built_in">cap</span>: <span class="number">4</span>, s2 <span class="built_in">cap</span>: <span class="number">8</span></span><br></pre></td></tr></table></figure>
<ul>
<li>需要注意，是超出切片 cap 的限制，而非底层数组长度的限制</li>
<li>新分配数组长度是原 cap 的 2 倍，而非原数组的 2 倍（也并非总是 2 倍，对于较大的切片，会尝试扩容 1/4，以节约内存）</li>
<li>正因为存在重新分配底层数组的缘故，在某些场合建议预留足够多的空间，避免中途内存分配和数据复制的开销</li>
<li>向 nil 切片追加数据时，会为其分配底层数组内存。</li>
</ul>
<p>在两个切片对象间复制数据，允许指向同一底层数组，允许目标区间重叠。最终所复制的长度以较短的切片长度为准：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"></span><br><span class="line">	s1 := s[<span class="number">5</span>:<span class="number">8</span>]</span><br><span class="line">	n := <span class="built_in">copy</span>(s[<span class="number">4</span>:], s1)</span><br><span class="line">	fmt.Println(n, s)</span><br><span class="line"></span><br><span class="line">	s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">6</span>)</span><br><span class="line">	n = <span class="built_in">copy</span>(s2, s)</span><br><span class="line">	fmt.Println(n, s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，也可以直接从字符串中复制数据到 []byte。如果切片长时间引用大数组中很小的片段，那么建议新建独立的切片，复制出所需要的数据，以便原数组内存可被及时回收。</p>
<h3 id="字典"><a class="markdownIt-Anchor" href="#字典"></a> 字典</h3>
<p>字典（哈希表）是一种使用频率极高的数据结构，将其作为语言内置类型，从运行时层面进行优化，可以获得更高性能。作为无序键值对集合，字典要求 key 必须是支持相等运算符（== 和 =!）的数据类型，比如数字、字符串、指针、数组、结构体以及对应接口类型。字典是引用类型，使用 make 函数或初始化表达语句来创建。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">	m[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line">	m[<span class="string">&quot;b&quot;</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	m2 := <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">		x <span class="type">int</span></span><br><span class="line">	&#125;&#123;</span><br><span class="line">		<span class="number">1</span>: &#123;x: <span class="number">100</span>&#125;,</span><br><span class="line">		<span class="number">2</span>: &#123;x: <span class="number">200</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(m, m2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>map 基本操作如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">		<span class="string">&quot;a&quot;</span>: <span class="number">1</span>,</span><br><span class="line">		<span class="string">&quot;b&quot;</span>: <span class="number">2</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m[<span class="string">&quot;a&quot;</span>] = <span class="number">10</span></span><br><span class="line">	m[<span class="string">&quot;c&quot;</span>] = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> v, ok := m[<span class="string">&quot;d&quot;</span>]; ok &#123;</span><br><span class="line">		<span class="built_in">println</span>(v)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">delete</span>(m, <span class="string">&quot;d&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>访问不存在的键，默认返回零值，不会引发错误。但是推荐使用 ok-idiom 模式，通过零值无法判断键值是否存在，因为存储的 value 本身就可能是零值</strong>。</p>
<p>对于字典类型，需要注意如下事项：</p>
<ul>
<li>对字典进行迭代时，每次返回的键值次序可能并不相同。</li>
<li>函数 len 返回当前键值对数量，cap 不接受字典类型</li>
<li>因为内存安全和哈希算法等缘故，<strong>字典被设计成 <code>not addressable</code>，因此不能直接修改 value 成员（结构或数组）</strong></li>
</ul>
<p>下面两种赋值方式都是不行的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">		name <span class="type">string</span></span><br><span class="line">		age  <span class="type">byte</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m := <span class="keyword">map</span>[<span class="type">int</span>]user&#123;</span><br><span class="line">		<span class="number">1</span>: &#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">19</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m[<span class="number">1</span>].age += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	p := &amp;m[<span class="number">1</span>]</span><br><span class="line">	p.age++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">./map_value.<span class="keyword">go</span>:<span class="number">13</span>:<span class="number">11</span>: cannot assign to <span class="keyword">struct</span> field m[<span class="number">1</span>].age in <span class="keyword">map</span></span><br><span class="line">./map_value.<span class="keyword">go</span>:<span class="number">15</span>:<span class="number">7</span>: cannot take the address of m[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p><strong>正确做法是返回整个 value，待修改后再设置字典键值，或直接用指针类型</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">		name <span class="type">string</span></span><br><span class="line">		age  <span class="type">byte</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m := <span class="keyword">map</span>[<span class="type">int</span>]user&#123;</span><br><span class="line">		<span class="number">1</span>: &#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">19</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	u := m[<span class="number">1</span>]</span><br><span class="line">	u.age += <span class="number">1</span></span><br><span class="line">	m[<span class="number">1</span>] = u</span><br><span class="line"></span><br><span class="line">	m2 := <span class="keyword">map</span>[<span class="type">int</span>]*user&#123;</span><br><span class="line">		<span class="number">1</span>: &amp;user&#123;<span class="string">&quot;Jack&quot;</span>, <span class="number">20</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	m2[<span class="number">1</span>].age++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不能对 nil 字典进行写操作，但是可以读</li>
<li>同样需要注意，内容为空的字典，与 nil 字典是不同的</li>
<li>在迭代期间删除或新增键值是安全的</li>
</ul>
<p>运行时会对字典并发操作做出检查，<strong>如果某个任务正在对字典进行写操作，那么其他任务就不能对该字典执行并发操作（读、写、删除）</strong>，否则会导致进程崩溃。可以用 <code>sync.RWMutex</code> 实现同步，避免读写操作同时进行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			m[<span class="string">&quot;a&quot;</span>] += <span class="number">1</span></span><br><span class="line">			time.Sleep(time.Millisecond)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			_ = m[<span class="string">&quot;b&quot;</span>]</span><br><span class="line">			time.Sleep(time.Millisecond)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./map_sync</span><br><span class="line">fatal <span class="type">error</span>: concurrent <span class="keyword">map</span> read and <span class="keyword">map</span> write</span><br></pre></td></tr></table></figure>
<p>使用数据竞争（data race）检查此类问题，可以输出详细的检测信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run -race map_sync.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>
<p><strong>字典对象本身就是指针包装，传参时无需再次取地址</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;x: %p\n&quot;</span>, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">	test(m)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;m: %p, %d\n&quot;</span>, m, unsafe.Sizeof(m))</span><br><span class="line"></span><br><span class="line">	m2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	test(m2)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;m2: %p, %d\n&quot;</span>, m2, unsafe.Sizeof(m2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./map_assign</span><br><span class="line">x: <span class="number">0xc00010e030</span></span><br><span class="line">m: <span class="number">0xc00010e030</span>, <span class="number">8</span></span><br><span class="line">x: <span class="number">0xc00010e060</span></span><br><span class="line">m2: <span class="number">0xc00010e060</span>, <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>在创建时预先准备好足够空间有助于提升性能，减少扩张时的内存分配和重新哈希操作。对于海量小对象，应直接用字典存储键值数据拷贝，而非指针。这有助于减少需要扫描的对象数量，大幅缩短垃圾回收时间。另外，字典不会收缩内存，所以适当替换成新对象是必要的。</p>
<h3 id="结构体"><a class="markdownIt-Anchor" href="#结构体"></a> 结构体</h3>
<p>结构体（struct）是将多个不同类型命名字段（field）序列打包成一个复合类型。字段名必须唯一，可以使用 <code>_</code> 补位。支持使用指针类型成员。<strong>字段名、排列顺序属于类型组成部分</strong>。除了对齐处理外，编译器不会优化，调整内存布局。</p>
<p>可以按照顺序初始化全部字段，或者使用命名方式初始化指定字段。<strong>推荐使用命名初始化，这样在扩充结构字段或者调整字段顺序时，不会导致初始化语句出错</strong>。</p>
<p>可以直接定义匿名结构类型变量，或者定义匿名结构类型字段。但是由于其缺少类型标识，在作为字段类型时无法直接初始化，稍显麻烦。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	u := <span class="keyword">struct</span> &#123;</span><br><span class="line">		name <span class="type">string</span></span><br><span class="line">		age  <span class="type">byte</span></span><br><span class="line">	&#125;&#123;</span><br><span class="line">		name: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">		age:  <span class="number">12</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">type</span> file <span class="keyword">struct</span> &#123;</span><br><span class="line">		name <span class="type">string</span></span><br><span class="line">		attr <span class="keyword">struct</span> &#123;</span><br><span class="line">			owner <span class="type">int</span></span><br><span class="line">			perm  <span class="type">int</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	f := file&#123;</span><br><span class="line">        name: <span class="string">&quot;test.data&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// attr : &#123;</span></span><br><span class="line">        <span class="comment">//     owner: 1,</span></span><br><span class="line">        <span class="comment">//     perm: 0755,</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	f.attr.owner = <span class="number">1</span></span><br><span class="line">	f.attr.perm = <span class="number">0755</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(u, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实也可以在初始化语句中再次定义，但是那样看上去会非常丑陋。对于 struct 而言，只有在所有类型全部支持时，才可以做相等操作。可以使用指针直接操作结构字段，但是不能是多级指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	u := <span class="keyword">struct</span> &#123;</span><br><span class="line">		name <span class="type">string</span></span><br><span class="line">		age  <span class="type">byte</span></span><br><span class="line">	&#125;&#123;</span><br><span class="line">		name: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">		age:  <span class="number">12</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p := &amp;u</span><br><span class="line">	p.name = <span class="string">&quot;Jack&quot;</span></span><br><span class="line">	p.age++</span><br><span class="line"></span><br><span class="line">	fmt.Println(u)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空结构（struct{}）是指没有字段的结构类型，它比较特殊，因为无论是其自身，还是作为数组元素类型，其长度都是 0。实际上，<strong>这类长度为 0 的对象通常都指向 runtime.zerobase 变量</strong>。空结构可以作为通道元素类型，用于事件通知。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;hello, world!&quot;</span>)</span><br><span class="line">		exit &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	&lt;-exit</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;end.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匿名字段是指没有名字，仅有类型的字段，<strong>也被称作嵌入字段或嵌入类型</strong>。从编译器来看，这只是隐式地以类型名作为字段名字，<strong>可以直接引用匿名字段中的成员，但是初始化时必须当做独立字段</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> attr <span class="keyword">struct</span> &#123;</span><br><span class="line">	perm <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	attr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := file&#123;</span><br><span class="line">		name: <span class="string">&quot;test.data&quot;</span>,</span><br><span class="line">		attr: attr&#123;</span><br><span class="line">			perm: <span class="number">0755</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	f.perm = <span class="number">0644</span></span><br><span class="line">	<span class="built_in">println</span>(f.perm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果嵌入其他包中的类型，<strong>则隐式字段名字不包含包名</strong>。不仅仅是结构体，除接口指针和多级指针以外的任何命名类型都可以作为匿名字段。另外由于未命名类型没有名字标识，也就无法作为匿名字段。<strong>也不能将基础类型和其指针类型同时嵌入，因为两者隐式名字相同</strong>。</p>
<p>虽然可以像普通字段那样访问匿名字段成员，但是会存在重名问题。默认情况下，编译器会从当前显式命名字段开始，逐步向内查找匿名字段成员。如果匿名字段成员被外层同名字段遮蔽，那么必须使用显式字段名。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">	file</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	d := data&#123;</span><br><span class="line">		name: <span class="string">&quot;data&quot;</span>,</span><br><span class="line">		file: file&#123;<span class="string">&quot;file&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	d.name = <span class="string">&quot;data2&quot;</span></span><br><span class="line">	d.file.name = <span class="string">&quot;file2&quot;</span></span><br><span class="line">	fmt.Println(d.name, d.file.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果多个相同层级的匿名字段成员重名，就只能使用显式字段名访问，因为编译器无法确定目标。</p>
<p>严格来说，Go 并不是传统意义上的面对对象编程语言，或者说仅实现了最小面对对象机制。<strong>匿名嵌入不是继承，无法实现多态处理。虽然配合方法集，可以用接口来实现一些类似操作，但是其本质上是不同的</strong>。</p>
<p>字段标签（tag）并不是注释，而是用来对字段进行描述的元数据。尽管它不属于数据成员，<strong>但是是类型的组成部分</strong>。在运行期，可用作反射获取标签信息，它常被用作格式校验，数据库关系映射等。</p>
<p>不管结构体包含多少字段，其内存总是一次性分配，各字段在相邻的地址空间按定义顺序排列。当然，对于引用类型、字符串和指针，结构内存只包含其基本（头部）数据。还有，所有匿名字段也包含在内。</p>
<p>借助 unsafe 包中的相关函数，可以输出所有字段的偏移量和长度。在分配内存时，字段需要做对齐处理，通常以所有字段中最长的基础类型宽度为标准。比较特殊的是空结构类型字段，如果它是最后一个字段，那么编译器会将其当做长度为 1 的类型做对齐处理，以便其地址不会越界，避免引发垃圾回收错误。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/Go/" rel="tag"># Go</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2021/04/28/learn-go-03/" rel="prev" title="Go 语言学习笔记（3）：方法与接口">
      <i class="fa fa-chevron-left"></i> Go 语言学习笔记（3）：方法与接口
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2021/04/25/learn-go-01/" rel="next" title="Go 语言学习笔记（1）：初识 Go，类型与表达式">
      Go 语言学习笔记（1）：初识 Go，类型与表达式 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">1.</span> <span class="nav-text"> 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80"><span class="nav-number">1.1.</span> <span class="nav-text"> 函数基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0"><span class="nav-number">1.2.</span> <span class="nav-text"> 参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E5%8F%82"><span class="nav-number">1.2.1.</span> <span class="nav-text"> 变参</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">1.3.</span> <span class="nav-text"> 返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.</span> <span class="nav-text"> 匿名函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.5.</span> <span class="nav-text"> 延迟调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">1.6.</span> <span class="nav-text"> 错误处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE"><span class="nav-number">2.</span> <span class="nav-text"> 数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.1.</span> <span class="nav-text"> 字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">2.2.</span> <span class="nav-text"> 数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E7%89%87"><span class="nav-number">2.3.</span> <span class="nav-text"> 切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E5%85%B8"><span class="nav-number">2.4.</span> <span class="nav-text"> 字典</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">2.5.</span> <span class="nav-text"> 结构体</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">211</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">


  

</body>
</html>
