<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="这篇文章主要分为两个部分：1. 介绍 Python 的映射类型，包括字典和集合；2. 介绍 Python 的文本和字节序列">
<meta property="og:type" content="article">
<meta property="og:title" content="流畅的 Python（2）：字典和集合 &amp; 文本和字节序列">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2021/07/25/fluent-python-02/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="这篇文章主要分为两个部分：1. 介绍 Python 的映射类型，包括字典和集合；2. 介绍 Python 的文本和字节序列">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-07-25T11:24:50.000Z">
<meta property="article:modified_time" content="2022-08-25T12:04:03.755Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2021/07/25/fluent-python-02/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>流畅的 Python（2）：字典和集合 & 文本和字节序列 | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2021/07/25/fluent-python-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          流畅的 Python（2）：字典和集合 & 文本和字节序列
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-25 19:24:50" itemprop="dateCreated datePublished" datetime="2021-07-25T19:24:50+08:00">2021-07-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/Python-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Python 读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这篇文章主要分为两个部分：1. 介绍 Python 的映射类型，包括字典和集合；2. 介绍 Python 的文本和字节序列</p>
<span id="more"></span>

<h2 id="字典和集合"><a href="#字典和集合" class="headerlink" title="字典和集合"></a>字典和集合</h2><p>dict 类型不但在各种程序里广泛使用，它也是 Python 语言的基石：模块的命名空间、实例的属性和函数的关键字参数等都用到了字典。</p>
<h3 id="泛映射类型"><a href="#泛映射类型" class="headerlink" title="泛映射类型"></a>泛映射类型</h3><p><code>collections.abc</code> 模块中有 Mapping 和 MutableMapping 两个抽象基类，它们的作用是为 dict 和其他类似的类型定义形式接口。但是非抽象类型一般不会直接继承这些抽象基类，它们会直接对 dict 或者 collections.UseDict 进行扩展。抽象基类的主要用途是：</p>
<ul>
<li>提供形式化的文档，定义了构建一个映射类型所需要的最基本的接口</li>
<li>与 isinstance 一起被用来判定某个数据是不是广义上的映射类型</li>
</ul>
<p>标准库里的所有映射类型都是通过 dict 实现，因此它们有共同的限制：即只有可散列的数据类型才能用作这些映射里的键：</p>
<ul>
<li>如果一个对象是可散列的，那么在该对象的生命周期里，它的散列值是不变的，而且这个对象需要实现 <code>_hash_()</code> 方法。另外可散列对象还需要有 <code>__eq__()</code> 方法，这样才能和其他键进行比较</li>
<li>原子不可变数据类型（str、bytes 和数值类型）都是可散列类型，frozenset 也是可散列的。而对于元祖，只有当一个元祖包含的所有元素都是可散列类型，那么它才是可散列的</li>
<li>一般来说，用户自定义类型的对象都是可散列的。散列值是依据 id() 函数的返回值计算出来的。如果一个对象实现了 <code>__eq__()</code> 方法，并且在方法中用到了这个对象的内部状态，那么只有当所有这些内部状态都是不可变的情况下，这个对象才是可散列的</li>
</ul>
<p>字典提供了多种构造方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">dict</span>(one = <span class="number">1</span>, two = <span class="number">2</span>, three = <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = &#123;<span class="string">&#x27;one&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;three&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="built_in">dict</span>(<span class="built_in">zip</span>([<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">dict</span>([(<span class="string">&quot;two&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;three&quot;</span>, <span class="number">3</span>), (<span class="string">&quot;one&quot;</span>, <span class="number">1</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = <span class="built_in">dict</span>(&#123;<span class="string">&#x27;one&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;three&#x27;</span>:<span class="number">3</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b == c == d == e</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="字典推导"><a href="#字典推导" class="headerlink" title="字典推导"></a>字典推导</h3><p>字典推导可以用来从以任何键值对作为元素的可迭代对象中构建出字典:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dial_codes = [(<span class="number">86</span>, <span class="string">&quot;China&quot;</span>), (<span class="number">91</span>, <span class="string">&quot;India&quot;</span>), (<span class="number">81</span>, <span class="string">&quot;Japan&quot;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>country_codes = &#123;country:code <span class="keyword">for</span> code, country <span class="keyword">in</span> dial_codes&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>country_codes</span><br><span class="line">&#123;<span class="string">&#x27;China&#x27;</span>: <span class="number">86</span>, <span class="string">&#x27;India&#x27;</span>: <span class="number">91</span>, <span class="string">&#x27;Japan&#x27;</span>: <span class="number">81</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;code:country.upper() <span class="keyword">for</span> country, code <span class="keyword">in</span> country_codes.items()&#125;</span><br><span class="line">&#123;<span class="number">86</span>: <span class="string">&#x27;CHINA&#x27;</span>, <span class="number">91</span>: <span class="string">&#x27;INDIA&#x27;</span>, <span class="number">81</span>: <span class="string">&#x27;JAPAN&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常见的映射方法"><a href="#常见的映射方法" class="headerlink" title="常见的映射方法"></a>常见的映射方法</h3><p>在映射对象的方法中，setdefault 需要重点推荐一下，一旦它发挥作用时，可以节省不少次的键查询，从而让程序更高效。当字典 d[k] 不能找到正确的键的时候，Python 会抛出异常，有的程序可能会用 <code>d.get(k, default)</code> 给找不到的键一个默认值。但是当要更新某个键对应的值的时候，这种方式就不是最好的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">WORD_RE = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\w+&#x27;</span>)</span><br><span class="line"></span><br><span class="line">index = &#123;&#125;</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(sys.argv[<span class="number">1</span>], encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="keyword">for</span> line_no, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(fp, <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">match</span> <span class="keyword">in</span> WORD_RE.finditer(line):</span><br><span class="line">            word = <span class="keyword">match</span>.group()</span><br><span class="line">            column_no = <span class="keyword">match</span>.start() + <span class="number">1</span></span><br><span class="line">            location = (line_no, column_no)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># not efficient</span></span><br><span class="line">            occurrences = index.get(word, [])</span><br><span class="line">            occurrences.append(location)</span><br><span class="line">            index[word] = occurrences</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> <span class="built_in">sorted</span>(index, key=<span class="built_in">str</span>.upper):</span><br><span class="line">    <span class="built_in">print</span>(word, index[word])</span><br></pre></td></tr></table></figure>

<p>这段代码中为字典赋值的效率并不高，通过 <code>dict.setdefault</code> 可以只用一行就解决：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.setdefault(word, []).append(location)</span><br></pre></td></tr></table></figure>

<p>这行代码获取单词所对应的出现记录列表，如果当前单词不存在，则把空列表放进映射，并返回该空列表。这样就不用在进行第二次查找的情况下更新列表了。也就是说，<code>setdefault</code> 的效果等同于如下语句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> my_dict:</span><br><span class="line">    my_dict[key] = []</span><br><span class="line">my_dict[key].append(new_value)</span><br></pre></td></tr></table></figure>

<p>但是后者至少需要进行两次键查询，如果键不存在的情况下则是三次。而用 setdefault 只需要一次即可完成整个操作。</p>
<p>另外，还介绍一个映射的 update 方法，它用于更新映射的对应条目。它可以接受一个映射或者键值对迭代器。它首先检查参数 m 是否有 keys 方法，如果有，update 方法就把 m 当做映射对象来处理，否则，函数会退一步把 m 当做包含了键值对的迭代器。Python 里大多数映射类型的构造方法都采用了类似的逻辑。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>country_codes = &#123;<span class="number">86</span>: <span class="string">&#x27;CHINA&#x27;</span>, <span class="number">91</span>: <span class="string">&#x27;INDIA&#x27;</span>, <span class="number">81</span>: <span class="string">&#x27;JAPAN&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>country_codes.update((k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">zip</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">81</span>], [<span class="string">&quot;USA&quot;</span>, <span class="string">&quot;Canada&quot;</span>, <span class="string">&quot;UK&quot;</span>]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>country_codes</span><br><span class="line">&#123;<span class="number">86</span>: <span class="string">&#x27;CHINA&#x27;</span>, <span class="number">91</span>: <span class="string">&#x27;INDIA&#x27;</span>, <span class="number">81</span>: <span class="string">&#x27;UK&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;USA&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Canada&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>country_codes.update(&#123;<span class="number">2</span>:<span class="string">&#x27;Japan&#x27;</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>country_codes</span><br><span class="line">&#123;<span class="number">86</span>: <span class="string">&#x27;CHINA&#x27;</span>, <span class="number">91</span>: <span class="string">&#x27;INDIA&#x27;</span>, <span class="number">81</span>: <span class="string">&#x27;UK&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;USA&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Japan&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="映射的弹性查询"><a href="#映射的弹性查询" class="headerlink" title="映射的弹性查询"></a>映射的弹性查询</h3><p>有时候，即使某个键在映射中不存在，也希望在读取这个键的值时能够得到一个默认值（不是通过 get() 调用）。有两种方法实现该目的：</p>
<ul>
<li>通过 defaultdict 而不是普通的 dict</li>
<li>给自己定义一个 dict 的子类，然后在子类中实现 <code>__missing__</code> 方法</li>
</ul>
<h4 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h4><p>用户创建 defaultdict 对象时，需要给它配置一个为找不到键创建默认值的方法。该可调用对象会在 <code>__getitem__</code> 碰到找不到键的时候被调用，让 <code>__getitem__</code> 返回某个默认值。用来生成默认值的可调用对象保存在名为 <code>default_factory</code> 的实例属性里。如果在创建 <code>defaultdict</code> 的时候没有指定 <code>default_factory</code>，查询不到的键会触发 KeyError。</p>
<p>需要注意，default_factory 只会在 <code>__getitem__</code> 里被调用，在其他方法里不会发挥作用。所以 <code>d[k]</code> 在 k 不存在时会创建一个默认值，而 <code>d.get(k)</code> 则会返回 None。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> collections</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>index = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>index[<span class="number">86</span>].append(<span class="string">&#x27;China&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>index</span><br><span class="line">defaultdict(&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;, &#123;<span class="number">86</span>: [<span class="string">&#x27;China&#x27;</span>]&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>index.get(<span class="number">87</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>index.get(<span class="number">87</span>, [])</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<p>defaultdict 依靠特殊方法 <code>__missing__</code> 在遇到找不到的键时调用 <code>default_factory</code>。所有映射类型都可以选择去支持 <code>__missing__</code>。</p>
<h4 id="特殊方法-missing"><a href="#特殊方法-missing" class="headerlink" title="特殊方法 __missing__"></a>特殊方法 <code>__missing__</code></h4><p>如果一个类继承了 <code>dict</code>，然后继承类提供了 <code>__missing__</code> 方法，那么就会在 <code>__getitem__</code> 碰到找不到的键的时候，Python 会自动调用它，而不是抛出一个 KeyError 异常。<code>__missing__</code> 方法会回被 <code>__getitem__</code> 调用，而对 <code>get</code> 或者 <code>__contains__</code> 无影响。</p>
<p>如下实现了一个 StrKeyDict 类，它在有非字符串的键被查找时，把它转化为字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrkeyDict</span>(<span class="title class_ inherited__">dict</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__missing__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(key, <span class="built_in">str</span>):</span><br><span class="line">            <span class="keyword">raise</span> KeyError(key)</span><br><span class="line">        <span class="keyword">return</span> self[<span class="built_in">str</span>(key)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key, default=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self[key]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">return</span> default</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__contains__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">return</span> key <span class="keyword">in</span> self.keys() <span class="keyword">or</span> <span class="built_in">str</span>(key) <span class="keyword">in</span> self.keys()</span><br><span class="line"></span><br><span class="line">s = StrkeyDict(&#123;<span class="string">&#x27;1&#x27;</span>:<span class="string">&#x27;A&#x27;</span>, <span class="string">&quot;2&quot;</span>:<span class="string">&#x27;B&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(s[<span class="string">&#x27;1&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(s[<span class="string">&#x27;2&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h3 id="字典的变种"><a href="#字典的变种" class="headerlink" title="字典的变种"></a>字典的变种</h3><p>这里总结了标准库里的 collections 模块中，除了 defaultdict 之外的不同映射类型：</p>
<ul>
<li>collections.OrderedDict：在添加键的时候保持顺序，因此键的迭代次序总是一致的，</li>
<li>collections.ChainMap：可以容纳不同的映射对象，在进行键查找时，这些对象会被当做一个整体被逐个查找，直到键被找到。该功能在给有嵌套作用域的语言作解释器时很有用，可以用一个映射对象来代表一个作用域的上下文</li>
<li>collections.Counter：会给键准备一个计数器，每次更新一个键的时候都会增加这个计数器。所以该类型可以用来给可散列对象，或者可以当成多重集合来使用，多重集合是指集合里的元素可以出现不止一次</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct = collections.C</span><br><span class="line">collections.ChainMap(  collections.Counter(</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct = collections.Counter(<span class="string">&quot;abcdefgab&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct</span><br><span class="line">Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;f&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;g&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct.update(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct</span><br><span class="line">Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;f&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;g&#x27;</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>collections.UserDict：把标准的 dict 用 Python 又实现了一遍。UserDict 是让用户继承写子类的</li>
</ul>
<h3 id="子类化-UserDict"><a href="#子类化-UserDict" class="headerlink" title="子类化 UserDict"></a>子类化 UserDict</h3><p>当需要创建自定义映射类型时，以 UserDict 为基类，要比普通的 dict 为基类更为方便。因为后者有时会在某些方法上实现上走一些捷径，导致我们需要在子类中重写这些方法。</p>
<p>UserDict 并不是 dict 的子类，但是它有一个叫做 data 的属性，它是 dict 的实例，这个属性实际上是 UserDict 最终存储数据的地方。如下使用 <code>UserDict</code> 重新实现了 StrKeyDict：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrkeyDict</span>(collections.UserDict):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set_item__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        self.data[<span class="built_in">str</span>(key)] = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__missing__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>((key), <span class="built_in">str</span>):</span><br><span class="line">            <span class="keyword">raise</span> KeyError(key)</span><br><span class="line">        <span class="keyword">return</span> self[<span class="built_in">str</span>(key)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__contains__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(key) <span class="keyword">in</span> self.data</span><br><span class="line"></span><br><span class="line">s = StrkeyDict(&#123;<span class="string">&#x27;1&#x27;</span>:<span class="string">&#x27;A&#x27;</span>, <span class="string">&quot;2&quot;</span>:<span class="string">&#x27;B&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(s[<span class="string">&#x27;1&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(s[<span class="string">&#x27;2&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>因为 UserDict 继承的是 MutableMapping，所以 StrKeyDict 里剩下的那些映射类型的方法都是从 UserDict、MutableMapping 和 Mapping 这些超类继承而来。所以我们直接继承了 <code>Mapping.get</code> 方法，它的实现方式能够满足我们对 StrKeyDict 的要求。</p>
<h3 id="不可变映射类型"><a href="#不可变映射类型" class="headerlink" title="不可变映射类型"></a>不可变映射类型</h3><p>标准库里所有的映射类型都是可变的，从 Python3.3 开始，types 模块中引入了一个封装类名为 <code>MappingProxyType</code>，如果给这个类一个映射，它会返回一个只读的映射视图。虽然是个只读视图，但是它是动态的。这意味着如果对原映射做出了改动，通过这个视图可以观察到，但是无法通过这个视图对原映射做出修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> MappingProxyType</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="number">1</span>:<span class="string">&#x27;A&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy = MappingProxyType(d)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy[<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy[<span class="number">2</span>] = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;mappingproxy&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">2</span>] = <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy[<span class="number">2</span>]</span><br><span class="line"><span class="string">&#x27;B&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="集合论"><a href="#集合论" class="headerlink" title="集合论"></a>集合论</h3><p>集合的本质是许多唯一对象的聚集，因此集合可以用于去重：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">set</span>(l)</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<p>集合中的元素必须是可散列的，set 类型本身是不可散列的，但是 frozenset 可以，因此可以创建一个包含不同 frozet 的 set。集合还实现了很多基础的中缀运算符，用于实现集合的合集、交集、差集运算：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 | s2</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 &amp; s2</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 - s2</span><br><span class="line">&#123;<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>除了速度极快的查找功能，内置的 set 和 frozenset 提供了丰富的功能和操作</p>
<h4 id="集合字面量"><a href="#集合字面量" class="headerlink" title="集合字面量"></a>集合字面量</h4><p>集合的字面量使用如下形式表示：<code>&#123;1&#125;</code>, <code>&#123;&#39;1&#39;, &#39;2&#39;&#125;</code>，注意空集必须写成 set() 的形式，如果写成 <code>&#123;&#125;</code>，这代表一个空字典：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(&#123;&#125;)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(&#123;<span class="number">1</span>&#125;)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;set&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>由于 Python 里没有针对 frozenset 的特殊字面量语法，只能采用构造方法。frozenset 的标准字符串表示就像构造方法调用一样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fs = <span class="built_in">frozenset</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fs</span><br><span class="line"><span class="built_in">frozenset</span>(&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="集合推导"><a href="#集合推导" class="headerlink" title="集合推导"></a>集合推导</h4><p>Python 也支持集合推导：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = &#123;i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> i &amp; <span class="number">1</span> &#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="集合的操作"><a href="#集合的操作" class="headerlink" title="集合的操作"></a>集合的操作</h4><p>集合所支持的操作不少是运算符重载的特殊方法，其中有些运算符和方法会对集合做就地修改，这类操作在数学中是没有意义的，另外 frozenset 也不会实现这些操作。中缀运算符要求两侧的被操作对象都是集合类型，但是它们的对应方法则只要求被传入的参数是可迭代对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 | s2</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.union(<span class="built_in">range</span>(<span class="number">2</span>, <span class="number">5</span>))</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dict-和-set-的背后"><a href="#dict-和-set-的背后" class="headerlink" title="dict 和 set 的背后"></a>dict 和 set 的背后</h3><p>Python 中字典和集合的速度是非常快的。这是因为 Python 中的字典背后使用了散列表。散列表其实是一个稀疏的数组（总是有空白的元素称为稀疏数组），散列表的单元通常称为 bucket，在 dict 的散列表当中，每个键值对都占用一个表元，每个表元包含两个部分，一个是对键的引用，一个是对值的引用，由于表元的大小一致，因此可以通过偏移量来读取某个表元。</p>
<p>Python 会设法保证有大约 1&#x2F;3 的表元是空的，因此每次快达到该阈值时，原有的散列表会被复制到一个更大的空间里。如果要把一个对象放入到散列表当中，首先需要计算这个元素键的散列值，Python 利用 hash() 方法实现它：</p>
<ul>
<li>内置的 hash() 方法可以用于所有内置类型对象上，对自定义对象调用 hash()，实际上运行的是自定义的 <code>__hash()__</code>。如果两个对象在比较时是相等的，那它的散列值必须是相等，否则散列表就不能正常运行了</li>
<li>为了获取 dict[search_key] 所对应的值，会通过 hash(search_key) 计算出 search_key 的散列值后，会把这个值的最低几位数字作为偏移量（取决于当前散列表的大小），在散列表中查找表元，如果找到的表元是空的，则抛出 KeyError，如果不是空的，则比较 search_key 与 found_key（保存在表元中）是否相等，如果相等，则返回 found_value</li>
<li>如果不匹配则说明发生了散列冲突，之所以会发生散列冲突，是因为散列表是把随机的元素映射到只有几位的数字上，这样就可能造成散列值本身不同，但是最后的散列索引相同。为了解决散列冲突，算法会在散列值中再取几位来，然后用特殊方法处理后，去新的散列索引上寻找表元。继续重复上述判断</li>
</ul>
<p>添加新元素和更新现有的键值的操作几乎和上面一样。另外在插入新值时，Python 可能会按照散列表的拥挤程度来决定是否要重新分配内存以进行扩容。如果增加了散列表大小，散列值和散列索引所占用的位数都会增加。</p>
<p>以上 Pthon 散列表的实现给 dict 带来如下的影响：</p>
<ul>
<li><p>键必须是可散列的：</p>
<ul>
<li>支持 hash() 函数，并且通过 <strong>hash</strong>() 方法所得到的散列值是不变的</li>
<li>支持 <strong>eq</strong>() 方法来检测相等性</li>
<li>若 a &#x3D;&#x3D; b，则 hash(a) &#x3D;&#x3D; hash(b) 也为真</li>
<li>所有用户自定义类型的对象默认都是可散列的，因为它们的散列值由 id() 来获取，而且它们都是不相等的。</li>
<li>如果一个类实现了 <strong>eq</strong> 方法，并且希望它是可散列的，则必须要要用一个合适的 <strong>hash</strong>() 方法，以保证在 a&#x3D;&#x3D;b 为真时，hash(a) &#x3D;&#x3D; hash(b) 也为真。另外一个类的 <strong>hash</strong>() 方法依赖于可变状态时，那么它的实例是不可散列的。</li>
</ul>
</li>
<li><p>字典在内存上的开销巨大：如果需要存放数量巨大的记录，那么存放在元祖或具名元祖中是比较好的选择。元祖之所以更能节省空间，原因有二：1）避免了散列表所耗费的空间，2）无需把记录中字段的名称在每个元素里都存一遍</p>
</li>
<li><p>键的次序取决于添加顺序：由 dict({key1:value1, key2:value2}) 和 dict({key2:value2, key1:value1}) 得到的两个字段，在进行比较时它们是相等的，但是如果在 key1 和 key2 被添加到字典的过程中发生冲突的话，这两个键出现在字典里的顺序是不一样的</p>
</li>
<li><p>往字典里添加新建可能改变已有键的顺序：往字典中添加新键时，Python 可能会为字典进行扩容。扩容过程会把已有的元素添加到新表中，这个过程可能会发生散列冲突，而导致新散列表中键的次序变化。因此如果在迭代一个字典的所有键的过程中同时对字典进行修改，那么可能会跳过一些键。<strong>因此不能对字典同时进行迭代和修改</strong>。</p>
</li>
<li><p>在 Python3 中  <code>keys()</code>、<code>items()</code> 和 <code>.values</code> 方法返回的都是视图，视图具有动态特性，可以实时反馈字典的变化。</p>
</li>
</ul>
<p>set 和 frozenset 的实现也依赖于散列表，但是它们的散列表里存放的只有元素的引用。上面对字典与散列表关系的总结，对集合来说几乎适用的：</p>
<ul>
<li>集合里的元素必须是可散列的</li>
<li>集合很消耗内存</li>
<li>可以很高效地判断元素是否存在于某个集合当中</li>
<li>元素的次序取决与被添加到集合里的次序</li>
<li>往集合中添加元素，可能改变集合中已有元素的次序</li>
</ul>
<h2 id="文本和字节序列"><a href="#文本和字节序列" class="headerlink" title="文本和字节序列"></a>文本和字节序列</h2><p>Python3 明确区分了人类可读的文本字符串和原始的字节序列。隐式地把字节序列转换成 Unicode 文本已经成为过去。</p>
<h3 id="字符问题"><a href="#字符问题" class="headerlink" title="字符问题"></a>字符问题</h3><p>一个字符串是一个字符序列，从 Python3 开始，str 对象中获取的元素是 Unicode 字符。Unicode 标准把字符的标识和具体的字节表述进行了区分：</p>
<ul>
<li>字符的标识：即码位，在 Unicode 标准中以 4-6 个十六进制数字表示，且需要加前缀 <code>U+</code>。</li>
<li>字符的具体表示：取决于所用的编码。编码是在码位和字节序列之间转换时使用的算法。</li>
</ul>
<p>把码位转换成字节序列的过程是编码，把字节序列转换成码位的过程解码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&quot;中国&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(s)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = s.encode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="string">b&#x27;\xe4\xb8\xad\xe5\x9b\xbd&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;中国&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="字节概要"><a href="#字节概要" class="headerlink" title="字节概要"></a>字节概要</h3><p>Python 内置了两种基本的二进制序列类型：python3 引入了不可变 bytes 类型和 Python2.6 添加的可变 bytearray 类型。bytes 或 bytearray 对象的各个元素是介于 0-255 之间的整数，而不像 str 对象那样是单个字符。</p>
<p>二进制序列的切片始终是统一类型的二进制序列，即使长度为 1 的切片。bytes 字面量以 b 开头，bytearray 对象没有字面量句法，而是以 bytearray() 和字节序列字面量参数的形式显示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="built_in">bytes</span>(<span class="string">&#x27;中国&#x27;</span>, encoding=<span class="string">&#x27;utf_8&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line"><span class="string">b&#x27;\xe4\xb8\xad\xe5\x9b\xbd&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="number">0</span>]</span><br><span class="line"><span class="number">228</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[:<span class="number">1</span>]</span><br><span class="line"><span class="string">b&#x27;\xe4&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c_arr = <span class="built_in">bytearray</span>(c)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c_arr</span><br><span class="line"><span class="built_in">bytearray</span>(<span class="string">b&#x27;\xe4\xb8\xad\xe5\x9b\xbd&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c_arr[-<span class="number">1</span>:]</span><br><span class="line"><span class="built_in">bytearray</span>(<span class="string">b&#x27;\xbd&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这里 c[0] 返回一个整数，而 c[:1] 返回一个序列。s[0] &#x3D;&#x3D; [:1] 只对 str 这个序列类型成立，对于其他序列类型都是不成立的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&quot;abcd&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">0</span>] == s[:<span class="number">1</span>]</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">0</span>] == s[:<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>虽然二进制序列是整数序列，但是它们的字面量表示法表明其中有 ASCII 文本，因此各个字节的值可能会有三种表示方法：</p>
<ul>
<li>可打印的 ASCII 范围内字节，使用 ASCII 字符本身</li>
<li>不可打印的 ASCII 范围内的字节，使用转义序列</li>
<li>其他字节的值，使用十六进制转义序列</li>
</ul>
<p>除了格式化方法和几个处理 Unicode 数据的方法，str 类型的其他方法都支持 bytes 和 bytearray 类型，这意味着我们可以使用熟悉的字符串方法处理二进制序列。二进制序列有个类方法是 str 没有的：fromhex，它的作用是解析十六进制数字对，构建二进制序列。</p>
<p>可以通过如下方法构建 bytes 或 bytearray 对象：</p>
<ul>
<li>一个 str 对象和一个 encoding 关键字参数</li>
<li>一个可迭代对象，提供 0-255 之间的数值</li>
<li>一个实现了缓冲协议的对象（如 bytes、bytearray、memoryview、array.array 等），此时把源对象中的字节序列复制到新的二进制序列中</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> array</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = array.array(<span class="string">&#x27;h&#x27;</span>, [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets = <span class="built_in">bytes</span>(numbers)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets</span><br><span class="line"><span class="string">b&#x27;\xfe\xff\xff\xff\x00\x00\x01\x00\x02\x00&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果想从二进制序列中提取结构化信息，struct 模块是重要的工具。struct 模块提供了一些函数，把打包的字节序列转换成不同类型的字段组成的元祖，还有一些函数用于执行反向转换，把元祖转换成打包的字节序列。struct 模块能够处理 bytes、bytearray、memoryview。memoryview 类不是用于创建或者存储字节序列的，而是共享内存，让你访问其他二进制序列、打包的数组和缓冲中的数据切片，而无需复制字节序列。</p>
<h3 id="基本的编解码器"><a href="#基本的编解码器" class="headerlink" title="基本的编解码器"></a>基本的编解码器</h3><p>Python 自带了超过 100 种编解码器，用于在文本和字节之间互相转换，每个编解码器都有一个名称，例如 utf8 等：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;中国&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b1 = s.encode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b2 = s.encode(<span class="string">&#x27;gb2312&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b1</span><br><span class="line"><span class="string">b&#x27;\xe4\xb8\xad\xe5\x9b\xbd&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b2</span><br><span class="line"><span class="string">b&#x27;\xd6\xd0\xb9\xfa&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b2.decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">UnicodeDecodeError: <span class="string">&#x27;utf-8&#x27;</span> codec can<span class="string">&#x27;t decode byte 0xd6 in position 0: invalid continuation byte</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; b2.decode(&#x27;</span>utf8<span class="string">&#x27;, errors=&#x27;</span>ignore<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">&#x27;</span>й<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; b2.decode(&#x27;</span>gb2312<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">&#x27;</span>中国<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="了解编解码问题"><a href="#了解编解码问题" class="headerlink" title="了解编解码问题"></a>了解编解码问题</h3><p>虽然有一个一般性的 UnicodeError，但是报告错误时几乎都会指明具体的异常：UnicodeEncodeError 或 UnicodeDecodeError。如果源码的编码与预期不符，加载 Python 模块时还可能抛出 SyntaxError。</p>
<ul>
<li>多数非 UTF 编解码器只能处理 Unicode 字符中的一小部分子集，把文本转换成字节序列时，如果目标编码中没有定义某个字符，那么就会排除 UnicodeEncodeError 异常。可以通过 errors 参数来对错误进行特殊处理</li>
<li>把二进制序列转换成文本时，如果遇到无法转换的字节序列，就会抛出 UnicodeDecodeError</li>
<li>Python3 默认使用 UTF-8 编码源码，如果加载的 .py 模包含 UTF-8 之外的数据，而且没有生命编码，会抛出该异常。为了修正该问题，可以在文件顶部添加 encoding 注释，例如 <code># encoding: gb2312</code>。Python3 允许在源码中使用非 ASICC 标识符</li>
</ul>
<p>编解码器的错误处理方式是可扩展的，可以为 error 参数注册额外的字符串，方法是把一个名称和一个错误处理函数传给 codesc.register_error 函数。</p>
<p>我们不能仅仅根据字节序列，就找出其中的编码。但是就像人类语言也有规则和限制和一样，也可以从字节流中试探和分析找出编码。统一字符编码侦测包 Chardet 能识别所支持的 30 种编码。Chardet 是一个 python 库，可以在程序中使用，它也提供了命令行工具 chardetect。</p>
<p>二进制序列编码文本通常不会明确指自己的编码，但是 UTF 格式可以在文本内容的开头添加一个字节序标记：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;中国&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = s.encode(<span class="string">&#x27;utf16&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="string">b&#x27;\xff\xfe-N\xfdV&#x27;</span></span><br></pre></td></tr></table></figure>

<p>开头的 <code>b\xff\xfe</code> 即 BOM（byte-order mark），指明编码时的字节序。在小端字节序设备中，各个码位的最低有效字节在前面。在大字节序 CPU 中，编码顺序是相反的。与字节序有关的问题只对一个字占多个字节的编码有影响，UTF8 的一个优势在于：不管设备使用哪种字节序，生成的字节序列始终一致，因此不需要 BOM。</p>
<h3 id="处理文本文件"><a href="#处理文本文件" class="headerlink" title="处理文本文件"></a>处理文本文件</h3><p>处理文件的最佳实践是：要尽早把输入（例如读取文件）的字节序列解码成字符串，之后在业务逻辑中处理字符串对象，对输出来说，要尽量晚地把字符串编码成字节序列。这种处理方法也被称为 <code>Unicode 三明治</code>。</p>
<p>Python3 中可以很容易实现该处理方法，内置的 open 函数会在读取文件时做必要的解码，以文本模式写入文件时还会做必要的编码。需要在多台设备中或多种场合下运行的代码，一定不能依赖默认编码，打开文件时始终应该明确传入 encoding&#x3D; 参数，因为不同的设备使用的默认编码可能不同。</p>
<p>有几个设置对 Python I&#x2F;O 的编码默认值有影响：</p>
<ul>
<li>如果打开文件时没有指定 encoding 参数，默认值由 locale.getpreferredencoding() 提供</li>
<li>如果设定了 PYTHONIOENCODING 环境变量，sys.stdout&#x2F;stdin&#x2F;stderr 的编码使用设定的值，否则继承各自所在的控制台。如果输入&#x2F;输出重定向到文件中，则由 locale.getpreferredencoding() 提供</li>
<li>Python 在二进制数据和字符串之间转换时，内部使用 sys.getdefaultencoding() 获得编码。该函数在 Python3 中是供核心开发者使用</li>
<li>sys.getfilesystemencoding() 用于编解码文件名</li>
</ul>
<p>关于编码默认值的最佳建议是：别依赖默认值。如果遵从 <code>Unicode 三明治</code>的建议，并且始终在程序中显式地指定默认编码，那么将避免很多问题。</p>
<h3 id="为了正确比较而规范化-Unicode-字符串"><a href="#为了正确比较而规范化-Unicode-字符串" class="headerlink" title="为了正确比较而规范化 Unicode 字符串"></a>为了正确比较而规范化 Unicode 字符串</h3><p>因为 Unicode 有组合字符，所以字符串比较比较复杂。有时候对应用程序而言，应该视为相等的字符，但是 Python 看到的是不同的码位序列，因此不能判定二者相等。该问题的解决方案是使用 <code>unicodedata.normalize</code> 函数提供的 Unicode 规划化。该函数的第一个参数是以下 4 个字符串中的一个：</p>
<ul>
<li>NFC：使用最少的码位构成的等价字符串。NFC 也是 W3C 推荐的规范化形式</li>
<li>NFD：把组合字符分解成基字符和单独的组合字符</li>
<li>NFKC 和 NFKD：这两种是比较严格的规范化形式，对兼容字符有影响。NFKC 或 NFKD 可能会损失或曲解信息，但是可以为搜索和索引提供便利的中间表述</li>
</ul>
<h4 id="大小写折叠"><a href="#大小写折叠" class="headerlink" title="大小写折叠"></a>大小写折叠</h4><p>大小写折叠其实就是把所有文本都变成小写，再做其他转换。该功能由 str.casefold() 方法支持。自 Python3.4 起，str.casefold() 和 str.lower() 得到不同结果的有 116 个码位。</p>
<h4 id="规范化文本匹配使用函数"><a href="#规范化文本匹配使用函数" class="headerlink" title="规范化文本匹配使用函数"></a>规范化文本匹配使用函数</h4><p>如上所述，NFC 和 NFD 可以放心使用，而且能合理比较 unicode 字符串。对于大多数应用来说，NFC 是最好的规范化形式。不区分大小写的比较应该使用 <code>str.casefold()</code>：</p>
<p>如果要处理多语言文本，可以自己封装两个函数：nfc_equal 可以实现 Unicode 字符串的比较，fold_equal 可以实现忽略大小写的比较：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unicodedata <span class="keyword">import</span> normalize</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nfc_equal</span>(<span class="params">str1, str2</span>):</span><br><span class="line">    <span class="keyword">return</span> normalize(<span class="string">&#x27;NFC&#x27;</span>, str1) == normalize(<span class="string">&#x27;NFC&#x27;</span>, str2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fold_equal</span>(<span class="params">str1, str2</span>):</span><br><span class="line">    <span class="keyword">return</span> normalize(<span class="string">&#x27;NFC&#x27;</span>, str1).casefold() == normalize(<span class="string">&#x27;NFC&#x27;</span>, str2).casefold()</span><br></pre></td></tr></table></figure>

<h3 id="Unicode-文本排序"><a href="#Unicode-文本排序" class="headerlink" title="Unicode 文本排序"></a>Unicode 文本排序</h3><p>Python 比较任何类型的序列时，会一一比较序列里的各个元素。对字符串来说，比较的是码位。可是在比较非 ASCII 字符时，得到的结果不尽如人意。在 Python 中，非 ASCII 文本的标准排序方式是使用 locale.strxfrm 函数，该函数会把字符串转换成适合所在区域进行比较的形式。使用 locale.strxfrm 函数之前，必须先为应用设定合适的区域设置，使用 setlocale 来设置区域：</p>
<ul>
<li>区域设置是全局的，应用或框架应该在进程启动时设定区域设置，而且此后不要修改</li>
<li>操作系统必须支持区域设置</li>
<li>必须知道如何拼写区域名称</li>
<li>操作系统的制作者必须正确实现了所设置的区域</li>
</ul>
<p>标准库提供的国际化排序方案是可用的，但是似乎只支持 GNU&#x2F;Linux，而且还要依赖于区域设置，这会为部署带来问题。还有一个较为简单的方案：PyPI 中的 PyUCA 库。它是 Unicode 排序算法（Unicode Collation Algorithm，UCA）的纯 Python 实现。</p>
<p>PyUCA 没有考虑区域设置，如果想要定制排序方式，可以把自定义的排序表路径传给 Collator() 构造方法。</p>
<h3 id="Unicode-数据库"><a href="#Unicode-数据库" class="headerlink" title="Unicode 数据库"></a>Unicode 数据库</h3><p>Unicode 标准提供了一个完整的数据库，不仅包括码位和字符名称之间的映射，还有各个字符的元数据，以及字符之间的关系。字符串的 <code>isprintable</code>、<code>isnumeric</code> 等方法就是靠这些信息进行判断：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> unicodedata</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;我&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>unicodedata.name(s)</span><br><span class="line"><span class="string">&#x27;CJK UNIFIED IDEOGRAPH-6211&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.isdigit()</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.isprintable()</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="支持字符串和字节序列的双模式-API"><a href="#支持字符串和字节序列的双模式-API" class="headerlink" title="支持字符串和字节序列的双模式 API"></a>支持字符串和字节序列的双模式 API</h3><p>标准库的一些函数能接受字符串或字节序列作为参数，然后根据类型展现不同的行为。re 和 os 模块中就有这样的函数。</p>
<h4 id="正则表中的字符串和字节序列"><a href="#正则表中的字符串和字节序列" class="headerlink" title="正则表中的字符串和字节序列"></a>正则表中的字符串和字节序列</h4><p>如果使用字节序列构建正则表达式，<code>\d</code>、<code>\w</code> 等模式只能匹配 ASCII 字符，但是如果是字符串模式，就能匹配 ASCII 之外的 Unicde 数字或字母。下面程序很好地说明了这一点：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;中国 is no 1&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sb = s.encode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re_words_str = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\w+&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re_words_bytes = re.<span class="built_in">compile</span>(<span class="string">rb&#x27;\w+&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re_words_str.findall(s)</span><br><span class="line">[<span class="string">&#x27;中国&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;no&#x27;</span>, <span class="string">&#x27;1&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re_words_bytes.findall(sb)</span><br><span class="line">[<span class="string">b&#x27;is&#x27;</span>, <span class="string">b&#x27;no&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>可以使用正则表达式来搜索字符串和字节序列（字节序列只能用字节序列正则表达式）搜索，但是后一种情况，ASCII 范围外的字节不会当成数字和组成单词的字母。</p>
<h4 id="os-函数中的字符串和字节序列"><a href="#os-函数中的字符串和字节序列" class="headerlink" title="os 函数中的字符串和字节序列"></a>os 函数中的字符串和字节序列</h4><p>os 模块中的所有函数、文件名或路径名参数既能使用字符串，也能使用字节序列。如果这样的函数使用字符串参数调用，该参数会使用 <code>sys.getfilesystemencoding()</code> 得到的编解码器自动编码，然后操作系统会使用相同的编解码器解码。如果参数是字节序列，那么返回值也是字节序列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.listdir(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;一.txt&#x27;</span>, <span class="string">&#x27;a.txt&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.listdir(<span class="string">b&#x27;.&#x27;</span>)</span><br><span class="line">[<span class="string">b&#x27;\xe4\xb8\x80.txt&#x27;</span>, <span class="string">b&#x27;a.txt&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>为了便于手动处理字符串或字节序列形式的文件名或路径名，os 模块提供了特殊的编码和解码函数：</p>
<ul>
<li>fsencode(filename)：如果 filename 是 str 类型，使用 <code>sys.getfilesystemencoding()</code> 返回的编解码器把 filename 编码成字节序列，否则返回未经修改的 filename 字节序列</li>
<li>fsdecode(filename)：如果 filename 是 bytes 类型，使用 <code>sys.getfilesystemencoding()</code> 返回的编解码器把 filename 解码成字符串，否则返回未经修改的 filename 字符串</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/Python/" rel="tag"># Python</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2021/08/05/fluent-python-03/" rel="prev" title="流畅的 Python（3）：一等函数 & 使用一等函数实现设计模式">
      <i class="fa fa-chevron-left"></i> 流畅的 Python（3）：一等函数 & 使用一等函数实现设计模式
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2021/07/18/fluent-python-01/" rel="next" title="流畅的 Python（1）：Python 数据模型 & 内置序列类型概览">
      流畅的 Python（1）：Python 数据模型 & 内置序列类型概览 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88"><span class="nav-number">1.</span> <span class="nav-text">字典和集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">泛映射类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E5%85%B8%E6%8E%A8%E5%AF%BC"><span class="nav-number">1.2.</span> <span class="nav-text">字典推导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%98%A0%E5%B0%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">常见的映射方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E7%9A%84%E5%BC%B9%E6%80%A7%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.4.</span> <span class="nav-text">映射的弹性查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#defaultdict"><span class="nav-number">1.4.1.</span> <span class="nav-text">defaultdict</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95-missing"><span class="nav-number">1.4.2.</span> <span class="nav-text">特殊方法 __missing__</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E5%85%B8%E7%9A%84%E5%8F%98%E7%A7%8D"><span class="nav-number">1.5.</span> <span class="nav-text">字典的变种</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E7%B1%BB%E5%8C%96-UserDict"><span class="nav-number">1.6.</span> <span class="nav-text">子类化 UserDict</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.7.</span> <span class="nav-text">不可变映射类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E8%AE%BA"><span class="nav-number">1.8.</span> <span class="nav-text">集合论</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-number">1.8.1.</span> <span class="nav-text">集合字面量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E6%8E%A8%E5%AF%BC"><span class="nav-number">1.8.2.</span> <span class="nav-text">集合推导</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">1.8.3.</span> <span class="nav-text">集合的操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dict-%E5%92%8C-set-%E7%9A%84%E8%83%8C%E5%90%8E"><span class="nav-number">1.9.</span> <span class="nav-text">dict 和 set 的背后</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E5%92%8C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97"><span class="nav-number">2.</span> <span class="nav-text">文本和字节序列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E9%97%AE%E9%A2%98"><span class="nav-number">2.1.</span> <span class="nav-text">字符问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E6%A6%82%E8%A6%81"><span class="nav-number">2.2.</span> <span class="nav-text">字节概要</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-number">2.3.</span> <span class="nav-text">基本的编解码器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3%E7%BC%96%E8%A7%A3%E7%A0%81%E9%97%AE%E9%A2%98"><span class="nav-number">2.4.</span> <span class="nav-text">了解编解码问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="nav-number">2.5.</span> <span class="nav-text">处理文本文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BA%86%E6%AD%A3%E7%A1%AE%E6%AF%94%E8%BE%83%E8%80%8C%E8%A7%84%E8%8C%83%E5%8C%96-Unicode-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.6.</span> <span class="nav-text">为了正确比较而规范化 Unicode 字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E5%B0%8F%E5%86%99%E6%8A%98%E5%8F%A0"><span class="nav-number">2.6.1.</span> <span class="nav-text">大小写折叠</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%84%E8%8C%83%E5%8C%96%E6%96%87%E6%9C%AC%E5%8C%B9%E9%85%8D%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-number">2.6.2.</span> <span class="nav-text">规范化文本匹配使用函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unicode-%E6%96%87%E6%9C%AC%E6%8E%92%E5%BA%8F"><span class="nav-number">2.7.</span> <span class="nav-text">Unicode 文本排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unicode-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">2.8.</span> <span class="nav-text">Unicode 数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97%E7%9A%84%E5%8F%8C%E6%A8%A1%E5%BC%8F-API"><span class="nav-number">2.9.</span> <span class="nav-text">支持字符串和字节序列的双模式 API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97"><span class="nav-number">2.9.1.</span> <span class="nav-text">正则表中的字符串和字节序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#os-%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97"><span class="nav-number">2.9.2.</span> <span class="nav-text">os 函数中的字符串和字节序列</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">119</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
