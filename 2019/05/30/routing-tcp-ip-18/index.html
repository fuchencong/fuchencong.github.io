<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="没有任何一种路由协议能够像 BGP 那样，拥有大量实施路由策略的工具和属性，正是这些策略能力使得 BGP 足够强大。如果使用不当，也同样会给自己的网络（甚至其他网络）造成严重损害。接下来将深入讨论 BGP 的策略工具，说明如何正确使用这些工具以及出现问题后如何进行故障检测与排除操作。">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP&#x2F;IP 路由技术 18：BGP 与路由策略">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2019/05/30/routing-tcp-ip-18/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="没有任何一种路由协议能够像 BGP 那样，拥有大量实施路由策略的工具和属性，正是这些策略能力使得 BGP 足够强大。如果使用不当，也同样会给自己的网络（甚至其他网络）造成严重损害。接下来将深入讨论 BGP 的策略工具，说明如何正确使用这些工具以及出现问题后如何进行故障检测与排除操作。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2019/05/30/routing-tcp-ip-18/images/01.jpg">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2019/05/30/routing-tcp-ip-18/images/02.jpg">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2019/05/30/routing-tcp-ip-18/images/03.jpg">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2019/05/30/routing-tcp-ip-18/images/04.jpg">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2019/05/30/routing-tcp-ip-18/images/05.jpg">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2019/05/30/routing-tcp-ip-18/images/06.jpg">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2019/05/30/routing-tcp-ip-18/images/07.jpg">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2019/05/30/routing-tcp-ip-18/images/08.jpg">
<meta property="article:published_time" content="2019-05-30T09:00:37.000Z">
<meta property="article:modified_time" content="2024-04-22T11:24:46.197Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="Route">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fuchencong.github.io/fuchencong.github.io/2019/05/30/routing-tcp-ip-18/images/01.jpg">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2019/05/30/routing-tcp-ip-18/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>TCP/IP 路由技术 18：BGP 与路由策略 | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2019/05/30/routing-tcp-ip-18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          TCP/IP 路由技术 18：BGP 与路由策略
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-30 17:00:37" itemprop="dateCreated datePublished" datetime="2019-05-30T17:00:37+08:00">2019-05-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/Network/" itemprop="url" rel="index"><span itemprop="name">Network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>没有任何一种路由协议能够像 BGP 那样，拥有大量实施路由策略的工具和属性，正是这些策略能力使得 BGP 足够强大。如果使用不当，也同样会给自己的网络（甚至其他网络）造成严重损害。接下来将深入讨论 BGP 的策略工具，说明如何正确使用这些工具以及出现问题后如何进行故障检测与排除操作。</p>
<span id="more"></span>

<p>路由策略指的是：</p>
<ul>
<li>一组选择去往目的端的路由的规则</li>
<li>有多条可选路由可以到达目的端</li>
<li>用于遵循更大范围内的网络行为目标</li>
</ul>
<p>每种路由协议都拥有一套 在多个去往相同目的端的可选路径 中选择最佳路径的规则集，因此前两条定义的只是路由协议的常规决策进程，而最后一条则区分了路由策略：定义一组规则，通过某种方式修改路由协议的决策进程，从而实现期望的网络行为。目前可用的 BGP 策略设置工具主要有：</p>
<ul>
<li>前缀列表和分发列表，用于过滤单个 NLRI</li>
<li>AS_PATH 列表，用于过滤路由的 AS_PATH 属性（而不是 NLRI）</li>
<li>正则表达式，可以为某些工具提供灵活、强大的模式匹配能力</li>
<li>路由映射，可以实现复杂的策略组合</li>
</ul>
<p>与上述策略工具结合使用的就是被称为 BGP 路径属性的大量特征，BGP 决策进程可以在选择去往目的端的最佳路径时加以评估。有些路径属性属于强制属性，每条 BGP 路由都必须携带这些属性，有些路径属性则属于可选属性，BGP 路由可以在需要时携带这些属性。</p>
<p>在介绍策略工具或路径属性之前，必须首先理解路由器将策略配置应用于 BGP 可达性信息的方式以及 BGP 邻居之间管理策略变更的方式。</p>
<h2 id="策略与-BGP-数据库"><a href="#策略与-BGP-数据库" class="headerlink" title="策略与 BGP 数据库"></a>策略与 BGP 数据库</h2><p>之前说过，BGP RIB 可以分为以下三个部分：</p>
<ul>
<li>Adj-RIBs-In：存储了从对等体学到的路由更新中未经处理的路由信息，Adj-RIBs-In 中的路由被认为是可行路由</li>
<li>Loc-RIB：包含了 BGP 发话路由器对 Adj-RIBs-In 中的路由应用本地路由策略之后选定的路由</li>
<li>Adj-RIBs-Out：包含了 BGP 发话路由器在 BGP Update 消息中宣告给对等体的路由。出站路由策略决定将哪些路由放到 Adj-RIBs-Out 中</li>
</ul>
<p>下图解释了三个数据库之间的相互关系以及它们与 BGP 决策进程之间的关系：</p>
<img src="/fuchencong.github.io/2019/05/30/routing-tcp-ip-18/images/01.jpg" class="">

<ul>
<li>从邻居的 BGP Update 消息中收到的所有原始 BGP 路由都将进入 Adj-RIBs-In 数据库，入站 BGP 路由策略会在 Adj-RIBs-In 中的路由被提交到 BGP 决策进程之前修改这些路由，经过 BGP 决策进程的处理之后，选择结果将进入 Loc-RIB 数据库</li>
<li>Loc-RIB 中的信息使用方式有两种：首先由本地单播路由选择进程进行评估，该进程不仅查看 BGP Loc-RIB 中的路由，而且还查看通过其他单播 IP 路由协议学到的路由、本地配置的静态路由以及通过本地子网连接学到的路由。如果 BGP Loc-RIB 中有一条去往指定目的端的路由，同时还有一条通过其他路由协议学到的路由去往同一目的端，那么路由选择进程就会使用分配给不同路由协议的管理距离来确定最终的路由选择，然后再将选定的路由添加到本地路由器的路由表（RIB）中</li>
<li>show ip bgp rib-failure 命令可以显示单播 IP 路由选择进程并没有将该路由安装到路由表的原因（该路由是有效的）</li>
<li>除了为本地路由表提供信息，Loc-RIB 还会将自己的路由发送给 Adj-RIBs-Out 数据库，路由器利用 Adj-RIBs-Out 数据库中的路由构造发送给 BGP 对等体的 BGP Update 消息。之所以需要 Adj-RIBs-Out 数据库，是因为配置了出站 BGP 路由策略之后，Loc-RIB 中的路由在被添加到 Adj-RIBs-Out 之前会修改这些路由。</li>
</ul>
<p>接下来将重温一下 BGP 决策进程：</p>
<ul>
<li>优选权重最大的路由，这是 IOS 专有功能</li>
<li>如果权重相同，则优选 LOCAL_PERF 值最大的路由</li>
<li>如果 LOCAL_PERF 值相等，则优选该路由器本地发起的路由，即优选来自 IGP 的路由或同一台路由器上的直连路由</li>
<li>如果 LOCAL_PERF 值相等且没有本地发起的路由，那么就优选 AS_PATH 最短的路由</li>
<li>如果 AS_PATH 长度相等，那么就优选 ORIGIN 代码最小的路径，IGP 小于 EGP，EGP 小于 Incomplete</li>
<li>如果 ORIGIN 代码相同，那么就优选 MED（MULTI_EXIT_DISC）值最小的路由。仅当所有备选路由的 AS 号均相同才比较 MED 值</li>
<li>如果 MED 相同，那么就优选 EBGP 路由，次选联盟 EBGP 路由，最后选择 IBGP 路由</li>
<li>如果此时的路由仍相同，那么就优选到达 BGP NEXT_HOP 路径最短的路由，该路由是到达下一跳地址的路由中 IGP 度量最小的路由</li>
<li>如果此时的路由仍相同，且这些路由均来自同一个邻接 AS，并通过命令 maximum-paths 启用了 BGP 多路径功能，那么就在 Loc-RIB 中安装所有等价路由</li>
<li>如果没有启动多路径功能，那么就优选 BGP 路由器 ID 最小的路由。如果使用了路由反射机制，那么就优选 ORIGINATOR_ID 最小的路由</li>
<li>如果此时的路由仍相同且使用了路由反射机制，那么就优选 CLUSTER_LIST 最短的路由</li>
<li>如果此时的路由仍相同，那么就优选 IP 地址最小的邻居宣告</li>
</ul>
<p>接下来将通过如下网络说明入站策略和出站策略之间的作用关系以及对 BGP 行为的影响：</p>
<img src="/fuchencong.github.io/2019/05/30/routing-tcp-ip-18/images/02.jpg" class="">

<p>AS500 正在向 AS100 和 AS200 中的对等体宣告前缀 10.1.1.0&#x2F;24，这两台路由器都将该前缀宣告给了 AS300 中的 Eldora，Eldora 又将这两条路由安装到自己的 Adj-RIBs-In 中，之后的决策进程需要评估这两台哦路由，由于 AS100 中的路由器 RID 为 10.2.1.1，AS200 中的路由器是 10.3.1.1，因此决策进程将经由 AS100 的路由选定为最佳路由，并安装到本地路由表中。</p>
<p>在接收端对等体的 BGP 表检查出站策略的更改结果可能并不是一种最好的方法，如果仅仅希望查看宣告给邻居的是哪些路由，那么就可以使用 show ip bgp neighbor advertised-routes 命令，该命令显示的是出站策略生效之前宣告给邻居的路由信息。如果需要确定应用于指定邻居的策略情况，可以使用 show ip bgp neighbor policy 命令。</p>
<p>如果邻居启用了入站软重配置特性（inbound soft reconfiguration is not enabled），那么 show ip bgp neighbor advertised-routes 命令就可以显示从邻居收到的路由。</p>
<h2 id="IOS-BGP-实现"><a href="#IOS-BGP-实现" class="headerlink" title="IOS BGP 实现"></a>IOS BGP 实现</h2><p>上面小节解释了入站&#x2F;出站策略与信息流之间的作用方式，但并没有解释这些信息流的实际发生方式或管理方式，这些都取决于各个实现者具体的软件结构创建方式，不仅要遵循 BGP 标准，而且还要与其他 BGP 实现保持互操作，并尽可能提高运行效率。</p>
<h3 id="InQ-和-OutQ"><a href="#InQ-和-OutQ" class="headerlink" title="InQ 和 OutQ"></a>InQ 和 OutQ</h3><p>在 IOS 中的 BGP 表实际上就是 IOS 的 Loc-RIB 实现。IOS 不使用 Adj-RIBs-In 和 Adj-RIBs-Out，而是使用被称为 InQ h和 OutQ 的队列（每个邻居一个），IOS 利用这些队列保存路由，直至宣告路由。IOS BGP 处于稳定状态的典型形态时，InQ 和 OutQ 队列通常都为空。</p>
<h3 id="IOS-BGP-进程"><a href="#IOS-BGP-进程" class="headerlink" title="IOS BGP 进程"></a>IOS BGP 进程</h3><p>必须由专门的进程负责将信息移入和移出数据库并管理这些信息，这些进程就是 BGP 决策进程和单播 IP 路由选择进程。如下显示了 IOS BGP 进程实现所包含的模块信息：</p>
<ul>
<li>I&#x2F;O（Input&#x2F;Output，输入&#x2F;输出）</li>
<li>Router（路由器）</li>
<li>Scanner（扫描器）</li>
<li>Event（事件）</li>
</ul>
<p>如下解释了这些模块进程之间的关系：</p>
<img src="/fuchencong.github.io/2019/05/30/routing-tcp-ip-18/images/03.jpg" class="">

<p>BGP 的 I&#x2F;O 模块与路由器的 TCP 套接字进行连接，在输入侧，I&#x2F;O 进程负责组装从 TCP 接收到的 BGP 消息并将这些消息放入到 InQ 中，在输出侧，I&#x2F;O 进程负责从 OutQ 取出 BGP 消息并发送给 TCP。</p>
<p>BGP Router 进程负责执行 BGP 的通用功能，从 InQ 取出 BGP 消息并进行处理，如果是 Update 消息，那么就根据已配置的入站策略评估这些路由，然后再运行 BGP 决策进程并将相应的信息写入 BGP 表。在输出侧，Router 进程负责从 BGP 表取出路由，根据已配置的出站策略评估这些路由，然后再根据评估结果生成 Update 消息并将其放到 OutQ 中。</p>
<p>BGP Router 模块还负责提取 BGP 表中出现添加、删除或变更操作的路由，并修改 RIB 中的相关信息。</p>
<p>BGP Scanner 模块负责将 RIB 中的前缀和已配置的 network、redistribute 以及 aggregate 语句进行评估，将所有默认路径属性或已配置的路径属性添加到匹配前缀上，并将最终的 BGP 路由放入 BGP 表。Scanner 进程还要负责监控下一跳，路由阻尼机制的管理以及条件式路由宣告工作。</p>
<h3 id="NHT、Event-以及-Open-进程"><a href="#NHT、Event-以及-Open-进程" class="headerlink" title="NHT、Event 以及 Open 进程"></a>NHT、Event 以及 Open 进程</h3><p>最新的 IOS 版本对 BGP 进程做了大量改进，可以将扫描时间较少 75%以上，其中一个重要改进就是 NHT（Next Hop Tracker，下一跳跟踪器）的轻量级扫描器，NHT 的主要目的是提升 BGP 性能，同时还能减轻 Scanner 进程在下一跳和最佳路径验证方面的工作，从而较少扫描时间。</p>
<p>另外 BGP Event（事件）模块，该模块可以让 network 语句和重分发操作实现事件驱动，即通过增加或删除 network 或 redistribute 语句来触发向 BGP 表增加或删除前缀，同时不需要等待 Scanner 进程以及 Scanner 进程执行扫描所花费的时间。</p>
<p>BGP Open 进程属于瞬态进程，而不是稳态进程。也就是说该进程仅在需要时才会启动，并在结束后终止。只要路由器试图与邻居打开 BGP 会话，那么就会运行该进程。</p>
<h3 id="表版本"><a href="#表版本" class="headerlink" title="表版本"></a>表版本</h3><p>由于不同 BGP 进程都会更新 BGP 表、RIB 甚至可能是很多对等体，因而 BGP 必须通过相应的机制来跟踪收到的信息、前缀的最新版本以及需要利用最新前缀版本更新哪些内容，这些都是表版本号要处理的工作：</p>
<ul>
<li>每个邻居都有一个表版本</li>
<li>每个前缀都有一个表版本</li>
<li>RIB 有一个表版本</li>
<li>BGP 进程有一个表版本</li>
</ul>
<p>表版本是一个 32 位数字，BGP 分配的新表版本号始终大于上一个已分配的表版本号，表版本号的分配规则如下：</p>
<ul>
<li>BGP 启动后，BGP 会将表版本号初始化为 1，并将该表版本号分配给 RIB 以及所有已建立的邻居</li>
<li>收到一个前缀后，BGP 表版本号加 1，并将该表版本号分配给该前缀。因此 BGP 表版本号始终是前缀表版本号中的最大值</li>
<li>如果 BGP 表中的前缀发生了变化，那么该前缀的表版本号将增加到当前 BGP 表版本号加 1，BGP 表版本号进行相应的递增</li>
<li>如果从 BGP 表中撤销了一条前缀，那么 BGP 表版本号将递增。</li>
<li>BGP Router 进程根据 BGP 表中的前缀更新 RIB 时，RIB 的表版本号将成为所有前缀（包括添加到 RIB 中的前缀、RIB 中发生变化的前缀以及从 RIB 中撤销的前缀）的表版本号中的最大值。如果 BGP 表中前缀的表版本号大于 RIB 表版本号，那么 BGP Router 进程就知道该前缀还未添加到 RIB 中</li>
<li>与此相似，前缀宣告给邻居后，该邻居的表版本号将增加到宣告给该邻居的所有前缀的表版本号中的最大值。这也是跟踪路由器宣告了哪些路由的一种手段。如果 BGP 表中某前缀的表版本号大于该邻居的表版本号，那么 BGP 就知道该前缀还未宣告给该邻居</li>
</ul>
<p>需要注意，表版本号是分配给前缀，而不是去往该前缀的路由的。每条前缀都保持了 BGP 第一次学到这些前缀时分配的表版本号，最后学到的前缀拥有最新的表版本号。</p>
<p>表版本可以确定路由器的 BGP 是否处于收敛状态提供快速参考。如果 show ip bgp 的输出结果中的表版本号均相同，那么就表明该网络处于稳定状态。如果路由器拥有大量 BGP 对等体以及大量路由表，那么这种简易参考机制非常有用。如果表版本号增长速度很快，而且 BGP Router 进程以及 IO 进程占用的 CPU 资源很高，那么就表明该路由器正忙于学习该对等体宣告来的路由，或者网络中存在不稳定因素。</p>
<p>监控表版本号也是网络基线工作的一部分，需要注意的是，通过表版本号判断网络是否处于异常状态的基础是必须首先确定网络处于正常状态时的表版本号变化情况。</p>
<h2 id="管理策略变更"><a href="#管理策略变更" class="headerlink" title="管理策略变更"></a>管理策略变更</h2><p>作为 Internet 的路由协议，BGP 的设计目的是要处理比 IGP 大得多的路由数据库。BGP 管理成千上万条路由的方式之一就是在网络拓扑结构处于稳定状态时，BGP 也保持安静。距离矢量 IGP 需要按照一定的周期向直连邻居发送路由更新，链路状态 IGP 需要通过泛洪本地生成的链路状态消息来周期性地刷新链路状态数据库。与此相反，BGP 在没有变化的情况下从来不向邻居发送 Update 消息。</p>
<p>虽然这种静默处理方式能够实现 BGP 的扩展性，但却给路由策略带来了问题。在 BGP 决策进程评估入站路由之前对这些路由应用了入站策略。但是如果配置了一个新的入站策略，那么该入站策略在对等体发送新的 Update 消息之前根本不会起作用。而如果网络没有出现任何变化情况，那么对等体就不会发送新的 Update 消息。</p>
<h3 id="清除-BGP-会话"><a href="#清除-BGP-会话" class="headerlink" title="清除 BGP 会话"></a>清除 BGP 会话</h3><p>应用一个新配置的路由策略的方式之一就是利用 clear ip bgp 命令重置与指定邻居之间的 BGP 会话，运行该命令之后，会向指定邻居发送一条 Cease Notification 消息，或者发送一个携带 FIN 标记的 TCP 数据包，然后再关闭该 BGP 会话。此后邻居会发起会话重建请求，会话建立完成后，邻居就交换新的 Update 消息，此时所有的现存策略都会这些路由进行评估。</p>
<p>清除 BGP 会话的用处很多，不仅仅局限于让新配置的路由策略生效，来回关闭 BGP 会话也是故障检测与排除流程的一部分。但是清除 BGP 会话很明显属于一种破坏性操作，重建已清除的 BGP 会话可能就要几秒甚至几分钟（取决于需要更新的 BGP 路由的跳数），通常不建议用于生产性网络。</p>
<h3 id="软重配"><a href="#软重配" class="headerlink" title="软重配"></a>软重配</h3><p>需要一种更好的机制在不中断 BGP 会话的情况下，让新的路由策略能够评估或修改来自对等体的前缀，为此 Cisco 创建了软重配（Soft Reconfiguration）解决方案。软重配机制在将邻居宣告来的路由提交给入站策略或决策进程之前存储这些路由，路由器可以在不中断到邻居的 BGP 会话的情况下，在任意时间将新路由策略应用到这些路由上。</p>
<p>软重配机制的配置步骤如下：</p>
<ul>
<li>第 1 步：利用 neighbor soft-reconfiguration inbound 语句为邻居启用 Adj-RIBs-In</li>
<li>第 2 步：配置了新的入站策略之后，利用 clear ip bgp soft 应用该策略</li>
</ul>
<p>clear ip bgp soft in 命令使用本地存储的来自邻居的路由来应用入站策略，而不是执行 BGP 会话的硬重启操作，从而导致邻居再次发送路由。各种硬重启选项也同样适用于软重启，如指定重启的 IPv4 或 IPv6 邻居地址、指定重启到特定 AS 的所有会话、指定重启的 EBGP 会话、指定重启的 IPv4 和 IPv6 单播或多播会话等。</p>
<p>在配置了软重配机制后，就可以看到相应邻居宣告的路由，因为这些路由已经存储在本地的 Adj-RIBs-In 中。启用了软重配机制后，show ip bgp neighbor received-routes 命令可以显示指定邻居宣告并存储在 Adj-RIBs-In 中的路由。</p>
<p>clear ip bgp soft out 命令可以执行软重启操作以应用出站策略，此时路由器会生成新的 Update 消息并发送给该命令覆盖的所有邻居，而不会来回关启 BGP 会话。由于支持出站软重启特性并不需要创建数据库，因而没有与 neighbor soft-reconfiguration Inbound 语句相对应的 neighbor soft-reconfiguration outband 语句。如果邻居不支持软重配机制或不希望在路由器上配置软重配机制，那么就可以使用该特性。如果更改了入站策略，而不想对邻居的会话执行硬重启操作，那么就可以在连接该邻居并去往该邻居（这里的邻居指的是配置入站策略的路由器）的方向执行出站软重启操作，之后路由器就会向邻居发送一条携带新入站策略的新 Update 消息，使得该策略生效。</p>
<p>支持入站软重配机制必须付出一定的代价，因为必须在路由器的内存中设置相应的 Adj-RIBs-In 数据库。如果大量邻居都发送 Internet 全部路由，那么支持入站软重配机制的内存需求量较大。因此，还需要创建另一种解决方案，既不会有硬重启的破坏性，也不会有软重配的昂贵内存开销，该解决方案就是路由刷新。</p>
<h3 id="路由刷新"><a href="#路由刷新" class="headerlink" title="路由刷新"></a>路由刷新</h3><p>硬重启和软重启的主要目标都是将新配置的入站策略应用于邻居宣告的所有前缀上，但是硬重启会对网络造成破坏，软重启则会耗用大量无法接受的内存资源。如下给出了一种更好的解决方案，此时配置了新入站策略的路由器可以要求邻居重新发送其前缀信息。</p>
<img src="/fuchencong.github.io/2019/05/30/routing-tcp-ip-18/images/04.jpg" class="">

<p>该流程可以通过路由刷新机制来实现，路由刷新机制会向邻居发送一条新的 BGP 消息（路由刷新消息），告诉邻居重新发送其前缀信息。需要注意，必须运行相应的命令才能发送路由刷新消息。也就是说，不会自动检测策略变更情况来触发该消息。所用的命令与前面的软重配机制相同，都是 clear ip bgp soft in，区别在于邻居的配置中不包含 neighbor soft-reconfiguration inbound 语句。</p>
<p>如下给出了路由刷新消息的格式（BGP 报头后面包含了一组代码）。AFI（Address Family Identifier，地址族标识符）和 SAFI（Subsequent Address Family Identifier，子地址族标识符）允许该消息指定将要发送的前缀类型。有关地址族（可以区分多协议 BGP 宣告的不同地址类型）的详细内容，后续文章会详细介绍。</p>
<img src="/fuchencong.github.io/2019/05/30/routing-tcp-ip-18/images/05.jpg" class="">

<p>当然，路由器的邻居当中也有可能会有部分邻居不支持路由刷新功能。此时就必须知道哪些邻居不支持该功能，从而可以为这些邻居采用其他可选方案（硬重启或软重配）来应用入站策略变更。因此在打开邻居会话的过程中必须协商路由刷新能力，如果邻居支持该能力，那么就必须记录到邻居表中。</p>
<p>利用 debug ip bgp in 命令可以观察路由刷新能力的协商过程。注意，软重配机制与路由刷新机制相互排斥。如果邻居的配置中包含了 neighbor soft-reconfiguration inbound 语句，那么即便该邻居支持路由刷新机制，也必须创建 Adj-RIBs-In 数据库，如果为邻居运行 clear ip bgp soft in 命令，那么就会用到 Adj-RIBs-In 数据库，并不会向邻居发送路由刷新消息。</p>
<p>现代 BGP 网络完全不需要使用硬重启机制来插入新的入站路由策略，路由刷新是当前实现非破坏性入站策略变更管理的优选手段。</p>
<h2 id="路由过滤技术"><a href="#路由过滤技术" class="headerlink" title="路由过滤技术"></a>路由过滤技术</h2><p>ACL（Access List，访问列表）可以根据数据包头部中的源和&#x2F;或目的地址来允许或拒绝数据包。通过能力增强，ACL 目前完全能够根据数据包头部的各种数值以及上层头部的大量数值组合来精确识别数据包。ACL 目前的应用范围已不仅仅局限于数据包过滤器，包括从服务分类到重分发在内的大量操作功能都要利用 ACL 来标识数据包。</p>
<p>对于路由过滤器来说也是如此，虽然可以利用路由过滤器来允许或拒绝路由的宣告或接受，但同样也可以利用路由过滤器为大量策略设置功能来识别路由。需要记住的关键概念是，路由过滤器标识的是路由，而不是数据包，是配置路由策略的基础工具。接下来将介绍 IOS 提供的各种路由过滤器并解释它们的一些常见应用。</p>
<h3 id="通过-NLRI-过滤路由"><a href="#通过-NLRI-过滤路由" class="headerlink" title="通过 NLRI 过滤路由"></a>通过 NLRI 过滤路由</h3><p>如果只需要识别少量路由或者待过滤的路由之间没有共同特征进行有效分类，那么通过路由的目的前缀（路由的 NLRI）来过滤路由就是一种最精确也是最好的路由过滤方法。如果仅利用过滤器简单地允许或拒绝路由的宣告（出）或接受（入），那么就可以在邻居上应用过滤器或者在重分发配置中应用过滤器。</p>
<p>IOS 为基于 NLRI 的路由过滤提供了两种有效的工具：分发列表和前缀列表。其中前缀列表是最新工具也是优选工具，它提供的各种配置选项使其更加灵活，而且对路由器的性能影响也很小。</p>
<h3 id="案例研究：使用分发列表"><a href="#案例研究：使用分发列表" class="headerlink" title="案例研究：使用分发列表"></a>案例研究：使用分发列表</h3><p>对于 BGP 来说，第一个也是最简单的路由过滤器就是由 distribute-list 命令定义的分发列表。使用该路由过滤器时，需要为每个邻居定义该路由过滤器，并指向一个访问列表，由访问列表定义该路由过滤器将要作用的前缀或 NLRI。</p>
<p>下面是本案例将要用到的网络结构图：</p>
<img src="/fuchencong.github.io/2019/05/30/routing-tcp-ip-18/images/06.jpg" class="">

<p>为了确保 Innsbruck 或 Cervinia 不会将数据包转发给 AS30（除非数据包的目的地址属于 AS30 前缀），此时就应该使用出站路由过滤来确保 Zermatt 和 Moritz 向它们的 EBGP 对等体仅宣告 AS30 前缀。Zermatt 通过 neighbor distribute-list 实现了出站路由过滤器，该过滤器应用于邻居 Innsbruck，同时引用了 ACL 1 来识别需要被过滤的前缀，并利用关键字 out 将该过滤器设置为出站过滤器。</p>
<p>该网络还存在另一个问题，Innsbruck 不仅将 Meribel 列为 AS50 目的端下一跳，而且将 Cervinia 也列为下一跳。Cervinia 也有类似问题。这是因为 Innsbruck 和 Cervinia 不仅与 Meribel 建立对等会话，而且它们之间也建立了对等会话：Meribel 将路由宣告给自己的两个 EBGP 对等体后，这些对等体又反过来将路由宣告给对方。虽然这些路由在 BGP 表中被标记为有效路由，但是 Cervinia 并不是从 Innsbruck 到 Meribel 的有效下一跳，而且 Innsbruck 也不是 Cervinia 到 Merribel 的有效下一跳，因为共享的 IXC 链路是去往 Meribel 的唯一链路。</p>
<p>Innsbruck 为解决这个问题而配置的入站路由过滤器（在 Cervinia 上也配置了相似的过滤器），利用 ACL 1 拒绝 AS50 前缀并允许其他所有前缀，对 Cervinia 应用 distribute-list 命令，并且仅过滤从该邻居收到的路由。此外，也对 Meribel 应用了一个入站路由过滤器，利用 ACL 2 来确保不从该邻居接收 AS200 前缀，因而在经由 Cervinia 去往 10.200.0.0&#x2F;16 的路由变得不可达时，Innsbruck 与 Meribel 之间也不会出现路由环路。</p>
<h3 id="使用扩展-ACL-的路由过滤器"><a href="#使用扩展-ACL-的路由过滤器" class="headerlink" title="使用扩展 ACL 的路由过滤器"></a>使用扩展 ACL 的路由过滤器</h3><p>随着前缀过滤需求复杂度的不断增加，利用 ACL 识别待过滤前缀在操作上的难度也变得越来越大：</p>
<ul>
<li>利用网络掩码识别有类别边界内的前缀很困难，也很容易混淆</li>
<li>利用访问列表识别连续的前缀区间很困难</li>
<li>如果需要过滤的前缀集经常发生变化，那么编辑访问列表的操作难度将非常大</li>
</ul>
<p>使用访问列表作为路由过滤器的操作难度在于利用数据包识别工具来识别路由。标准 ACL（识别一个简单的单一前缀列表）非常直观，但是如果要执行更复杂的识别操作，那么就需要使用扩展访问列表。例如，扩展列表不仅可以识别单个 16 比特前缀 10.20.0.0&#x2F;16，而且还能识别前 16 比特是 10.20 的所有更长前缀，相应的扩展访问列表如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access-list 100 permit ip 10.20.0.0 0.0.255.255 255.255.0.0 0.0.255.255</span><br></pre></td></tr></table></figure>

<p>该 ACL 包含了 4 个 32 比特点分十进制地址：</p>
<ul>
<li>10.20.0.0：指定有意义的前缀编号</li>
<li>0.0.255.255：是一个通配符掩码，指定前 16 比特固定不变，后 16 比特（在通配符中标记为不关心的比特）可以是任何值</li>
<li>255.255.0.0：指定前缀的 16 比特掩码，即最小前缀长度</li>
<li>0.0.255.255：是一个应用于地址掩码的通配符掩码，指定掩码的 16 比特必须为全1，后 16 比特可以为任意值</li>
</ul>
<p>从这些示例可以看出，在路由过滤操作中使用 ACL 非常不直观，幸运的是，前缀列表提供了一种更好也更容易理解的 NLRI 过滤工具。</p>
<h3 id="案例研究：使用前缀列表"><a href="#案例研究：使用前缀列表" class="headerlink" title="案例研究：使用前缀列表"></a>案例研究：使用前缀列表</h3><p>前缀列表的过滤功能与之前 ACL 完全相同， ip prefix-list 语句的一些优点：</p>
<ul>
<li>前缀列表使用名称而不是数字，因而更容易标识各个过滤器</li>
<li>可以在前缀列表的开头增加 ip prefix-list description 语句，最多可以通过 80 个文本字符来帮助了解前缀列表的作用</li>
<li>增加序号（seq）来协助编辑前缀列表</li>
<li>使用的是 CIDR 记法（在斜线后面指定前缀比特长度），而不是访问列表使用的前缀掩码记法。CIDR 不但输入简单，而且也更容易理解</li>
<li>利用 neighbor prefix-list 语句将过滤器应用于 BGP 邻居，与 neighbor distribute-list 语句相似，需要指定过滤器的入站（in）或出站（out）方向。需要注意的是，虽然也可以利用 neighbor distribute-list prefix-list 语句来调用前缀列表，但使用该语句而不是更简单的 neighbor prefix-list 语句通常并无意义</li>
<li>前缀列表对 CPU 资源的耗用也相对较少，因而实现相同功能的基于 ACL 的路由过滤器相比，前缀列表能够让路由器拥有更好的性能。如果路由器配置了大量策略，那么改善程度将非常明显</li>
</ul>
<p>与访问列表相似，前缀列表也按照从上到下的顺序依次执行。前缀列表默认会添加序列号，即输入前缀列表表项时不需要自己输入序列号。IOS 将第一跳表项的序列号设置为 5，后续表项的序列号依次增 5。新表项都添加在前缀列表的最底部。如果希望在列表的其他位置添加表项，那么就可以在输入表项时指定序号，这样就可以将该表项添加到列表的指定位置。</p>
<p>与 ACL 相似，前缀列表也隐含 拒绝全部，如果向前缀列表发送前缀后没有发现匹配项，那么就拒绝该前缀。与 ACL 一样，一种好的做法就是在前缀列表的末尾显示配置 拒绝全部，以提醒操作员该表项的存在。</p>
<p>可以使用关键字 ge 和 le 来指定一个大于 0 且小于 32 的区间范围，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip prefix-list Example-C <span class="built_in">seq</span> 20 permit 10.128.0.0/12 ge 16 le 24</span><br></pre></td></tr></table></figure>

<p>该表项的前 12 比特为 10.128 且前缀长度至少为 16 比特但不大于 24 比特的所有前缀。</p>
<p>配置了大量策略规则的 BGP 路由器（如位于对等互联点的 BGP 路由器）通常拥有很多前缀列表，而这些前缀列表都可能很长。show ip prefix-list 命令只能查看单个前缀列表，而 show ip prefix-list Summary 和 show ip prefix-list detail 命令却可以显示路由器上配置的所有前缀列表的信息、显示路由器配置的前缀列表以及每个前缀列表的使用情况。</p>
<p>有时可能出于某种原因需要在 BGP 配置中同时使用前缀列表和分发列表，需要注意的是，不能为相同方向上的同一个邻居同时使用前缀列表和分发列表。</p>
<h3 id="使用-AS-PATH"><a href="#使用-AS-PATH" class="headerlink" title="使用 AS_PATH"></a>使用 AS_PATH</h3><p>BGP 在看待路由时采用的是 更高层级 的视图，根据经由 AS 的路径来跟踪路由，而不像 IGP 根据经由各个路由器的路径来跟踪路由。AS_PATH 属性是 BGP 用来跟踪 AS 间路径的主要机制。因此人们常常根据 BGP 路由所经过的自治系统（而不是各个前缀）对 BGP 路由进行策略控制。</p>
<p>AS_PATH 过滤器是一种可以根据 AS_PATH 属性（而不是 NLRI）识别 BGP 路由的强大工具。AS_PATH 过滤器的强大之处在于其可以使用被称为正则表达式的文本解析工具来匹配 AS_PATH 属性中的各种模式。</p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>正则表达式利用字符串（元字符或文本）来查找文本中的匹配项，AS_PATH 访问列表则利用正则表达式在 BGP 更新的 AS_PATH 属性中查找匹配项。元字符是充当运算符的特殊正则表达式字符，作用是告诉正则表达式如何执行匹配操作。如下列出了 Cisco IOS 的可用元字符：</p>
<ul>
<li>.：匹配任意单个字符</li>
<li>[]：匹配方括号内的任意字符</li>
<li>[^]：匹配除方括号内的字符之外的任意字符（^要位于文本序列之前）</li>
<li>-：匹配被连字符分割的两个文本之间的任何字符</li>
<li>?：匹配 0 或 1 个字符（或模式）实例</li>
<li>*：匹配 0 或多个字符（或模式）实例</li>
<li>+：匹配一个或多个字符（或模式）实例</li>
<li>^：匹配字符串的开始</li>
<li>$：匹配字符串的结束</li>
<li>|：匹配被改元字符隔开的两个文本之一</li>
<li>_：匹配逗号、字符串的开始、字符串的结束或空格</li>
</ul>
<h3 id="案例研究：使用-AS-PATH-过滤器"><a href="#案例研究：使用-AS-PATH-过滤器" class="headerlink" title="案例研究：使用 AS_PATH 过滤器"></a>案例研究：使用 AS_PATH 过滤器</h3><p>利用 neighbor filter-list 语句可以将 AS_PATH 过滤器（包含一条或多条 ip as-path access-list 表项）应用于指定邻居。与分发列表&#x2F;前缀列表相似，也可以利用关键字 in 或 out 将 AS_PATH 过滤器应用于入站路由或出站路由。</p>
<p>与常规的 ACL 相似，AS_PATH ACL 也包含隐含的 拒绝全部，也就是说，如果路由到列表末尾都没有找到匹配项，那么默认操作就是拒绝该路由。与常规 ACL 一样，一种好的做法就是在 AS_PATH ACL 的末尾显示配置 拒绝全部 或 允许全部 语句，以免对访问列表的总体行为产生任何困惑。</p>
<h3 id="案例研究：利用路由映射设置策略"><a href="#案例研究：利用路由映射设置策略" class="headerlink" title="案例研究：利用路由映射设置策略"></a>案例研究：利用路由映射设置策略</h3><p>路由过滤器不但可以匹配路由的前缀（NLRI），而且还可以匹配路由的 AS_PATH 属性。路由过滤器对匹配路由执行的操作很简单，就是接受（允许）或丢弃（拒绝）。可以将路由过滤器应用于从指定邻居接收到的路由或宣告给指定邻居的路由。路由策略的运行结果是通过控制路由器是否能够通过某个邻居知晓路由来实现的。</p>
<p>路由映射提供了非常好的灵活性和精确性，可以实现复杂的路由策略：</p>
<p>路由映射能够匹配很多不同的 BGP 路由属性<br>路由映射不但能够接受或丢弃路由，而且还能设置或更改路由的属性<br>路由映射可以组合多种匹配规则、设置多种属性并构建复杂的路由策略<br>之前介绍过路由映射在重分发和策略路由方面的使用方式，此时的路由映射主要用于构建复杂的 BGP 策略，但是原理完全相同。与前缀列表类似，路由映射也使用名称，这样更容易在 IOS 配置中识别路由映射的组件，也更容易引用映射。路由映射包含一个或多条 route-map 语句，每条 route-map 语句都有一个序列号，从而简化了路由映射的编辑操作。此外，与 ACL 和前缀列表一样，每条 route-map 语句也都包含关键字 permit 或 deny。</p>
<p>路由映射本身与每条被引用的路由相匹配，为了控制匹配行为，需要向路由映射语句添加一个或多个 match 子句。如果在路由映射语句下面指定了多个 match 子句，那么路由必须匹配所有 match 子句，以便路由映射语句的 permit 或 deny 操作生效。使用 set 字句可以更改路由的特性，与 match 子句一样，可以有一个或多个 set 字句。</p>
<p>与访问列表相似，路由映射也按照从上到下的顺序依次执行。如果路由与 route map 语句的所有 match 字句都匹配，那么就执行已匹配的所有 set 子句以及 permit 或 deny 操作，之后对该路由的处理也将终止。如果路由并不匹配 route map 语句的所有 match 子句，那么就接着看下一条语句。与访问列表一样，路由映射语句序列的末尾也有隐含的 拒绝全部 语句，如果路由与路由映射中的所有语句均不匹配，那么就丢弃该路由。</p>
<p>使用 show route-map 命令可以显示简单明了的路由汇总信息。</p>
<h3 id="过滤器处理"><a href="#过滤器处理" class="headerlink" title="过滤器处理"></a>过滤器处理</h3><p>可以在需要的时候为每个邻居的每个方向都配置一个 NLRI 过滤器（前缀列表或分发列表，但不是两者）、一个 AS_PATH 过滤器以及一个路由映射。</p>
<p>可以在单个邻居会话的相同方向配置多种类型的过滤器，而这些过滤器的实际处理顺序与 IOS 版本有关，过滤器在配置中的出现顺序也可能会随着 IOS 版本的变化而变化。</p>
<p>最好不要关心处理顺序，如果单个邻居的同一方向配置了多个过滤器，那么在接受（入站）或宣告（出站）路由之前，该路由必须得到所有过滤器的允许。除非能够确定自己永远只为给定邻居配置单个 NLRI 过滤器或单个 AS_PATH 过滤器，否则围绕处理顺序而产生的混淆会使得在路由映射中配置 NLRI 过滤器和 AS_PATH 过滤器是一种更佳选择：</p>
<ul>
<li>为邻居配置的路由策略要易于理解</li>
<li>顺序化的路由映射语句使得策略编辑（无论什么时候）更加容易</li>
<li>由于路由映射语句是按序处理的，因而可以控制 NLRI 过滤器以及 AS_PATH 过滤器对路由的评估顺序</li>
</ul>
<h2 id="影响-BGP-决策进程"><a href="#影响-BGP-决策进程" class="headerlink" title="影响 BGP 决策进程"></a>影响 BGP 决策进程</h2><p>BGP 路由策略是通过影响 BGP 决策进程来实现其意图的。当然 NLRI 和 AS_PATH 过滤器本身也能粗略地影响 BGP 决策进程，实现方式是控制路由器知道哪些路由以及路由器能够将决策进程应用于哪些路由。但是我们需要利用更精细化的路由策略通过更改路由属性来影响决策进程，而不是简单地允许或阻塞路由。</p>
<p>之前已经介绍过 IOS 的 BGP 决策进程，下面将通过 5 个案例来解释利用路由映射实现复杂路由策略的方法，这 5 个案例将分别解释如下场景中的路由优先级的影响方法：</p>
<ul>
<li>单台路由器内（拥有多条去往相同目的地的 BGP 路由）</li>
<li>本地 AS 内部</li>
<li>邻接 AS 内部</li>
<li>跨越邻接自治系统的 AS 内部</li>
<li>单台路由器内部（拥有多条来自不同路由协议且去往相同目的端的 BGP 路由）</li>
</ul>
<h3 id="案例研究：权重管理"><a href="#案例研究：权重管理" class="headerlink" title="案例研究：权重管理"></a>案例研究：权重管理</h3><p>管理权重不属于 BGP 标准规定的路径属性，是 Cisco 的专有 BGP 属性。路由从一台路由器宣告到另一台路由器时，管理权重并不会随之宣告出去，管理权重仅对单台路由器的 BGP 表的路由有效。因此管理权重只影响单台路由器的 BGP 决策进程，这种影响并不会传递给其他路由器。</p>
<p>每条路由都会分配一个权重（取值范围为 0-65535），对于去往同一目的地的多条路由来说，路由器会优选权重最大的路由。默认情况下，源自本路由器的 BGP 路由的权重为 32768，学自其他邻居的 BGP 路由的权重为 0。这种默认行为可以在存在多条去往同一目的端的路由且其中有一条路由是本地生成的路由时，确保本地路由器优选自己的路由，次选邻居宣告的路由。这样做是有道理的：如果路由器向 BGP 注入了一条路由，那么从 BGP 的角度来看，这台路由器在如何到达该目的端方面应该是最权威的。</p>
<p>权重是众多路由属性中最先考虑的路径属性，也就是说，管理权重在 BGP 决策进程中是首要决定因素。</p>
<p>如果学自特定邻居的所有路由的权重均相同，那么命令 neighbor weight 就非常有用。但有时必须为来自同一邻居的不同路由设置不同的权重，此时就需要利用路由映射为希望更改权重的路由提供更特殊的特性。</p>
<p>利用路由映射设置权重时，只能匹配 AS_PATH，无法利用 match ip address 字句来匹配单个 IP 地址。与 neighbor weight 语句一样，也可以在同一个邻居配置中使用 weight-setting 路由映射。如果同时使用，那么路由映射的优先级要高于 neighbor weight 语句。</p>
<p>使用权重时需要额外注意，更改 AS 中的单台路由的 BGP 决策进程可能会产生不可预料的路由行为。虽然权重有自己的用途，但是对于绝大多数应用场合来说，BGP 决策进程在整个自治系统中都应该相同。</p>
<h3 id="案例研究：使用-LOCAL-PREF-属性"><a href="#案例研究：使用-LOCAL-PREF-属性" class="headerlink" title="案例研究：使用 LOCAL_PREF 属性"></a>案例研究：使用 LOCAL_PREF 属性</h3><p>如果希望影响单台路由器的出站路径选择，但又不希望影响其他路由器，那么管理权重就非常有用。但在很多情况下，设置路由策略以影响出站路径选择时，都希望将该策略应用于整个自治系统，此时就可以使用 LOCAL_PREF 属性。该属性并不局限于单台路由器，而是附加在路由上宣告给 IBGP 对等体。该属性不会在 EBGP 对等体之间进行传递吗，因而将其称为本地优先级，仅用于本地自治系统。在用于设置路由策略的 BGP 路径属性中，LOCAL_PERF 可能是最常用的路径属性。</p>
<p>路由的 LOCAL_PREF 属性的取值范围在 0 - 4294967295 之间，值越大，路由越优。在默认情况下，所有宣告给 IBGP 对等体的 LOCAL_PREF 属性值都是 100。利用 ip default local-preference 语句可以更改 LOCAL_PREF 属性的默认值，利用路由映射和命令 set local-preference 可以更改单条路由的 LOCAL_PREF 属性值。</p>
<p>由于学自 IBGP 对等体的路由不会宣告给其他 IBGP 对等体，因而在内部邻居的出站方向设置策略而不是在外部邻居的入站方向设置策略，就能更好地控制希望影响的路由。</p>
<h3 id="案例研究：使用-MULTI-EXIT-DISC-属性"><a href="#案例研究：使用-MULTI-EXIT-DISC-属性" class="headerlink" title="案例研究：使用 MULTI_EXIT_DISC 属性"></a>案例研究：使用 MULTI_EXIT_DISC 属性</h3><p>如果希望影响入站路径选择而不是出站路径选择，也就是说，向邻接 AS 中的多个外部对等体宣告前缀时，希望告诉邻接 AS 应该优选哪条路由。一种方式就是宣告前缀中附加 MED 属性。</p>
<p>MULTI_EXIT_DISC（即 MED）属性的作用是影响邻居自治系统中的路由决策。MED 也被称为外部度量值，并在 BGP 表中标记为 metric。与 LOCAL_PERF 相似，MED 也是长为 4 个字节的数值，取值范围为 0-4294967925。</p>
<p>MED 是一个相对比较弱的属性，BGP 决策进程在评价去往同一目的端的多条路由时，权重、LOCAL_PERF 和 AS_PATH 长度以及 ORIGIN 属性都优于 MED。如果这些变量均相同，那么就选择 MED 值最小的路由。MED 的另一个术语是度量，而度量的另一个术语就是距离，因而 MED 值越小，路由越优先。</p>
<p>MED 是一种可选非传递属性，BGP 发话路由器从外部对等体学到路由后可以将路由的 MED 传递给 IBGP 对等体，但路由器不能将源自邻接 AS 的 MED 传递给其他 AS 中的对等体，因而 MED 仅在邻居自治系统之间具有相关性。</p>
<p>之前说过，利用 network 语句注入前缀时，该前缀必须位于路由表中。学自 IBGP 的路由的度量均为 0，而学自 IS-IS 的路由的路由的度量为 20。IOS 利用 network 语句将前缀注入 BGP 时，会以相应的 IGP 度量值为该路由添加 MED 属性。如果 IOS 路由器从 EBGP 对等体收到了未携带 MED 的前缀，那么在该路由宣告给 IBGP 对等体之前都会以默认值为 0 为该路由添加 MED 属性。</p>
<p>下面总结 IOS 对 MED 的处理行为：</p>
<ul>
<li>如果根据路由表中的 IGP 路由将指定前缀注入到 BGP 中，那么为该前缀分配的 MED 值等于 IGP 度量值</li>
<li>如果将指定前缀从源端 AS 宣告到邻居 AS 中，那么将保留 MED，而且对该邻居 AS 中的所有 IBGP 路由器来说均已知</li>
<li>如果邻居 AS 将路由宣告给自己的邻居 AS，那么在宣告前必须删除该路由的 MED 属性</li>
<li>如果路由器从 EBGP 对等体收到一条未携带 MED 属性的路由，那么就在自己的 BGP 表中将该路由标记为 as-is，且无 MED</li>
<li>如果路由器的 BGP 表中有一条无 MED 的路由且要宣告给 IBGP 对等体，那么在宣告之前需要以默认值 0 为该路由添加 MED 属性</li>
</ul>
<p>从历史角度来看，IETF 的 BGP 规则在 MED 的默认处理方式上一直不是很明确，因而不同的设备商都有自己的默认处理方式。因此在多厂商网络环境中使用 MED 时，必须理解所有 BGP 实现的默认行为，并将它们的默认行为调成一致。IOS 提供了 bgp bestpath med missing-as-worst 语句来帮助调整默认的 MED 处理行为。如果 BGP 配置中包含了该语句，那么 IOS 在为缺失 MED 属性时将 4294967295 作为默认值，而不是将 0 作为默认值。</p>
<p>可以通过路由映射或以下两种 set 字句之一为指定路由添加 MED 属性：</p>
<ul>
<li>set metric 子句可以将度量设置为 0-4294967295 之间的任意值，如果希望手工控制 MED 值，那么就可以使用该子句</li>
<li>set metric-type internal 子句可以将 MED 与该路由的下一跳的 IGP 度量关联起来。即不是手工设置 MED 值，而是由路由器自动将 MED 值设置为去往该前缀的下一跳的路由的 IGP 度量。多台路由器向邻居 AS 宣告给定前缀时（使用该子句可以确保最靠近该前缀的下一跳的路由器宣告的 MED 值最小），邻居 AS 也要向最靠近目的端的 AS 边界路由器发送数据包</li>
</ul>
<p>如果不同自治系统中的外部对等体都宣告了相同路由，那么就会忽略这些路由的 MED 值。正常情况下，这是正确的默认处理行为：通常不希望接受来自多个不受自己控制的管理机构 有竞争性 的 MED 值。但是该规则偶尔也会有例外，IOS 为这类场景提供了一种配置选项，bgp always-compare-med 语句强制要求路由器在 BGP 决策进程中包含 MED 比选步骤，即使这些前缀是由不同 ASN 宣告的。</p>
<p>接下来再介绍两个 IOS BGP 的默认行为。第一个默认行为就是如何在 BGP 表中评价去往同一目的端的多条路由。IOS 按照自上而下的顺序评价这些路由，每次两条，根据 BGP 决策进程从中选出最后的最佳路由。</p>
<p>另外一个需要考虑的 IOS BGP 默认行为就是如何记录收到的去往相同前缀的路由。路由器收到每条路由之后，都会在该前缀的路由表项列表的顶部增加一条表项。</p>
<p>表项顺序不同，最佳路由的选择结果也可能不同。而表项顺序取决于路由器第一次收到路由的顺序。表项顺序不同，最佳路由的选择结果也可能不同。而表项顺序取决于路由器第一次收到路由的顺序，因而最佳路径选择进程得到的结果并不恒定。</p>
<p>IOS 提供了一种可以让最佳路径选择成为确定性进程的配置选项。在 BGP 配置中增加 bgp deterministic-med 语句之后，进入 BGP 表的表项就会按照宣告 ASN 进行分组，而不再是简单地照新旧次序进行排列，先从每个组中选中最佳表项，然后再对比这些表项。</p>
<p>虽然 IOS 没有默认启用 bgp deterministic-med语句，但现代最佳实践建议启用该语句，以确保从多个 AS 学到相同前缀时能够拥有一致、可预测的 BGP 路径选择行为。 bgp always-compare-med 也能增强路径选择的确定行为，如果使用了该语句，就没有必要使用 bgp deterministic-med语句，两者之间也有区别，前者仅用于希望比较来自不同 AS 路由的 MED 的场景。</p>
<p>对于 MED 来说，最后需要说明的一点，通常不希望邻居自治系统发送它们的 MED 设置情况，从而影响自己 AS 的 BGP 决策进程。为此可以在所有 EBGP 会话上配置一条入站策略，将接收到的路由的 MED 值均改写成相同值。如果所有路由的 MED 值均相等，那么就不会影响自己的 BGP 决策进程了。</p>
<h3 id="案例研究：附加-AS-PATH"><a href="#案例研究：附加-AS-PATH" class="headerlink" title="案例研究：附加 AS_PATH"></a>案例研究：附加 AS_PATH</h3><p>MULTI_EXIT_DISC 属性能够影响来自邻居自治系统的入站流量，但无法影响更远端自治系统的路由决策。在如下网络中，路由器 Meribel 拥有两条去往 AS30 中同一目的地的等价路径。由于这两条路径除路由器 ID 之外其他属性均相同，因而 Meribel 的 BGP 决策进程选择路由器 ID 较小的 Innsbruck 作为去往 AS30 的全部流量的下一跳路由器。因此，AS50 去往 AS30 的流量根本不会经过 Cervinia-Moritz 链路，导致该可用带宽的利用率低。</p>
<img src="/fuchencong.github.io/2019/05/30/routing-tcp-ip-18/images/07.jpg" class="">

<p>由于 AS30 与 AS50 不是直接相连的邻居自治系统，因而 AS30 无法利用 MED 影响 AS50 的路由决策。但是通过 set as-path prepend 字句的路由映射所宣告路由的 AS_PATH 属性之后，AS30 就可以影响 AS50 的路由决策了。该子句可以在路由宣告给 EBGP 对等体的时候向路由的 AS_PATH 属性附加额外的 ASN，使得该路径劣于同一 AS 中其他路由器宣告的去往相同前缀的路由。</p>
<p>使用 AS_PATH 预附加策略时必须特别谨慎，如果不能完全理解所做配置的影响结果，那么就可能会出现无法预料或中断的路有选择结果。还需要注意一点就是，应该始终使用附加路由器的 AS 号执行 AS_PATH 附加操作。如果使用了其他的 AS 号，而且被宣告路由遇到了使用该 AS 号的 AS，那么这个 AS 将不再接受该路由。IOS 提供了配置选项 bgp enforce-first-as，允许网络运营商创建一定的规则：不接受邻居 AS 发送的路由，除非 AS_PATH 上的最后一个 ASN 是该邻居的 ASN。如果邻居在宣告路由上附加的 ASN 不是自己的 ASN，那么该配置选项就会导致这些路由被拒绝。</p>
<p>AS_PATH 附加操作通常是一种反复试验操作，将不同数量的 ASN 附加到 AS_PATH 中可能会产生不同的结果。如果网络为其它自治系统提供穿透服务，那么可以利用 IOS 语句 bgp maxas-limit 来部署设置 AS_PATH 最大长度的路由策略。</p>
<h3 id="案例研究：管理距离与后门路由"><a href="#案例研究：管理距离与后门路由" class="headerlink" title="案例研究：管理距离与后门路由"></a>案例研究：管理距离与后门路由</h3><p>IOS 提供的另一种在单台路由器上控制路由优先级的专用工具就是管理距离。管理权重的作用是影响学自不同 BGP 对等体但去往相同目的端的多条路由的优先级，而管理距离的作用是影响学自不同路由协议但去往相同目的端的多条路由的优先级。也就是说，管理权重的控制效果体现在 BGP 表中，而管理距离的控制效果体现在 IP 路由表中。Cisco 的默认管理距离如下：</p>
<img src="/fuchencong.github.io/2019/05/30/routing-tcp-ip-18/images/08.jpg" class="">

<p>通常根据学到指定路由的协议或源端为路由分配管理距离，距离越短，路由越优。EBGP 的默认管理距离为 20，小于所有 IGP 的管理距离。这一点对上面的实例网路似乎存在问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Zermatt 将 AS30 中的某个内部地址宣告给 Innsbruck，该地址通过 IXC 传递给 Cervinia，然后又传递给 Mortiz，然后又传递回 Moritz。由于 Moritz 是通过 EBGP 学到该路由的，因而将优选该路由去往目的地，次选 IGP 路由去往 AS 内的同一目的端（因为 IGP 路由的管理距离较大）。</span><br><span class="line">事实上，由于存在基本的 BGP 环路避免机制，因而根本不会出现上述情况。Moritz 在来自 Cervinia 的路由的 AS_PATH 中发现 ASN 30 之后，就会直接丢弃该路由。</span><br></pre></td></tr></table></figure>

<p>另一方面，IBGP 不会向 AS_PATH 添加 AS 号，因而学自 IGP 然后又被传递给 AS 内 IBGP 对等体的路由可能产生路由环路或黑洞路由。因此，将 IBGP 路由的管理距离设置为 200，高于所有 IGP 路由。对于去往同一目的端的路由来说，学自 IGP 的路由始终由于 IBGP 路由。</p>
<p>本地 BGP 路由指的是利用 BGP network 命令而源自本地路由器的路由。与 IBGP 路由一样，这些路由的默认管理距离也为 200，因而这些路由并不由于 IGP 路由。</p>
<p>如果希望更改 BGP 路由的默认管理距离，那么就需要使用 distance bgp 语句，该语句可以分别设置 EBGP、IBGP 和本地 BGP 路由的距离。通常是不需要更改所有 BGP 路由的默认距离。</p>
<p>network backdoor 语句与 network 语句的效果相同：将 EBGP 路由视为本地 BGP 路由，同时将管理距离更改为 200。区别在于 network backdoor 语句指定的地址不宣告给 EBGP 对等体。</p>
<h2 id="控制复杂的路由映射"><a href="#控制复杂的路由映射" class="headerlink" title="控制复杂的路由映射"></a>控制复杂的路由映射</h2><p>随着 BGP 路由策略复杂度的增加，经常碰到的一个特征就是路由策略的组件常常会出现大量重复。IOS 提供了响应的工具将策略配置中的重复部分或可重用部分配置成独立的对象，并提供了创建前往策略配置中其他部分的条件转移工具。结合 COMMUNITY 属性以及对等体组成对等体模板等归类工具，不但可以创建复杂的 BGP 路由策略，而且还能有效组织并控制这些路由策略。</p>
<h3 id="continue-子句"><a href="#continue-子句" class="headerlink" title="continue 子句"></a>continue 子句</h3><p>continue 子句允许创建去往路由映射中其他部分的条件转移，类似于编程语言中的 if-then-else。</p>
<p>正常情况下，路由映射是按照自上而下的顺序依次处理的，如果前缀匹配，那么就执行指定操作，路由映射的处理过程也就立即结束。如果前缀与给定序列不匹配，那么就进入下一个序列继续处理，直至找到匹配序列或者在路由映射的末尾执行默认动作。</p>
<p>利用 continue 子句，可以匹配前缀并执行相应的操作，此后不是停止处理，而是将该前缀发送给路由映射的其他部分执行后续处理。continue 子句特别适用于如下场景：存在很多不同的匹配条件，对每种匹配条件都定义了不同的 set 操作，而且还希望对不同的匹配前缀都执行相同的操作。</p>
<p>使用 show route-map 命令观察路由映射，该命令的好处在于不但能够以一种简单易读的形式显式构成路由映射每个序列的子句，而且还能显式每个序列相匹配的路由条数。这样就能快速解读路由映射以开展故障检测与排除操作，或者能够在修改路由映射之前清晰地解读路由映射。</p>
<h3 id="策略列表"><a href="#策略列表" class="headerlink" title="策略列表"></a>策略列表</h3><p>路由映射中的每个序列都被视为一条 if-then 语句：如果匹配条件，那么就执行该操作。可以将路由映射中的一串序列理解为通过 else 语句连在一起。路由映射是按照序列顺序依次执行的，除非使用 continue 子句直接跳转到路由映射的其他部分。如果路由映射序列中存在多条 match 或 set 子句，那么就可以视为一组部分 AND 条件：如果同时匹配了 A、B 和 C，那么就设置 X、Y 和 Z。</p>
<p>对于非常冗长的路由映射来说，匹配条件中重复出现相同的 match 语句是很平常的一件事情。策略列表可以提供这些可重用的匹配条件并放在一起，之后路由映射就可以应用这些策略列表，而不思重复这些匹配条件。策略列表的好处在于：</p>
<p>如果有多个共享的匹配子句，那么就可以在策略列表中输入这些匹配子句，然后再在相关的路由映射序列中引用这些策略列表，而不用每次都重复输入这些匹配子句<br>如果必须更改匹配子句集的部分内容，那么就可以在策略列表中一次性修改完成，而不用在整个路由映射中搜索需要需要修改的内容并修改匹配子句的每个实例<br>由于策略列表使用的是名称，因此很容易在冗长的路由映射中定位那些使用了共享匹配子句集的序列<br>使用 ip policy-map 语句即可配置策略列表。与路由映射相似，策略列表也通过任意名称进行标识并含有允许或拒绝语句。策略列表仅支持 match 子句，不支持 set 子句。</p>
<h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>本章深入讨论了在 BGP 网络中配置路由策略的大量可用工具。虽然 BGP 本身并不是一个特别复杂的协议，但其支持的路由策略却非常复杂，使得 BGP 网络也变得非常复杂，特别是服务提供商等大型转接 AS 的 BGP 网络尤为复杂。</p>
<p>随着 BGP 网络规模的增大，必须借助相应的工具来控制和扩展网络。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/Route/" rel="tag"># Route</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2019/07/02/network-multicast-address/" rel="prev" title="IP 组播地址">
      <i class="fa fa-chevron-left"></i> IP 组播地址
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2019/05/28/routing-tcp-ip-17/" rel="next" title="TCP/IP 路由技术 17：BGP 与 NLRI">
      TCP/IP 路由技术 17：BGP 与 NLRI <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AD%96%E7%95%A5%E4%B8%8E-BGP-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">1.</span> <span class="nav-text">策略与 BGP 数据库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IOS-BGP-%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.</span> <span class="nav-text">IOS BGP 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#InQ-%E5%92%8C-OutQ"><span class="nav-number">2.1.</span> <span class="nav-text">InQ 和 OutQ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IOS-BGP-%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.2.</span> <span class="nav-text">IOS BGP 进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NHT%E3%80%81Event-%E4%BB%A5%E5%8F%8A-Open-%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.3.</span> <span class="nav-text">NHT、Event 以及 Open 进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E7%89%88%E6%9C%AC"><span class="nav-number">2.4.</span> <span class="nav-text">表版本</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5%E5%8F%98%E6%9B%B4"><span class="nav-number">3.</span> <span class="nav-text">管理策略变更</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%85%E9%99%A4-BGP-%E4%BC%9A%E8%AF%9D"><span class="nav-number">3.1.</span> <span class="nav-text">清除 BGP 会话</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E9%87%8D%E9%85%8D"><span class="nav-number">3.2.</span> <span class="nav-text">软重配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E5%88%B7%E6%96%B0"><span class="nav-number">3.3.</span> <span class="nav-text">路由刷新</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E8%BF%87%E6%BB%A4%E6%8A%80%E6%9C%AF"><span class="nav-number">4.</span> <span class="nav-text">路由过滤技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-NLRI-%E8%BF%87%E6%BB%A4%E8%B7%AF%E7%94%B1"><span class="nav-number">4.1.</span> <span class="nav-text">通过 NLRI 过滤路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%88%86%E5%8F%91%E5%88%97%E8%A1%A8"><span class="nav-number">4.2.</span> <span class="nav-text">案例研究：使用分发列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%89%A9%E5%B1%95-ACL-%E7%9A%84%E8%B7%AF%E7%94%B1%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">4.3.</span> <span class="nav-text">使用扩展 ACL 的路由过滤器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%89%8D%E7%BC%80%E5%88%97%E8%A1%A8"><span class="nav-number">4.4.</span> <span class="nav-text">案例研究：使用前缀列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-AS-PATH"><span class="nav-number">4.5.</span> <span class="nav-text">使用 AS_PATH</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.6.</span> <span class="nav-text">正则表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%EF%BC%9A%E4%BD%BF%E7%94%A8-AS-PATH-%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">4.7.</span> <span class="nav-text">案例研究：使用 AS_PATH 过滤器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%EF%BC%9A%E5%88%A9%E7%94%A8%E8%B7%AF%E7%94%B1%E6%98%A0%E5%B0%84%E8%AE%BE%E7%BD%AE%E7%AD%96%E7%95%A5"><span class="nav-number">4.8.</span> <span class="nav-text">案例研究：利用路由映射设置策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E5%A4%84%E7%90%86"><span class="nav-number">4.9.</span> <span class="nav-text">过滤器处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%B1%E5%93%8D-BGP-%E5%86%B3%E7%AD%96%E8%BF%9B%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">影响 BGP 决策进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%EF%BC%9A%E6%9D%83%E9%87%8D%E7%AE%A1%E7%90%86"><span class="nav-number">5.1.</span> <span class="nav-text">案例研究：权重管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%EF%BC%9A%E4%BD%BF%E7%94%A8-LOCAL-PREF-%E5%B1%9E%E6%80%A7"><span class="nav-number">5.2.</span> <span class="nav-text">案例研究：使用 LOCAL_PREF 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%EF%BC%9A%E4%BD%BF%E7%94%A8-MULTI-EXIT-DISC-%E5%B1%9E%E6%80%A7"><span class="nav-number">5.3.</span> <span class="nav-text">案例研究：使用 MULTI_EXIT_DISC 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%EF%BC%9A%E9%99%84%E5%8A%A0-AS-PATH"><span class="nav-number">5.4.</span> <span class="nav-text">案例研究：附加 AS_PATH</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%EF%BC%9A%E7%AE%A1%E7%90%86%E8%B7%9D%E7%A6%BB%E4%B8%8E%E5%90%8E%E9%97%A8%E8%B7%AF%E7%94%B1"><span class="nav-number">5.5.</span> <span class="nav-text">案例研究：管理距离与后门路由</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%A4%8D%E6%9D%82%E7%9A%84%E8%B7%AF%E7%94%B1%E6%98%A0%E5%B0%84"><span class="nav-number">6.</span> <span class="nav-text">控制复杂的路由映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#continue-%E5%AD%90%E5%8F%A5"><span class="nav-number">6.1.</span> <span class="nav-text">continue 子句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%96%E7%95%A5%E5%88%97%E8%A1%A8"><span class="nav-number">6.2.</span> <span class="nav-text">策略列表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%95%E6%9C%9B"><span class="nav-number">7.</span> <span class="nav-text">展望</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">176</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
