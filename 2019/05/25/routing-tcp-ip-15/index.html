<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="如果所有网络都使用单一路由协议（如 OSPF 或 IS-IS），那么可以想象如今的互连网会是什么样子。如果每个子网地址均可见的情况下，将根本无法保证网络的稳定性。网络的安全性也将脆弱不堪，这是因为针对路由协议的攻击（甚至是一个不起眼的配置差错）都可能会导致整个互联网的瘫痪。此外，谁能管理这样的网络呢？如果在全世界范围内协调所有网络管理员开展协议升级或协议增强等繁琐的维护工作呢？">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP&#x2F;IP 路由技术 15：域间路由概念">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2019/05/25/routing-tcp-ip-15/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="如果所有网络都使用单一路由协议（如 OSPF 或 IS-IS），那么可以想象如今的互连网会是什么样子。如果每个子网地址均可见的情况下，将根本无法保证网络的稳定性。网络的安全性也将脆弱不堪，这是因为针对路由协议的攻击（甚至是一个不起眼的配置差错）都可能会导致整个互联网的瘫痪。此外，谁能管理这样的网络呢？如果在全世界范围内协调所有网络管理员开展协议升级或协议增强等繁琐的维护工作呢？">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2019/05/25/routing-tcp-ip-15/images/01.jpg">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2019/05/25/routing-tcp-ip-15/images/02.jpg">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2019/05/25/routing-tcp-ip-15/images/03.jpg">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2019/05/25/routing-tcp-ip-15/images/04.jpg">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2019/05/25/routing-tcp-ip-15/images/05.jpg">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2019/05/25/routing-tcp-ip-15/images/06.jpg">
<meta property="article:published_time" content="2019-05-25T06:00:01.000Z">
<meta property="article:modified_time" content="2024-04-10T06:30:53.675Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="Route">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fuchencong.github.io/fuchencong.github.io/2019/05/25/routing-tcp-ip-15/images/01.jpg">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2019/05/25/routing-tcp-ip-15/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>TCP/IP 路由技术 15：域间路由概念 | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2019/05/25/routing-tcp-ip-15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          TCP/IP 路由技术 15：域间路由概念
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-25 14:00:01" itemprop="dateCreated datePublished" datetime="2019-05-25T14:00:01+08:00">2019-05-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/Network/" itemprop="url" rel="index"><span itemprop="name">Network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>如果所有网络都使用单一路由协议（如 OSPF 或 IS-IS），那么可以想象如今的互连网会是什么样子。如果每个子网地址均可见的情况下，将根本无法保证网络的稳定性。网络的安全性也将脆弱不堪，这是因为针对路由协议的攻击（甚至是一个不起眼的配置差错）都可能会导致整个互联网的瘫痪。此外，谁能管理这样的网络呢？如果在全世界范围内协调所有网络管理员开展协议升级或协议增强等繁琐的维护工作呢？</p>
<span id="more"></span>

<p>人们尝试创建一种可扩展的方式来管理网络，最基本的思路就是创建称为 AS（Autonomous System，自治系统）的管理域（AS 定义了同一管理权限下的网络边界）以及可在这些管理域之间进行路由的协议（该路由协议对于管理域来说是外部路由协议）。</p>
<p>目前用于自治系统间的路由协议是 BGP（Border Gateway Protocol，边界网关协议）。</p>
<h2 id="早期域间路由协议：EGP"><a href="#早期域间路由协议：EGP" class="headerlink" title="早期域间路由协议：EGP"></a>早期域间路由协议：EGP</h2><p>EGP（Exterior Gateway Protocol，外部网关协议）目前已经完全废止，IOS 不再支持该协议。但是 EGP 可以帮助理解当初在设计可操作的域间（即 Inter-AS）路由协议的思路。EGP 的某些基本概念也沿用到了 BGP 上，而且 EGP 的某些功能还有助于理解 BGP 设计思路背后的一些概念。</p>
<h3 id="EGP-起源"><a href="#EGP-起源" class="headerlink" title="EGP 起源"></a>EGP 起源</h3><p>Rosen 在 RFC 827 中提出将 APRANET 从单一网络迁移到一个互相连接的、自治控制的网络系统。对于每个网络（称为 AS）来说，AS 的管理权限是完全开放的，可以任意选择本网的管理方式。事实上，自治系统的概念扩展了网络互连的范围，并增加了一个新的分级层次。只要有一个单一互联网络（由多个网络组成的一个网络），就有一个自治系统网络，每个自治系统本身就是一个互连网络。AS 需要通过自治系统号来加以标识。AS 号是一组 16 位比特数字，由负责分配 IP 地址的编制机构进行分配。与 IP 地址类似，AS 号也有一些用于私有用途的保留号，这些保留的 AS 号为 64512 - 65535。</p>
<p>对于每个 AS 的可选管理权限来说，最重要的就是可以任意选择网关所运行的路由协议。由于网关设备位于 AS 内部，因而它们运行的路由协议也称为 IGP（Interior Gateway Protocol，内部网关协议）。每个 AS 通过一个或多个外部网关与其他 AS 互连在一起，RFC 827 提出外部网关之间应该通过 EGP 协议来共享路由信息。虽然 EGP 是一种距离矢量协议，但它并不是一种路由协议，因为 EGP 没有在网络间选择最优路径的算法。更准确地来说，EGP 是一种通用语言，外部网关之间利用该语言来相互交互可达性信息。其中可达性信息是一个包含了主网地址（而不是子网）和网关的简单列表，通过该列表可以到达所有网络和网关。</p>
<h3 id="EGP-操作"><a href="#EGP-操作" class="headerlink" title="EGP 操作"></a>EGP 操作</h3><p>RFC 827 定义的是 EGP 版本 1，版本 2 对版本 1 做了少量修改，首次在 RFC 888 中提出，正式的 EGPv2 规范则由 RFC 904 定义。</p>
<h3 id="EGP-拓扑结构问题"><a href="#EGP-拓扑结构问题" class="headerlink" title="EGP 拓扑结构问题"></a>EGP 拓扑结构问题</h3><p>EGP 邻居（也称为对等体）之间需要交换 EGP 消息，如果邻居位于同一个 AS 之内，那么就称为内部邻居。如果邻居位于不同的自治系统之内，那么就称为外部邻居。EGP 没有邻居自动发现功能，需要用手工方式来配置邻居地址，邻居之间交换消息采用单播方式传送到手工配置的邻居地址。</p>
<p>由于不能将 EGP 消息传送到单个邻居之外，因此 RFC 888 建议将 EGP 消息的 TTL 设置为低值。但是，没有任何一种 EGP 功能需要 EGP 邻居共享同一条数据链路。由于 EGP 消息采用单播方式（而不是广播或多播方式）传送给邻居，因而可以穿越路由器边界。</p>
<p>EGP 网关既可以是核心网关，也可以是末梢网关。这两类网关都能接受来自其他自治系统的网络信息，但末梢网关只能发送自身 AS 中的网络信息，只有核心网关才能发送除自身 AS 之外的学自其他 AS 的网络信息。</p>
<p>为了理解 EGP 定义核心网关与末梢网关的原因，就必须了解 EGP 在架构方面的局限性。EGP 并不是一种路由协议，其更新信息仅列出了可达网络，并没有包含确定最短路径和防止路由环路的足够信息。因此建立起来的 EGP 拓扑结构必须不存在任何环路。</p>
<p>如下所示的 EGP 拓扑结构中只有一个核心 AS，其他自治系统（末梢自治系统）必须连接到该核心 AS 上。这种两级树状拓扑结构与 OSPF 中的两级拓扑结构需求非常相似，而且作用也完全相同。域间 OSPF 路由在本质上属于距离矢量路由，因而很容易形成路由环路。因此 OSPF 要求所有非主干 OSPF 域之间的流量都必须经过主干域。</p>
<img src="/fuchencong.github.io/2019/05/25/routing-tcp-ip-15/images/01.jpg" class="">

<p>利用这种强制性的无环路域间拓扑结构，可以大大降低路由环路的可能性。与此类似，要求末梢自治系统之间的所有 EGP 可达性信息都必须经过核心 AS，这样就能大大降低 EGP 拓扑结构潜在的路由环路可能性。</p>
<h3 id="EGP-功能"><a href="#EGP-功能" class="headerlink" title="EGP 功能"></a>EGP 功能</h3><p>EGP 包含以下 3 种协议机制：</p>
<ul>
<li>邻居获取协议（Neighbor Acquisition Protocol）</li>
<li>邻居可达性协议（Neighbor Reachability Protocol）</li>
<li>网络可达性协议（Network Reachability Protocol）</li>
</ul>
<p>这三种协议机制利用 10 类消息来建立邻居关系、维护邻居关系、与邻居交换网络可达性信息，并向邻居通告程序差错或格式差错。</p>
<h4 id="邻居获取协议"><a href="#邻居获取协议" class="headerlink" title="邻居获取协议"></a>邻居获取协议</h4><p>EGP 邻居在正常交换可达性信息之前，必须首先确认兼容性问题。该功能由一个简单的握手过程来完成，由其中的一个邻居发送 Neighbor Acquisition Request（邻居获取请求）消息，由另一个邻居响应 Neighbor Acquisition Confirm（邻居获取确认）消息。</p>
<p>在实际应用中，EGP 网关都是通过手工配置邻居的 IP 地址来获知其邻居的，此后网关就向手工配置的邻居发送单播 Neighbor Acquisition Request 消息，该消息包含了一个 Hello 间隔（即网关同意从邻居接受的两条 Hello 消息之间的最小间隔）和轮询间隔（即网关同意因路由器更新而被邻居轮询的最小间隔）。邻居的响应消息 Neighbor Acquisition Confirm 消息中也包含了其 Hello 间隔与轮询间隔。如果邻居双方就这两个间隔达成一致，那么就可以交换网络可达性信息了。</p>
<p>如果网关的响应消息不是 Neighbor Acquisition Confirm，而是 Neighbor Acquisition Refuse（邻居获取拒绝），那么就表示拒绝该邻居。网关也可以使用 Neighbor Cease（邻居终止）消息随时终止已经建立的邻居关系。邻居收到 Neighbor Cease 消息后，将回应 Neighbor Cease Acknowledgement（邻居终止确认）消息。</p>
<p>如果网关发送 Neighbor Acquisition Request 消息，而邻居无任何响应，RFC 888 建议以一个合理的速率来重传 Neighbor Acquisition Request 消息。另外，每条 EGP 消息都有一个序列号，该序列号可以标识 EGP 消息对。</p>
<p>两个 EGP 网关成为邻居之后，其中一个网关将成为主动邻居，另一个网关就成为被动邻居。始终由主动网关发送 Neighbor Acquisition Request 消息来发起邻居关系，被动网关从不发送该消息，它们仅对该消息进行响应。但是被动网关可以发起 Neighbor Cease 消息，此时主动网关必须回应 Neighbor Cease Acknowledgement 消息。</p>
<p>核心网关（可能是多个其他自治系统中的路由器的邻居）既可能是某个邻居邻接关系的主动网关，也可能是其他邻居邻接关系的被动网关。Cisco 的 EGP 实现利用 AS 来作为决定因素，即 AS 号小的邻居成为主动邻居。</p>
<h4 id="邻居可达性协议"><a href="#邻居可达性协议" class="headerlink" title="邻居可达性协议"></a>邻居可达性协议</h4><p>网关获取某个邻居之后，就会通过发送周期性的 Hello 消息来维护邻居关系，而邻居则以 I-H-U（I-Heard-You）消息作为 Hello 消息的回应。RFC 904 没有指定 Hello 消息的标准周期，Cisco 使用的默认周期为 60s。</p>
<p>交换完 Hello&#x2F;I-H-U 消息之后，邻居的状态就由 Down（停用）切换为 Up（启用）。如果主动邻居连续发了 3 条消息之后仍未收到响应消息，那么邻居的状态将被切换为 Down 状态。之后网关继续以正常的 Hello 间隔发送 3 条以上的 Hello 消息，如果仍未收到响应消息，那么邻居的状态将切换为 Cease 状态。网关然后以 60s 的间隔发送三条 Neighbor Cease 消息，如果邻居均回应 Neighbor Cease Acknowledgement 消息，那么该网关就将邻居的状态切换为 idle 状态，并等待 5min，之后在切回到 Acquire 状态，并尝试重新获取邻居。</p>
<p>对于处于被动模式下的核心网关，如果网关在 60s 的 Hello 时间间隔内未收到 Hello 消息，那么就会尝试唤醒邻居。由于被动模式下的网关无法发送 Hello 消息，因而发送 Poll（轮询）消息，此后网关将等待一个 Poll 间隔。如果网关未收到响应消息，那么将再次发送一条 Poll 消息，并且再等待一个 Poll 间隔。如果仍未收到响应消息，那么网关就将邻居的状态更改为 Down 状态，然后又立即更改为 Cease 状态。在发送三条 Cease 消息之后，邻居的状态将被更改为 Idle 状态。</p>
<h4 id="网络可达性协议"><a href="#网络可达性协议" class="headerlink" title="网络可达性协议"></a>网络可达性协议</h4><p>如果邻居的状态为 up，那么 EGP 邻居之间就可以相互交换可达性信息。每个网关都会周期性地向邻居发送包含了 序列号的 Poll（轮询）消息，邻居则以包含了相同序列号和可达网络列表的 Update 消息进行响应。</p>
<p>邻居间交换的每对 Hello&#x2F;I-H-U 消息中都包含了相同的序列号，直至发送 Poll 消息为止。Poll&#x2F;Update 消息对也使用相同的序列号。主动邻居每收到一次 update 消息，就将序列号加 1。两个邻居之间的 Poll 消息序列号相互独立，它们之间完全不同，而邻居总是以包含了与 Poll 消息中完全相同的序列号的 Update 消息作为响应消息。</p>
<p>通常来说，网关仅在被轮询时才发送 Update 消息，这就意味着拓扑结构的变化可能最长有 3 分钟时间无法向外部宣告。因而 EGP 解决这个问题的方式是允许网关在每个轮询间隔内发送一条主动提供的 Update 消息，但 IOS 不支持这种主动提供的 Update 消息。</p>
<p>Poll 和 Update 消息都包含源网络地址，源网络指的是通过该网络可以测量所有可达性信息，即通过连接在源网络上的路由器可以到达所有可达性信息，也就是说，连接在源网络上的路由器可以达到所有被请求或被宣告的网络。源网络通常就是与两个邻居都相连的网络。</p>
<p>在源网络地址之后是一台或多台路由器以及通过这些路由器可以到达的网络列表。列表上的路由器的共同特征是都连接在源网络上，如果列表上的路由器不是发起 update 消息的 EGP 网关，那么该路由器就是非直连或第三方邻居。虽然宣告非直达路由器能够节省公共链路带宽，但更重要的是，非直达邻居通过消除不必要的路由器跳数来提升路由效率。</p>
<p>EGP 的 Update 消息可以仅包含非直达邻居，也就是说，消息的发起方可能不将其作为通往其他网络的下一跳。此时将发起方称为路由服务器。路由服务器通过 IGP 或静态路由来学习可达性信息，并将这些可达性信息宣告给 EGP 邻居，而自身并不执行任何包转发功能。</p>
<p>从 EGP 网关的角度来看，邻居要么是内部网关，要么是外部网关。如果位于同一个 AS 中，那么邻居就是内部网关。如果位于不同的 AS 中，那么邻居就是外部网关。EGP 的 Update 消息包含了两个用来描述其列表中的路由器是内部网关还是外部网关的字段。只有核心网关的 Update 消息才包含外部网关信息。</p>
<p>EGP 的 Update 消息为每个列出的网络都关联一个距离值，距离字段为一个字节，因此取值范围为 0-255。RFC 904 并没有指定距离值的解析方式，而且也没有 RFC 定义任何利用该距离值来计算 AS 间最短路径的算法。IOS 将距离值理解为跳数，默认规则很简单：</p>
<ul>
<li>如果网关在 AS 内宣告所有网络，那么距离值为 0</li>
<li>如果网关在本 AS 之外宣告所有网络，那么距离值为 3</li>
<li>如果网关指示某网络不可达，那么将其距离设置为 255</li>
</ul>
<p>因此，从本质上来看，EGP 使用的距离值对于确定到指定网络的最佳路径毫无作用。</p>
<p>EGP 表项的管理距离为 140，该管理距离高于所有 IGP（外部 EIGRP 除外），因而即使 EGP 宣告的是同一个网络，路由器也总是选择 IGP 路由。</p>
<h3 id="EGP-的不足"><a href="#EGP-的不足" class="headerlink" title="EGP 的不足"></a>EGP 的不足</h3><p>EGP 的根本问题是无法检测路由环路，虽然 EGP 使用的距离值存在上限（255），而计数到无穷大也算是一种环路检测机制，但是高极限值加上轮询间隔，使得计数到无穷大变得毫无实用意义。因此 EGP 必须运行在一个设计良好的无环路拓扑结构上。</p>
<p>EGP 另一个重要不足就是无法与 IGP 进行足够的互操作，以确定从一个网络到另一个网络的最短路由。EGP 的其他不足之处还包括在大量网络之间传播信息时容易失败，而且还容易传播错误网络信息。</p>
<p>最后 EGP 无法及时宣告网络的变化情况，邻居获取进程慢，而且网络变化的宣告过程也缓慢不堪。</p>
<p>虽然人们试图创建 EGPv3，但毫无成效。最后 EGP 仍然被彻底废弃，取而代之的是全新的 AS 间协议：BGP。目前外部网关协议（EGP）不仅是一个协议的名称，而且还是一类协议的名称，所有衍生自 EGP 概念的协议都被称为 EGP。尽管如此，当今的自治系统以及 AS 间的路由当中仍然能够看到传统 EGP 的身影。</p>
<h2 id="BGP-的出现"><a href="#BGP-的出现" class="headerlink" title="BGP 的出现"></a>BGP 的出现</h2><p>由于 EGP 只是一种可达性协议，而不是一种真正的路由协议，因此针对 EGP 所做的大量增强性尝试都失败了。因此需要重新设计一个全新的域间协议：这将是一个真正的路由协议，能够精确区分去往同一个目的地的多条路由，能够避免出现环路，而且还能与 IGP 协作计算距离。</p>
<p>该 AS 间路由协议就是由 1989 年 RFC 1105 首次引入的 BGP。当前的 BGP 版本 BGP-4 是由 1995 年 RFC 1771 规定的，BGP-4 与前面的几个版本有显著区别，最重要的区别在于 BGP-4 属于无类别协议，而早期的版本属于有类别协议。出现这一根本性改变的源动力就是外部网关协议存在的根因：保持 Internet 路由的可管理性和可靠性。</p>
<p>目前运行的 BGP 几乎都毫无例外地是 BGP-4，因此现在谈论 BGP 的时候，指的就是 BGP-4。</p>
<h2 id="BGP-基础"><a href="#BGP-基础" class="headerlink" title="BGP 基础"></a>BGP 基础</h2><p>与 EGP 一样，BGP 也为每个 BGP 对等体建立唯一的、基于单播的连接。为了提高对等连接的可靠性，BGP 使用 TCP（端口号 179）作为底层传送机制。由于将确认、重传和序列化工作交由 TCP 层处理，因而 BGP 的会话维护以及更新机制也得到了大幅简化。由于 BGP 建立在 TCP 之上，因而需要为每个对等体都建立一条独立的点到点会话。此外，由于邻居之间的 MD5 认证也基于 TCP，因而 BGP 也得到了进一步简化。</p>
<p>BGP 是一种距离矢量协议，每个 BGP 节点都依赖于下游邻居从路由表中传递路由；BGP 节点基于它们所宣告的路由进行路由计算，并将计算结果传递给上游邻居。但是其他距离矢量协议都以单一数值来量化距离，而 BGP 却使用数据包到达特定目的地所要经过的自治系统列表（以 AS 号来表示）。由于该列表完全描述了数据包所要经过的路径，因而为了与其他传统距离矢量协议相区别，也将 BGP 称为路径矢量路由协议。与 BGP 路由相关联的 AS 号列表则被称为 AS_PATH。AS_PATH 是与每条路由相关联的路径属性之一。</p>
<p>虽然 BGP 依赖直接对等体来共享路由信息并成为路由分布式计算的一部分（与其他距离矢量协议相似），但 AS_PATH 列表提供的去往目的地的列表看起来更像是一种链路状态协议（与传统的距离矢量协议相比）。</p>
<p>之前讲过，EGP 不是一种真正的路由协议，因为它没有一个成熟的算法来计算最短路径，而且也无法检测路由环路。与此相反，AS_PATH 属性使得 BGP 在这两方面都同时满足了作为路由协议的要求。路由器在接收到路由更新后，如果在 AS_PATH 中发现了自己的本地 AS 号，那么路由器就知道出现了路由环路。</p>
<p>虽然 AS_PATH 给出了去往目的地的路径上的详细自治系统信息，但 BGP 并不显示每个 AS 中的详细拓扑信息。<strong>由于 BGP 看到的仅仅是一个自治系统树，而 IGP 看到的是 AS 内部的拓扑情况，因而可以说 BGP 比 IGP 看到的是更高层的 Internet 视图</strong>。由于该更高层次的视图与 IGP 看到的视图并不兼容，因此 IOS 维护了一个独立的路由表（Routing Information Database，路由信息库）以承载 BGP 路由。</p>
<p>使用 show ip bgp 显示典型的 BGP 路由表信息，其输出与命令 show ip route 显示的 AS 内部路由表有些不同，但其中的信息基本一致。BGP 路由表显示了目的网络、下一跳路由器以及用于选择最短路径的度量值，而 PATH 列则列出了每个网络的 AS_PATH 属性。</p>
<p>对于每个目的网络来说，表中列出了多个下一跳。与 AS 内部路由表仅列出当前在用路由不同，BGP RIB 列出了所有已知路径。标识 *&gt; 表示该路径是路由器当前使用的路由，该最短路径是拥有最短 AS_PATH 的路径。如果存在多条拥有等价路径的路由，那么路由器就必须具备相应的规则来确定最佳路径。如果去往特定目的端时存在多条并行等价路径，那么 IOS 的默认 BGP 实现将仅选择一条路径，这一点与其他 IP 路由协议不同，其他 IP 路由协议在默认情况下是在等价路径之间做负载均衡。</p>
<p>两个邻居在首次建立 BGP 对等连接时，会交换各自的全部 BGP 路由表，之后仅交换增量部分的更新，也就是说，仅当网络出现变化时才相互交换路由信息，并且仅交换变化信息。由于 BGP 并不使用周期性的路由更新机制，因而对等体之间必须交换 Keepalive，以维护该对等连接。IOS 的默认保持激活时间间隔为 60s，如果对等体在 3 个时间间隔内未收到保持的激活消息，那么该对等体宣告其邻居中断。</p>
<h2 id="自治系统类型"><a href="#自治系统类型" class="headerlink" title="自治系统类型"></a>自治系统类型</h2><p>与 IGP 相比，BGP 是从更高的层次上看待整个互联网络：IGP 关注的事是穿越一台路由器的跳数，而 BGP 关注的是穿越一个个自治系统的跳数。另外，与子网存在末梢（stub）子网与转接（transit）子网之分一样，自治系统也存在末梢 AS 与转接 AS 之分。</p>
<ul>
<li>末梢 AS 指的是源自该 AS 的所有数据包都要离开该 AS，而且进入该 AS 的所有数据包都拥有该 AS 内的目的地址</li>
<li>转接 AS 指的是进入该 AS 的数据包至少有部分数据包拥有该 AS 之外的目的地址，并且需要根据这些目的地址将这些数据包转发给其他 AS</li>
</ul>
<p>一般来说，路由进出末梢 AS 都非常简单，相应的末梢 AS 的 BGP 配置也很简单。事实上，很多时候甚至不需要 BGP。BGP 的实际作用只有在配置转接自治系统时才能真正体现，BGP 可以拥有多个转接自治系统。虽然 BGP 协议本身比较简单（比 EIGRP、OSPF 或 IS-IS 简单得多），但每条路由都关联了大量路径属性，因而可以通过一组强大的策略工具来控制这些路由。有了路径属性以及利用这些路径属性的工具之后，就可以灵活地配置路径策略。路径策略指的是对路由施加某种优先规则，从而改变路由的默认行为。</p>
<p>由于 BGP 支持多地址簇，因而 BGP 不仅仅是一种单播 IP 路由协议，而且是支撑大量 IP 网络服务的基础协议，这些网络服务不但可以跨越转接自治系统，而且还可以延伸到末梢自治系统中。为 BGP 提供这些增强能力的机制就是 MP-BGP（Multiprotocol BGP）。</p>
<h2 id="EBGP-与-IBGP"><a href="#EBGP-与-IBGP" class="headerlink" title="EBGP 与 IBGP"></a>EBGP 与 IBGP</h2><p>EGP 协议引入了内部邻居与外部邻居的概念，也就是说，如果 EGP 进程与本 AS 内的邻居建立对等关系，那么该邻居就是内部邻居，如果该邻居位于其他 AS 中，那么就是外部邻居。</p>
<p>BGP 也使用相同的概念，如果 BGP 会话是在不同自治系统内的两个邻居之间建立的，那么该会话就是 EBGP（External BGP，外部 BGP）会话，如果 BGP 会话是在同一个自治系统内的两个邻居之间建立的，那么该会话就是 IBGP（Internal BGP，内部 BGP）会话。如下所示：</p>
<img src="/fuchencong.github.io/2019/05/25/routing-tcp-ip-15/images/02.jpg" class="">

<p><strong>由于每个 AS 通常都拥有多台路由器，因而在 AS 内部通过 BGP 宣告信息时始终都要用到 IBGP</strong>。从习惯来说，IBGP 会话通常与转接 AS 相关联，末梢 AS 一般仅在一台或多台边界路由器上运行 EBGP，并通过 IGP 路由传送&#x2F;接收边界路由器的数据包。但是随着越来越多的服务（如基于 MPLS 的 VPN 以及 IP 多播）需要用到 MP-BGP，末梢 AS 也逐渐出现了 IBGP。</p>
<p>之前讲过，BGP 不仅将 AS_PATH 用作 AS 的跳数度量，而且还可以利用 AS_PATH 来避免环路。如果路由器发现自己的 AS 号位于 AS_PATH 列表中，那么就丢弃该路由，但是这也给 IBGP 带来一些问题。如果 AS 内的路由器在传递路由时都将自己的 AS 号添加到 PATH 列表中，则 AS_PATH 列表将无法真实地表达 AS 间的路径长度，而且 AS_PATH 的环路避免功能要求路由器在看到自己的 AS 号位于 AS_PATH 列表之后，就认为出现了环路并丢弃该路由。</p>
<p>为了解决上述问题，IBGP 规定了如下特殊规则：</p>
<ul>
<li>仅当路由器将路由发送给 EBGP 邻居时，才将自己的 AS 号添加到该路由的 AS_PATH 中。如果发送给 IBGP 邻居，那么就不向 AS_PATH 添加自己的 AS 号</li>
</ul>
<p>但是这也有其他问题，检测 AS_PATH 列表中的 AS 号是 BGP 检测与避免路由环路的方法，但 AS_PATH 对于单个 AS 范围来说毫无意义，因此如果在 AS 内部出现了路由环路，该如何避免？为了解决这个问题，还必须重新审视 EGP。由于 EGP 没有环路避免机制，因而唯一的解决方案是确保一个无环路拓扑结构。这一点也是 OSPF 和 IS-IS 采用层次化区域拓扑结构的原因所在。由于 SPF 树（是链路状态协议发现环路的手段）不会跨越区域边界，因而能够实现区域间无环路拓扑结构。</p>
<p>这种方法也是解决 IBGP 路由环路问题的解决方案：确保 IBGP 对等会话不出现环路的条件就是构建无环路拓扑结构。该解决方案的一个关键点就是 BGP 会话运行在 TCP 之上，TCP 是一种单播点到点（可以在一定程度上避免潜在的环路风险），而且不会要求 BGP 会话双方物理相连。但是这也无法完全解决 IBGP 的所有问题，在如下网络中，通过 EBGP 和 IBGP 会话传送去往前缀 A 的路由，RTR3 的路由表显示 RTR1 是去往前缀 A 的下一跳，并且 RTR2 是去往 RTR1 的下一跳，但是 RTR2 没有去往前缀 A 的路由表项，所以数据包在经 RTR3 传送到 RTR2 后，RTR2 将丢弃该数据包。</p>
<img src="/fuchencong.github.io/2019/05/25/routing-tcp-ip-15/images/03.jpg" class="">

<p>该网络虽然实现了无环路路由交换，但是并没有共享该数据包将要使用的足够的实际路径信息，因而无法成功转发该数据包。因此建立 IBGP 会话时必须考虑以下两个层面的信息：</p>
<ul>
<li>有关被宣告前缀的下一跳信息</li>
<li>有关该前缀下一跳地址的下一跳信息</li>
</ul>
<p>查找去往数据包目的地的路由时，如果下一跳地址并不直接相连，那么就需要再次执行路由查询，以找到去往下一跳地址的路由。由于 IGP 都是逐跳路由，因而递归查询对于 IGP 来说没有问题，但是对于 IBGP 来说却是一个问题。对于数据包将要经过的路径上的所有路由器来说，它们的路由表必须拥有足够的信息，必须知道如何转发该数据包。</p>
<p>一种解决方法是将所有学自 EBGP 邻居的路由重新分发到 IGP 中，但是其存在以下两个问题：</p>
<ul>
<li>由于 BGP 的假设之一就是外部对等体不在自己的信任域内，因而与接受来自 IGP 或 IBGP 对等体的路由信息相比，在接受来自外部对等体的路由信息时必须制定更加谨慎的规则。毫无章法地将外部路由扔到 IGP 数据库中会带来严重的安全及稳定性威胁</li>
<li>一般来说，从外部 BGP 对等体收到的路由信息要么是全球 Internet 路由表或其中的一大部分，要么就是其他的大量路由集。而 IGP 的性能与路由信息库的大小成反比，路由条目过多将会导致 IGP 消耗路由器的大部分或全部处理能力，使得路由器的可用性急剧下降。</li>
</ul>
<p><strong>经实践证明，大多数场合下的最佳实践就是让 BGP 将学到的路由保持在 BGP 中，如果必须将这些路由分发给 AS中的路由器，那么就通过 IBGP 来分发这些路由。通过 IBGP 有效分发路由的实践方式要求单个 AS 内的所有 BGP 路由器之间必须建立全网状的 IBGP 会话。虽然为了解决扩展性问题，还需要对这种实践方式做一些调整</strong>。</p>
<p>但是这也带来了环路避免问题，大多数自治系统的实际内部结构非常复杂，BGP 逻辑拓扑结构与自治系统的物理拓扑结构可以非常不同，虽然每个 EBGP 会话与外部物理链路一致，但全网状的 IBGP 会话却显得非常复杂。每个 IBGP 会话都必须穿越某些物理链路。</p>
<p>为了避免复杂拓扑结构中的 BGP 路由环路问题，需要再增加一条 IBGP 规则：</p>
<ul>
<li>始终不要将学自内部邻居的路由发送给其他内部邻居</li>
</ul>
<p>建立 IBGP 全网状连接的目的是确保 AS 内的所有路由器都拥有将数据包转发到下一跳的路由信息。而 IBGP 会话可以确保任意一台路由器在学到来自外部邻居的路由之后，都能将该路由信息转发给 AS 内的所有路由器。任何一台路由器都不用再将该路由信息转发给 AS 内的其他路由器，此外，如果没有将学自内部邻居的路由信息传送给其他内部邻居，那么也就不会存在任何路由环路。</p>
<h2 id="多归属"><a href="#多归属" class="headerlink" title="多归属"></a>多归属</h2><p>拥有多条外部连接的 AS 就是多归属 AS，根据定义，数据包穿越 AS 时，转接 AS 必须是多归属 AS。下面将详细介绍各种 AS 类型的多归属情况：</p>
<h3 id="转接-AS-多归属"><a href="#转接-AS-多归属" class="headerlink" title="转接 AS 多归属"></a>转接 AS 多归属</h3><p>转接 AS 通常是服务提供商网络（负责将 Internet 连接或语音及视频服务传送给其连接的客户）或运营商网络（专门为较小的服务提供商网络提供地理覆盖广阔的骨干网）。但是转接 AS 也可能是大型商业、政府或教育结构的骨干网。</p>
<p>转接网络通常存在以下三类外部连接：</p>
<ul>
<li>用户对等互联：发起或终结流量并通过转接 AS 到达连接在该 AS 上其他用户网络或者到达连接在其他 AS 上的用户网络的网络</li>
<li>专用对等互联：如果两个或多个服务提供商同意共享路由信息，那么就可以达成对等协议。对等协议可以在两个服务商之间达成（称为双边对等协议），也可以在一群规模相似的提供商之间达成（称为多边对等协议）。确定对等协议费用问题的一个重要因素就是流量模型。如果对等双方的流量在双向上基本均衡，那么通常就不需要相互支付费用（称为免结算对等互联或免费对等互联）。如果两个方向的流量差异明显，某个方向上流量明显大于另一个方向，那么较小的服务提供商通常就需要支付一定的对等互联费用，来获得访问较大服务提供商的客户群或更多连接的权利。最典型的情况就是区域性 ISP 连接到国家级 ISP 或全球 ISP。</li>
<li>公共对等互联：这类对等互联位于专门建立的用于这类对等互联的 IXP（Internet Exchange Point，互连网交换中心）。公共对等互联一般都是免费的，虽然以前互相连接的对等体之间一般都在 IXP 中使用以太网或 FDDI 连接，但目前绝大多数 IXP 都开始使用以太网交换机或 VPLS（Virtual Private Lan Service，虚拟专用 LAN 服务）进行互联</li>
</ul>
<h3 id="末梢-AS-多归属"><a href="#末梢-AS-多归属" class="headerlink" title="末梢 AS 多归属"></a>末梢 AS 多归属</h3><p>虽然转接 AS 具备多归属特性是显而易见的（否则也不能称为转接 AS），但多归属特性对于末梢 AS 也是非常普遍的。如果末梢 AS 小到不需要多归属，也就是说仅通过单条链路连接更高级的 AS，那么一般也不需要部署 BGP，此时在连接的两端部署静态路由，不但配置简单，而且管理也更安全。通过静态路由的方式能够严格控制在每个 AS 中宣告的其他 AS 的哪些信息，而不存在通过管理边界意外泄露非期望前缀的风险。</p>
<p>末梢 AS 采取多归属方式的主要理由如下：</p>
<ul>
<li>为链路或接口故障导致的接入中断提供冗余</li>
<li>为路由器故障导致的接入中断提供冗余</li>
<li>为 ISP 故障导致的接入中断提供冗余</li>
<li>为地域范围广阔的自治系统提供本地连接性</li>
<li>独立于提供商</li>
<li>企业或外部策略</li>
<li>负载均衡</li>
</ul>
<p>多归属还能为地域范围广阔的 AS 提供本地 Internet 连接性。如下所示的末梢 AS，该 AS 不再是单个 ISP 对等互联点，而是在全国范围内分布了 5 个对等互联点，源自国内任意位置的数据包都被路由到距离源端最近的 Internet 对等互联点（最近的出口点）。</p>
<img src="/fuchencong.github.io/2019/05/25/routing-tcp-ip-15/images/04.jpg" class="">

<p>在该网络中，EBGP 的对等体可能位于同一个 AS 中，即去往同一个 ISP，也可能每个对等体均去往不同的 ISP 以实现 ISP 的冗余性。大多数真实的网络环境可能是这两种情况的混合体。多归属到多个 ISP 不仅能够提供 ISP 冗余能力，保护自己的网络免受单一提供商系统范围故障而导致的网络中断，而且还能实现提供商的独立性。与多个 ISP 建立对等互联还存在一定的成本优势。</p>
<p>如果需要执行 AUP（Acceptable Use Policies，许可使用策略）或企业策略，要求某些流量必须使用某个转接 AS，其他流量必须使用另一个转接网络，那么也需要部署多归属机制。与转接 AS 提供商需要具备相应的工具及方法来更改默认路由行为以满足不同对等互联的需求一样，多归属末梢 AS 的提供商也需要具备相应的工具及方法，避免自己的网络被所连接的 AS 无意间用作转接网络，或者为所连接的 ISP 施加不同的优先级，或者实现所需的 AUP，这些就是路由策略所要完成的任务。</p>
<h3 id="多归属与路由策略"><a href="#多归属与路由策略" class="headerlink" title="多归属与路由策略"></a>多归属与路由策略</h3><p>与 IGP 相比，BGP 尤其适合部署路由策略，这是因为 BGP 提供了一组被称为路径属性的特性。可以利用策略工具来添加、更改或删除这些路径属性，从而影响各种不同的路由行为。</p>
<h3 id="多归属面临的问题：负载共享与负载均衡"><a href="#多归属面临的问题：负载共享与负载均衡" class="headerlink" title="多归属面临的问题：负载共享与负载均衡"></a>多归属面临的问题：负载共享与负载均衡</h3><p>多归属的主要好处是能够提供冗余性、实现路径的多样化并增加对外部对等体的带宽。如果部署多归属的主要目标是提供更多的带宽（一般是在两台路由器之间捆绑多条链路），而且每条链路的带宽都相同，那么就可以在被捆绑的所有链路中完全均等地共享这些流量负载。</p>
<p>如果多归属的主要目的是提供冗余性，那么任意一条链路的负载都必须低于冗余链路所承载的全部流量。此时，当其中一条链路出现故障导致需要将其正常流量重路由到另一条链路上时，该正常链路将能处理全部负载。</p>
<p>需要注意的是，负载共享与负载均衡并不相同，负载均衡指的是打着有效利用带宽的名义，在多有外部链路上竭力维持完全相同的负载比例。当然这也并不是说无法通过控制路由优先级的方式在所有外部链路上实现流量的完全均分，但问题是为了实现负载均衡而强制让某些流量使用次优路由的话，很可能会劣化 Internet 的接入性能。</p>
<p>多归属的主要目的是提高冗余性并提升路由效率，而不是实现负载均衡。</p>
<h3 id="多归属面临的问题：流量控制"><a href="#多归属面临的问题：流量控制" class="headerlink" title="多归属面临的问题：流量控制"></a>多归属面临的问题：流量控制</h3><p>多归属可能会导致去往相同目的端且来自相同源端的流量使用不同的路径进入和离开 AS（因而很难预测）。这种路径多样性在外部链路都比较近的情况下没有什么问题，但是随着外部链路的距离越来越远，相应的潜在问题也就越来越突出。</p>
<p>如果边界路由器将默认路由宣告到本 AS 中，内部路由器在找不到明细路由时将选择该默认路由。由于 AS 内的路由器没有关于其路由域外部目的端的明细路由或者不知道目的端的实际距离，它们唯一的路由选择标准就是宣告默认路由的最近的路由器。</p>
<p>出现不对称流量的主要问题如下：</p>
<ul>
<li>网络流量模型变得不可预测，使得网络基线、容量规划以及故障检测与排除都变得非常困难</li>
<li>链路利用率不均衡，某些链路的带宽严重饱和，而其他链路则过分轻载</li>
<li>出站流量和入站流量在延迟时间上存在显著的差异，而这种时延变化会对某些时延敏感型应用带来不利影响</li>
</ul>
<p>BGP 可以解决这类不对称路由问题，边界路由器都与各自的 ISP 对等体建立 EBGP 会话，那么它们就能学到去往目的端的路由，此后如果源端路由器学习到了这两条路由，那么就能确定去往目的端的最短路径，这样一来，源端和目的端的流量模型就对称了。</p>
<p>BGP 不仅仅能够提供做出更优路由选择的手段，而且其策略能力还能让用户根据自己的需要定义一条 更佳路由（这条路由并不在路由协议默认定义的范围之内）。</p>
<h3 id="多归属面临的问题：PA-地址"><a href="#多归属面临的问题：PA-地址" class="headerlink" title="多归属面临的问题：PA 地址"></a>多归属面临的问题：PA 地址</h3><p>较小的组织机构连接到 ISP 网络上时，一般都会向 ISP 申请 IP 地址空间，ISP 分配的地址空间源自 ISP 的大地址池。通常采用这种方式分配给终端用户的地址称为 PA（Provider Assigned or Provider-Aggregatable，提供商分配的或提供商）地址。</p>
<p>如果作为终端用户的组织机构多归属到多个 ISP，并且该组织机构拥有其中某个提供商分配的 PA 地址空间，那么宣告该地址空间以正确路由到入站数据包就会存在一定的问题。要想完全理解这个问题，必须首先理解 ISP 获得地址块的方式以及 ISP 向用户分配其地址块的方式。接下来将先介绍 CIDR，之后再详细解释该问题。</p>
<h2 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h2><p>虽然自治系统以及外部网关协议的发明解决了 20 世纪 80 年代出现的 Internet 扩展性问题，但是随后 Internet 又出现了了一些新的扩展性问题：</p>
<ul>
<li>B 类地址空间耗尽</li>
<li>Internet 路由表爆炸</li>
<li>整个 32 比特 IPv4 地址空间的最终耗尽</li>
</ul>
<p>为了解决上述问题，当时开发了 CIDR 和 NAT 这两个短期解决方案，而长期解决方案则是创造新的 IP 版本，为可预见的未来提供足够的地址空间，即现在的 IPv6。CIDR 和 NAT 都取得了巨大的成功，所以现在人们很少再像当初那样希望将网络迁移到 IPv6。</p>
<p>CIDR 只是一种利用 Internet 分层架构的地址汇总方案，利用有类别的地址分配方式强行增加人为的边界。</p>
<h3 id="汇总概述"><a href="#汇总概述" class="headerlink" title="汇总概述"></a>汇总概述</h3><p>汇总或路由聚合指的是用一个较不精确的地址来宣告一组连续的地址。汇总&#x2F;路由聚合的本质就是减小子网掩码的长度直至屏蔽所有被汇总地址的公共比特。汇总地址的关键特性就是掩码长度短于其所汇总地址的掩码长度。最极端的汇总地址是默认地址 0.0.0.0&#x2F;0，此时掩码已缩减至无任何网络比特，默认地址就是所有的 IP 地址的聚合地址。</p>
<p>汇总操作还可以跨越地址的类别边界。因此，为了支持主类网络地址的聚合操作，整个路由环境都必须是无类别的。</p>
<h3 id="无类别路由"><a href="#无类别路由" class="headerlink" title="无类别路由"></a>无类别路由</h3><p>无类别路由主要包括以下两个方面：</p>
<ul>
<li>无类别可以是路由协议的特性</li>
<li>无类别可以是路由器的特性</li>
</ul>
<p>当今的网络已不再使用 有类别 IP 路由协议（包括 RIPv1，IGRP 以及 BGP-4 之前的 BGP 版本）。有类别路由也不再是当今绝大多数路由器的默认选项，IOS 从 11.3 开始就将无类别路由作为默认选项。</p>
<p>作为路由信息的一部分，无类别路由协议携带了每个被宣告地址的网络部分的描述信息，通常将网络地址的网络部分称为地址前缀。描述地址前缀时，既可以包含一个地址掩码，也可以仅包含前缀比特数。常见的无类别 IP 路由协议包括 RIP-2，EIGRP，OSPF，集成 IS-IS 以及 BGP-4。</p>
<p>有类别路由器在路由表中将目的地址记录为主类网络以及这些网络的子网，在执行路由查找时，有类别路由器首先查找主类网络地址，接着再在主类网络地址下的子网列表中查找匹配项，如果没有找到匹配项，那么就会丢弃数据包，即便存在像默认路由一样的路由。汇总与地址聚合技术对于现代网络设计中的 CIDR 以及扩展性来说必不可少，但对于有类别网络环境来说却是一个问题。</p>
<p>无类别路由器会忽略地址类别，并在路由表中为所有前缀查找最长匹配的目的地址。即对于任何给定的目的地址来说，无类别路由器都会选择匹配了最多地址比特的路由。</p>
<h3 id="汇总：好处、坏处及不对称流量"><a href="#汇总：好处、坏处及不对称流量" class="headerlink" title="汇总：好处、坏处及不对称流量"></a>汇总：好处、坏处及不对称流量</h3><p>汇总是一种节省网络资源的有效工具，可以节约包括存储路由表所需要的内存容量、网络带宽以及路由器传送和处理路由信息的能力在内的各种资源。此外，汇总还能通过隐藏网络的不稳定性来有效节约网络资源。</p>
<p>假设网络中存在一条翻动路由（flapping route），所谓翻动路由指的是由于物理连接或路由器接口故障而出现不停 Up&#x2F;Down 的路由。如果没有汇总机制，那么每次子网出现 Up&#x2F;Down 的时候，都需要将该路由翻动信息传给外部路由器。而如果通告的是单个聚合地址，那么无论哪个明细子网出现了变化，路由器也不会宣告这些变化信息。</p>
<p>汇总的代价就是牺牲了路由的精确性，失去路由精确性的网络可能会产生一些不同的问题，例如出现两个子网之间的流量不对称问题。但是与汇总带来的好处相比，不对称流量可能是一个值得付出的代价。与网络设计中的大量选项相似，需要在汇总的正面效果与不对称流量的负面效果之间做出抉择。</p>
<h3 id="CIDR：延缓-B-类地址空间的耗尽速度"><a href="#CIDR：延缓-B-类地址空间的耗尽速度" class="headerlink" title="CIDR：延缓 B 类地址空间的耗尽速度"></a>CIDR：延缓 B 类地址空间的耗尽速度</h3><p>B 类地址空间耗尽的主要原因是 IPv4 地址的类别设计存在固有缺陷，一个 C 类地址可以提供 254 个主机地址，而一个 B 类地址却可以提供 65534 个主机地址，两者之间差距过于悬殊。有了 CIDR 后，只要申请合适子网掩码长度的地址块即可，这样就大大节省了传统地址分配浪费掉的主机地址。</p>
<p>CIDR 抛弃了 IPv4 最初采用的类别概念，CIDR 术语以前缀的长度来说明地址块的大小，前缀长度越短，地址块所包含的地址数就越多，最重要的是，CIDR 的前缀块之间不存在强制性的界限，完全可以包含 &#x2F;23、&#x2F;22、&#x2F;21 等地址块，直至为 &#x2F;0。采用 CIDR 技术分配地址块的效率更高，能够更好地满足实际需求，不会出现大量浪费现象。</p>
<h3 id="CIDR：降低路由表爆炸的风险"><a href="#CIDR：降低路由表爆炸的风险" class="headerlink" title="CIDR：降低路由表爆炸的风险"></a>CIDR：降低路由表爆炸的风险</h3><p>处理明细路由会给核心路由器带来不稳定影响，如果希望在 Internet 路由表中看到更长的前缀信息，那么就需要处理更多的 BGP 更新，从而跟踪更多相对无关紧要的状态变化情况。如果网络结构是层次化的（无论是层次化的 OSPF 区域还是层次化的自治系统）。</p>
<p>所有自治系统都是从单个 CIDR 前缀获得自己的地址空间，这样 AS 可以仅向 Internet 宣告该前缀，这样就能大幅缩减 Internet 路由表的规模。</p>
<p>很明显，向更高层级的网络域宣告单个汇总地址比宣告成百上千个地址要好的多，而且更重要的是，该方案还能极大地增强 Internet 的稳定性，如果低层级域中的网络状态出现了变化，那么该变化信息最多只会传播给第一个汇总点，而不会传播给更远的网络。</p>
<h3 id="管理和分配-IPv4-地址块"><a href="#管理和分配-IPv4-地址块" class="headerlink" title="管理和分配 IPv4 地址块"></a>管理和分配 IPv4 地址块</h3><p>在最高层级网络，IANA（Internet Assigned Numbers Authority，互连网数字分配机构）在 ICANN（Internet Corporation of Assigned Names and Numbers，互联网名称与数字地址分配机构）的管理下负责分配 IP 地址。最初的 IANA 是唯一的 IR（Internet Registry，互联网注册机构），也就是申请注册和分配 IP 地址、AS 号等资源的机构。</p>
<p>CIDR 出现后不久，在 IANA 下面创建了多个 RIR（Regional Internet Registries，区域性互联网注册机构），以便按照语言及当地习惯更好地为本地区提供服务。</p>
<p>IANA 根据预测需要以 8&#x2F; 的 CIDR 地址块为单位将 IPv4 地址分配给 RIR，由 RIR 将这些地址块的部分地址分配给 LIR（Local Internet Registeries，本地互联网注册机构）。LIR 通常是一些比较大的 ISP，最后再有这些 LIR 将地址块分配给最终客户。</p>
<p>RIR 的地址分配策略是为其 LIR 分配足够大的 IPv4 地址池，以满足这些 LIR 的 18 个月的地址需求。出现下列情形时，RIR 将会向 IANA 申请新的地址块：</p>
<ul>
<li>RIR 的可用地址池不足 50%</li>
<li>RIR 的可用地址池不足以满足 LIR 未来 9 个月的预测需求</li>
</ul>
<p>出现上述情形之一时，IANA 就会给 RIR 分配一个或多个新的 &#x2F;8 地址块，使得 RIR 的可用地址池能够满足未来 18 个月的分配需求。</p>
<p>RIR 在给 LIR 分配地址块时采用的都是慢启动策略，为了尽可能地节约 IPv4 地址，慢启动策略为初始分配定义了一个最小前缀长度，例如 APNIC 从 &#x2F;21 开始分配地址块。所有的 RIR 都要求申请方在申请新地址块之前，必须保证其已有地址的使用率达到 80%。与此相应，LIR 将地址块分配给用户时也鼓励它们使用相同的证明文档。此外，LIR 还鼓励用户尽可能地采用动态地址分配方式（DHCP），以节约有限的 IPv4 地址资源。</p>
<p>虽然所有的 RIR 在申请方提供了足够证明文件后，都会打破他们的慢启动大小规则，但最终分配的前缀长度不可能小于 &#x2F;19。</p>
<h3 id="CIDR-面临的问题：多归属与-PA-地址"><a href="#CIDR-面临的问题：多归属与-PA-地址" class="headerlink" title="CIDR 面临的问题：多归属与 PA 地址"></a>CIDR 面临的问题：多归属与 PA 地址</h3><p>现在继续分析之前提到过的多归属到多个服务提供商时存在的问题，如下所示，某个 AS 多归属到两个 ISP，ISP1 是 AS1 的 LIR，ISP1 从自己的 &#x2F;20 CIDR 地址块 198.133.176.0&#x2F;20 中给该 AS 分配一个前缀 198.133.180.0&#x2F;22。两个 ISP 都将自己的前缀上行宣告给 Internet，AS1 的前缀是 ISP1 宣告的聚合地址中的一部分。</p>
<img src="/fuchencong.github.io/2019/05/25/routing-tcp-ip-15/images/05.jpg" class="">

<p>如果两个 ISP 之外的其他设备向 AS1 中的目的端发送数据包，Internet 路由器将数据包的目的地址匹配为 ISP1 宣告的聚合地址，因而通过 ISP1 路由这些数据包。去往 AS1 中任意目的端的所有数据包（源自这两个 ISP 之外的源端）都将经由 ISP1 进行路由。从 ISP2 进入 AS1 的唯一入站流量就是源自 ISP2 或连接在 ISP2 上的客户的流量。</p>
<p>为了让来自 Internet 的数据包使用 ISP2，就必须让 IPS2 宣告 AS1 的前缀，但是这样做又有新的问题，从 Internet 上去往 AS1 的数据包都将匹配由 ISP2 宣告的明细前缀 198.133.180.0&#x2F;22，使得所有去往 AS1 的流量都将经由 ISP2。</p>
<p>解决这个问题的方法就是让 ISP1 在自己的 CIDR 地址块上打孔（通常称为地址泄露或去聚合），在宣告汇总前缀的同时还宣告明显前缀。这样一来，源自 Internet 的流量就可以通过两条路由进入 AS1，数据包也将经由最佳路径进行路由。</p>
<p>这种多归属实践方式不但违背了 CIDR 的初衷，即缩减路由表的规模并将网络的不稳定隐藏到聚合点之后，而且还给提供商以及 AS1 的用户带来了一些难处，之后继续讨论。</p>
<h3 id="CIDR-面临的问题：地址可携带性"><a href="#CIDR-面临的问题：地址可携带性" class="headerlink" title="CIDR 面临的问题：地址可携带性"></a>CIDR 面临的问题：地址可携带性</h3><p>ISP 通常不允许用户在迁移到新提供商之后保留其分配给用户的地址块，不但 ISP 不愿意放弃其地址空间的一部分，而且 RIR 也强烈建议用户在更换 ISP 时应该交回已分配的地址空间。</p>
<p>但是对于终端用户来说，重新编址会带来不同程度的困难。对于那些在自身路由域中使用私有地址空间、在网络边缘使用 NAT（Network Address Translation，网络地址转换）的用户来说，重新编址应该是最简单的，只更改面向公网的地址即可，对内部用户的影响最小。另一个极端的终端用户场景是为每个内部网络设备都静态分配了公网地址，此时这些用户不得不登录网络中的每台设备进行重新编址。</p>
<p>如果终端用户在整个网络域都使用了 CIDR 地址块，那么通过 DHCP 在一定程度上减轻重新编址所带来的痛苦。此时除了更改 DHCP 的地址范围并重启用户机器之外，只需要对那些静态分配了 IP 地址的网络设备进行重新编址即可。</p>
<p>重新编址的最大挑战就是变更安全配置，由于防火墙和路由器的访问列表都使用 IP 地址作为识别数据包的方式，因而重新配置这些安全设备将极为耗时且风险较大。另外，重新配置路由器的访问列表也是一件极具挑战的任务。</p>
<h3 id="CIDR-面临的问题：PI-地址"><a href="#CIDR-面临的问题：PI-地址" class="headerlink" title="CIDR 面临的问题：PI 地址"></a>CIDR 面临的问题：PI 地址</h3><p>对于上个例子中的多归属用户来说，解决方案之一就是获得 PI（Provider-Independent，与提供商独立的）地址空间，也就是说用户可以向 RIR 申请一个不属于 ISP1 或 ISP2 的 CIDR 地址块的独立地址块。这样 ISP1 和 ISP2 都能在不干扰自身地址空间的 情况下宣告该用户的地址块，PI 地址空间需要从 RIR 申请。</p>
<p>虽然很难申请 PI 地址空间，但路由的可靠性至少得到了增强。部分骨干网提供商为了有效加强聚合策略，从而控制 Internet 路由表的规模及稳定性，并设置相应的策略，以丢弃所有前缀大于 &#x2F;19 的路由更新，将前缀长度小于或等于 &#x2F;19 的前缀称为 全局可路由前缀。</p>
<h3 id="CIDR-面临的问题：流量工程"><a href="#CIDR-面临的问题：流量工程" class="headerlink" title="CIDR 面临的问题：流量工程"></a>CIDR 面临的问题：流量工程</h3><p>通过控制前缀宣告策略来引导入站流量穿越。如下所示，虽然 AS1 拥有 &#x2F;22 的 CIDR 地址块，但是却将该地址块宣告为 4 个独立的 &#x2F;24 前缀。这里没有显示这 4 条前缀宣告从 AS1 到 Internet 所用的详细路径信息，因为这些路径是随时可变的。AS1 将单个 &#x2F;22 前缀宣告成了 4 个 &#x2F;24 前缀，从而达到控制入站流量的目的。目的地址为 198.133.180.0&#x2F;22 的数据包将匹配这 4 个更长前缀中的某个前缀，并经由与学到的 &#x2F;24 前缀相匹配的路径路由到 AS1 中。</p>
<img src="/fuchencong.github.io/2019/05/25/routing-tcp-ip-15/images/06.jpg" class="">

<p>这类流量工程机制通常可以用于多场场合：</p>
<ul>
<li>在多条链路、多个入口点或多个上行提供商之间实现流量的负载均衡</li>
<li>让入站流量选择价格更低或利用率较低的内部链路</li>
<li>强制入站流量在距离目的端最近的对等互联点（而不是在距离源端最近的对等互联点）进入 AS，从而节约内部网络资源</li>
</ul>
<h3 id="CIDR-的问题解决之道"><a href="#CIDR-的问题解决之道" class="headerlink" title="CIDR 的问题解决之道"></a>CIDR 的问题解决之道</h3><p>发明 CIDR （以及 NAT 和动态编址技术）的目的是延缓 IPv4 可用地址的耗尽速度并缩减 Internet 路由表的增长速度，从而为 IPv6 的开发争取尽可能多的时间。而 CIDR 的确非常有效地延缓了 IPv4 地址的耗尽速度，CIDR 的另一个目标（延缓 Internet 路由表的增长速度）也得到了有效实现，但是多归属以及流量工程措施导致的去聚合以及长前缀泄露也使得该目标的后期效果一般。</p>
<p>CIDR 自 1993 年到 2000 年左右一直都在按照既定目标发挥作用，虽然此后的实际成效有效，但仍然发挥了重要的正面作用，而 CIDR（以及 NAT 和动态 IPv4 地址分配机制）的任务是为 IPv6 的发展和部署争取尽可能多的时间。</p>
<h3 id="IPv6-时代的到来"><a href="#IPv6-时代的到来" class="headerlink" title="IPv6 时代的到来"></a>IPv6 时代的到来</h3><p>由于 CIDR 以及其他权宜之计极为成功，以至于关注 IPv4 地址持续供给的呼声几乎销声匿迹，由于将依然是庞然大物的 IPv4 基础设施迁移到 IPv6 是一件非常困难的事情，因而在 CIDR 及 NAT 能够延长 IPv4 生命期的情况下，几乎没有人愿意开展这方面的工作。</p>
<p>最终，IPv6 的驱动力仍来自最初的目标：足够的 IP 地址。随着 CIDR 的效果越来越差以及 IPv4 地址分配速度的加快，网络运营商考虑的不再是商业场景或杀手级应用，而是持续扩展其 IP 网络及服务的能力。因而在采购标准方面将 IPv6 作为一个非常关键的要素，这使得设备商及应用开发者开始逐步投入更多的工程资源。</p>
<h3 id="再论-Internet-路由表爆炸"><a href="#再论-Internet-路由表爆炸" class="headerlink" title="再论 Internet 路由表爆炸"></a>再论 Internet 路由表爆炸</h3><p>虽然 IPv6 解决了可预见未来的 IP 地址可用性问题，但是并没有解决路由表爆炸问题，实际上，IPv6 可能会使路由表爆炸问题显得更为严峻。IPv4 地址的可用性限制以及 NAT 的使用需求从一定程度上限制了路由表的规模，而 IPv6 却会大规模拓宽该限制。</p>
<p>考虑到路由表爆炸问题已经日益严重，除了要开发有效解除该问题的长期解决方案之外，还必须在开发长期解决方案的同时，利用能够快速推广的短期解决方案缓解路由表爆炸的严重影响。虽然有关长期解决方案的研究工作刚刚开展，但必须包含基于新技术（如光交换）的路由器硬件和一种或多种替代 BGP 的协议。未来路由技术的可能发展趋势就是控制平面（智能）与 转发平面（性能）相分离，利用 MPLS（Multi-Protocol Label Switching，多协议标签交换技术）等技术将智能推送到网络边缘，并在网络中部署 SDN（Software Defined Networking），从而打破传统的在控制组件和转发组件之间的一对一通信方式。</p>
<p>目前正在讨论的另一种短期解决方案就是将 IP 地址的定位符（locator）功能与标识符（identifier）功能分开：</p>
<ul>
<li>定位符的作用是让路由器找到设备的位置，随着设备的移动，其定位符也会发生变化</li>
<li>标识符的作用是命名设备，无论设备身处何处，其标识符都保持不变</li>
</ul>
<p>将定位符功能与标识符功能分离之后，定位符就能更加灵活，也更具可聚合性，使得 Internet 路由表更加稳定。目前主要的定位符&#x2F;标识符分离方案如下：</p>
<ul>
<li>GSE（Global，Site，and End System Address Elements，全局、站点以及端系统地址要素），也称 8 + 8</li>
<li>Shim6（Level 3 Multihoming Shim Protocol，三级多归属垫片协议）</li>
<li>HIP（Host Identify Protocol，主机标识协议）</li>
<li>LISP（Locator&#x2F;ID Separation Protocol，定位符&#x2F;ID 分离协议）</li>
</ul>
<p>另一种短期解决方案能够宣告更长的前缀以满足多归属或流量工程的需要，但是其对宣告长前缀的路由在被 BGP 拒绝之前所能穿越的 AS 数量进行限制。这种 AS_PATHLIMIT BGP 路由属性是一种折中方案，既允许长前缀路由表项存在于靠近源端 AS 的位置，又限制这些长前缀的传播距离，以免影响路由选择。</p>
<h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>接下来将详细讨论 BGP 协议本身以及相应的配置及故障检测与排除内容。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/Route/" rel="tag"># Route</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2019/05/27/routing-tcp-ip-16/" rel="prev" title="TCP/IP 路由技术 16：BGP 简介">
      <i class="fa fa-chevron-left"></i> TCP/IP 路由技术 16：BGP 简介
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2019/05/23/routing-tcp-ip-14/" rel="next" title="TCP/IP 路由技术 14：路由映射">
      TCP/IP 路由技术 14：路由映射 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A9%E6%9C%9F%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%EF%BC%9AEGP"><span class="nav-number">1.</span> <span class="nav-text">早期域间路由协议：EGP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#EGP-%E8%B5%B7%E6%BA%90"><span class="nav-number">1.1.</span> <span class="nav-text">EGP 起源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EGP-%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.</span> <span class="nav-text">EGP 操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EGP-%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.3.</span> <span class="nav-text">EGP 拓扑结构问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EGP-%E5%8A%9F%E8%83%BD"><span class="nav-number">1.4.</span> <span class="nav-text">EGP 功能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%BB%E5%B1%85%E8%8E%B7%E5%8F%96%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.4.1.</span> <span class="nav-text">邻居获取协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%BB%E5%B1%85%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.4.2.</span> <span class="nav-text">邻居可达性协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.4.3.</span> <span class="nav-text">网络可达性协议</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EGP-%E7%9A%84%E4%B8%8D%E8%B6%B3"><span class="nav-number">1.5.</span> <span class="nav-text">EGP 的不足</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BGP-%E7%9A%84%E5%87%BA%E7%8E%B0"><span class="nav-number">2.</span> <span class="nav-text">BGP 的出现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BGP-%E5%9F%BA%E7%A1%80"><span class="nav-number">3.</span> <span class="nav-text">BGP 基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.</span> <span class="nav-text">自治系统类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EBGP-%E4%B8%8E-IBGP"><span class="nav-number">5.</span> <span class="nav-text">EBGP 与 IBGP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E5%BD%92%E5%B1%9E"><span class="nav-number">6.</span> <span class="nav-text">多归属</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E6%8E%A5-AS-%E5%A4%9A%E5%BD%92%E5%B1%9E"><span class="nav-number">6.1.</span> <span class="nav-text">转接 AS 多归属</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AB%E6%A2%A2-AS-%E5%A4%9A%E5%BD%92%E5%B1%9E"><span class="nav-number">6.2.</span> <span class="nav-text">末梢 AS 多归属</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%BD%92%E5%B1%9E%E4%B8%8E%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5"><span class="nav-number">6.3.</span> <span class="nav-text">多归属与路由策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%BD%92%E5%B1%9E%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A%E8%B4%9F%E8%BD%BD%E5%85%B1%E4%BA%AB%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">6.4.</span> <span class="nav-text">多归属面临的问题：负载共享与负载均衡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%BD%92%E5%B1%9E%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">6.5.</span> <span class="nav-text">多归属面临的问题：流量控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%BD%92%E5%B1%9E%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9APA-%E5%9C%B0%E5%9D%80"><span class="nav-number">6.6.</span> <span class="nav-text">多归属面临的问题：PA 地址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CIDR"><span class="nav-number">7.</span> <span class="nav-text">CIDR</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%87%E6%80%BB%E6%A6%82%E8%BF%B0"><span class="nav-number">7.1.</span> <span class="nav-text">汇总概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E7%B1%BB%E5%88%AB%E8%B7%AF%E7%94%B1"><span class="nav-number">7.2.</span> <span class="nav-text">无类别路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%87%E6%80%BB%EF%BC%9A%E5%A5%BD%E5%A4%84%E3%80%81%E5%9D%8F%E5%A4%84%E5%8F%8A%E4%B8%8D%E5%AF%B9%E7%A7%B0%E6%B5%81%E9%87%8F"><span class="nav-number">7.3.</span> <span class="nav-text">汇总：好处、坏处及不对称流量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CIDR%EF%BC%9A%E5%BB%B6%E7%BC%93-B-%E7%B1%BB%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E8%80%97%E5%B0%BD%E9%80%9F%E5%BA%A6"><span class="nav-number">7.4.</span> <span class="nav-text">CIDR：延缓 B 类地址空间的耗尽速度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CIDR%EF%BC%9A%E9%99%8D%E4%BD%8E%E8%B7%AF%E7%94%B1%E8%A1%A8%E7%88%86%E7%82%B8%E7%9A%84%E9%A3%8E%E9%99%A9"><span class="nav-number">7.5.</span> <span class="nav-text">CIDR：降低路由表爆炸的风险</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E5%92%8C%E5%88%86%E9%85%8D-IPv4-%E5%9C%B0%E5%9D%80%E5%9D%97"><span class="nav-number">7.6.</span> <span class="nav-text">管理和分配 IPv4 地址块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CIDR-%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A%E5%A4%9A%E5%BD%92%E5%B1%9E%E4%B8%8E-PA-%E5%9C%B0%E5%9D%80"><span class="nav-number">7.7.</span> <span class="nav-text">CIDR 面临的问题：多归属与 PA 地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CIDR-%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A%E5%9C%B0%E5%9D%80%E5%8F%AF%E6%90%BA%E5%B8%A6%E6%80%A7"><span class="nav-number">7.8.</span> <span class="nav-text">CIDR 面临的问题：地址可携带性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CIDR-%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9API-%E5%9C%B0%E5%9D%80"><span class="nav-number">7.9.</span> <span class="nav-text">CIDR 面临的问题：PI 地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CIDR-%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A%E6%B5%81%E9%87%8F%E5%B7%A5%E7%A8%8B"><span class="nav-number">7.10.</span> <span class="nav-text">CIDR 面临的问题：流量工程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CIDR-%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E4%B9%8B%E9%81%93"><span class="nav-number">7.11.</span> <span class="nav-text">CIDR 的问题解决之道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IPv6-%E6%97%B6%E4%BB%A3%E7%9A%84%E5%88%B0%E6%9D%A5"><span class="nav-number">7.12.</span> <span class="nav-text">IPv6 时代的到来</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%8D%E8%AE%BA-Internet-%E8%B7%AF%E7%94%B1%E8%A1%A8%E7%88%86%E7%82%B8"><span class="nav-number">7.13.</span> <span class="nav-text">再论 Internet 路由表爆炸</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%95%E6%9C%9B"><span class="nav-number">8.</span> <span class="nav-text">展望</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">171</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
