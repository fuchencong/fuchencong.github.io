<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/fuchencong.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/fuchencong.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/fuchencong.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/fuchencong.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/fuchencong.github.io/css/main.css">


<link rel="stylesheet" href="/fuchencong.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fuchencong.github.io","root":"/fuchencong.github.io/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="增强型内部网关路由选择协议（Enhanced Interior Gateway Routing Protocol，EIGRP）是在 Cisco IOS 9.21 版本中首次发布的，它是 Cisco 内部网关路由选择协议（Interior Gateway Routing protocol，IGRP）的增强版。和 IGRP 协议一样，EIGRP 协议依然是一个距离矢量协议，并且使用了 IGRP 协议所">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP&#x2F;IP 路由技术 07：增强型内部网关路由选择协议（EIGRP）">
<meta property="og:url" content="https://fuchencong.github.io/fuchencong.github.io/2019/05/12/routing-tcp-ip-07/index.html">
<meta property="og:site_name" content="fuchencong">
<meta property="og:description" content="增强型内部网关路由选择协议（Enhanced Interior Gateway Routing Protocol，EIGRP）是在 Cisco IOS 9.21 版本中首次发布的，它是 Cisco 内部网关路由选择协议（Interior Gateway Routing protocol，IGRP）的增强版。和 IGRP 协议一样，EIGRP 协议依然是一个距离矢量协议，并且使用了 IGRP 协议所">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2019/05/12/routing-tcp-ip-07/images/process.png">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2019/05/12/routing-tcp-ip-07/images/eigrp.png">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2019/05/12/routing-tcp-ip-07/images/dual.png">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2019/05/12/routing-tcp-ip-07/images/message.png">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2019/05/12/routing-tcp-ip-07/images/inner_tlv.png">
<meta property="og:image" content="https://fuchencong.github.io/fuchencong.github.io/2019/05/12/routing-tcp-ip-07/images/outter_tlv.png">
<meta property="article:published_time" content="2019-05-12T02:44:27.000Z">
<meta property="article:modified_time" content="2023-05-26T09:17:53.840Z">
<meta property="article:author" content="fuchencong">
<meta property="article:tag" content="Route">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fuchencong.github.io/fuchencong.github.io/2019/05/12/routing-tcp-ip-07/images/process.png">

<link rel="canonical" href="https://fuchencong.github.io/fuchencong.github.io/2019/05/12/routing-tcp-ip-07/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>TCP/IP 路由技术 07：增强型内部网关路由选择协议（EIGRP） | fuchencong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/fuchencong.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">fuchencong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The way I am</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/fuchencong.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/fuchencong.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/fuchencong.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/fuchencong.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/fuchencong.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fuchencong.github.io/fuchencong.github.io/2019/05/12/routing-tcp-ip-07/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/fuchencong.github.io/images/logo.jpeg">
      <meta itemprop="name" content="fuchencong">
      <meta itemprop="description" content="Having dreams is what makes life tolerable.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fuchencong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          TCP/IP 路由技术 07：增强型内部网关路由选择协议（EIGRP）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-12 10:44:27" itemprop="dateCreated datePublished" datetime="2019-05-12T10:44:27+08:00">2019-05-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/fuchencong.github.io/categories/Network/" itemprop="url" rel="index"><span itemprop="name">Network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>增强型内部网关路由选择协议（Enhanced Interior Gateway Routing Protocol，EIGRP）是在 Cisco IOS 9.21 版本中首次发布的，它是 Cisco 内部网关路由选择协议（Interior Gateway Routing protocol，IGRP）的增强版。和 IGRP 协议一样，EIGRP 协议依然是一个距离矢量协议，并且使用了 IGRP 协议所用的复合度量。</p>
<span id="more"></span>

<h2 id="EIGRP-的前身：IGRP-协议回顾"><a href="#EIGRP-的前身：IGRP-协议回顾" class="headerlink" title="EIGRP 的前身：IGRP 协议回顾"></a>EIGRP 的前身：IGRP 协议回顾</h2><p>20 世纪 80 年代中期，作为对 RIP 协议局限性的回应，Cisco 公司开发了 IGRP 协议，其中最重要的变化就是跳数的度量和 15 跳对网络路径大小的限制。IGRP 通过多种路由变量参数计算出一个复合型的度量，并提供一些 <code>旋钮</code> 供这些变量参数施以权重，以便反映和衡量网络的一些特征和需求。</p>
<p>IGRP 协议相对于 RIP 协议还有其他一些优点：</p>
<ul>
<li>非等价负载均衡</li>
<li>更新周期是 RIP 协议的 3 倍时间长</li>
<li>更新数据包格式更有效</li>
</ul>
<p>IRGP 协议和 EIGRP 协议的一个主要缺点是它们是 Cisco 公司的私有协议，因此只能在 Cisco 公司的产品平台上使用，而 RIP 协议则可以作为所有平台上的任何 IP 路由选择进程的一部分来使用。</p>
<p>从宏观角度来看，IGRP 协议继承了许多 RIP 协议的操作特点。IGRP 协议也是一个有类别距离矢量型协议，除了被水平分割法则抑制的路由外，IGRP 将不断周期性地向邻居路由器广播它的整张路由选择表。像 RIP 协议一样，路由器启动时，IGRP 在所有运行 IGRP 的接口上广播出一个请求数据包，并对收到的更新执行一个完整性检查，用来验证更新数据包的源地址是否和收到更新的那个子网属于同一个子网。新的带有可达路由度量值的路由更新条目将会被放置在路由表中，并且仅当它所带的度量值小于到达相同目的地址的原有路由条目的度量时，才能替代原有的路由条目。IGRP 协议同样使用带毒性反转的水平分割法则、触发更新和抑制计时器等手段来保证它的稳定性，同 RIP 协议一样，IGRP 协议也在网络边界上进行地址汇总。</p>
<p>与 RIP 协议不同的，IGRP 协议不使用 UDP 来访问数据包，它直接通过 IP 层的协议号 9 来进行数据包访问。</p>
<h3 id="进程域"><a href="#进程域" class="headerlink" title="进程域"></a>进程域</h3><p>IGRP 协议也使用进程域的概念，通过定义和跟踪多个进程域，可以把一个域内的通信和另一个域内的通信隔离开来。域间的流量可以通过路由重新分配和路由过滤来严密地控制。在如下的网络中，定义了两个自主系统（AS），每个自主系统都是一个路由选择域：在同一个共同的管理机构下运行的一个或多个 IGP 协议的路由器集合。它们通过外部网关协议来通信。</p>
<img src="/fuchencong.github.io/2019/05/12/routing-tcp-ip-07/images/process.png" class="">

<p>在自治系统 AS10 内，有两个 IGRP 进程域：IGRP 20 和 IGRP 30。在 IGRP 协议内，定义了两个自主系统号 20 和 30，就此处而言，这些数字是用来区分同一个路由选择域内的两个不同路由选择进程的。进程域 IGRP 20 和 IGRP 30 是通过和这两个进程域都相连的一台路由器进行通信的。这台路由器同时运行两个 IGRP 进程，并且在这两个进程之间自动地进行路由再分配。</p>
<p>在 IGRP 的路由更新消息中，IGRP 把路由条目分为 3 类：</p>
<ul>
<li>内部路由：到达某个主网络的子网络地址的路径。作为内部路由被通告的子网对于通告路由器和接收路由器共同相连的主网络来说是本地的</li>
<li>系统路由：是指到达在网络边界路由器上被汇总的网络地址的路径</li>
<li>外部路由：是指被标记成缺省网络（default network）的路径。对于缺省网络，路由器将直接发送所有的数据包而不对更具体的目标网络进行查找匹配</li>
</ul>
<p>如下展示了一个具体的例子：</p>
<img src="/fuchencong.github.io/2019/05/12/routing-tcp-ip-07/images/eigrp.png" class="">

<ul>
<li>路由器 LeHand 和 Tully 都与子网 192.168.2.64&#x2F;26 相连，所以主网络 192.168.2.0 被认为是这两台路由器共享的本地网络</li>
<li>而路由器 LeHand 还和子网 192.168.2.192&#x2F;26 相连，而该子网是 192.168.2.0 的另一个子网，因此路由器 LeHand 把子网 192.168.2.192&#x2F;26 作为内部路由通告给路由器 Tully</li>
<li>路由器 LeHand 和路由器 Thompson 相连的本地网络是 192.168.3.0。由于路由器 LeHand 是主网络 192.168.2.0 和 192.168.3.0 的边界路由器，因此网络 192.168.2.0 被定义为一条系统路由通告给 Thompson，同样的，网络 192.168.3.0 也被作为一条系统路由通告给路由器 Tully</li>
<li>网络 192.168.1.0 属于另一个自主系统，因而路由器 LeHand 把它作为一条缺省网络地址来通告，而 192.168.1.0 就被作为一条外部路由通告给路由器 Tully 和 Thompson</li>
</ul>
<h3 id="IGRP-的计时器和稳定性"><a href="#IGRP-的计时器和稳定性" class="headerlink" title="IGRP 的计时器和稳定性"></a>IGRP 的计时器和稳定性</h3><p>IGRP 协议的更新周期是 90s，为了防止更新计时器的同步，IGRP 针对每一个更新时间都减掉一个最大为 20% 的随机抖动变量。当一条路由器首次被用时，这条路由的无效计时器就会被设置成 270s，即为更新周期的 3 倍时间。垃圾收集计时器设置成 630s，即是更新周期的 7 倍。每次收到对应的路由更新消息后，这些计时器就会被重置。如果在收到路由更新消息之前，无效计时器超时，则这条路由就会被标记为不可达。但是在垃圾收集计时器超时前，该路由还会被保留在路由表中，并且作为不可达的路由通告出去。如果垃圾收集计时器超时，这条路由才会从表中删除。</p>
<p>由于 IGRP 使用了 90s 的更新计时器（RIP 为 30s），这意味这 IGRP 协议的周期性更新将比 RIP 协议占用更少的带宽，但是这也意味着 IGRP 协议比 RIP 协议的收敛更慢。</p>
<p>如果一条路由的目的地址变为不可达，或下一跳路由器增大了到达目的地址的度量以至于引起一个触发更新的话，那么这条路由将进入 280s 的抑制时间状态。直到抑制计时器超时之前，有关这个目的地址新的信息都不会被路由器接受。IGRP 协议的抑制特性可以用 <code>no metric holddown</code> 来禁止，在一个没有路由环路的网络拓扑中，抑制特性没有实际的意义，禁止该特性将有助于减少 IGRP 的收敛时间。</p>
<h3 id="IGRP-的度量"><a href="#IGRP-的度量" class="headerlink" title="IGRP 的度量"></a>IGRP 的度量</h3><p>与 RIP 协议相比，IGRP 协议引入的一个最重要的变化是：它基于链路的特征，使用了多种度量参数。这些也继承到了 EIGRP 协议中。在 IGRP 协议中，它将根据链路的特性计算出一个复合的度量值，这些链路特性包括链路带宽、时延、负载和可靠性。缺省条件下，IGRP 选用路由的链路带宽和时延作为度量值。带宽是数据传送能力的量度，而时延则是端-端传送时间的量度。链路的另外两个特性：负载和可靠性只有在路由器上进行人工配置后才会被应用。虽然 IGRP 协议不使用 MTU 作为计算复合度量值的参数，但 IGRP 也会跟踪每条路由上的最小 MTU 的大小。</p>
<p>通过 <code>show interfaces</code> 命令可以观察一个特定接口上有关 IGRP 的复合度量值的大小。带宽用 kbit&#x2F;s 单位来表示，它在计算链路的度量值时仅作为一个静态的值，没有必要反映出链路实际使用的带宽，也就是说，带宽不需要动态地去度量。缺省的带宽值可以通过 bandwidth 命令来更改。IGRP 的更新消息使用 3 个字节表示 IGRP 带宽，它使用因子 10**7 除以带宽得来的。</p>
<p>时延和带宽一样，也是一个静态特征的度量值， 不需要动态地去度量。时延可以通过 show interface 命令的 DLY 参数来表示，单位是微秒。一个接口的缺省时延可以通过命令 delay 进行更改。在 IGRP 更新消息中，时延也是用 3 个字节表示，以 10us 作为最小计量单位。IGRP 通过设定 DLY 为 0xFFFFFF 来标识一条不可达到的路由，这个数值约为 167.8s。因此一条 IGRP 路由端-端最大时延是 167s。</p>
<p>因为 IGRP 协议使用带宽和时延来作为它的缺省度量值，因此这些参数必须配置正确，并且要在所有的 IGRP 路由器的接口上统一规划配置。除非有一个很好的理由，并且对更改这些参数的配置后所产生的结果有清楚的理解，否则最好不要更改一个接口的带宽和时延参数。在大多数的情况下，最好保留使用这些参数的缺省值而不要加以改变。</p>
<p>另外需要注意：OSPF 协议也使用带宽来计算它的度量值，因此，在一个同时运行 IGRP 和 OSPF 协议的网络中，如果要改变 IGRP 的度量值，应该使用 delay 来影响 IGRP 的度量，如果改变带宽将会同时影响到 IGRP 和 OSPF。</p>
<p>可靠性是一个动态的度量参数，它使用一个字节表示，255 表示完全可靠，而 1 表示最低可靠的链路。在命令 show interface 的输出中，可靠性被表示成 255 的分数。</p>
<p>在 IGRP 的更新里，负载用一个字节表示，1 表示最小的负载链路，255 表示 100% 的负载链路。在 show interface 命令的输出中其表示成一个 255 的分数。</p>
<p>如果可靠性或负载被用来作为一个度量或复合度量的一部分，计算度量的算法不允许在出错率或信道占用率上突然发生变化而影响网络的稳定性。为了防止度量频繁的改变，可靠性和负载是基于 5min 时间常数的指数加权平均计算的，它们每 5s 被更新一次。</p>
<p>对于每个 IGRP 路由的复合度量，可以用下面的公式计算：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">metric = [k1 * BW + (k2 * BW) / (256 - LOAD) + k3 * DLY] * [k5 / (RELIABILITY + k4)]</span><br></pre></td></tr></table></figure>

<p>这里的 BW 是沿着路由路径到达目的网络的所有出站接口的 BW 带宽中的最小值，而 DLY 是这条路由路径 DLY 时延的总和。</p>
<p>系数 k1 到 k5 是可配置的加权值，它们的缺省值是：k1 &#x3D; k3 &#x3D; 1，k2 &#x3D; K4 &#x3D; k5 &#x3D; 0。如果 k5 被设置为 0，则 [ k5 &#x2F; (RELIABILITY + k4) ] 该项不可用。这些值可以通过如下命令来更改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">metric weights tos k1 k2 k3 k4 k5</span><br></pre></td></tr></table></figure>

<p>如果 k1 到 k5 分别使用默认值，那么 IGRP 的复合度量计算公式将简化成缺省的度量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">metric = BW + DLY</span><br></pre></td></tr></table></figure>

<p>如果要查看 IGRP 记录的每条路由实际的参数值，可以使用 <code>show ip route address</code> 命令。除了跳数以外，IGRP 还记录了沿着路由最小的 MTU。MTU 不会用来作为度量的计算。跳数是下一跳路由器报告的跳数，仅仅用来限制网络规模的大小。默认情况下，最大跳数为 100，如果一条路由超过了设置的最大跳数，那么它的时延将被设置成 0xFFFFFF，变成一条不可达的路由。请注意，所有的度量都是基于沿着路由方向的路由器的出站接口计算的。</p>
<h2 id="从-IGRP-到-EIGRP"><a href="#从-IGRP-到-EIGRP" class="headerlink" title="从 IGRP 到 EIGRP"></a>从 IGRP 到 EIGRP</h2><p>EIGRP 协议除了保留 IGRP 协议引入的一些概念外，例如多种变量、协议域和非等价负载均衡，该协议和 IGRP 有明显的不同。EIGRP 协议有时也被描述成一个具有<code>链路状态协议行为特性的距离矢量协议</code>。</p>
<p>到目前为止，所讨论的所有距离矢量协议的运行都是基于 Bellman-Ford 算法或其一些派生算法的基础上的。因此这些协议容易产生路由选择环路和计数无穷大的问题。结果是，这些协议必须采取一些避免路由选择环路的措施，例如水平分隔、路由毒性逆转和抑制计时器等。由于每一台路由器在向它的邻居传送路由信息之前，都必须对收到的路由信息运行路由选择算法，因此大型网络的收敛可能会变得更慢。更为重要的是，距离矢量协议在通告路由时，如果网络核心的关键链路发生了变化，就意味着有很多发生变化的路由要进行通告。</p>
<p>相对于距离矢量协议，链路状态协议受到路由选择环路和有害路由选择信息的影响就小得多。首先，链路状态数据包的转发不依赖于路由计算的执行，因而大型网络就可以更快速地收敛。其次，它只通告链路和链路的状态，而不通告路由，这意味着链路的变化不会引起使用这条链路的所有路由被通告。</p>
<p>其他的路由选择协议执行路由的计算，不论是在给它的邻居发送距离矢量更新之前，还是在生成网络拓扑数据库之后，它们的共同特性都是单独地进行路由的计算。相反，EIGRP 协议使用了一个称为 <code>扩散计算</code> 的方法：在多台路由器之间通过一个并行的方式执行路由的计算，从而在保持无环路的拓扑时可以随时获取较快的收敛。</p>
<p>虽然 EIGRP 更新仍然是将距离矢量传送给它直连的邻居，但是 EIGRP 更新是非周期的、部分的和有边界的。</p>
<ul>
<li>非周期的：是指更新不是规定的时间间隔发送的，而是在度量或网络拓扑发生变化时才发送更新</li>
<li>部分的:是指更新只包含发生变化的路由条目，而不是路由器的所有条目</li>
<li>有边界的：是指更新仅仅发送给受影响的路由器</li>
</ul>
<p>这些特性意味着，EIGRP 协议比典型的距离矢量协议所使用的带宽少的多。如果在低带宽的广域网链路上进行路由选择，在路由收敛期间，路由选择信息的流量会比较大，这时要考虑可以使用的最大带宽。缺省情况下，EIGRP 协议使用的带宽不超过链路总带宽的 50%。可以使用 <code>ip bandwidth-percent eigrp</code> 来改变这个缺省的百分比。</p>
<p>EIGRP 协议是一个无类别的协议（也就是说在其路由更新中的每一个路由条目都包含子网掩码），EIGRP 协议不仅可以利用可变长子网掩码进行子网的划分，而且可以利用可变长子网掩码进行地址的聚合，即一组主网络地址的汇总。</p>
<p>EIGRP 协议能够使用 MD5 加密校验来对 EIGRP 数据包进行认证。另外，EIGRP 协议不仅可以进行 IP 协议的路由选择，而且可以进行 IPX 协议和 AppleTalk 协议的路由选择。</p>
<h2 id="EIGRP-的基本原理与实现"><a href="#EIGRP-的基本原理与实现" class="headerlink" title="EIGRP 的基本原理与实现"></a>EIGRP 的基本原理与实现</h2><p>EIGRP 协议使用和 IGRP 协议相同的公式来计算它的复合度量值。但是，EIGRP 协议使用一个 256 的倍数因子扩展了度量参数，使它具有更好的度量粒度。</p>
<p>如下所示，EIGRP 协议包含以下 4 个部件：</p>
<ul>
<li>依赖于协议的模块</li>
<li>可靠传输协议（RTP）</li>
<li>邻居发现和恢复</li>
<li>扩散更新算法（DUAL）</li>
</ul>
<h3 id="依赖于协议的模块"><a href="#依赖于协议的模块" class="headerlink" title="依赖于协议的模块"></a>依赖于协议的模块</h3><p>EIGRP 协议实现了 IP 协议、IPX 协议和 AppleTalk 协议的模块，它可以负担起某一特定协议的路由选择任务。例如，IPX EIGRP 模块可以负责在 IPX 网络上与其他 IPX EIGRP 进程进行路由信息交换，并将这些信息传递给 DUAL。</p>
<p>每个单独模块的通信量被封装在它们各自的网络层协议中。例如，对于 IPX 协议的 EIGRP 通过 IPX 协议数据包传输。EIGRP 协议在很多情况下和其他路由选择协议自动进行路由重新分配，例如，如果 IGRP 进程和 EIGRP 进程在同一个自主系统内，那么 IP EIGRP 也将自动地和 IGRP 进行路由重新分配。</p>
<h3 id="可靠传输协议"><a href="#可靠传输协议" class="headerlink" title="可靠传输协议"></a>可靠传输协议</h3><p>可靠传输协议（Reliable Transport Protocol, RTP）用来管理 EIGRP 数据包的发送和接收。有保障的发送是依赖于 Cisco 公司私有算法实现的，该私有算法被称为 可靠组播，它使用保留的 D 类地址 224.0.0.10，每一个接收可靠组播数据包的邻居都会发送一个单播的确认数据包。</p>
<p>而有序的发送是通过在每个数据包中包含两个序列号来实现的，每一个数据包都包含一个由发送该数据包的路由器分配的序列号，这个序列号在每台路由器发送一个新的数据包时递增 1。另外，发送路由器会把最近从目的路由器收到的数据包的序列号放在该数据包中。</p>
<p>在一些实例中，RTP 也可以使用不可靠的发送，不需要确认，而且在使用不可靠发送的 EIGRP 数据包中不包含序列号。</p>
<p>EIGRP 协议使用多种类型的数据包，所有这些数据包都通过 IP 头部的协议号 88 来标识：</p>
<ul>
<li>Hello：用于邻居发现和恢复进程。Hello 数据包使用组播方式发送，而且使用不可靠的发送方式</li>
<li>确认（ACK）：是不包含数据的 Hello 数据包，ACK 总是使用单播和不可靠的发送方式</li>
<li>更新（Update）：用于传递路由更新信息。EIGRP 协议的更新数据包只在必要的时候传递必要的信息，而且仅仅传递给需要路由信息的路由器。当只有某一指定的路由器需要路由更新时，更新数据包就是单播发送的，当有多台路由器需要路由更新时，更新数据包就是组播发送的。更新数据包总是使用可靠的发送方式</li>
<li>查询（Query）和答复（Reply）：是 DUAL 有限状态机用来管理它的扩散计算的。查询消息可以使用组播方式或者单播方式发送，而回复消息总是单播方式发送。查询和回复数据包都使用可靠的发送方式</li>
<li>请求（Request）：最初打算提供给路由服务器使用的数据包类型，但是这个应用从来没有实现过。</li>
<li>如果任何数据包通过可靠的方式组播出去，而没有从邻居那里收到 ACK 数据包，那么这个数据包就会以单播方式被重新发送给那个没有响应的邻居。如果经过 16 次这样的单播重传还没有收到一个 ACK 数据包的话，那么这个邻居就会被宣告为无效。</li>
</ul>
<p>为了等待一个 ACK，从组播方式切换到单播方式的时间间隔可以由组播流计时器（multicast flow timer）指定。后续的单播之间的时间间隔可以由重传超时（Retransmission Timeout，RTO）指定。对于每一个邻居，组播流计时器和重传计时器都可以通过平均回程时间（Smooth Round-Trip Time，SRTT）来计算。SRTT 是一个用来衡量路由器发送 EIGRP 数据包到邻居和从邻居那里接收到该数据包的确认所花费的平均时间。</p>
<h3 id="邻居发现和恢复"><a href="#邻居发现和恢复" class="headerlink" title="邻居发现和恢复"></a>邻居发现和恢复</h3><p>因为 EIGRP 协议的更新消息是非周期的，因此有一个发现和跟踪邻居的方法是非常重要的，在这里，邻居是指网络上直连的通告 EIGRP 的路由器。</p>
<p>在大多数网络中，Hello 数据包是以组播方式每 5s 发送一次的，其中减掉一个很小的随机时间差用来防止更新的同步。在所有的实例中，Hello 数据包都是不进行确认的，缺省的 Hello 数据包的时间间隔可以在每个接口上使用命令 ip hello-interval eigrp 进行更改。</p>
<p>当一台路由器从它的邻居收到一个 Hello 数据包时，这个数据包将包含一个抑制时间（holdtime），这个抑制时间会告诉接收路由器，在它收到后续的 Hello 数据包之前等待的最长时间。如果抑制计时器超时了，路由器还没有收到 Hello 数据包，那么将宣告这个邻居不可达，并且通知 DUAL 这个邻居丢了。缺省情况下，抑制时间是 Hello 时间间隔的 3 倍。</p>
<p>每个邻居的相关信息都记录在一个邻居表中，邻居表记录了邻居路由器的 IP 地址和收到 Hello 数据包的接口。邻居通告的抑制时间，重传超时定时器（RTO）等信息也记录在邻居表中。如果一个 EIGRP 的更新、查询或恢复数据包被发送出去，那么这个数据包的一个拷贝就会放在一个重传队列里排队。如果重传超时了还没有收到确认数据包，那么重传队列中数据包的拷贝将再次发送出去。队列计数（Q Count）就是标识这个重传队列中等待发送的数据包数量。从邻居收到的最新的数据包序列号也记录在了邻居表中。可靠传输协议 RTP 跟踪这些序列号，以确保来自邻居的数据包不是无序的。</p>
<h3 id="扩散更新算法"><a href="#扩散更新算法" class="headerlink" title="扩散更新算法"></a>扩散更新算法</h3><p>扩散更新算法（Diffusing Update Algorithm，DUAL）是一个收敛算法，它代替了用于其他距离向量协议使用的 Bellman-Ford 或 Ford-Fulkerson 算法。DUAL 算法的背后设计思想是，即使暂时的路由选择环路也会对一个网络的性能造成损害，为了随时能够打破路由环路，而使用扩散算法去执行一个分布式最短路径路由选择。</p>
<h4 id="DUAL：预备概念"><a href="#DUAL：预备概念" class="headerlink" title="DUAL：预备概念"></a>DUAL：预备概念</h4><p>为了能够正确地操作 DUAL，较低层的协议必须确保满足下面几个条件</p>
<ul>
<li>一个节点需要在有限的时间内检测到一个新的邻居存在或一个相连邻居的丢失</li>
<li>在一个正在运行的链路上传送的所有信息应该在一个有限的时间内正确地收到，并包含正确的序列号</li>
<li>所有的消息，包括改变链路的代价、链路失败和发现新邻居的通告，都应该在一个有限的时间内一次一个地处理，并且应该被有序地检测到</li>
</ul>
<p>EIGRP 协议使用邻居发现&#x2F;恢复和可靠传输协议（RTP）来确定这些前提条件。</p>
<ul>
<li>邻接（adjacency）：路由器使用 Hello 数据包发现它的邻居并标识自己给邻居识别。当邻居被发现时，EIGRP 协议将试图和邻居形成一个邻接关系。邻接是指两个互相交换路由信息的邻居之间形成的一条逻辑的关联关系。一旦邻接成功建立，路由器就可以从它的邻居那里接收路由更新消息了。这里的路由更新消息包括发送路由器所知道的所有路由和这些路由的度量值。对于每一条路由，路由器将会基于它邻居通告的距离和到它的邻居的链路代价计算出一个距离</li>
<li>可行距离（Feasible Distance，FD）：到达每一个目的地的最小度量将作为该目的网络的可行距离。</li>
<li>可行性条件（Feasibility Condition，FC）：可达性条件就是需要满足下面这样的条件：本地路由器的一个邻居路由器所通告的到达一个目的网络的距离是否小于本地路由器所到达相同目的网络的可行距离（FD）</li>
<li>可行后继路由器（Feasible Successor, FS）：如果本地路由器的邻居路由器所通告的到达目的网络的距离满足了 FC，那么这个邻居就会称为该目的网络的一个可行后继路由器</li>
<li>后继路由器（Successor）：对于在拓扑结构列表中列出的每一个目的网络，将选用拥有最小度量值的路由并放置到路由表中。通告这条路由的邻居就成为一个后继路由器，即到达目的网络的下一跳路由器</li>
</ul>
<p>可行后继路由器和可行性条件的概念是避免环路的一项核心技术，因为可行后继路由器总是 <code>下游路由器</code>（即可行后继路由器到达目的地的度量距离比本地路由器的可行距离 FD 更短），所以路由器从来不会选择一条导致反过来还要经过它本身的路径，像这样的路径一般有一个大于本地路由器 FD 的距离。</p>
<p>存在一个或多个可行后继路由器的每一个目的网络，将与下面的每一项一起记录在 <code>拓扑结构表</code> 中：</p>
<ul>
<li>目的网络的可行距离</li>
<li>所有的可行后继路由器</li>
<li>每一个可行后继路由器所通告的到达目的网络的通告距离</li>
<li>本地路由器所计算的经过每一个可行后继路由器到达目的网路的距离，即基于可行后继路由器所通告的到达目的子网的距离和本地路由器与该可行后继路由器之间相连链路的成本计算所得的距离</li>
</ul>
<p>通过命令 show ip eigrp topology 可以查看路由器的拓扑结构表，其会列出每个子网以及到达这些子网的可行路由器。圆括号中的两个度量也都是和每个可行后继路由器相关联的。第一个数字是本地路由器计算得出的经过该可行后继路由器到达目的网络的度量值，第二个数字是邻居通告的度量值。</p>
<p>如果有多条路由的度量值都匹配它的可行距离，那么这些路由都将出现在路由表中，路由器将在这些路由表项上执行等价负载均衡。</p>
<p>如果一台可行后继路由器通告的一条路由在本地路由器上所计算的度量比通过当前后继路由器的度量小，那么这台可行后继路由器就成为后继路由器，下面情况会引发这种情况的发生：</p>
<ul>
<li>发现一条新的路由</li>
<li>一条后继路由器路由的度量值增加后超过了可行后继路由器的度量值</li>
<li>一条可行后继路由器路由的度量值减小后小于后继路由器的度量值</li>
</ul>
<p>由于可行后继路由器减少了扩散计算的数量，并提高了网络的性能，因此可行后继路由器十分重要。可行后继路由器也对降低重新收敛的次数有一定的贡献。如果到达后继路由器的一条链路失效了，或者链路的代价增加并超过了可行距离，那么这台路由器将首先在它的拓扑结构表中查找可行后继路由器，如果发现存在一台可行后继路由器，那么它就成为后继路由器。路由器只有在找不到任何一台可行后继路由器的情况下，才开始进行扩散计算。</p>
<p>成功进行 EIGRP 设计的关键在于：确保对所有的目的地来说总是存在一台可行后继路由器。</p>
<h4 id="DUAL-有限状态机"><a href="#DUAL-有限状态机" class="headerlink" title="DUAL 有限状态机"></a>DUAL 有限状态机</h4><p>当一个 EIGRP 的路由器不执行扩散计算时，每一条路由都处于被动状态（passive state）。在产生输入事件的任何时候，路由器都会重新评估一条路由的可行后继路由器的列表。一个输入事件可以是：</p>
<ul>
<li>直连链路的代价发生变化</li>
<li>直连链路的状态发生变化</li>
<li>收到一个更新数据包</li>
<li>收到一个查询数据包</li>
<li>收到一个答复数据包</li>
</ul>
<p>路由器重新评估的第一步是，在本地路由器上执行一个本地计算，也就是对所有的可行后继路由器，重新计算到达目的地的距离。可能的结果有以下几种：</p>
<ul>
<li>如果拥有最低度量距离的可行后继路由器和已经存在的后继路由器不同，那么可行后继路由器将成为后继路由器</li>
<li>如果新的度量距离小于 FD，那么就更新 FD</li>
<li>如果新的度量距离和已经存在的度量距离不同，那么将向所有的邻居发送更新</li>
</ul>
<p>当路由器执行一个本地计算时，路由依然保持被动状态。如果本地路由器发现了一台可行后继路由器，那么将发送一个更新消息给它所有的邻居，但不改变路由的状态。如果在拓扑结构表中没有发现任何一台可行后继路由器的话，而且路由器的状态改变成活动状态。</p>
<p>在扩散计算完成和路由的状态返回到被动状态之前，路由器不能：</p>
<ul>
<li>改变路由的后继路由器</li>
<li>改变正在通告的路由的距离</li>
<li>改变路由的 FD</li>
<li>开始进行路由的另一个扩散计算</li>
</ul>
<p>路由器通过向它所有的邻居发送查询来开始一个扩散计算的，查询中包含一个到达目的地的新的本地路由器计算的距离。收到查询后，每一台邻居路由器将执行它自己的本地计算：</p>
<ul>
<li>如果该邻居拥有到达目的地的一台或多台可行后继路由器，它将发送一个答复给原来发送查询的路由器，答复中包含这台路由器所计算的它到达目的网络的最小距离</li>
<li>如果一个邻居没有可行后继路由器，它将把路由状态改变为活动状态，并且开始扩散计算</li>
</ul>
<p>每次向邻居发送一个查询消息时，本地路由器将设置一个答复状态标记（reply status flag, r）来不断地跟踪所有未处理的查询。当本地路由器收到所有邻居路由器的查询答复时，扩散计算就完成了。在扩散计算的开始，一个活动计时器被设置成 3min，如果在活动计时器超时后还没有收到希望收到的所有答复，那么这条路由将被宣告 卡在活动状态（Stuck-In-Active，SIA）。这些没有答复的邻居将从邻居表中删除，并且扩散计算认为这个邻居回应了一个无穷大的度量。由于查询的丢失而造成邻居的删除显然会带来负面的影响，但是，在一个稳定的、设计良好的网络中，SIA 的情形是从来不会发生的。</p>
<p>在扩散计算完成时，始发路由器会将 FD 设置成无穷大，这样可以确保任何答复到达目的地是有限距离的邻居路由器都满足 FC，并成为一台后继路由器。对于这些答复消息，度量都是由答复消息中所通告的距离加上与发送答复的邻居路由器相连的链路代价计算得出的。选择一台后继路由器是基于最低的度量值的，而且该度量值被设置成 FD。</p>
<p>因为有多种类型的输入事件能够引起一条路由改变它的状态，所以当一条路由处于活动状态时就说明可能发生了一些类型的输入事件。DUAL 定义了多种活动状态，查询始发标记（query origin flag, O）用来指出当前的状态。</p>
<p>如下显示了完整的 DUAL 有限状态机</p>
<img src="/fuchencong.github.io/2019/05/12/routing-tcp-ip-07/images/dual.png" class="">

<p>扩散计算算法的主要核心内容：</p>
<ul>
<li>任何时间，发生一个输入事件，就会执行一个本地计算</li>
<li>如果在路由器的拓扑结构表中发现了一台或多台可行后继路由器，那么将使用具有最低度量代价的可行后继路由器作为它的后继路由器</li>
<li>如果没有发现可行后继路由器，那么将使它的路由变成活动状态，向它的邻居路由器发送查询消息，以便确定一个可行后继路由器</li>
<li>在所有的查询被答复响应之前，或者活动计时器超时之前，将保持路由状态为活动状态</li>
<li>如果扩散计算的结果无法发现一个可行后继路由器，那么将宣告这个目的地不可达</li>
</ul>
<h3 id="EIGRP-的数据包格式"><a href="#EIGRP-的数据包格式" class="headerlink" title="EIGRP 的数据包格式"></a>EIGRP 的数据包格式</h3><p>EIGRP 协议数据包的 IP 头部指定它的协议号为 88，紧接着 IP 头部后面的是 EIGRP 协议头部，EIGRP 协议头部后面是类型&#x2F;长度&#x2F;数值（Type&#x2F;Length&#x2F;Value，TLV）这 3 个参数的不同组合。这些 TLV 不仅携带路由条目的信息，而且提供多个字段来管理 DUAL 算法的处理、组播的先后次序和 IOS 软件版本。</p>
<p>EIGRP 包头<br>如下显示了 EIGRP 的头部，它是每一个 EIGRP 数据包的开始部分</p>
<img src="/fuchencong.github.io/2019/05/12/routing-tcp-ip-07/images/message.png" class="">

<ul>
<li>版本号：指出发起 EIGRP 进程的具体版本号，EIGRP 协议本身的版本自发布后还没有改变过</li>
<li>操作码：指出 EIGRP 数据包的类型</li>
<li>校验和：它是基于除了 IP 头部的整个 EIGRP 数据包计算的</li>
<li>标记：目前包含两个标记。最右边的位设置为 Init 位，指出附加的路有条目是新的邻居关系的开始。第二位表示条件接收位，并使用一个私有的可靠组播算法</li>
<li>序列号：是一个用在 RTP 中的 32 位序列号</li>
<li>确认序列号：是本地路由器从邻居路由器那里接收到的最新的一个 32 序列号。一个包含非 0 ACK 字段的 Hello 数据包将被看做是一个 ACK 数据包，而不看做是一个 Hello 数据包</li>
<li>自主系统号：制定一个 EIGRP 协议域的标识号</li>
</ul>
<p>跟在 EIGRP 头部后面的就是 TLV 字段。每一个 TLV 字段都包含一个 2 字节的类型字段、一个 2 字节的 TLV 长度字段和一个由类型决定其格式的可变值字段。</p>
<h4 id="一般的-TLV-字段"><a href="#一般的-TLV-字段" class="headerlink" title="一般的 TLV 字段"></a>一般的 TLV 字段</h4><p>这些 TLV 字段可以携带 EIGRP 的管理信息而不需要指定任何一个可路由的协议。带参数的 TLV 用来传递度量权重和抑制时间。序列、软件版本和下一个组播序列等 TLV 用于 Cisco 的私有可靠性组播算法。</p>
<h4 id="IP-特有的-TLV-字段"><a href="#IP-特有的-TLV-字段" class="headerlink" title="IP 特有的 TLV 字段"></a>IP 特有的 TLV 字段</h4><p>每一个内部路由和外部路由的 TLV 都包含一个路由条目。每个更新、查询和答复数据包都至少包含一个路由 TLV。内部路由和外部路由的 TLV 包括了路由的度量信息，EIGRP 协议使用的度量和 IGRP 协议相同，只是扩大了 256 倍。</p>
<p>IP 内部路由是指在 EIGRP 自治系统内部可以到达目的地的路径。内部路由的 TLV 格式如下：</p>
<img src="/fuchencong.github.io/2019/05/12/routing-tcp-ip-07/images/inner_tlv.png" class="">

<ul>
<li>下一跳：是指下一跳 IP 地址，这个地址可能是，也可能不是始发路由器的地址</li>
<li>延迟：是指所配置的以 10us 为单位表示的延迟总和，一条 0xFFFFFFFF 的延迟标识一个不可达路由</li>
<li>带宽：即用 256 * 10000000 &#x2F; 沿着路由方向所有接口所配置的最小带宽</li>
<li>MTU：是指沿着到达目的地的路由上所有链路中最小的 MTU。虽然 EIGRP 数据包中包括了这个参数，但是从未在度量值的计算中使用过</li>
<li>跳数：表示目的地的路由的跳数。路由器将通告与之直连网络的跳数为 0 跳，后续的路由器将记录并通告相对于下一跳路由器的路由</li>
<li>可靠性：用来反映沿着到达目的地的路由上接口的出站错误率总和，0xFF 表示完全可靠</li>
<li>负载：用来反映沿着到达目的地的路由上接口的出站负载总和，0x01 表示一条最小负载的链路</li>
<li>保留字段：一个未使用的字段，并且总是设置为 0x0000</li>
<li>前缀长度：指出一个地址掩码中的网络位的个数</li>
<li>目的地址：表示一个路由的目的地址，这个字段的长度针对不同掩码长度的地址是可变的</li>
</ul>
<p>IP 外部路由是指到达 EIGRP 自主系统外部的目的地址的一条路径，或者是一条通过路由重新分配注入到 EIGRP 域内的路由。外部路由的 TLV 格式如下：</p>
<img src="/fuchencong.github.io/2019/05/12/routing-tcp-ip-07/images/outter_tlv.png" class="">

<ul>
<li>下一跳：即路由的下一跳 IP 地址。正在通告路由的路由器可能不是达到目的地的最佳下一跳路由器</li>
<li>原路由器：是一个 IP 地址，或者重分配外部路由到 EIGRP 自主系统的路由器 ID</li>
<li>源自主系统号：是指始发路由的路由器所在的自主系统号</li>
<li>Arbitrtrary Tag：可以用来携带一组路由映射的标记。</li>
<li>外部协议度量：即外部协议的度量，在和 IGRP 协议之间进行重新分配时，这个字段用来跟踪 IGRP 协议的度量值</li>
<li>保留字段：一个未使用的字段并且总设置为 0x0000</li>
<li>外部协议 ID：用来标识外部路由是从哪一个协议学习到的</li>
<li>标记：目前仅定义了两个标记，最右边的位如果被设置，该路由就是外部路由，如果右边第二位被设置，该路由就是一个候选的缺省路由。</li>
<li>其余的字段描述了度量和目的地址，这些字段的含义与在内部路由 TLV 中相同字段的含义是一样的</li>
</ul>
<h3 id="地址聚合"><a href="#地址聚合" class="headerlink" title="地址聚合"></a>地址聚合</h3><p>子网地址可以考虑成一组更小的子网的汇总，而一个主网地址可以看作一组子网的汇总。汇总都是通过减少子网掩码的长度来完成的。地址聚合是打破主网络地址分类限制的进一步汇总措施，聚合的地址表示了一组数字上连续的网络地址，或称为超网（supernet）。对于一组网络地址，寻找所有网络地址的共同位并对这些位进行掩码，被掩码覆盖的部分就是聚合地址。</p>
<p>当设计一个超网时，有一点很重要，就是超网的成员地址应该由原来掩码位的一个完整和连续的地址集合组成。如果不遵从这个设计规则的话，将会引起寻址方案冲突、减小聚合路由的性能并且可能导致路由选择环路和路由选择<code>黑洞</code>。</p>
<p>汇总寻址的一个明显好处就是节省网络资源。由于通告更少的路由从而节省了网络带宽，而处理更少的路由则节省了 CPU 的周期，而且由于减小了路由表的大小而节省了内存的使用。</p>
<p>无类别路由选择，VLSM 和聚合寻址都是通过创建层次化的地址来达到最大限度地节省网络资源的。与 IGRP 不同，EIGRP 协议支持这些寻址策略。</p>
<p>在 Internet 上，地址聚合也允许地址的节省和地址的分层。对于以指数速度增长的 Internet，有两点需要关注：</p>
<ul>
<li>可供使用的 IP 地址的消耗（尤其是 B 类 IP 地址）</li>
<li>存储 Internet 路由选择信息所需要的巨大数据库</li>
</ul>
<p>这个问题的一种解决方案就是使用称为无类别域间路由选择（CIDR）的方法。在 CIDR 下，C 类地址的聚合由 IANA 结构分配给国际上不同的地址分配权威机构，这些地址分配权威机构轮流地把他们自己管理的那部分地址分配给本地的网络服务提供商（ISP）。当一个组织申请 IP 地址时，将可以分配给它一组连续的称为 CIDR 块的 C 类地址。</p>
<p>各个组织团体所属的 Internet 路由器就可以把单一的汇总地址通告给他们的 ISP，反过来 ISP 也可以把其自己所以的地址聚合起来。目前所了解到的 Internet 全球路由表的大小接近 2000000 条路由（这说明没有很好地坚持使用 CIDR 技术）。</p>
<h3 id="EIGRP-和-IPv6"><a href="#EIGRP-和-IPv6" class="headerlink" title="EIGRP 和 IPv6"></a>EIGRP 和 IPv6</h3><p>EIGRP 协议不支持 IPv6，但是对 EIGRP 协议进行扩展从而支持 IPv6 协议的努力也在进行。由于 EIGRP 数据包使用 TLV 传送数据，因此扩展该协议支持 IPv6 将可以通过增加专门的 IPv6 TLV 来简单的实现。</p>
<h2 id="配置-EIGRP"><a href="#配置-EIGRP" class="headerlink" title="配置 EIGRP"></a>配置 EIGRP</h2><p>接下来将讲解基本的 EIGRP 配置，并讲述了路由汇总的技巧和与 IGRP 协议之间的互操作性。</p>
<h3 id="案例研究：EIGRP-的基本配置"><a href="#案例研究：EIGRP-的基本配置" class="headerlink" title="案例研究：EIGRP 的基本配置"></a>案例研究：EIGRP 的基本配置</h3><p>EIGRP 只需要两个步骤就可以启动一个 EIGRP 的路由选择进程：</p>
<ul>
<li>使用 router eigrp process-id 命令启动 EIGRP 进程</li>
<li>使用 network 命令来指定运行 EIGRP 协议的每个主网络</li>
</ul>
<p>EIGRP 进程 ID 号可以是 1 - 65535 之间的任何一个数字，只要对共享路由信息的所有路由器上的所有 EIGRP 进程 ID 号是相同的，那么网络管理员就可以随意地选用进程 ID 号。EIGRP 协议缺省的管理距离是 90。</p>
<h3 id="案例研究：非等价负载均衡"><a href="#案例研究：非等价负载均衡" class="headerlink" title="案例研究：非等价负载均衡"></a>案例研究：非等价负载均衡</h3><p>在和 RIP 协议同样的 CEF &#x2F; 快速交换 &#x2F; 处理交换转发机制的限制下，EIGRP 可以在最多 16 条等价的路由路径上实现等价负载均衡。但与 RIP 协议不同的是，EIGRP 协议也可以实现非等价负载均衡。</p>
<p>如果不做进一步的配置，EIGRP 协议将会简单地选择路径代价最小的路径。差异变量（variance）命令用来确定哪些路由在非等价负载均衡中是可以使用的。Variance 定义了一个倍数因子，用来表示一条路由的度量值和最小代价路由的差异程度。任何路由的度量值如果超过了最小代价路由的度量值乘以 Variance 的值，那么这条路由将不被使用。</p>
<p>Variance 的缺省值是 1，这意味着如果要实现负载均衡，多条路由的度量必须是相同的。Variance 必须是整数。在非等价负载均衡中的路由必须满足以下 3 个条件：</p>
<ul>
<li>增加到负载共享组中的路由条数不能超过最大路径条数的限制</li>
<li>下一跳路由器必须在度量值上更接近目的网络。换句话说，在下一跳路由器上到达目的网络的度量值必须小于本地路由器到达该目的网络的度量值。到达目的网络更近的下一跳路由器，通常称为下游路由器</li>
<li>最小路由代价的度量乘以 variance 后，必须大于所增加的非最小路由代价的度量值</li>
</ul>
<p>关于按每目的地（per destination）和按每数据包（per packet）进行负载均衡的规则，之前已经讨论过，同样适用于这里。如果数据包转发是快速交换或缺省配置的 CEF 交换，就按照每目的地负载均衡，如果数据包转发是处理交换或更改的 CEF 交换，就按照每数据包进行负载均衡。</p>
<p>如果 variance 设置为 1，那么 EIGRP 将只会把到达目的网络最小代价的路由加入到它的路由表中。然而，在一些情况下，即使没有发生负载均衡，也要将所有可用的路由都加入到路由表中。所有的数据包应该使用路径代价最小的路由，只有当主路径失效时，才被切换到下一个最好的路径。在路由表中存在多条路径时，为了使路由器只使用最小代价的路径，可以把缺省的配置改成 traffic-share min。隐含的缺省命令为 traffic-share balanced。</p>
<h3 id="案例研究：设置最大路径数"><a href="#案例研究：设置最大路径数" class="headerlink" title="案例研究：设置最大路径数"></a>案例研究：设置最大路径数</h3><p>EIGRP 协议可以进行负载均衡的路由路径的最大条数可以用 maximum-paths 命令来设置，所有版本的缺省值是 4。Variance 命令用于确保到达指定网络的哪些路由是可用的，而 maximum-paths 命令用于限制负载均衡组中最多可用的路由。</p>
<p>在网络中配置并行的路径时应该小心谨慎，太多的并行路径在某个链路失效时会增加 EIGRP 的收敛时间，这是因为邻居路由器的数目增加了，因此增加了查询的范围。</p>
<h3 id="案例研究：多个-EIGRP-进程"><a href="#案例研究：多个-EIGRP-进程" class="headerlink" title="案例研究：多个 EIGRP 进程"></a>案例研究：多个 EIGRP 进程</h3><p>每个 EIGRP 进程都只在指定网络的接口上运行。使用 passive-interface 命令可以防止 EIGRP Hello 发送到不属于它们的数据链路上去。对于 EIGRP 协议来说，这个命令阻塞了不必要的 Hello 消息，这样将不会形成邻接关系，也不会发送其他的 EIGRP 流量。</p>
<p>在使用被动接口的地方，EIGRP 的网络语句可以配置通配符掩码位。这里的通配符掩码位指定了在 EIGRP 进程中标识所包含的接口时使用的该地址位数。</p>
<h3 id="案例研究：关闭自动路由汇总"><a href="#案例研究：关闭自动路由汇总" class="headerlink" title="案例研究：关闭自动路由汇总"></a>案例研究：关闭自动路由汇总</h3><p>在缺省情况下，EIGRP 协议在网络边界上进行路由汇总，但是 EIGRP 的自动路由汇总可以被关闭。可以使用命令 no auto-summary 在路由器上关闭自动路由汇总，在关闭自动路由汇总后，就可以在路由表中看到远端地址的子网了。</p>
<p>有时，关闭路由汇总是有用的。例如在不连续子网的情况下，边界路由器分别通告汇总后的路由到上游路由器，此时上游路由器从多个接口上收到到达某个主网络的汇总路由通告，这会产生一个路由不明确的情况：要达到这个主网络某个子网的数据包可能会，也可能不会被路由到正确的链路上。</p>
<h3 id="案例研究：末梢路由选择"><a href="#案例研究：末梢路由选择" class="headerlink" title="案例研究：末梢路由选择"></a>案例研究：末梢路由选择</h3><p>当一台路由器的 EIGRP 拓扑表变坏的时候（可能是度量值变大了，也可能是后继路由器不再可达了），如果没有可行后继路由器到达该地址，那么这个路由条目将进入 active 状态，同时这台路由器会向它的所有邻居路由器发送查询数据包。</p>
<p>一台具有 EIGRP 末梢邻居的路由器将不会向它的末梢发送查询，因此这也就排除了配置为末梢的远端站点引起的 卡在活动状态 的情形发生的机会，也降低了网络中其余部分路由选择的不稳定。</p>
<p>通过 eigrp stub 可以将一台路由器配置成末梢路由器，这将使得路由器仅仅发送与它直连的路由和汇总路由的更新消息。使用如下命令可以配置包括下列路由的任何组合，如直连路由、汇总路由、静态路由或重新分配到 EIGRP 内的路由：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eigrp stub &#123; connected | redistributed | static | summary | receive-only &#125;</span><br></pre></td></tr></table></figure>

<p>如果使用 receive-only 选项进行配置，那么更新消息中将不包含任何路由信息。此时末梢路由器不得不利用其它方式把它直连的地址通告到网络的其余部分。可以在中心路由器上使用 show ip eigrp neighbor detail 命令检验配置为末梢路由器的邻居。</p>
<p>配置 EIGRP 的末梢路由极增加了 EIGRP 网络的扩展性，因为这最大限度地减少查询的数量，也就减少了网络中断时间（这期间要求相关地址处于 active 状态）。</p>
<h3 id="案例研究：地址汇总"><a href="#案例研究：地址汇总" class="headerlink" title="案例研究：地址汇总"></a>案例研究：地址汇总</h3><p>命令 <code>ip summary-address eigrp</code> 将会自动地抑制更具体的到达相应路由器的网络通告。在一个大型网络中，压缩路由表的大小和存储它们所需要的内存是很重要的。</p>
<h3 id="案例研究：认证"><a href="#案例研究：认证" class="headerlink" title="案例研究：认证"></a>案例研究：认证</h3><p>MD5 加密校验和是 EIGRP 唯一支持的认证方式。由于明文口令认证应该只使用在邻居设备不支持比较安全的 MD5 认证的时候，而 EIGRP 协议仅会在 Cisco 设备之间互相宣告，因此不会发生不支持 MD5 认证的情况。</p>
<p>配置 EIGRP 协议的认证有以下几个步骤：</p>
<p>定义一个带有名字的钥匙链<br>在钥匙链上定义一个或一组钥匙<br>在接口上启用认证并指定使用的钥匙链<br>可选地配置钥匙的管理<br>EIGRP 协议认证是在接口上配置命令 ip authentication key-chain eigrp 和 命令 ip authentication mode eigrp md5 来启用和连接到一个钥匙链上的。</p>
<h2 id="EIGRP-故障诊断"><a href="#EIGRP-故障诊断" class="headerlink" title="EIGRP 故障诊断"></a>EIGRP 故障诊断</h2><p>RIP 协议的路由信息交换的故障诊断是一个比较简单的过程，路由选择更新要么传播出去了，要么没有传播出去，要么包含了精确的路由信息要么没有包含。EIGRP 协议复杂性的增加也意味着故障排除过程的复杂性增加了。在 EIGRP 协议的故障排除过程中，必须验证邻居表和邻接关系的正确性，检查 DUAL 算法的查询&#x2F;响应过程的正确性，并考虑在自动汇总时对 VLSM 的影响。</p>
<p>使用 debug eigrp packets 命令可以显示 eigrp 交换报文，通过 <code>debug ip eigrp neighbor</code> 命令可以进一步设置一个过滤器，观察指定 EIGRP 进程域内和指定邻居的交换报文。</p>
<p>当本地路由器的一条路由变为活动状态并且向它的邻居路由器发送查询时，在本地路由器收到每个查询的答复之前，这条路由将一直保持活动状态。但是如果一个邻居失效或者发生其它情况导致无法做出答复时，这条路由将会永久地停留在活动状态。活动计时器和 SIA-Retransmit 计时器将设计用来防止这种情况的发生。</p>
<p>当发送一个查询时，就会设置活动计时器和 SIA-Retransmit 计时器。如果在收到查询的答复消息之前，活动计时器超时了，这条路由就宣告 卡 在活动状态，这个邻居也就被推断为失效，并从邻居表中刷新掉。SIA 路由和任何其他经过这个邻居的路由也会从路由表中删除。DUAL 算法将会认为这个邻居已经答复了一个含有无穷大度量的消息。</p>
<p>查询会引起扩散计算的不断增大，而答复将会引起扩散计算的不断减小，因此，查询最终只能到达网络的边界，而答复最终也会引起往回收缩。但是如果扩散计算的直径增大到足够大，活动计时器将可能在收到所有的答复前超时，结果，从邻居表中刷新掉一个合法的邻居将明显带来网络的不稳定性。</p>
<p>当一个邻居神秘地从邻居表中消失，随后又重新消失，或者用户抱怨总是断断续续不能到目的地，SIA 路由是故障所在。检查路由器的错误日志是找出是否出现一个 SIA 路由的好方法。</p>
<p>当追踪 SIA 路由产生的原因时，应该仔细关注路由器的拓扑结构表。如果路由处于活动状态，那么就应该注意仍然没有收到邻居路由器的答复。通常在一个大型的 EIGRP 网络中，引起 SIA 的原因是网络拥塞严重、数据链路带宽较低、以及路由器内存过低或 CPU 利用率负荷过大等等。可以使用命令 <code>ip bandwidth-percent eigrp</code> 调整 EIGRP 使用的带宽。</p>
<p>也可以使用 <code>timers active-time</code> 来增大活动计时器的周期，这样在某些情况下可以帮助避免 SIA 路由，但是采取这种方法应该仔细考虑对网络路由再次收敛的影响。</p>
<p>SIA-Retransmit 计时器是一个新的计时器，它和两个新的 EIGRP 数据包类型：SIA 查询和 SIA 答复一起帮助使 SIA 减少到最少，并对响应查询确实有问题的链路上的邻居进行重置。</p>
<p>SIA-Retransmit 计时器通常被设置为活动计时器数值的一半，通常是 90s。在 SIA-Restransmit 计时器超时之后，路由器将向邻居路由器（已经向其发送了查询消息，但是还没有收到应答）发送一个 SIA 查询，邻居路由器在收到 SIA 查询后继续扩散该 SIA 查询，同时回复一个 SIA 答复。收到 SIA 答复后，路由器重置活动计时器和 SIA-Retransmit 计时器。在收到 SIA 答复消息前，路由器最多会发送 3 个 SIA 查询（假定始终没有收到答复消息），然后才会重置一台邻居路由器。因此在一台路由器响应 SIA 查询的时候（大约 6min），它不应该宣告为 stuck-in-active 状态和重置，这对于在一个大型网络中对查询作出响应已经给了足够的时间了。</p>
<p>SIA-Retransmit 计时器可以完成两件事情。如果邻居路由器正在对 SIA 查询进行响应，那么将会给大型网络更多的时间来对地址的查询作出响应，如果邻居路由器没有进行响应，那么邻居路由器将被重置。需要注意，只有那些没有从它的邻居收到响应的路由器才会重置它的邻接关系。在引入 SIA-Retransmit 计时器之前，即使网络下游某处出现问题，在活动计时器超时后如果还没有收到对一个活动查询的相应，那么路由器就会重置和它邻居的邻接关系。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当比较 EIGRP 协议和 OSPF 协议时，人们经常说 EIGRP 协议的优势在于它的配置比较简单，在许多网络中这种看法是正确的，但是在配置一个大型网络时，OSPF 反而显得比较简单。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/fuchencong.github.io/tags/Route/" rel="tag"># Route</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2019/05/15/routing-tcp-ip-08/" rel="prev" title="TCP/IP 路由技术 08：开放最短路径优先协议（OSPFv2）">
      <i class="fa fa-chevron-left"></i> TCP/IP 路由技术 08：开放最短路径优先协议（OSPFv2）
    </a></div>
      <div class="post-nav-item">
    <a href="/fuchencong.github.io/2019/05/09/routing-tcp-ip-06/" rel="next" title="TCP/IP 路由技术 06：RIPv2、RIPng 和无类别路由选择">
      TCP/IP 路由技术 06：RIPv2、RIPng 和无类别路由选择 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#EIGRP-%E7%9A%84%E5%89%8D%E8%BA%AB%EF%BC%9AIGRP-%E5%8D%8F%E8%AE%AE%E5%9B%9E%E9%A1%BE"><span class="nav-number">1.</span> <span class="nav-text">EIGRP 的前身：IGRP 协议回顾</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%9F%9F"><span class="nav-number">1.1.</span> <span class="nav-text">进程域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IGRP-%E7%9A%84%E8%AE%A1%E6%97%B6%E5%99%A8%E5%92%8C%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="nav-number">1.2.</span> <span class="nav-text">IGRP 的计时器和稳定性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IGRP-%E7%9A%84%E5%BA%A6%E9%87%8F"><span class="nav-number">1.3.</span> <span class="nav-text">IGRP 的度量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E-IGRP-%E5%88%B0-EIGRP"><span class="nav-number">2.</span> <span class="nav-text">从 IGRP 到 EIGRP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EIGRP-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.</span> <span class="nav-text">EIGRP 的基本原理与实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E4%BA%8E%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%A8%A1%E5%9D%97"><span class="nav-number">3.1.</span> <span class="nav-text">依赖于协议的模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.2.</span> <span class="nav-text">可靠传输协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%BB%E5%B1%85%E5%8F%91%E7%8E%B0%E5%92%8C%E6%81%A2%E5%A4%8D"><span class="nav-number">3.3.</span> <span class="nav-text">邻居发现和恢复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E6%95%A3%E6%9B%B4%E6%96%B0%E7%AE%97%E6%B3%95"><span class="nav-number">3.4.</span> <span class="nav-text">扩散更新算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DUAL%EF%BC%9A%E9%A2%84%E5%A4%87%E6%A6%82%E5%BF%B5"><span class="nav-number">3.4.1.</span> <span class="nav-text">DUAL：预备概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DUAL-%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="nav-number">3.4.2.</span> <span class="nav-text">DUAL 有限状态机</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EIGRP-%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85%E6%A0%BC%E5%BC%8F"><span class="nav-number">3.5.</span> <span class="nav-text">EIGRP 的数据包格式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E7%9A%84-TLV-%E5%AD%97%E6%AE%B5"><span class="nav-number">3.5.1.</span> <span class="nav-text">一般的 TLV 字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IP-%E7%89%B9%E6%9C%89%E7%9A%84-TLV-%E5%AD%97%E6%AE%B5"><span class="nav-number">3.5.2.</span> <span class="nav-text">IP 特有的 TLV 字段</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E8%81%9A%E5%90%88"><span class="nav-number">3.6.</span> <span class="nav-text">地址聚合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EIGRP-%E5%92%8C-IPv6"><span class="nav-number">3.7.</span> <span class="nav-text">EIGRP 和 IPv6</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE-EIGRP"><span class="nav-number">4.</span> <span class="nav-text">配置 EIGRP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%EF%BC%9AEIGRP-%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE"><span class="nav-number">4.1.</span> <span class="nav-text">案例研究：EIGRP 的基本配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%EF%BC%9A%E9%9D%9E%E7%AD%89%E4%BB%B7%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">4.2.</span> <span class="nav-text">案例研究：非等价负载均衡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%EF%BC%9A%E8%AE%BE%E7%BD%AE%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E6%95%B0"><span class="nav-number">4.3.</span> <span class="nav-text">案例研究：设置最大路径数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%EF%BC%9A%E5%A4%9A%E4%B8%AA-EIGRP-%E8%BF%9B%E7%A8%8B"><span class="nav-number">4.4.</span> <span class="nav-text">案例研究：多个 EIGRP 进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%EF%BC%9A%E5%85%B3%E9%97%AD%E8%87%AA%E5%8A%A8%E8%B7%AF%E7%94%B1%E6%B1%87%E6%80%BB"><span class="nav-number">4.5.</span> <span class="nav-text">案例研究：关闭自动路由汇总</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%EF%BC%9A%E6%9C%AB%E6%A2%A2%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9"><span class="nav-number">4.6.</span> <span class="nav-text">案例研究：末梢路由选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%EF%BC%9A%E5%9C%B0%E5%9D%80%E6%B1%87%E6%80%BB"><span class="nav-number">4.7.</span> <span class="nav-text">案例研究：地址汇总</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%EF%BC%9A%E8%AE%A4%E8%AF%81"><span class="nav-number">4.8.</span> <span class="nav-text">案例研究：认证</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EIGRP-%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD"><span class="nav-number">5.</span> <span class="nav-text">EIGRP 故障诊断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fuchencong"
      src="/fuchencong.github.io/images/logo.jpeg">
  <p class="site-author-name" itemprop="name">fuchencong</p>
  <div class="site-description" itemprop="description">Having dreams is what makes life tolerable.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/fuchencong.github.io/archives/">
        
          <span class="site-state-item-count">143</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/fuchencong.github.io/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/fuchencong.github.io/tags/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchencong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchencong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fuchencong@163.com" title="E-Mail → mailto:fuchencong@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fuchencong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/fuchencong.github.io/lib/anime.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/fuchencong.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/fuchencong.github.io/js/utils.js"></script>

<script src="/fuchencong.github.io/js/motion.js"></script>


<script src="/fuchencong.github.io/js/schemes/muse.js"></script>


<script src="/fuchencong.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
